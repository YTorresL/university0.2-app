module.exports = {

"[project]/node_modules/mapbox-gl/dist/mapbox-gl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(("TURBOPACK member replacement", __turbopack_context__.e), function() {
    'use strict';
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) {
            shared = chunk;
        } else if (!worker) {
            worker = chunk;
        } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
        }
    }
    define([
        "exports"
    ], function(t1) {
        var e = 1e-6, r = "undefined" != typeof Float32Array ? Float32Array : Array;
        function n(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = r * s - i * n;
            return o ? (t1[0] = s * (o = 1 / o), t1[1] = -n * o, t1[2] = -i * o, t1[3] = r * o, t1) : null;
        }
        function i() {
            var t1 = new r(9);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }
        function s(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8];
            return t1[0] = o * c - a * u, t1[1] = i * u - n * c, t1[2] = n * a - i * o, t1[3] = a * l - s * c, t1[4] = r * c - i * l, t1[5] = i * s - r * a, t1[6] = s * u - o * l, t1[7] = n * l - r * u, t1[8] = r * o - n * s, t1;
        }
        function o(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], d = r[1], f = r[2], m = r[3], y = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
            return t1[0] = p * n + d * o + f * u, t1[1] = p * i + d * a + f * c, t1[2] = p * s + d * l + f * h, t1[3] = m * n + y * o + g * u, t1[4] = m * i + y * a + g * c, t1[5] = m * s + y * l + g * h, t1[6] = x * n + v * o + b * u, t1[7] = x * i + v * a + b * c, t1[8] = x * s + v * l + b * h, t1;
        }
        function a() {
            var t1 = new r(16);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }
        function l(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function u(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], d = e[11], f = e[12], m = e[13], y = e[14], g = e[15], x = r * a - n * o, v = r * l - i * o, b = r * u - s * o, w = n * l - i * a, _ = n * u - s * a, A = i * u - s * l, M = c * m - h * f, I = c * y - p * f, S = c * g - d * f, P = h * y - p * m, E = h * g - d * m, k = p * g - d * y, z = x * k - v * E + b * P + w * S - _ * I + A * M;
            return z ? (t1[0] = (a * k - l * E + u * P) * (z = 1 / z), t1[1] = (i * E - n * k - s * P) * z, t1[2] = (m * A - y * _ + g * w) * z, t1[3] = (p * _ - h * A - d * w) * z, t1[4] = (l * S - o * k - u * I) * z, t1[5] = (r * k - i * S + s * I) * z, t1[6] = (y * b - f * A - g * v) * z, t1[7] = (c * A - p * b + d * v) * z, t1[8] = (o * E - a * S + u * M) * z, t1[9] = (n * S - r * E - s * M) * z, t1[10] = (f * _ - m * b + g * x) * z, t1[11] = (h * b - c * _ - d * x) * z, t1[12] = (a * I - o * P - l * M) * z, t1[13] = (r * P - n * I + i * M) * z, t1[14] = (m * v - f * w - y * x) * z, t1[15] = (c * w - h * v + p * x) * z, t1) : null;
        }
        function c(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], m = e[12], y = e[13], g = e[14], x = e[15], v = r[0], b = r[1], w = r[2], _ = r[3];
            return t1[0] = v * n + b * a + w * h + _ * m, t1[1] = v * i + b * l + w * p + _ * y, t1[2] = v * s + b * u + w * d + _ * g, t1[3] = v * o + b * c + w * f + _ * x, t1[4] = (v = r[4]) * n + (b = r[5]) * a + (w = r[6]) * h + (_ = r[7]) * m, t1[5] = v * i + b * l + w * p + _ * y, t1[6] = v * s + b * u + w * d + _ * g, t1[7] = v * o + b * c + w * f + _ * x, t1[8] = (v = r[8]) * n + (b = r[9]) * a + (w = r[10]) * h + (_ = r[11]) * m, t1[9] = v * i + b * l + w * p + _ * y, t1[10] = v * s + b * u + w * d + _ * g, t1[11] = v * o + b * c + w * f + _ * x, t1[12] = (v = r[12]) * n + (b = r[13]) * a + (w = r[14]) * h + (_ = r[15]) * m, t1[13] = v * i + b * l + w * p + _ * y, t1[14] = v * s + b * u + w * d + _ * g, t1[15] = v * o + b * c + w * f + _ * x, t1;
        }
        function h(t1, e, r) {
            var n, i, s, o, a, l, u, c, h, p, d, f, m = r[0], y = r[1], g = r[2];
            return e === t1 ? (t1[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t1[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t1[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t1[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], t1[0] = n = e[0], t1[1] = i, t1[2] = s, t1[3] = o, t1[4] = a, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = d, t1[11] = f, t1[12] = n * m + a * y + h * g + e[12], t1[13] = i * m + l * y + p * g + e[13], t1[14] = s * m + u * y + d * g + e[14], t1[15] = o * m + c * y + f * g + e[15]), t1;
        }
        function p(t1, e, r) {
            var n = r[0], i = r[1], s = r[2];
            return t1[0] = e[0] * n, t1[1] = e[1] * n, t1[2] = e[2] * n, t1[3] = e[3] * n, t1[4] = e[4] * i, t1[5] = e[5] * i, t1[6] = e[6] * i, t1[7] = e[7] * i, t1[8] = e[8] * s, t1[9] = e[9] * s, t1[10] = e[10] * s, t1[11] = e[11] * s, t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
        }
        function d(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[4], o = e[5], a = e[6], l = e[7], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[4] = s * i + u * n, t1[5] = o * i + c * n, t1[6] = a * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - s * n, t1[9] = c * i - o * n, t1[10] = h * i - a * n, t1[11] = p * i - l * n, t1;
        }
        function f(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], o = e[1], a = e[2], l = e[3], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i - u * n, t1[1] = o * i - c * n, t1[2] = a * i - h * n, t1[3] = l * i - p * n, t1[8] = s * n + u * i, t1[9] = o * n + c * i, t1[10] = a * n + h * i, t1[11] = l * n + p * i, t1;
        }
        function m(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], o = e[1], a = e[2], l = e[3], u = e[4], c = e[5], h = e[6], p = e[7];
            return e !== t1 && (t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i + u * n, t1[1] = o * i + c * n, t1[2] = a * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - s * n, t1[5] = c * i - o * n, t1[6] = h * i - a * n, t1[7] = p * i - l * n, t1;
        }
        function y(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function g(t1, r, n) {
            var i, s, o, a = n[0], l = n[1], u = n[2], c = Math.hypot(a, l, u);
            return c < e ? null : (a *= c = 1 / c, l *= c, u *= c, i = Math.sin(r), s = Math.cos(r), t1[0] = a * a * (o = 1 - s) + s, t1[1] = l * a * o + u * i, t1[2] = u * a * o - l * i, t1[3] = 0, t1[4] = a * l * o - u * i, t1[5] = l * l * o + s, t1[6] = u * l * o + a * i, t1[7] = 0, t1[8] = a * u * o + l * i, t1[9] = l * u * o - a * i, t1[10] = u * u * o + s, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
        }
        function x(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = r + r, a = n + n, l = i + i, u = r * o, c = n * o, h = n * a, p = i * o, d = i * a, f = i * l, m = s * o, y = s * a, g = s * l;
            return t1[0] = 1 - h - f, t1[1] = c + g, t1[2] = p - y, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - f, t1[6] = d + m, t1[7] = 0, t1[8] = p + y, t1[9] = d - m, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        Math.hypot || (Math.hypot = function() {
            for(var t1 = 0, e = arguments.length; e--;)t1 += arguments[e] * arguments[e];
            return Math.sqrt(t1);
        });
        var v = c;
        function b() {
            var t1 = new r(3);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function w(t1) {
            var e = new r(3);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e;
        }
        function _(t1) {
            return Math.hypot(t1[0], t1[1], t1[2]);
        }
        function A(t1, e, n) {
            var i = new r(3);
            return i[0] = t1, i[1] = e, i[2] = n, i;
        }
        function M(t1, e, r, n) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1;
        }
        function I(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1;
        }
        function S(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1;
        }
        function P(t1, e, r) {
            return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1;
        }
        function E(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1;
        }
        function k(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1;
        }
        function z(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1;
        }
        function T(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1;
        }
        function B(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2];
            return r * r + n * n + i * i;
        }
        function V(t1) {
            var e = t1[0], r = t1[1], n = t1[2];
            return e * e + r * r + n * n;
        }
        function C(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1;
        }
        function F(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = e[0] * s, t1[1] = e[1] * s, t1[2] = e[2] * s, t1;
        }
        function D(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2];
        }
        function L(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = r[0], a = r[1], l = r[2];
            return t1[0] = i * l - s * a, t1[1] = s * o - n * l, t1[2] = n * a - i * o, t1;
        }
        function R(t1, e, r, n) {
            var i = e[0], s = e[1], o = e[2];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = o + n * (r[2] - o), t1;
        }
        function O(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t1[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (o = o || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / o, t1[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / o, t1;
        }
        function U(t1, e, r) {
            var n = e[0], i = e[1], s = e[2];
            return t1[0] = n * r[0] + i * r[3] + s * r[6], t1[1] = n * r[1] + i * r[4] + s * r[7], t1[2] = n * r[2] + i * r[5] + s * r[8], t1;
        }
        function N(t1, e, r) {
            var n = r[0], i = r[1], s = r[2], o = e[0], a = e[1], l = e[2], u = i * l - s * a, c = s * o - n * l, h = n * a - i * o, p = i * h - s * c, d = s * u - n * h, f = n * c - i * u, m = 2 * r[3];
            return c *= m, h *= m, d *= 2, f *= 2, t1[0] = o + (u *= m) + (p *= 2), t1[1] = a + c + d, t1[2] = l + h + f, t1;
        }
        function j(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1;
        }
        function $(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2];
        }
        var G = S, H = P, q = _;
        function X() {
            var t1 = new r(4);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0), t1;
        }
        function Z(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
        }
        function W(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = r * r + n * n + i * i + s * s;
            return o > 0 && (o = 1 / Math.sqrt(o)), t1[0] = r * o, t1[1] = n * o, t1[2] = i * o, t1[3] = s * o, t1;
        }
        function Y(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = e[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * o, t1[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * o, t1[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * o, t1[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * o, t1;
        }
        function K() {
            var t1 = new r(4);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function J(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }
        function Q(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], o = e[3], a = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + o * a, t1[1] = i * l + s * a, t1[2] = s * l - i * a, t1[3] = o * l - n * a, t1;
        }
        function tt(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], o = e[3], a = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l - s * a, t1[1] = i * l + o * a, t1[2] = s * l + n * a, t1[3] = o * l - i * a, t1;
        }
        b(), X();
        var et, rt, nt, it = W, st = (et = b(), rt = A(1, 0, 0), nt = A(0, 1, 0), function(t1, e, r) {
            var n = D(e, r);
            return n < -.999999 ? (L(et, rt, e), q(et) < 1e-6 && L(et, nt, e), F(et, et), function(t1, e, r) {
                r *= .5;
                var n = Math.sin(r);
                t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = Math.cos(r);
            }(t1, et, Math.PI), t1) : n > .999999 ? (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1) : (L(et, e, r), t1[0] = et[0], t1[1] = et[1], t1[2] = et[2], t1[3] = 1 + n, it(t1, t1));
        });
        function ot() {
            var t1 = new r(2);
            return r != Float32Array && (t1[0] = 0, t1[1] = 0), t1;
        }
        function at(t1, e) {
            var n = new r(2);
            return n[0] = t1, n[1] = e, n;
        }
        function lt(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1;
        }
        function ut(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1;
        }
        function ct(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1;
        }
        function ht(t1) {
            return Math.hypot(t1[0], t1[1]);
        }
        function pt(t1, e) {
            var r = e[0], n = e[1], i = r * r + n * n;
            return i > 0 && (i = 1 / Math.sqrt(i)), t1[0] = e[0] * i, t1[1] = e[1] * i, t1;
        }
        function dt(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1];
        }
        K(), K(), i();
        var ft, mt, yt = ut;
        function gt(t1) {
            return t1 && t1.__esModule && Object.prototype.hasOwnProperty.call(t1, "default") ? t1.default : t1;
        }
        ot();
        var xt = function() {
            if (mt) return ft;
            function t1(t1, e, r, n) {
                this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e, this.p2x = r, this.p2y = n;
            }
            return mt = 1, ft = t1, t1.prototype = {
                sampleCurveX: function(t1) {
                    return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
                },
                sampleCurveY: function(t1) {
                    return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
                },
                sampleCurveDerivativeX: function(t1) {
                    return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
                },
                solveCurveX: function(t1, e) {
                    if (void 0 === e && (e = 1e-6), t1 < 0) return 0;
                    if (t1 > 1) return 1;
                    for(var r = t1, n = 0; n < 8; n++){
                        var i = this.sampleCurveX(r) - t1;
                        if (Math.abs(i) < e) return r;
                        var s = this.sampleCurveDerivativeX(r);
                        if (Math.abs(s) < 1e-6) break;
                        r -= i / s;
                    }
                    var o = 0, a = 1;
                    for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e)); n++)t1 > i ? o = r : a = r, r = .5 * (a - o) + o;
                    return r;
                },
                solve: function(t1, e) {
                    return this.sampleCurveY(this.solveCurveX(t1, e));
                }
            }, ft;
        }(), vt = gt(xt);
        function bt(t1, e) {
            this.x = t1, this.y = e;
        }
        function wt(t1, e) {
            if (Array.isArray(t1)) {
                if (!Array.isArray(e) || t1.length !== e.length) return !1;
                for(let r = 0; r < t1.length; r++)if (!wt(t1[r], e[r])) return !1;
                return !0;
            }
            if ("object" == typeof t1 && null !== t1 && null !== e) {
                if ("object" != typeof e) return !1;
                if (Object.keys(t1).length !== Object.keys(e).length) return !1;
                for(const r in t1)if (!wt(t1[r], e[r])) return !1;
                return !0;
            }
            return t1 === e;
        }
        bt.prototype = {
            clone () {
                return new bt(this.x, this.y);
            },
            add (t1) {
                return this.clone()._add(t1);
            },
            sub (t1) {
                return this.clone()._sub(t1);
            },
            multByPoint (t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint (t1) {
                return this.clone()._divByPoint(t1);
            },
            mult (t1) {
                return this.clone()._mult(t1);
            },
            div (t1) {
                return this.clone()._div(t1);
            },
            rotate (t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround (t1, e) {
                return this.clone()._rotateAround(t1, e);
            },
            matMult (t1) {
                return this.clone()._matMult(t1);
            },
            unit () {
                return this.clone()._unit();
            },
            perp () {
                return this.clone()._perp();
            },
            round () {
                return this.clone()._round();
            },
            mag () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals (t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist (t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr (t1) {
                const e = t1.x - this.x, r = t1.y - this.y;
                return e * e + r * r;
            },
            angle () {
                return Math.atan2(this.y, this.x);
            },
            angleTo (t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith (t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep (t1, e) {
                return Math.atan2(this.x * e - this.y * t1, this.x * t1 + this.y * e);
            },
            _matMult (t1) {
                const e = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e, this;
            },
            _add (t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub (t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult (t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div (t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint (t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint (t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit () {
                return this._div(this.mag()), this;
            },
            _perp () {
                const t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate (t1) {
                const e = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e * this.y;
                return this.x = e * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround (t1, e) {
                const r = Math.cos(t1), n = Math.sin(t1), i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
                return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
            },
            _round () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            },
            constructor: bt
        }, bt.convert = function(t1) {
            if (t1 instanceof bt) return t1;
            if (Array.isArray(t1)) return new bt(+t1[0], +t1[1]);
            if (void 0 !== t1.x && void 0 !== t1.y) return new bt(+t1.x, +t1.y);
            throw new Error("Expected [x, y] or {x, y} point format");
        };
        const _t = Math.PI / 180, At = 180 / Math.PI;
        function Mt(t1) {
            return t1 * _t;
        }
        function It(t1) {
            return t1 * At;
        }
        const St = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function Pt(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e = t1 * t1, r = e * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e) + r - .75);
        }
        function Et(t1, e, r, n) {
            const i = new vt(t1, e, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const kt = Et(.25, .1, .25, 1);
        function zt(t1, e, r) {
            return Math.min(r, Math.max(e, t1));
        }
        function Tt(t1, e, r) {
            return (r = zt((r - t1) / (e - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function Bt(t1, e, r) {
            const n = r - e, i = ((t1 - e) % n + n) % n + e;
            return i === e ? r : i;
        }
        function Vt(t1, e, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let s = null;
            t1.forEach((t1, o)=>{
                e(t1, (t1, e)=>{
                    t1 && (s = t1), i[o] = e, 0 == --n && r(s, i);
                });
            });
        }
        function Ct(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        let Ft = 1;
        function Dt() {
            return Ft++;
        }
        function Lt(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function Rt(t1, e) {
            t1.forEach((t1)=>{
                e[t1] && (e[t1] = e[t1].bind(e));
            });
        }
        function Ot(t1, e, r) {
            const n = {};
            for(const r in t1)n[r] = e.call(this, t1[r], r, t1);
            return n;
        }
        function Ut(t1, e, r) {
            const n = {};
            for(const r in t1)e.call(this, t1[r], r, t1) && (n[r] = t1[r]);
            return n;
        }
        function Nt(t1) {
            return Array.isArray(t1) ? t1.map(Nt) : "object" == typeof t1 && t1 ? Ot(t1, Nt) : t1;
        }
        function jt(t1, e) {
            for(let r = 0; r < t1.length; r++)if (e.indexOf(t1[r]) >= 0) return !0;
            return !1;
        }
        const $t = {};
        function Gt(t1) {
            $t[t1] || ("undefined" != typeof console && console.warn(t1), $t[t1] = !0);
        }
        function Ht(t1, e, r) {
            return (r.y - t1.y) * (e.x - t1.x) > (e.y - t1.y) * (r.x - t1.x);
        }
        function qt(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, o = s - 1; i < s; o = i++)r = t1[i], n = t1[o], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function Xt([t1, e, r]) {
            const n = Mt(e + 90), i = Mt(r);
            return {
                x: t1 * Math.cos(n) * Math.sin(i),
                y: t1 * Math.sin(n) * Math.sin(i),
                z: t1 * Math.cos(i),
                azimuthal: e,
                polar: r
            };
        }
        function Zt(t1) {
            return ("undefined" != typeof self || void 0 !== t1) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t1 ? t1 : self) instanceof WorkerGlobalScope;
        }
        function Wt(t1) {
            const e = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const s = n || i;
                return e[r] = !s || s.toLowerCase(), "";
            }), e["max-age"]) {
                const t1 = parseInt(e["max-age"], 10);
                isNaN(t1) ? delete e["max-age"] : e["max-age"] = t1;
            }
            return e;
        }
        let Yt = null;
        function Kt(t1, e) {
            return [
                t1[4 * e],
                t1[4 * e + 1],
                t1[4 * e + 2],
                t1[4 * e + 3]
            ];
        }
        function Jt(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] < n ? e = i + 1 : r = i;
            }
            return e;
        }
        function Qt(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] <= n ? e = i + 1 : r = i;
            }
            return e;
        }
        function te(t1) {
            return t1 > 0 ? 1 / (1.001 - t1) : 1 + t1;
        }
        function ee(t1) {
            return t1 > 0 ? 1 - 1 / (1.001 - t1) : -t1;
        }
        function re(t1, e, r) {
            return (t1 - e.min) * (r.max - r.min) / (e.max - e.min) + r.min;
        }
        const ne = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                if (!ne.API_URL) return null;
                try {
                    const t1 = new URL(ne.API_URL);
                    return "api.mapbox.cn" === t1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t1.hostname ? "https://events.mapbox.com/events/v2" : null;
                } catch (t1) {
                    return null;
                }
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
            MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
            MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
            BUILDING_GEN_URL: "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.1.wasm",
            GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
            TILES3D_URL_PREFIX: "3dtiles/v1"
        };
        function ie(t1) {
            return ne.API_URL_REGEX.test(t1);
        }
        function se(t1) {
            return ne.API_SPRITE_REGEX.test(t1);
        }
        let oe, ae, le, ue, ce, he;
        function pe() {
            return null == oe && (oe = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), oe;
        }
        const de = {
            now: ()=>void 0 !== ue ? ue : performance.now(),
            setNow (t1) {
                ue = t1;
            },
            restoreNow () {
                ue = void 0;
            },
            frame (t1) {
                const e = requestAnimationFrame(t1);
                return {
                    cancel: ()=>cancelAnimationFrame(e)
                };
            },
            getImageData (t1, e = 0) {
                const { width: r, height: n } = t1;
                ce || (ce = document.createElement("canvas"));
                const i = ce.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!i) throw new Error("failed to create canvas 2d context");
                return (r > ce.width || n > ce.height) && (ce.width = r, ce.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t1, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);
            },
            resolveURL: (t1)=>(ae || (ae = document.createElement("a")), ae.href = t1, ae.href),
            get devicePixelRatio () {
                return window.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!window.matchMedia && (null == le && (le = window.matchMedia("(prefers-reduced-motion: reduce)")), le.matches);
            },
            hasCanvasFingerprintNoise () {
                if (void 0 !== he) return he;
                if (!pe()) return he = !1, !1;
                const t1 = new OffscreenCanvas(85, 1), e = t1.getContext("2d", {
                    willReadFrequently: !0
                });
                let r = 0;
                for(let n = 0; n < t1.width; ++n)e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);
                const n = e.getImageData(0, 0, t1.width, t1.height);
                r = 0;
                for(let t1 = 0; t1 < n.data.length; ++t1)if (t1 % 4 != 3 && r++ !== n.data[t1]) return he = !0, !0;
                return he = !1, !1;
            }
        };
        function fe(t1, e) {
            const r = t1.indexOf("?");
            if (r < 0) return `${t1}?${new URLSearchParams(e).toString()}`;
            const n = new URLSearchParams(t1.slice(r));
            for(const t1 in e)n.set(t1, e[t1]);
            return `${t1.slice(0, r)}?${n.toString()}`;
        }
        function me(t1, e = {
            persistentParams: []
        }) {
            const r = t1.indexOf("?");
            if (r < 0) return t1;
            const n = new URLSearchParams, i = new URLSearchParams(t1.slice(r));
            for (const t1 of e.persistentParams){
                const e = i.get(t1);
                e && n.set(t1, e);
            }
            const s = n.toString();
            return `${t1.slice(0, r)}${s.length > 0 ? `?${s}` : ""}`;
        }
        const ye = "mapbox-tiles";
        let ge = 500, xe = 50;
        const ve = [
            "language",
            "worldview",
            "jobid"
        ];
        let be, we;
        function _e() {
            try {
                return caches;
            } catch (t1) {}
        }
        function Ae() {
            const t1 = _e();
            t1 && null == be && (be = t1.open(ye));
        }
        let Me = 1 / 0;
        const Ie = {
            supported: !1,
            testSupport: function(t1) {
                !Ee && Pe && (ke ? Te(t1) : Se = t1);
            }
        };
        let Se, Pe, Ee = !1, ke = !1;
        const ze = "undefined" != typeof self ? self : {};
        function Te(t1) {
            const e = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, Pe), t1.isContextLost()) return;
                Ie.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e), Ee = !0;
        }
        ze.document && (Pe = ze.document.createElement("img"), Pe.onload = function() {
            Se && Te(Se), Se = null, ke = !0;
        }, Pe.onerror = function() {
            Ee = !0, Se = null;
        }, Pe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Be = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Iconset: "Iconset",
            Image: "Image",
            Model: "Model"
        };
        "function" == typeof Object.freeze && Object.freeze(Be);
        class Ve extends Error {
            constructor(t1, e, r){
                401 === e && ie(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const Ce = Zt() ? ()=>self.worker.referrer : ()=>("blob:" === location.protocol ? parent : self).location.href;
        const Fe = function(t1, e) {
            if (!(/^file:/.test(r = t1.url) || /^file:/.test(Ce()) && !/^\w+:/.test(r))) {
                if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t1, e) {
                    const r = new AbortController, n = new Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: Ce(),
                        referrerPolicy: t1.referrerPolicy,
                        signal: r.signal
                    });
                    let i = !1, s = !1;
                    const o = (a = n.url).indexOf("sku=") > 0 && ie(a);
                    var a;
                    "json" === t1.type && n.headers.set("Accept", "application/json");
                    const l = (r, i, a)=>{
                        if (s) return;
                        if (r && "SecurityError" !== r.message && Gt(r.toString()), i && a) return u(i);
                        const l = Date.now();
                        fetch(n).then((r)=>{
                            if (r.ok) {
                                const t1 = o ? r.clone() : null;
                                return u(r, t1, l);
                            }
                            return e(new Ve(r.statusText, r.status, t1.url));
                        }).catch((r)=>{
                            "AbortError" !== r.name && e(new Error(`${r.message} ${t1.url}`));
                        });
                    }, u = (r, o, a)=>{
                        ("arrayBuffer" === t1.type ? r.arrayBuffer() : "json" === t1.type ? r.json() : r.text()).then((t1)=>{
                            s || (o && a && function(t1, e, r) {
                                if (Ae(), null == be) return;
                                const n = Wt(e.headers.get("Cache-Control") || "");
                                if (n["no-store"]) return;
                                const i = {
                                    status: e.status,
                                    statusText: e.statusText,
                                    headers: new Headers
                                };
                                e.headers.forEach((t1, e)=>i.headers.set(e, t1)), n["max-age"] && i.headers.set("Expires", new Date(r + 1e3 * n["max-age"]).toUTCString());
                                const s = i.headers.get("Expires");
                                if (!s) return;
                                if (new Date(s).getTime() - r < 42e4) return;
                                let o = me(t1.url, {
                                    persistentParams: ve
                                });
                                if (206 === e.status) {
                                    const e = t1.headers.get("Range");
                                    if (!e) return;
                                    i.status = 200, o = fe(o, {
                                        range: e
                                    });
                                }
                                !function(t1, e) {
                                    if (void 0 === we) try {
                                        new Response(new ReadableStream), we = !0;
                                    } catch (t1) {
                                        we = !1;
                                    }
                                    we ? e(t1.body) : t1.blob().then(e).catch((t1)=>Gt(t1.message));
                                }(e, (t1)=>{
                                    const r = new Response(200 !== (n = e.status) && 404 !== n && [
                                        101,
                                        103,
                                        204,
                                        205,
                                        304
                                    ].includes(n) ? null : t1, i);
                                    var n;
                                    Ae(), null != be && be.then((t1)=>t1.put(o, r)).catch((t1)=>Gt(t1.message));
                                });
                            }(n, o, a), i = !0, e(null, t1, r.headers.get("Cache-Control"), r.headers.get("Expires")));
                        }).catch((t1)=>{
                            s || e(new Error(t1.message));
                        });
                    };
                    return o ? function(t1, e) {
                        if (Ae(), null == be) return e(null);
                        be.then((r)=>{
                            let n = me(t1.url, {
                                persistentParams: ve
                            });
                            const i = t1.headers.get("Range");
                            i && (n = fe(n, {
                                range: i
                            })), r.match(n).then((t1)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e = new Date(t1.headers.get("Expires") || 0), r = Wt(t1.headers.get("Cache-Control") || "");
                                    return Number(e) > Date.now() && !r["no-cache"];
                                }(t1);
                                r.delete(n).catch(e), i && r.put(n, t1.clone()).catch(e), e(null, t1, i);
                            }).catch(e);
                        }).catch(e);
                    }(n, l) : l(null, null), {
                        cancel: ()=>{
                            s = !0, i || r.abort();
                        }
                    };
                }(t1, e);
                if (Zt(self) && self.worker.actor) return self.worker.actor.send("getResource", t1, e, void 0, !0);
            }
            var r;
            return function(t1, e) {
                const r = new XMLHttpRequest;
                r.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (r.responseType = "arraybuffer");
                for(const e in t1.headers)r.setRequestHeader(e, t1.headers[e]);
                return "json" === t1.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t1.credentials, r.onerror = ()=>{
                    e(new Error(r.statusText));
                }, r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let n = r.response;
                        if ("json" === t1.type) try {
                            n = JSON.parse(r.response);
                        } catch (t1) {
                            return e(t1);
                        }
                        e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
                    } else e(new Ve(r.statusText, r.status, t1.url));
                }, r.send(t1.body), {
                    cancel: ()=>r.abort()
                };
            }(t1, e);
        }, De = function(t1, e) {
            return Fe(Ct(t1, {
                type: "arrayBuffer"
            }), e);
        };
        function Le(t1) {
            const e = document.createElement("a");
            return e.href = t1, e.protocol === location.protocol && e.host === location.host;
        }
        const Re = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let Oe, Ue;
        Oe = [], Ue = 0;
        const Ne = function(t1, e) {
            if (Ie.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), Ue >= ne.MAX_PARALLEL_IMAGE_REQUESTS) {
                const r = {
                    requestParameters: t1,
                    callback: e,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return Oe.push(r), r;
            }
            Ue++;
            let r = !1;
            const n = ()=>{
                if (!r) for(r = !0, Ue--; Oe.length && Ue < ne.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = Oe.shift(), { requestParameters: e, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = Ne(e, r).cancel);
                }
            }, i = De(t1, (t1, r, i, s)=>{
                n(), t1 ? e(t1) : r && (self.createImageBitmap ? function(t1, e) {
                    const r = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    createImageBitmap(r).then((t1)=>{
                        e(null, t1);
                    }).catch((t1)=>{
                        e(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(r, (t1, r)=>e(t1, r, i, s)) : function(t1, e) {
                    const r = new Image;
                    r.onload = ()=>{
                        e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(()=>{
                            r.src = Re;
                        });
                    }, r.onerror = ()=>e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const n = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    r.src = t1.byteLength ? URL.createObjectURL(n) : Re;
                }(r, (t1, r)=>e(t1, r, i, s)));
            });
            return {
                cancel: ()=>{
                    i.cancel(), n();
                }
            };
        };
        var je, $e, Ge, He = {
            exports: {}
        }, qe = {
            exports: {}
        }, Xe = {
            exports: {}
        }, Ze = function() {
            if (Ge) return He.exports;
            Ge = 1;
            var t1 = (je || (je = 1, qe.exports = function(t1, e) {
                var r, n, i, s, o, a, l, u;
                for(n = t1.length - (r = 3 & t1.length), i = e, o = 3432918353, a = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
                switch(l = 0, r){
                    case 3:
                        l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                    case 2:
                        l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                    case 1:
                        i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295;
                }
                return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
            }), qe.exports), e = ($e || ($e = 1, Xe.exports = function(t1, e) {
                for(var r, n = t1.length, i = e ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(s) | (255 & t1.charCodeAt(++s)) << 8 | (255 & t1.charCodeAt(++s)) << 16 | (255 & t1.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
                switch(n){
                    case 3:
                        i ^= (255 & t1.charCodeAt(s + 2)) << 16;
                    case 2:
                        i ^= (255 & t1.charCodeAt(s + 1)) << 8;
                    case 1:
                        i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
            }), Xe.exports);
            return He.exports = t1, He.exports.murmur3 = t1, He.exports.murmur2 = e, He.exports;
        }(), We = gt(Ze);
        class Ye {
            constructor(t1, ...e){
                Ct(this, e[0] || {}), this.type = t1;
            }
        }
        class Ke extends Ye {
            constructor(t1, e = {}){
                super("error", Ct({
                    error: t1
                }, e));
            }
        }
        function Je(t1, e, r) {
            r[t1] && -1 !== r[t1].indexOf(e) || (r[t1] = r[t1] || [], r[t1].push(e));
        }
        function Qe(t1, e, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class tr {
            on(t1, e) {
                return this._listeners = this._listeners || {}, Je(t1, e, this._listeners), this;
            }
            off(t1, e) {
                return Qe(t1, e, this._listeners), Qe(t1, e, this._oneTimeListeners), this;
            }
            once(t1, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Je(t1, e, this._oneTimeListeners), this) : new Promise((e)=>{
                    this.once(t1, e);
                });
            }
            fire(t1, e) {
                const r = "string" == typeof t1 ? new Ye(t1, e) : t1, n = r.type;
                if (this.listens(n)) {
                    r.target = this;
                    const t1 = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                    for (const e of t1)e.call(this, r);
                    const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                    for (const t1 of e)Qe(n, t1, this._oneTimeListeners), t1.call(this, r);
                    const i = this._eventedParent;
                    i && (Ct(r, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(r));
                } else r instanceof Ke && console.error(r.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e) {
                return this._eventedParent = t1, this._eventedParentData = e, this;
            }
        }
        class er {
            constructor(t1){
                "string" == typeof t1 ? this.name = t1 : (this.name = t1.name, this.iconsetId = t1.iconsetId);
            }
            static from(t1) {
                return new er(t1);
            }
            static toString(t1) {
                return t1.iconsetId ? `${t1.name}${t1.iconsetId}` : t1.name;
            }
            static parse(t1) {
                const [e, r] = t1.split("");
                return new er({
                    name: e,
                    iconsetId: r
                });
            }
            static isEqual(t1, e) {
                return t1.name === e.name && t1.iconsetId === e.iconsetId;
            }
            toString() {
                return er.toString(this);
            }
            serialize() {
                return {
                    name: this.name,
                    iconsetId: this.iconsetId
                };
            }
        }
        var rr, nr = {}, ir = function() {
            if (rr) return nr;
            rr = 1;
            var t1 = {
                transparent: [
                    0,
                    0,
                    0,
                    0
                ],
                aliceblue: [
                    240,
                    248,
                    255,
                    1
                ],
                antiquewhite: [
                    250,
                    235,
                    215,
                    1
                ],
                aqua: [
                    0,
                    255,
                    255,
                    1
                ],
                aquamarine: [
                    127,
                    255,
                    212,
                    1
                ],
                azure: [
                    240,
                    255,
                    255,
                    1
                ],
                beige: [
                    245,
                    245,
                    220,
                    1
                ],
                bisque: [
                    255,
                    228,
                    196,
                    1
                ],
                black: [
                    0,
                    0,
                    0,
                    1
                ],
                blanchedalmond: [
                    255,
                    235,
                    205,
                    1
                ],
                blue: [
                    0,
                    0,
                    255,
                    1
                ],
                blueviolet: [
                    138,
                    43,
                    226,
                    1
                ],
                brown: [
                    165,
                    42,
                    42,
                    1
                ],
                burlywood: [
                    222,
                    184,
                    135,
                    1
                ],
                cadetblue: [
                    95,
                    158,
                    160,
                    1
                ],
                chartreuse: [
                    127,
                    255,
                    0,
                    1
                ],
                chocolate: [
                    210,
                    105,
                    30,
                    1
                ],
                coral: [
                    255,
                    127,
                    80,
                    1
                ],
                cornflowerblue: [
                    100,
                    149,
                    237,
                    1
                ],
                cornsilk: [
                    255,
                    248,
                    220,
                    1
                ],
                crimson: [
                    220,
                    20,
                    60,
                    1
                ],
                cyan: [
                    0,
                    255,
                    255,
                    1
                ],
                darkblue: [
                    0,
                    0,
                    139,
                    1
                ],
                darkcyan: [
                    0,
                    139,
                    139,
                    1
                ],
                darkgoldenrod: [
                    184,
                    134,
                    11,
                    1
                ],
                darkgray: [
                    169,
                    169,
                    169,
                    1
                ],
                darkgreen: [
                    0,
                    100,
                    0,
                    1
                ],
                darkgrey: [
                    169,
                    169,
                    169,
                    1
                ],
                darkkhaki: [
                    189,
                    183,
                    107,
                    1
                ],
                darkmagenta: [
                    139,
                    0,
                    139,
                    1
                ],
                darkolivegreen: [
                    85,
                    107,
                    47,
                    1
                ],
                darkorange: [
                    255,
                    140,
                    0,
                    1
                ],
                darkorchid: [
                    153,
                    50,
                    204,
                    1
                ],
                darkred: [
                    139,
                    0,
                    0,
                    1
                ],
                darksalmon: [
                    233,
                    150,
                    122,
                    1
                ],
                darkseagreen: [
                    143,
                    188,
                    143,
                    1
                ],
                darkslateblue: [
                    72,
                    61,
                    139,
                    1
                ],
                darkslategray: [
                    47,
                    79,
                    79,
                    1
                ],
                darkslategrey: [
                    47,
                    79,
                    79,
                    1
                ],
                darkturquoise: [
                    0,
                    206,
                    209,
                    1
                ],
                darkviolet: [
                    148,
                    0,
                    211,
                    1
                ],
                deeppink: [
                    255,
                    20,
                    147,
                    1
                ],
                deepskyblue: [
                    0,
                    191,
                    255,
                    1
                ],
                dimgray: [
                    105,
                    105,
                    105,
                    1
                ],
                dimgrey: [
                    105,
                    105,
                    105,
                    1
                ],
                dodgerblue: [
                    30,
                    144,
                    255,
                    1
                ],
                firebrick: [
                    178,
                    34,
                    34,
                    1
                ],
                floralwhite: [
                    255,
                    250,
                    240,
                    1
                ],
                forestgreen: [
                    34,
                    139,
                    34,
                    1
                ],
                fuchsia: [
                    255,
                    0,
                    255,
                    1
                ],
                gainsboro: [
                    220,
                    220,
                    220,
                    1
                ],
                ghostwhite: [
                    248,
                    248,
                    255,
                    1
                ],
                gold: [
                    255,
                    215,
                    0,
                    1
                ],
                goldenrod: [
                    218,
                    165,
                    32,
                    1
                ],
                gray: [
                    128,
                    128,
                    128,
                    1
                ],
                green: [
                    0,
                    128,
                    0,
                    1
                ],
                greenyellow: [
                    173,
                    255,
                    47,
                    1
                ],
                grey: [
                    128,
                    128,
                    128,
                    1
                ],
                honeydew: [
                    240,
                    255,
                    240,
                    1
                ],
                hotpink: [
                    255,
                    105,
                    180,
                    1
                ],
                indianred: [
                    205,
                    92,
                    92,
                    1
                ],
                indigo: [
                    75,
                    0,
                    130,
                    1
                ],
                ivory: [
                    255,
                    255,
                    240,
                    1
                ],
                khaki: [
                    240,
                    230,
                    140,
                    1
                ],
                lavender: [
                    230,
                    230,
                    250,
                    1
                ],
                lavenderblush: [
                    255,
                    240,
                    245,
                    1
                ],
                lawngreen: [
                    124,
                    252,
                    0,
                    1
                ],
                lemonchiffon: [
                    255,
                    250,
                    205,
                    1
                ],
                lightblue: [
                    173,
                    216,
                    230,
                    1
                ],
                lightcoral: [
                    240,
                    128,
                    128,
                    1
                ],
                lightcyan: [
                    224,
                    255,
                    255,
                    1
                ],
                lightgoldenrodyellow: [
                    250,
                    250,
                    210,
                    1
                ],
                lightgray: [
                    211,
                    211,
                    211,
                    1
                ],
                lightgreen: [
                    144,
                    238,
                    144,
                    1
                ],
                lightgrey: [
                    211,
                    211,
                    211,
                    1
                ],
                lightpink: [
                    255,
                    182,
                    193,
                    1
                ],
                lightsalmon: [
                    255,
                    160,
                    122,
                    1
                ],
                lightseagreen: [
                    32,
                    178,
                    170,
                    1
                ],
                lightskyblue: [
                    135,
                    206,
                    250,
                    1
                ],
                lightslategray: [
                    119,
                    136,
                    153,
                    1
                ],
                lightslategrey: [
                    119,
                    136,
                    153,
                    1
                ],
                lightsteelblue: [
                    176,
                    196,
                    222,
                    1
                ],
                lightyellow: [
                    255,
                    255,
                    224,
                    1
                ],
                lime: [
                    0,
                    255,
                    0,
                    1
                ],
                limegreen: [
                    50,
                    205,
                    50,
                    1
                ],
                linen: [
                    250,
                    240,
                    230,
                    1
                ],
                magenta: [
                    255,
                    0,
                    255,
                    1
                ],
                maroon: [
                    128,
                    0,
                    0,
                    1
                ],
                mediumaquamarine: [
                    102,
                    205,
                    170,
                    1
                ],
                mediumblue: [
                    0,
                    0,
                    205,
                    1
                ],
                mediumorchid: [
                    186,
                    85,
                    211,
                    1
                ],
                mediumpurple: [
                    147,
                    112,
                    219,
                    1
                ],
                mediumseagreen: [
                    60,
                    179,
                    113,
                    1
                ],
                mediumslateblue: [
                    123,
                    104,
                    238,
                    1
                ],
                mediumspringgreen: [
                    0,
                    250,
                    154,
                    1
                ],
                mediumturquoise: [
                    72,
                    209,
                    204,
                    1
                ],
                mediumvioletred: [
                    199,
                    21,
                    133,
                    1
                ],
                midnightblue: [
                    25,
                    25,
                    112,
                    1
                ],
                mintcream: [
                    245,
                    255,
                    250,
                    1
                ],
                mistyrose: [
                    255,
                    228,
                    225,
                    1
                ],
                moccasin: [
                    255,
                    228,
                    181,
                    1
                ],
                navajowhite: [
                    255,
                    222,
                    173,
                    1
                ],
                navy: [
                    0,
                    0,
                    128,
                    1
                ],
                oldlace: [
                    253,
                    245,
                    230,
                    1
                ],
                olive: [
                    128,
                    128,
                    0,
                    1
                ],
                olivedrab: [
                    107,
                    142,
                    35,
                    1
                ],
                orange: [
                    255,
                    165,
                    0,
                    1
                ],
                orangered: [
                    255,
                    69,
                    0,
                    1
                ],
                orchid: [
                    218,
                    112,
                    214,
                    1
                ],
                palegoldenrod: [
                    238,
                    232,
                    170,
                    1
                ],
                palegreen: [
                    152,
                    251,
                    152,
                    1
                ],
                paleturquoise: [
                    175,
                    238,
                    238,
                    1
                ],
                palevioletred: [
                    219,
                    112,
                    147,
                    1
                ],
                papayawhip: [
                    255,
                    239,
                    213,
                    1
                ],
                peachpuff: [
                    255,
                    218,
                    185,
                    1
                ],
                peru: [
                    205,
                    133,
                    63,
                    1
                ],
                pink: [
                    255,
                    192,
                    203,
                    1
                ],
                plum: [
                    221,
                    160,
                    221,
                    1
                ],
                powderblue: [
                    176,
                    224,
                    230,
                    1
                ],
                purple: [
                    128,
                    0,
                    128,
                    1
                ],
                rebeccapurple: [
                    102,
                    51,
                    153,
                    1
                ],
                red: [
                    255,
                    0,
                    0,
                    1
                ],
                rosybrown: [
                    188,
                    143,
                    143,
                    1
                ],
                royalblue: [
                    65,
                    105,
                    225,
                    1
                ],
                saddlebrown: [
                    139,
                    69,
                    19,
                    1
                ],
                salmon: [
                    250,
                    128,
                    114,
                    1
                ],
                sandybrown: [
                    244,
                    164,
                    96,
                    1
                ],
                seagreen: [
                    46,
                    139,
                    87,
                    1
                ],
                seashell: [
                    255,
                    245,
                    238,
                    1
                ],
                sienna: [
                    160,
                    82,
                    45,
                    1
                ],
                silver: [
                    192,
                    192,
                    192,
                    1
                ],
                skyblue: [
                    135,
                    206,
                    235,
                    1
                ],
                slateblue: [
                    106,
                    90,
                    205,
                    1
                ],
                slategray: [
                    112,
                    128,
                    144,
                    1
                ],
                slategrey: [
                    112,
                    128,
                    144,
                    1
                ],
                snow: [
                    255,
                    250,
                    250,
                    1
                ],
                springgreen: [
                    0,
                    255,
                    127,
                    1
                ],
                steelblue: [
                    70,
                    130,
                    180,
                    1
                ],
                tan: [
                    210,
                    180,
                    140,
                    1
                ],
                teal: [
                    0,
                    128,
                    128,
                    1
                ],
                thistle: [
                    216,
                    191,
                    216,
                    1
                ],
                tomato: [
                    255,
                    99,
                    71,
                    1
                ],
                turquoise: [
                    64,
                    224,
                    208,
                    1
                ],
                violet: [
                    238,
                    130,
                    238,
                    1
                ],
                wheat: [
                    245,
                    222,
                    179,
                    1
                ],
                white: [
                    255,
                    255,
                    255,
                    1
                ],
                whitesmoke: [
                    245,
                    245,
                    245,
                    1
                ],
                yellow: [
                    255,
                    255,
                    0,
                    1
                ],
                yellowgreen: [
                    154,
                    205,
                    50,
                    1
                ]
            };
            function e(t1) {
                return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
            }
            function r(t1) {
                return e("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
            }
            function n(t1) {
                return (e = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e > 1 ? 1 : e;
                //TURBOPACK unreachable
                ;
                var e;
            }
            function i(t1, e, r) {
                return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e - t1) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t1 + (e - t1) * (2 / 3 - r) * 6 : t1;
            }
            try {
                nr.parseCSSColor = function(s) {
                    var o, a = s.replace(/ /g, "").toLowerCase();
                    if (a in t1) return t1[a].slice();
                    if ("#" === a[0]) return 4 === a.length ? (o = parseInt(a.substr(1), 16)) >= 0 && o <= 4095 ? [
                        (3840 & o) >> 4 | (3840 & o) >> 8,
                        240 & o | (240 & o) >> 4,
                        15 & o | (15 & o) << 4,
                        1
                    ] : null : 7 === a.length && (o = parseInt(a.substr(1), 16)) >= 0 && o <= 16777215 ? [
                        (16711680 & o) >> 16,
                        (65280 & o) >> 8,
                        255 & o,
                        1
                    ] : null;
                    var l = a.indexOf("("), u = a.indexOf(")");
                    if (-1 !== l && u + 1 === a.length) {
                        var c = a.substr(0, l), h = a.substr(l + 1, u - (l + 1)).split(","), p = 1;
                        switch(c){
                            case "rgba":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "rgb":
                                return 3 !== h.length ? null : [
                                    r(h[0]),
                                    r(h[1]),
                                    r(h[2]),
                                    p
                                ];
                            case "hsla":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "hsl":
                                if (3 !== h.length) return null;
                                var d = (parseFloat(h[0]) % 360 + 360) % 360 / 360, f = n(h[1]), m = n(h[2]), y = m <= .5 ? m * (f + 1) : m + f - m * f, g = 2 * m - y;
                                return [
                                    e(255 * i(g, y, d + 1 / 3)),
                                    e(255 * i(g, y, d)),
                                    e(255 * i(g, y, d - 1 / 3)),
                                    p
                                ];
                            default:
                                return null;
                        }
                    }
                    return null;
                };
            } catch (t1) {}
            return nr;
        }();
        class sr {
            constructor(t1, e, r, n = 1){
                this.r = t1, this.g = e, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof sr) return t1;
                if ("string" != typeof t1) return;
                const e = ir.parseCSSColor(t1);
                return e ? new sr(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) : void 0;
            }
            toString() {
                const [t1, e, r, n] = [
                    this.r,
                    this.g,
                    this.b,
                    this.a
                ];
                return `rgba(${Math.round(255 * t1)},${Math.round(255 * e)},${Math.round(255 * r)},${n})`;
            }
            toNonPremultipliedRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new ar(t1, e, r, n, i);
            }
            toPremultipliedRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new lr(t1, e * i, r * i, n * i, i);
            }
            clone() {
                return new sr(this.r, this.g, this.b, this.a);
            }
        }
        class or {
            constructor(t1, e, r, n, i, s = !1){
                if (this.premultiplied = !1, this.premultiplied = s, t1) {
                    const s = t1.image.height, o = s * s;
                    this.premultiplied ? (e = 0 === i ? 0 : e / i * (s - 1), r = 0 === i ? 0 : r / i * (s - 1), n = 0 === i ? 0 : n / i * (s - 1)) : (e *= s - 1, r *= s - 1, n *= s - 1);
                    const a = Math.floor(e), l = Math.floor(r), u = Math.floor(n), c = Math.ceil(e), h = Math.ceil(r), p = Math.ceil(n), d = e - a, f = r - l, m = n - u, y = t1.image.data, g = 4 * (a + l * o + u * s), x = 4 * (a + l * o + p * s), v = 4 * (a + h * o + u * s), b = 4 * (a + h * o + p * s), w = 4 * (c + l * o + u * s), _ = 4 * (c + l * o + p * s), A = 4 * (c + h * o + u * s), M = 4 * (c + h * o + p * s);
                    if (g < 0 || M >= y.length) throw new Error("out of range");
                    this.r = ur(ur(ur(y[g], y[x], m), ur(y[v], y[b], m), f), ur(ur(y[w], y[_], m), ur(y[A], y[M], m), f), d) / 255 * (this.premultiplied ? i : 1), this.g = ur(ur(ur(y[g + 1], y[x + 1], m), ur(y[v + 1], y[b + 1], m), f), ur(ur(y[w + 1], y[_ + 1], m), ur(y[A + 1], y[M + 1], m), f), d) / 255 * (this.premultiplied ? i : 1), this.b = ur(ur(ur(y[g + 2], y[x + 2], m), ur(y[v + 2], y[b + 2], m), f), ur(ur(y[w + 2], y[_ + 2], m), ur(y[A + 2], y[M + 2], m), f), d) / 255 * (this.premultiplied ? i : 1), this.a = i;
                } else this.r = e, this.g = r, this.b = n, this.a = i;
            }
            toArray() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    255 * t1,
                    255 * e,
                    255 * r,
                    n
                ];
            }
            toHslaArray() {
                let { r: t1, g: e, b: r, a: n } = this;
                if (this.premultiplied) {
                    if (0 === n) return [
                        0,
                        0,
                        0,
                        0
                    ];
                    t1 /= n, e /= n, r /= n;
                }
                const i = Math.min(Math.max(t1, 0), 1), s = Math.min(Math.max(e, 0), 1), o = Math.min(Math.max(r, 0), 1), a = Math.min(i, s, o), l = Math.max(i, s, o), u = (a + l) / 2;
                if (a === l) return [
                    0,
                    0,
                    100 * u,
                    n
                ];
                const c = l - a, h = u > .5 ? c / (2 - l - a) : c / (l + a);
                let p = 0;
                return l === i ? p = (s - o) / c + (s < o ? 6 : 0) : l === s ? p = (o - i) / c + 2 : l === o && (p = (i - s) / c + 4), p *= 60, [
                    Math.min(Math.max(p, 0), 360),
                    Math.min(Math.max(100 * h, 0), 100),
                    Math.min(Math.max(100 * u, 0), 100),
                    n
                ];
            }
            toArray01() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    t1,
                    e,
                    r,
                    n
                ];
            }
            toArray01Scaled(t1) {
                const { r: e, g: r, b: n } = this;
                return [
                    e * t1,
                    r * t1,
                    n * t1
                ];
            }
            toArray01Linear() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    Math.pow(t1, 2.2),
                    Math.pow(e, 2.2),
                    Math.pow(r, 2.2),
                    n
                ];
            }
        }
        class ar extends or {
            constructor(t1, e, r, n, i){
                super(t1, e, r, n, i, !1);
            }
        }
        class lr extends or {
            constructor(t1, e, r, n, i){
                super(t1, e, r, n, i, !0);
            }
        }
        function ur(t1, e, r) {
            return t1 * (1 - r) + e * r;
        }
        function cr(t1, e, r) {
            return t1.map((t1, n)=>ur(t1, e[n], r));
        }
        sr.black = new sr(0, 0, 0, 1), sr.white = new sr(1, 1, 1, 1), sr.transparent = new sr(0, 0, 0, 0), sr.red = new sr(1, 0, 0, 1), sr.blue = new sr(0, 0, 1, 1);
        var hr = Object.freeze({
            __proto__: null,
            array: cr,
            color: function(t1, e, r) {
                return new sr(ur(t1.r, e.r, r), ur(t1.g, e.g, r), ur(t1.b, e.b, r), ur(t1.a, e.a, r));
            },
            number: ur
        });
        function pr(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        class dr extends Error {
            constructor(t1, e){
                super(e), this.message = e, this.key = t1;
            }
        }
        class fr {
            constructor(t1, e = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e)this.bindings[t1] = r;
            }
            concat(t1) {
                return new fr(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        const mr = {
            kind: "null"
        }, yr = {
            kind: "number"
        }, gr = {
            kind: "string"
        }, xr = {
            kind: "boolean"
        }, vr = {
            kind: "color"
        }, br = {
            kind: "object"
        }, wr = {
            kind: "value"
        }, _r = {
            kind: "collator"
        }, Ar = {
            kind: "formatted"
        }, Mr = {
            kind: "resolvedImage"
        };
        function Ir(t1, e) {
            return {
                kind: "array",
                itemType: t1,
                N: e
            };
        }
        function Sr(t1) {
            if ("array" === t1.kind) {
                const e = Sr(t1.itemType);
                return "number" == typeof t1.N ? `array<${e}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e}>`;
            }
            return t1.kind;
        }
        const Pr = [
            mr,
            yr,
            gr,
            xr,
            vr,
            Ar,
            br,
            Ir(wr),
            Mr
        ];
        function Er(t1, e) {
            if ("error" === e.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Er(t1.itemType, e.itemType)) && ("number" != typeof t1.N || t1.N === e.N)) return null;
            } else {
                if (t1.kind === e.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of Pr)if (!Er(t1, e)) return null;
                }
            }
            return `Expected ${Sr(t1)} but found ${Sr(e)} instead.`;
        }
        function kr(t1, e) {
            return e.some((e)=>e.kind === t1.kind);
        }
        function zr(t1, e) {
            return e.some((e)=>"null" === e ? null === t1 : "array" === e ? Array.isArray(t1) : "object" === e ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e === typeof t1);
        }
        function Tr(t1, e) {
            return "array" === t1.kind && "array" === e.kind ? t1.N === e.N && Tr(t1.itemType, e.itemType) : t1.kind === e.kind;
        }
        class Br {
            constructor(t1, e, r){
                this.sensitivity = t1 ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e) {
                return this.collator.compare(t1, e);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class Vr {
            constructor(t1, e, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class Cr {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new Cr([
                    new Vr(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || !!t1.image && t1.image.hasPrimary());
            }
            static factory(t1) {
                return t1 instanceof Cr ? t1 : Cr.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    if (e.image) {
                        const r = e.image.getPrimary().id.toString();
                        t1.push([
                            "image",
                            r
                        ]);
                        continue;
                    }
                    t1.push(e.text);
                    const r = {};
                    e.fontStack && (r["text-font"] = [
                        "literal",
                        e.fontStack.split(",")
                    ]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e.textColor.toNonPremultipliedRenderColor(null).toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class Fr {
            constructor(t1, e = {}){
                if (this.id = er.from(t1), this.options = Object.assign({}, e), e.transform) {
                    const { a: t1, b: r, c: n, d: i, e: s, f: o } = e.transform;
                    this.options.transform = new DOMMatrix([
                        t1,
                        r,
                        n,
                        i,
                        s,
                        o
                    ]);
                } else this.options.transform = new DOMMatrix([
                    1,
                    0,
                    0,
                    1,
                    0,
                    0
                ]);
            }
            toString() {
                const { a: t1, b: e, c: r, d: n, e: i, f: s } = this.options.transform;
                return JSON.stringify({
                    name: this.id.name,
                    iconsetId: this.id.iconsetId,
                    params: this.options.params,
                    transform: {
                        a: t1,
                        b: e,
                        c: r,
                        d: n,
                        e: i,
                        f: s
                    }
                });
            }
            static parse(t1) {
                let e, r, n, i;
                try {
                    ({ name: e, iconsetId: r, params: n, transform: i } = JSON.parse(t1) || {});
                } catch (t1) {
                    return null;
                }
                if (!e) return null;
                const { a: s, b: o, c: a, d: l, e: u, f: c } = i || {};
                return new Fr({
                    name: e,
                    iconsetId: r
                }, {
                    params: n,
                    transform: new DOMMatrix([
                        s,
                        o,
                        a,
                        l,
                        u,
                        c
                    ])
                });
            }
            scaleSelf(t1, e) {
                return this.options.transform.scaleSelf(t1, e), this;
            }
        }
        class Dr {
            constructor(t1, e, r, n, i = !1){
                this.primaryId = er.from(t1), this.primaryOptions = e, r && (this.secondaryId = er.from(r)), this.secondaryOptions = n, this.available = i;
            }
            toString() {
                return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
            }
            hasPrimary() {
                return !!this.primaryId;
            }
            getPrimary() {
                return new Fr(this.primaryId, this.primaryOptions);
            }
            hasSecondary() {
                return !!this.secondaryId;
            }
            getSecondary() {
                return this.secondaryId ? new Fr(this.secondaryId, this.secondaryOptions) : null;
            }
            static from(t1) {
                return "string" == typeof t1 ? Dr.build({
                    name: t1
                }) : t1;
            }
            static build(t1, e, r, n) {
                return !t1 || "object" == typeof t1 && !("name" in t1) ? null : new Dr(t1, r, e, n);
            }
        }
        function Lr(t1, e, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e,
                r,
                n
            ] : [
                t1,
                e,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Rr(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof sr) return !0;
            if (t1 instanceof Br) return !0;
            if (t1 instanceof Cr) return !0;
            if (t1 instanceof Dr) return !0;
            if (Array.isArray(t1)) {
                for (const e of t1)if (!Rr(e)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e in t1)if (!Rr(t1[e])) return !1;
                return !0;
            }
            return !1;
        }
        function Or(t1) {
            if (null === t1) return mr;
            if ("string" == typeof t1) return gr;
            if ("boolean" == typeof t1) return xr;
            if ("number" == typeof t1) return yr;
            if (t1 instanceof sr) return vr;
            if (t1 instanceof Br) return _r;
            if (t1 instanceof Cr) return Ar;
            if (t1 instanceof Dr) return Mr;
            if (Array.isArray(t1)) {
                const e = t1.length;
                let r;
                for (const e of t1){
                    const t1 = Or(e);
                    if (r) {
                        if (r === t1) continue;
                        r = wr;
                        break;
                    }
                    r = t1;
                }
                return Ir(r || wr, e);
            }
            return br;
        }
        function Ur(t1) {
            const e = typeof t1;
            return null === t1 ? "" : "string" === e || "number" === e || "boolean" === e ? String(t1) : t1 instanceof Cr || t1 instanceof Dr || t1 instanceof sr ? t1.toString() : JSON.stringify(t1);
        }
        class Nr {
            constructor(t1, e){
                this.type = t1, this.value = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!Rr(t1[1])) return e.error("invalid value");
                const r = t1[1];
                let n = Or(r);
                const i = e.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Nr(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof sr ? [
                    "rgba"
                ].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof Cr ? this.value.serialize() : this.value;
            }
        }
        class jr {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        }
        const $r = {
            string: gr,
            number: yr,
            boolean: xr,
            object: br
        };
        class Gr {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, s;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in $r) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = $r[r], n++;
                    } else i = wr;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t1[2], n++;
                    }
                    r = Ir(i, s);
                } else r = $r[i];
                const s = [];
                for(; n < t1.length; n++){
                    const r = e.parse(t1[n], n, wr);
                    if (!r) return null;
                    s.push(r);
                }
                return new Gr(r, s);
            }
            evaluate(t1) {
                for(let e = 0; e < this.args.length; e++){
                    const r = this.args[e].evaluate(t1);
                    if (!Er(this.type, Or(r))) return r;
                    if (e === this.args.length - 1) throw new jr(`The expression ${JSON.stringify(this.args[e].serialize())} evaluated to ${Sr(Or(r))} but was expected to be of type ${Sr(this.type)}.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }
                return e.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        class Hr {
            constructor(t1){
                this.type = Ar, this.sections = t1;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const s = t1[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t1 = null;
                        if (s["font-scale"] && (t1 = e.parseObjectValue(s["font-scale"], r, "font-scale", yr), !t1)) return null;
                        let o = null;
                        if (s["text-font"] && (o = e.parseObjectValue(s["text-font"], r, "text-font", Ir(gr)), !o)) return null;
                        let a = null;
                        if (s["text-color"] && (a = e.parseObjectValue(s["text-color"], r, "text-color", vr), !a)) return null;
                        const l = n[n.length - 1];
                        l.scale = t1, l.font = o, l.textColor = a;
                    } else {
                        const s = e.parse(t1[r], r, wr);
                        if (!s) return null;
                        const o = s.type.kind;
                        if ("string" !== o && "value" !== o && "null" !== o && "resolvedImage" !== o) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Hr(n);
            }
            evaluate(t1) {
                return new Cr(this.sections.map((e)=>{
                    const r = e.content.evaluate(t1);
                    return Tr(Or(r), Mr) ? new Vr("", r, null, null, null) : new Vr(Ur(r), null, e.scale ? e.scale.evaluate(t1) : null, e.font ? e.font.evaluate(t1).join(",") : null, e.textColor ? e.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e of this.sections)t1(e.content), e.scale && t1(e.scale), e.font && t1(e.font), e.textColor && t1(e.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    t1.push(e.content.serialize());
                    const r = {};
                    e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class qr {
            constructor(t1, e, r, n){
                this._imageWarnHistory = {}, this.type = Mr, this.namePrimary = t1, this.nameSecondary = e, r && (this.paramsPrimary = r.params, this.iconsetIdPrimary = r.iconset ? r.iconset.id : void 0), n && (this.paramsSecondary = n.params, this.iconsetIdSecondary = n.iconset ? n.iconset.id : void 0);
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected two or more arguments.");
                let r = 1;
                const n = [];
                function i() {
                    if (r < t1.length) {
                        const i = e.parse(t1[r], r++, gr);
                        return i ? (n.push({
                            image: i,
                            options: {}
                        }), !0) : (e.error(n.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
                    }
                    return !0;
                }
                function s() {
                    if (r < t1.length) {
                        const s = t1[r];
                        if (null === (i = s) || "object" != typeof i || Array.isArray(i)) return !0;
                        const o = s.params, a = s.iconset, l = e.concat(r);
                        if (!o && !a) return r++, !0;
                        if (o) {
                            if ("object" != typeof o || o.constructor !== Object) return l.error('Image options "params" should be an object'), !1;
                            const t1 = {}, e = l.concat(void 0, "params");
                            for(const r in o){
                                if (!r) return e.error("Image parameter name should be non-empty"), !1;
                                const n = e.concat(void 0, r).parse(o[r], void 0, vr, void 0, {
                                    typeAnnotation: "coerce"
                                });
                                if (!n) return !1;
                                t1[r] = n;
                            }
                            n[n.length - 1].options.params = t1;
                        }
                        if (a) {
                            if ("object" != typeof a || a.constructor !== Object) return l.error('Image options "iconset" should be an object'), !1;
                            if (!a.id) return l.error('Image options "iconset" should have an "id" property'), !1;
                            n[n.length - 1].options.iconset = a;
                        }
                        return r++, !0;
                    }
                    var i;
                    return !0;
                }
                for(let t1 = 0; t1 < 2; t1++)if (!i() || !s()) return;
                return new qr(n[0].image, n[1] ? n[1].image : void 0, n[0].options, n[1] ? n[1].options : void 0);
            }
            evaluateParams(t1, e) {
                const r = {};
                if (e) {
                    for(const n in e)if (e[n]) try {
                        r[n] = e[n].evaluate(t1);
                    } catch (t1) {
                        continue;
                    }
                    if (0 !== Object.keys(r).length) return {
                        params: r
                    };
                }
            }
            evaluate(t1) {
                const e = {
                    name: this.namePrimary.evaluate(t1),
                    iconsetId: this.iconsetIdPrimary
                }, r = this.nameSecondary ? {
                    name: this.nameSecondary.evaluate(t1),
                    iconsetId: this.iconsetIdSecondary
                } : void 0, n = Dr.build(e, r, this.paramsPrimary ? this.evaluateParams(t1, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t1, this.paramsSecondary) : void 0);
                if (n && t1.availableImages) {
                    const e = n.getPrimary().id;
                    if (n.available = t1.availableImages.some((t1)=>er.isEqual(t1, e)), n.available) {
                        const e = n.getSecondary() ? n.getSecondary().id : null;
                        e && (n.available = t1.availableImages.some((t1)=>er.isEqual(t1, e)));
                    }
                }
                return n;
            }
            eachChild(t1) {
                if (t1(this.namePrimary), this.paramsPrimary) for(const e in this.paramsPrimary)this.paramsPrimary[e] && t1(this.paramsPrimary[e]);
                if (this.nameSecondary && (t1(this.nameSecondary), this.paramsSecondary)) for(const e in this.paramsSecondary)this.paramsSecondary[e] && t1(this.paramsSecondary[e]);
            }
            outputDefined() {
                return !1;
            }
            serializeOptions(t1, e) {
                const r = {};
                if (e && (r.iconset = {
                    id: e
                }), t1) {
                    r.params = {};
                    for(const e in t1)t1[e] && (r.params[e] = t1[e].serialize());
                }
                return Object.keys(r).length > 0 ? r : void 0;
            }
            serialize() {
                const t1 = [
                    "image",
                    this.namePrimary.serialize()
                ];
                if (this.paramsPrimary || this.iconsetIdPrimary) {
                    const e = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
                    e && t1.push(e);
                }
                if (this.nameSecondary && (t1.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
                    const e = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
                    e && t1.push(e);
                }
                return t1;
            }
        }
        function Xr(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        const Zr = {
            "to-boolean": xr,
            "to-color": vr,
            "to-number": yr,
            "to-string": gr
        };
        class Wr {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[0], n = [];
                let i = mr;
                if ("to-array" === r) {
                    if (!Array.isArray(t1[1])) return null;
                    const r = t1[1].length;
                    if (e.expectedType) {
                        if ("array" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);
                        i = Ir(e.expectedType.itemType, r);
                    } else {
                        if (!(r > 0 && Rr(t1[1][0]))) return null;
                        i = Ir(Or(t1[1][0]), r);
                    }
                    for(let s = 0; s < r; s++){
                        const r = t1[1][s];
                        let o;
                        if ("array" === Xr(r)) o = e.parse(r, void 0, i.itemType);
                        else {
                            const t1 = Xr(r);
                            if (t1 !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t1}.`);
                            o = e.registry.literal.parse([
                                "literal",
                                void 0 === r ? null : r
                            ], e);
                        }
                        if (!o) return null;
                        n.push(o);
                    }
                } else {
                    if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e.error("Expected one argument.");
                    i = Zr[r];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], r, wr);
                        if (!i) return null;
                        n.push(i);
                    }
                }
                return new Wr(i, n);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e, r;
                    for (const n of this.args){
                        if (e = n.evaluate(t1), r = null, e instanceof sr) return e;
                        if ("string" == typeof e) {
                            const r = t1.parseColor(e);
                            if (r) return r;
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Lr(e[0], e[1], e[2], e[3]), !r)) return new sr(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                    }
                    throw new jr(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const r of this.args){
                        if (e = r.evaluate(t1), null === e) return 0;
                        const n = Number(e);
                        if (!isNaN(n)) return n;
                    }
                    throw new jr(`Could not convert ${JSON.stringify(e)} to number.`);
                }
                return "formatted" === this.type.kind ? Cr.fromString(Ur(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? Dr.build(Ur(this.args[0].evaluate(t1))) : "array" === this.type.kind ? this.args.map((e)=>e.evaluate(t1)) : Ur(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Hr([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new qr(this.args[0]).serialize();
                const t1 = "array" === this.type.kind ? [] : [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        const Yr = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class Kr {
            constructor(t1, e){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t1, this.options = e;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Yr[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            measureLight(t1) {
                return this.globals.brightness || 0;
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e - t1[0]) + this.featureDistanceData.bearing[1] * (n * e - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e = this._parseColorCache[t1];
                return e || (e = this._parseColorCache[t1] = sr.parse(t1)), e;
            }
            getConfig(t1) {
                return this.options ? this.options.get(t1) : null;
            }
        }
        class Jr {
            constructor(t1, e, r, n, i){
                this.name = t1, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;
            }
            evaluate(t1) {
                if (!this._evaluate) {
                    const t1 = Jr.definitions[this.name];
                    this._evaluate = Array.isArray(t1) ? t1[2] : t1.overloads[this._overloadIndex][1];
                }
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e) {
                const r = t1[0], n = Jr.definitions[r];
                if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, o = [];
                let a = null, l = -1;
                for (const [n, u] of s){
                    if (Array.isArray(n) && n.length !== t1.length - 1) continue;
                    o.push(n), l++, a = new bi(e.registry, e.path, null, e.scope, void 0, e._scope, e.options);
                    const s = [];
                    let c = !1;
                    for(let e = 1; e < t1.length; e++){
                        const r = t1[e], i = Array.isArray(n) ? n[e - 1] : n.type, o = a.parse(r, 1 + s.length, i);
                        if (!o) {
                            c = !0;
                            break;
                        }
                        s.push(o);
                    }
                    if (!c) if (Array.isArray(n) && n.length !== s.length) a.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);
                    else {
                        for(let t1 = 0; t1 < s.length; t1++){
                            const e = Array.isArray(n) ? n[t1] : n.type, r = s[t1];
                            a.concat(t1 + 1).checkSubtype(e, r.type);
                        }
                        if (0 === a.errors.length) return new Jr(r, i, u, s, l);
                    }
                }
                if (1 === o.length) e.errors.push(...a.errors);
                else {
                    const r = (o.length ? o : s.map(([t1])=>t1)).map(Qr).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(Sr(i.type));
                    }
                    e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e) {
                Jr.definitions = e;
                for(const r in e)t1[r] = Jr;
            }
        }
        function Qr(t1) {
            return Array.isArray(t1) ? `(${t1.map(Sr).join(", ")})` : `(${Sr(t1.type)}...)`;
        }
        class tn {
            constructor(t1, e, r){
                this.type = _r, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
                const n = void 0 === r["case-sensitive"] ? e.parse(!1, 1, xr) : e.parseObjectValue(r["case-sensitive"], 1, "case-sensitive", xr);
                if (!n) return null;
                const i = void 0 === r["diacritic-sensitive"] ? e.parse(!1, 1, xr) : e.parseObjectValue(r["diacritic-sensitive"], 1, "diacritic-sensitive", xr);
                if (!i) return null;
                let s = null;
                return r.locale && (s = e.parseObjectValue(r.locale, 1, "locale", gr), !s) ? null : new tn(n, i, s);
            }
            evaluate(t1) {
                return new Br(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        function en(t1, e, r = 0, n = t1.length - 1, i = nn) {
            for(; n > r;){
                if (n - r > 600) {
                    const s = n - r + 1, o = e - r + 1, a = Math.log(s), l = .5 * Math.exp(2 * a / 3), u = .5 * Math.sqrt(a * l * (s - l) / s) * (o - s / 2 < 0 ? -1 : 1);
                    en(t1, e, Math.max(r, Math.floor(e - o * l / s + u)), Math.min(n, Math.floor(e + (s - o) * l / s + u)), i);
                }
                const s = t1[e];
                let o = r, a = n;
                for(rn(t1, r, e), i(t1[n], s) > 0 && rn(t1, r, n); o < a;){
                    for(rn(t1, o, a), o++, a--; i(t1[o], s) < 0;)o++;
                    for(; i(t1[a], s) > 0;)a--;
                }
                0 === i(t1[r], s) ? rn(t1, r, a) : (a++, rn(t1, a, n)), a <= e && (r = a + 1), e <= a && (n = a - 1);
            }
        }
        function rn(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function nn(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function sn(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, o = s - 1; i < s; o = i++)r = t1[i], n = t1[o], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function on(t1, e) {
            t1[0] = Math.min(t1[0], e[0]), t1[1] = Math.min(t1[1], e[1]), t1[2] = Math.max(t1[2], e[0]), t1[3] = Math.max(t1[3], e[1]);
        }
        function an(t1, e) {
            return !(t1[0] <= e[0] || t1[2] >= e[2] || t1[1] <= e[1] || t1[3] >= e[3]);
        }
        function ln(t1, e, r) {
            const n = t1[0] - e[0], i = t1[1] - e[1], s = t1[0] - r[0], o = t1[1] - r[1];
            return n * o - s * i == 0 && n * s <= 0 && i * o <= 0;
        }
        function un(t1, e, r = !1) {
            let n = !1;
            for(let a = 0, l = e.length; a < l; a++){
                const l = e[a];
                for(let e = 0, a = l.length, u = a - 1; e < a; u = e++){
                    const a = l[u], c = l[e];
                    if (ln(t1, a, c)) return r;
                    (s = a)[1] > (i = t1)[1] != (o = c)[1] > i[1] && i[0] < (o[0] - s[0]) * (i[1] - s[1]) / (o[1] - s[1]) + s[0] && (n = !n);
                }
            }
            var i, s, o;
            return n;
        }
        function cn(t1, e, r, n) {
            const i = n[0] - r[0], s = n[1] - r[1], o = (t1[0] - r[0]) * s - i * (t1[1] - r[1]), a = (e[0] - r[0]) * s - i * (e[1] - r[1]);
            return o > 0 && a < 0 || o < 0 && a > 0;
        }
        function hn(t1, e, r, n) {
            return 0 != (i = [
                n[0] - r[0],
                n[1] - r[1]
            ])[0] * (s = [
                e[0] - t1[0],
                e[1] - t1[1]
            ])[1] - i[1] * s[0] && !(!cn(t1, e, r, n) || !cn(r, n, t1, e));
            //TURBOPACK unreachable
            ;
            var i, s;
        }
        function pn(t1) {
            const e = new bt(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r = new bt(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for (const n of t1[0])e.x > n.x && (e.x = n.x), e.y > n.y && (e.y = n.y), r.x < n.x && (r.x = n.x), r.y < n.y && (r.y = n.y);
            return {
                min: e,
                max: r
            };
        }
        const dn = 8192;
        function fn(t1, e) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z);
            return [
                Math.round(r * i * dn),
                Math.round(n * i * dn)
            ];
        }
        function mn(t1, e) {
            for(let r = 0; r < e.length; r++)if (un(t1, e[r])) return !0;
            return !1;
        }
        function yn(t1, e, r) {
            for (const n of r)for(let r = 0, i = n.length, s = i - 1; r < i; s = r++)if (hn(t1, e, n[s], n[r])) return !0;
            return !1;
        }
        function gn(t1, e) {
            for(let r = 0; r < t1.length; ++r)if (!un(t1[r], e)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (yn(t1[r], t1[r + 1], e)) return !1;
            return !0;
        }
        function xn(t1, e) {
            for(let r = 0; r < e.length; r++)if (gn(t1, e[r])) return !0;
            return !1;
        }
        function vn(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = [];
                for(let n = 0; n < t1[i].length; n++){
                    const o = fn(t1[i][n], r);
                    on(e, o), s.push(o);
                }
                n.push(s);
            }
            return n;
        }
        function bn(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = vn(t1[i], e, r);
                n.push(s);
            }
            return n;
        }
        function wn(t1, e, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e = .5 * n;
                let i = t1[0] - r[0] > e ? -n : r[0] - t1[0] > e ? n : 0;
                0 === i && (i = t1[0] - r[2] > e ? -n : r[2] - t1[0] > e ? n : 0), t1[0] += i;
            }
            on(e, t1);
        }
        function _n(t1, e, r, n) {
            const i = Math.pow(2, n.z) * dn, s = [
                n.x * dn,
                n.y * dn
            ], o = [];
            if (!t1) return o;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + s[0],
                    t1.y + s[1]
                ];
                wn(n, e, r, i), o.push(n);
            }
            return o;
        }
        function An(t1, e, r, n) {
            const i = Math.pow(2, n.z) * dn, s = [
                n.x * dn,
                n.y * dn
            ], o = [];
            if (!t1) return o;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + s[0],
                        n.y + s[1]
                    ];
                    on(e, r), t1.push(r);
                }
                o.push(t1);
            }
            if (e[2] - e[0] <= i / 2) {
                (a = e)[0] = a[1] = 1 / 0, a[2] = a[3] = -1 / 0;
                for (const t1 of o)for (const n of t1)wn(n, e, r, i);
            }
            var a;
            return o;
        }
        class Mn {
            constructor(t1, e){
                this.type = xr, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (Rr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) for(let t1 = 0; t1 < e.features.length; ++t1){
                        const r = e.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new Mn(e, e.features[t1].geometry);
                    }
                    else if ("Feature" === e.type) {
                        const t1 = e.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new Mn(e, e.geometry);
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new Mn(e, e);
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = vn(e.coordinates, n, i), o = _n(t1.geometry(), r, n, i);
                            if (!an(r, n)) return !1;
                            for (const t1 of o)if (!un(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = bn(e.coordinates, n, i), o = _n(t1.geometry(), r, n, i);
                            if (!an(r, n)) return !1;
                            for (const t1 of o)if (!mn(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = vn(e.coordinates, n, i), o = An(t1.geometry(), r, n, i);
                            if (!an(r, n)) return !1;
                            for (const t1 of o)if (!gn(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = bn(e.coordinates, n, i), o = An(t1.geometry(), r, n, i);
                            if (!an(r, n)) return !1;
                            for (const t1 of o)if (!xn(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        const In = {
            kilometers: 1,
            miles: 1e3 / 1609.344,
            nauticalmiles: 1e3 / 1852,
            meters: 1e3,
            metres: 1e3,
            yards: 1e3 / .9144,
            feet: 1e3 / .3048,
            inches: 1e3 / .0254
        }, Sn = 1 / 298.257223563, Pn = Sn * (2 - Sn), En = Math.PI / 180;
        class kn {
            static fromTile(t1, e, r) {
                const n = Math.PI * (1 - 2 * (t1 + .5) / Math.pow(2, e)), i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / En;
                return new kn(i, r);
            }
            static get units() {
                return In;
            }
            constructor(t1, e){
                if (void 0 === t1) throw new Error("No latitude given.");
                if (e && !In[e]) throw new Error(`Unknown unit ${e}. Use one of: ${Object.keys(In).join(", ")}`);
                const r = 6378.137 * En * (e ? In[e] : 1), n = Math.cos(t1 * En), i = 1 / (1 - Pn * (1 - n * n)), s = Math.sqrt(i);
                this.kx = r * s * n, this.ky = r * s * i * (1 - Pn);
            }
            distance(t1, e) {
                const r = Bn(t1[0] - e[0]) * this.kx, n = (t1[1] - e[1]) * this.ky;
                return Math.sqrt(r * r + n * n);
            }
            bearing(t1, e) {
                const r = Bn(e[0] - t1[0]) * this.kx;
                return Math.atan2(r, (e[1] - t1[1]) * this.ky) / En;
            }
            destination(t1, e, r) {
                const n = r * En;
                return this.offset(t1, Math.sin(n) * e, Math.cos(n) * e);
            }
            offset(t1, e, r) {
                return [
                    t1[0] + e / this.kx,
                    t1[1] + r / this.ky
                ];
            }
            lineDistance(t1) {
                let e = 0;
                for(let r = 0; r < t1.length - 1; r++)e += this.distance(t1[r], t1[r + 1]);
                return e;
            }
            area(t1) {
                let e = 0;
                for(let r = 0; r < t1.length; r++){
                    const n = t1[r];
                    for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)e += Bn(n[t1][0] - n[s][0]) * (n[t1][1] + n[s][1]) * (r ? -1 : 1);
                }
                return Math.abs(e) / 2 * this.kx * this.ky;
            }
            along(t1, e) {
                let r = 0;
                if (e <= 0) return t1[0];
                for(let n = 0; n < t1.length - 1; n++){
                    const i = t1[n], s = t1[n + 1], o = this.distance(i, s);
                    if (r += o, r > e) return Tn(i, s, (e - (r - o)) / o);
                }
                return t1[t1.length - 1];
            }
            pointToSegmentDistance(t1, e, r) {
                let [n, i] = e, s = Bn(r[0] - n) * this.kx, o = (r[1] - i) * this.ky;
                if (0 !== s || 0 !== o) {
                    const e = (Bn(t1[0] - n) * this.kx * s + (t1[1] - i) * this.ky * o) / (s * s + o * o);
                    e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += s / this.kx * e, i += o / this.ky * e);
                }
                return s = Bn(t1[0] - n) * this.kx, o = (t1[1] - i) * this.ky, Math.sqrt(s * s + o * o);
            }
            pointOnLine(t1, e) {
                let r = 1 / 0, n = t1[0][0], i = t1[0][1], s = 0, o = 0;
                for(let a = 0; a < t1.length - 1; a++){
                    let l = t1[a][0], u = t1[a][1], c = Bn(t1[a + 1][0] - l) * this.kx, h = (t1[a + 1][1] - u) * this.ky, p = 0;
                    0 === c && 0 === h || (p = (Bn(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t1[a + 1][0], u = t1[a + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = Bn(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;
                    const d = c * c + h * h;
                    d < r && (r = d, n = l, i = u, s = a, o = p);
                }
                return {
                    point: [
                        n,
                        i
                    ],
                    index: s,
                    t: Math.max(0, Math.min(1, o))
                };
            }
            lineSlice(t1, e, r) {
                let n = this.pointOnLine(r, t1), i = this.pointOnLine(r, e);
                if (n.index > i.index || n.index === i.index && n.t > i.t) {
                    const t1 = n;
                    n = i, i = t1;
                }
                const s = [
                    n.point
                ], o = n.index + 1, a = i.index;
                !zn(r[o], s[0]) && o <= a && s.push(r[o]);
                for(let t1 = o + 1; t1 <= a; t1++)s.push(r[t1]);
                return zn(r[a], i.point) || s.push(i.point), s;
            }
            lineSliceAlong(t1, e, r) {
                let n = 0;
                const i = [];
                for(let s = 0; s < r.length - 1; s++){
                    const o = r[s], a = r[s + 1], l = this.distance(o, a);
                    if (n += l, n > t1 && 0 === i.length && i.push(Tn(o, a, (t1 - (n - l)) / l)), n >= e) return i.push(Tn(o, a, (e - (n - l)) / l)), i;
                    n > t1 && i.push(a);
                }
                return i;
            }
            bufferPoint(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[0] + n,
                    t1[1] + r
                ];
            }
            bufferBBox(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[2] + n,
                    t1[3] + r
                ];
            }
            insideBBox(t1, e) {
                return Bn(t1[0] - e[0]) >= 0 && Bn(t1[0] - e[2]) <= 0 && t1[1] >= e[1] && t1[1] <= e[3];
            }
        }
        function zn(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }
        function Tn(t1, e, r) {
            const n = Bn(e[0] - t1[0]);
            return [
                t1[0] + n * r,
                t1[1] + (e[1] - t1[1]) * r
            ];
        }
        function Bn(t1) {
            for(; t1 < -180;)t1 += 360;
            for(; t1 > 180;)t1 -= 360;
            return t1;
        }
        class Vn {
            constructor(t1 = [], e = (t1, e)=>t1 < e ? -1 : t1 > e ? 1 : 0){
                if (this.data = t1, this.length = this.data.length, this.compare = e, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this._up(this.length++);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e = this.data.pop();
                return --this.length > 0 && (this.data[0] = e, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e, compare: r } = this, n = e[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, s = e[i];
                    if (r(n, s) >= 0) break;
                    e[t1] = s, t1 = i;
                }
                e[t1] = n;
            }
            _down(t1) {
                const { data: e, compare: r } = this, n = this.length >> 1, i = e[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1);
                    const s = n + 1;
                    if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break;
                    e[t1] = e[n], t1 = n;
                }
                e[t1] = i;
            }
        }
        var Cn = 8192;
        function Fn(t1, e) {
            return e.dist - t1.dist;
        }
        const Dn = 100, Ln = 50;
        function Rn(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (e.length !== t1.length) return !1;
            for(let r = 0; r < e.length; r++)if (e[r] !== t1[r]) return !1;
            return !0;
        }
        function On(t1) {
            return t1[1] - t1[0] + 1;
        }
        function Un(t1, e) {
            const r = t1[1] >= t1[0] && t1[1] < e;
            return r || console.warn("Distance Expression: Index is out of range"), r;
        }
        function Nn(t1, e) {
            if (t1[0] > t1[1]) return [
                null,
                null
            ];
            const r = On(t1);
            if (e) {
                if (2 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2);
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e,
                        t1[1]
                    ]
                ];
            }
            {
                if (1 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2) - 1;
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e + 1,
                        t1[1]
                    ]
                ];
            }
        }
        function jn(t1, e) {
            const r = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (!Un(e, t1.length)) return r;
            for(let n = e[0]; n <= e[1]; ++n)on(r, t1[n]);
            return r;
        }
        function $n(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let r = 0; r < t1.length; ++r)for(let n = 0; n < t1[r].length; ++n)on(e, t1[r][n]);
            return e;
        }
        function Gn(t1, e, r) {
            if (Rn(t1) || Rn(e)) return NaN;
            let n = 0, i = 0;
            return t1[2] < e[0] && (n = e[0] - t1[2]), t1[0] > e[2] && (n = t1[0] - e[2]), t1[1] > e[3] && (i = t1[1] - e[3]), t1[3] < e[1] && (i = e[1] - t1[3]), r.distance([
                0,
                0
            ], [
                n,
                i
            ]);
        }
        function Hn(t1) {
            return 360 * t1 - 180;
        }
        function qn(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Xn(t1, e) {
            const r = Math.pow(2, e.z), n = (t1.y / Cn + e.y) / r;
            return [
                Hn((t1.x / Cn + e.x) / r),
                qn(n)
            ];
        }
        function Zn(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; ++n)r.push(Xn(t1[n], e));
            return r;
        }
        function Wn(t1, e, r) {
            const n = r.pointOnLine(e, t1).point;
            return r.distance(t1, n);
        }
        function Yn(t1, e, r, n, i) {
            const s = r.slice(n[0], n[1] + 1);
            let o = 1 / 0;
            for(let r = e[0]; r <= e[1]; ++r)if (0 === (o = Math.min(o, Wn(t1[r], s, i)))) return 0;
            return o;
        }
        function Kn(t1, e, r, n, i) {
            const s = Math.min(i.pointToSegmentDistance(t1, r, n), i.pointToSegmentDistance(e, r, n)), o = Math.min(i.pointToSegmentDistance(r, t1, e), i.pointToSegmentDistance(n, t1, e));
            return Math.min(s, o);
        }
        function Jn(t1, e, r, n, i) {
            if (!Un(e, t1.length) || !Un(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let o = e[0]; o < e[1]; ++o)for(let e = n[0]; e < n[1]; ++e){
                if (hn(t1[o], t1[o + 1], r[e], r[e + 1])) return 0;
                s = Math.min(s, Kn(t1[o], t1[o + 1], r[e], r[e + 1], i));
            }
            return s;
        }
        function Qn(t1, e, r, n, i) {
            if (!Un(e, t1.length) || !Un(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let o = e[0]; o <= e[1]; ++o)for(let e = n[0]; e <= n[1]; ++e)if (0 === (s = Math.min(s, i.distance(t1[o], r[e])))) return s;
            return s;
        }
        function ti(t1, e, r) {
            if (un(t1, e, !0)) return 0;
            let n = 1 / 0;
            for (const i of e){
                const e = i.length;
                if (e < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
                if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t1, i[e - 1], i[0])))) return n;
                if (0 === (n = Math.min(n, Wn(t1, i, r)))) return n;
            }
            return n;
        }
        function ei(t1, e, r, n) {
            if (!Un(e, t1.length)) return NaN;
            for(let n = e[0]; n <= e[1]; ++n)if (un(t1[n], r, !0)) return 0;
            let i = 1 / 0;
            for(let s = e[0]; s < e[1]; ++s)for (const e of r)for(let r = 0, o = e.length, a = o - 1; r < o; a = r++){
                if (hn(t1[s], t1[s + 1], e[a], e[r])) return 0;
                i = Math.min(i, Kn(t1[s], t1[s + 1], e[a], e[r], n));
            }
            return i;
        }
        function ri(t1, e) {
            for (const r of t1)for(let t1 = 0; t1 <= r.length - 1; ++t1)if (un(r[t1], e, !0)) return !0;
            return !1;
        }
        function ni(t1, e, r, n = 1 / 0) {
            const i = $n(t1), s = $n(e);
            if (n !== 1 / 0 && Gn(i, s, r) >= n) return n;
            if (an(i, s)) {
                if (ri(t1, e)) return 0;
            } else if (ri(e, t1)) return 0;
            let o = n;
            for (const n of t1)for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)for (const i of e)for(let e = 0, a = i.length, l = a - 1; e < a; l = e++){
                if (hn(n[s], n[t1], i[l], i[e])) return 0;
                o = Math.min(o, Kn(n[s], n[t1], i[l], i[e], r));
            }
            return o;
        }
        function ii(t1, e, r, n, i, s, o) {
            if (null === s || null === o) return;
            const a = Gn(jn(n, s), jn(i, o), r);
            a < e && t1.push({
                dist: a,
                range1: s,
                range2: o
            });
        }
        function si(t1, e, r, n, i = 1 / 0) {
            let s = Math.min(n.distance(t1[0], r[0][0]), i);
            if (0 === s) return s;
            const o = new Vn([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        0
                    ]
                }
            ], Fn), a = e ? Ln : Dn, l = $n(r);
            for(; o.length;){
                const i = o.pop();
                if (i.dist >= s) continue;
                const u = i.range1;
                if (On(u) <= a) {
                    if (!Un(u, t1.length)) return NaN;
                    if (e) {
                        const e = ei(t1, u, r, n);
                        if (0 === (s = Math.min(s, e))) return s;
                    } else for(let e = u[0]; e <= u[1]; ++e){
                        const i = ti(t1[e], r, n);
                        if (0 === (s = Math.min(s, i))) return s;
                    }
                } else {
                    const r = Nn(u, e);
                    if (null !== r[0]) {
                        const e = Gn(jn(t1, r[0]), l, n);
                        e < s && o.push({
                            dist: e,
                            range1: r[0],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                    if (null !== r[1]) {
                        const e = Gn(jn(t1, r[1]), l, n);
                        e < s && o.push({
                            dist: e,
                            range1: r[1],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                }
            }
            return s;
        }
        function oi(t1, e, r, n, i, s = 1 / 0) {
            let o = Math.min(s, i.distance(t1[0], r[0]));
            if (0 === o) return o;
            const a = new Vn([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        r.length - 1
                    ]
                }
            ], Fn), l = e ? Ln : Dn, u = n ? Ln : Dn;
            for(; a.length;){
                const s = a.pop();
                if (s.dist >= o) continue;
                const c = s.range1, h = s.range2;
                if (On(c) <= l && On(h) <= u) {
                    if (!Un(c, t1.length) || !Un(h, r.length)) return NaN;
                    if (e && n ? o = Math.min(o, Jn(t1, c, r, h, i)) : e || n ? e && !n ? o = Math.min(o, Yn(r, h, t1, c, i)) : !e && n && (o = Math.min(o, Yn(t1, c, r, h, i))) : o = Math.min(o, Qn(t1, c, r, h, i)), 0 === o) return o;
                } else {
                    const s = Nn(c, e), l = Nn(h, n);
                    ii(a, o, i, t1, r, s[0], l[0]), ii(a, o, i, t1, r, s[0], l[1]), ii(a, o, i, t1, r, s[1], l[0]), ii(a, o, i, t1, r, s[1], l[1]);
                }
            }
            return o;
        }
        function ai(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const o = jn(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r)if (!(s !== 1 / 0 && Gn(o, jn(i, [
                0,
                i.length - 1
            ]), n) >= s) && (s = Math.min(s, oi(t1, e, i, !0, n, s)), 0 === s)) return s;
            return s;
        }
        function li(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const o = jn(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r){
                if (s !== 1 / 0 && Gn(o, $n(i), n) >= s) continue;
                const r = si(t1, e, i, n, s);
                if (isNaN(r)) return r;
                if (0 === (s = Math.min(s, r))) return s;
            }
            return s;
        }
        function ui(t1) {
            return "Point" === t1 || "MultiPoint" === t1 || "LineString" === t1 || "MultiLineString" === t1 || "Polygon" === t1 || "MultiPolygon" === t1;
        }
        class ci {
            constructor(t1, e){
                this.type = yr, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'distance' expression requires either one argument, but found ' ${t1.length - 1} instead.`);
                if (Rr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) {
                        for(let t1 = 0; t1 < e.features.length; ++t1)if (ui(e.features[t1].geometry.type)) return new ci(e, e.features[t1].geometry);
                    } else if ("Feature" === e.type) {
                        if (ui(e.geometry.type)) return new ci(e, e.geometry);
                    } else if (ui(e.type)) return new ci(e, e);
                }
                return e.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t1) {
                const e = t1.geometry(), r = t1.canonicalID();
                if (null != e && null != r) {
                    if ("Point" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1)for (const t1 of r)n.push(Xn(t1, e));
                        const i = new kn(n[0][1], "meters");
                        return "Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type ? oi(n, !1, "Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, i) : "MultiLineString" === r.type ? ai(n, !1, r.coordinates, i) : "Polygon" === r.type || "MultiPolygon" === r.type ? li(n, !1, "Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, i) : null;
                    }(e, r, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1){
                            const t1 = [];
                            for (const n of r)t1.push(Xn(n, e));
                            n.push(t1);
                        }
                        const i = new kn(n[0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return ai("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = ai(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        if ("Polygon" === r.type || "MultiPolygon" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < n.length; e++){
                                const s = li(n[e], !0, "Polygon" === r.type ? [
                                    r.coordinates
                                ] : r.coordinates, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return null;
                    }(e, r, this.geometries);
                    if ("Polygon" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of function(t1, e) {
                            const r = t1.length;
                            if (r <= 1) return [
                                t1
                            ];
                            const n = [];
                            let i, s;
                            for(let e = 0; e < r; e++){
                                const r = sn(t1[e]);
                                0 !== r && (t1[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                                    t1[e]
                                ]) : i.push(t1[e]));
                            }
                            return i && n.push(i), n;
                        }(t1)){
                            const t1 = [];
                            for(let n = 0; n < r.length; ++n)t1.push(Zn(r[n], e));
                            n.push(t1);
                        }
                        const i = new kn(n[0][0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return li("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = li(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return "Polygon" === r.type || "MultiPolygon" === r.type ? function(t1, e, r) {
                            let n = 1 / 0;
                            for (const i of t1)for (const t1 of e){
                                const e = ni(i, t1, r, n);
                                if (isNaN(e)) return e;
                                if (0 === (n = Math.min(n, e))) return n;
                            }
                            return n;
                        }("Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, n, i) : null;
                    }(e, r, this.geometries);
                    console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
                } else console.warn("Distance Expression: requirs valid feature and canonical information.");
                return null;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "distance",
                    this.geojson
                ];
            }
        }
        function hi(t1) {
            if (t1 instanceof Jr) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof Mn) return !1;
            if (t1 instanceof ci) return !1;
            if (t1 instanceof xi) return t1.featureConstant;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !hi(t1) && (e = !1);
            }), e;
        }
        function pi(t1) {
            if (t1 instanceof Jr && "feature-state" === t1.name) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !pi(t1) && (e = !1);
            }), e;
        }
        function di(t1) {
            if (t1 instanceof xi) return new Set([
                t1.key
            ]);
            let e = new Set;
            return t1.eachChild((t1)=>{
                e = new Set([
                    ...e,
                    ...di(t1)
                ]);
            }), e;
        }
        function fi(t1, e) {
            if (t1 instanceof Jr && e.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !fi(t1, e) && (r = !1);
            }), r;
        }
        function mi(t1, e, r) {
            return [
                t1,
                e,
                r
            ].filter(Boolean).join("");
        }
        function yi(t1, e) {
            switch(t1){
                case "string":
                    return Ur(e);
                case "number":
                    return +e;
                case "boolean":
                    return !!e;
                case "color":
                    return sr.parse(e);
                case "formatted":
                    return Cr.fromString(Ur(e));
                case "resolvedImage":
                    return Dr.build(Ur(e));
            }
            return e;
        }
        function gi(t1, e, r, n) {
            return void 0 !== n && (t1 = n * Math.round(t1 / n)), void 0 !== e && t1 < e && (t1 = e), void 0 !== r && t1 > r && (t1 = r), t1;
        }
        class xi {
            constructor(t1, e, r, n = !1){
                this.type = t1, this.key = e, this.scope = r, this.featureConstant = n;
            }
            static parse(t1, e) {
                let r = e.expectedType;
                if (null == r && (r = wr), t1.length < 2 || t1.length > 3) return e.error("Invalid number of arguments for 'config' expression.");
                const n = e.parse(t1[1], 1);
                if (!(n instanceof Nr)) return e.error("Key name of 'config' expression must be a string literal.");
                let i, s = !0;
                const o = Ur(n.value);
                if (t1.length >= 3) {
                    const r = e.parse(t1[2], 2);
                    if (!(r instanceof Nr)) return e.error("Scope of 'config' expression must be a string literal.");
                    i = Ur(r.value);
                }
                if (e.options) {
                    const t1 = mi(o, i, e._scope), r = e.options.get(t1);
                    r && (s = hi(r.value || r.default));
                }
                return new xi(r, o, i, s);
            }
            evaluate(t1) {
                const e = mi(this.key, this.scope, t1.scope), r = t1.getConfig(e);
                if (!r) return null;
                const { type: n, value: i, values: s, minValue: o, maxValue: a, stepValue: l } = r, u = r.default.evaluate(t1);
                let c = u;
                if (i) {
                    const e = t1.scope;
                    t1.scope = (e || "").split("").slice(1).join(""), c = i.evaluate(t1), t1.scope = e;
                }
                return n && (c = yi(n, c)), void 0 === c || void 0 === o && void 0 === a && void 0 === l || ("number" == typeof c ? c = gi(c, o, a, l) : Array.isArray(c) && (c = c.map((t1)=>"number" == typeof t1 ? gi(t1, o, a, l) : t1))), void 0 !== i && void 0 !== c && s && !s.includes(c) && (c = u, n && (c = yi(n, c))), (n && n !== this.type || void 0 !== c && !Tr(Or(c), this.type)) && (c = yi(this.type.kind, c)), c;
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "config",
                    this.key
                ];
                return this.scope && t1.concat(this.scope), t1;
            }
        }
        class vi {
            constructor(t1, e){
                this.type = e.type, this.name = t1, this.boundExpression = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e.scope.has(r) ? new vi(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        class bi {
            constructor(t1, e = [], r, n = new fr, i = [], s, o){
                this.registry = t1, this.path = e, this.key = e.map((t1)=>"string" == typeof t1 ? `['${t1}']` : `[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r, this._scope = s, this.options = o;
            }
            parse(t1, e, r, n, i = {}) {
                return e || r ? this.concat(e, null, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            parseObjectValue(t1, e, r, n, i, s = {}) {
                return this.concat(e, r, n, i)._parse(t1, s);
            }
            _parse(t1, e) {
                function r(t1, e, r) {
                    return "assert" === r ? new Gr(e, [
                        t1
                    ]) : "coerce" === r ? new Wr(e, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = "string" == typeof t1[0] ? this.registry[t1[0]] : void 0;
                    if (n) {
                        let i = n.parse(t1, this);
                        if (!i) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, n = i.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== n.kind) if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== n.kind && "string" !== n.kind) {
                                if (this.checkSubtype(t1, n)) return null;
                            } else i = r(i, t1, e.typeAnnotation || "coerce");
                            else i = r(i, t1, e.typeAnnotation || "assert");
                        }
                        if (!(i instanceof Nr) && "resolvedImage" !== i.type.kind && wi(i)) {
                            const t1 = new Kr(this._scope, this.options);
                            try {
                                i = new Nr(i.type, i.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return i;
                    }
                    return Wr.parse([
                        "to-array",
                        t1
                    ], this);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e, r, n) {
                let i = "number" == typeof t1 ? this.path.concat(t1) : this.path;
                i = "string" == typeof e ? i.concat(e) : i;
                const s = n ? this.scope.concat(n) : this.scope;
                return new bi(this.registry, i, r || null, s, this.errors, this._scope, this.options);
            }
            error(t1, ...e) {
                const r = `${this.key}${e.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new dr(r, t1));
            }
            checkSubtype(t1, e) {
                const r = Er(t1, e);
                return r && this.error(r), r;
            }
        }
        function wi(t1) {
            if (t1 instanceof vi) return wi(t1.boundExpression);
            if (t1 instanceof Jr && "error" === t1.name) return !1;
            if (t1 instanceof tn) return !1;
            if (t1 instanceof Mn) return !1;
            if (t1 instanceof ci) return !1;
            if (t1 instanceof xi) return !1;
            const e = t1 instanceof Wr || t1 instanceof Gr;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e ? r && wi(t1) : r && t1 instanceof Nr;
            }), !!r && hi(t1) && fi(t1, [
                "zoom",
                "heatmap-density",
                "worldview",
                "line-progress",
                "raster-value",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center",
                "measure-light",
                "raster-particle-speed"
            ]);
        }
        function _i(t1, e) {
            const r = t1.length - 1;
            let n, i, s = 0, o = r, a = 0;
            for(; s <= o;)if (a = Math.floor((s + o) / 2), n = t1[a], i = t1[a + 1], n <= e) {
                if (a === r || e < i) return a;
                s = a + 1;
            } else {
                if (!(n > e)) throw new jr("Input is not a number.");
                o = a - 1;
            }
            return 0;
        }
        class Ai {
            constructor(t1, e, r){
                this.type = t1, this.input = e, this.labels = [], this.outputs = [];
                for (const [t1, e] of r)this.labels.push(t1), this.outputs.push(e);
            }
            static parse(t1, e) {
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                const r = e.parse(t1[1], 1, yr);
                if (!r) return null;
                const n = [];
                let i = null;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const s = 1 === r ? -1 / 0 : t1[r], o = t1[r + 1], a = r, l = r + 1;
                    if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a);
                    if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a);
                    const u = e.parse(o, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        s,
                        u
                    ]);
                }
                return new Ai(i, r, n);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                return n >= e[i - 1] ? r[i - 1].evaluate(t1) : r[_i(e, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e = 0; e < this.labels.length; e++)e > 0 && t1.push(this.labels[e]), t1.push(this.outputs[e].serialize());
                return t1;
            }
        }
        const Mi = .95047, Ii = 1.08883, Si = 4 / 29, Pi = 6 / 29, Ei = 3 * Pi * Pi, ki = Pi * Pi * Pi, zi = Math.PI / 180, Ti = 180 / Math.PI;
        function Bi(t1) {
            return t1 > ki ? Math.pow(t1, 1 / 3) : t1 / Ei + Si;
        }
        function Vi(t1) {
            return t1 > Pi ? t1 * t1 * t1 : Ei * (t1 - Si);
        }
        function Ci(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function Fi(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function Di(t1) {
            const e = Fi(t1.r), r = Fi(t1.g), n = Fi(t1.b), i = Bi((.4124564 * e + .3575761 * r + .1804375 * n) / Mi), s = Bi((.2126729 * e + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - Bi((.0193339 * e + .119192 * r + .9503041 * n) / Ii)),
                alpha: t1.a
            };
        }
        function Li(t1) {
            let e = (t1.l + 16) / 116, r = isNaN(t1.a) ? e : e + t1.a / 500, n = isNaN(t1.b) ? e : e - t1.b / 200;
            return e = 1 * Vi(e), r = Mi * Vi(r), n = Ii * Vi(n), new sr(Ci(3.2404542 * r - 1.5371385 * e - .4985314 * n), Ci(-.969266 * r + 1.8760108 * e + .041556 * n), Ci(.0556434 * r - .2040259 * e + 1.0572252 * n), t1.alpha);
        }
        function Ri(t1, e, r) {
            const n = e - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const Oi = {
            forward: Di,
            reverse: Li,
            interpolate: function(t1, e, r) {
                return {
                    l: ur(t1.l, e.l, r),
                    a: ur(t1.a, e.a, r),
                    b: ur(t1.b, e.b, r),
                    alpha: ur(t1.alpha, e.alpha, r)
                };
            }
        }, Ui = {
            forward: function(t1) {
                const { l: e, a: r, b: n } = Di(t1), i = Math.atan2(n, r) * Ti;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e = t1.h * zi, r = t1.c;
                return Li({
                    l: t1.l,
                    a: Math.cos(e) * r,
                    b: Math.sin(e) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e, r) {
                return {
                    h: Ri(t1.h, e.h, r),
                    c: ur(t1.c, e.c, r),
                    l: ur(t1.l, e.l, r),
                    alpha: ur(t1.alpha, e.alpha, r)
                };
            }
        };
        var Ni = Object.freeze({
            __proto__: null,
            hcl: Ui,
            lab: Oi
        });
        class ji {
            constructor(t1, e, r, n, i){
                this.type = t1, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e] of i)this.labels.push(t1), this.outputs.push(e);
            }
            static interpolationFactor(t1, e, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = $i(e, t1.base, r, n);
                else if ("linear" === t1.name) i = $i(e, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    i = new vt(s[0], s[1], s[2], s[3]).solve($i(e, 1, r, n));
                }
                return i;
            }
            static parse(t1, e) {
                let [r, n, i, ...s] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length - 1 > 3 && (t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                if (i = e.parse(i, 2, yr), !i) return null;
                const o = [];
                let a = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? a = vr : e.expectedType && "value" !== e.expectedType.kind && (a = e.expectedType);
                for(let t1 = 0; t1 < s.length; t1 += 2){
                    const r = s[t1], n = s[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (o.length && o[o.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e.parse(n, l, a);
                    if (!u) return null;
                    a = a || u.type, o.push([
                        r,
                        u
                    ]);
                }
                return "number" === a.kind || "color" === a.kind || "array" === a.kind && "number" === a.itemType.kind && "number" == typeof a.N ? new ji(a, r, n, i, o) : e.error(`Type ${Sr(a)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                if (n >= e[i - 1]) return r[i - 1].evaluate(t1);
                const s = _i(e, n), o = ji.interpolationFactor(this.interpolation, n, e[s], e[s + 1]), a = r[s].evaluate(t1), l = r[s + 1].evaluate(t1);
                return "interpolate" === this.operator ? hr[this.type.kind.toLowerCase()](a, l, o) : "interpolate-hcl" === this.operator ? Ui.reverse(Ui.interpolate(Ui.forward(a), Ui.forward(l), o)) : Oi.reverse(Oi.interpolate(Oi.forward(a), Oi.forward(l), o));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier",
                    ...this.interpolation.controlPoints
                ];
                const e = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                for(let t1 = 0; t1 < this.labels.length; t1++)e.push(this.labels[t1], this.outputs[t1].serialize());
                return e;
            }
        }
        function $i(t1, e, r, n) {
            const i = n - r, s = t1 - r;
            return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
        }
        class Gi {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expectected at least one argument.");
                let r = null;
                const n = e.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const s = n && i.some((t1)=>Er(n, t1.type));
                return new Gi(s ? wr : r, i);
            }
            evaluate(t1) {
                let e, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof Dr && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class Hi {
            constructor(t1, e){
                this.type = e.type, this.bindings = [].concat(t1), this.result = e;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e of this.bindings)t1(e[1]);
                t1(this.result);
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e.parse(t1[n + 1], n + 1);
                    if (!s) return null;
                    r.push([
                        i,
                        s
                    ]);
                }
                const n = e.parse(t1[t1.length - 1], t1.length - 1, e.expectedType, r);
                return n ? new Hi(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e, r] of this.bindings)t1.push(e, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        class qi {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, yr), n = e.parse(t1[2], 2, Ir(e.expectedType || wr));
                return r && n ? new qi(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new jr(`Array index out of bounds: ${e} < 0.`);
                if (e >= r.length) throw new jr(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e !== Math.floor(e)) throw new jr(`Array index must be an integer, but found ${e} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`);
                return r[e];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class Xi {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, yr), n = e.parse(t1[2], 2, Ir(e.expectedType || wr));
                return r && n ? new Xi(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new jr(`Array index out of bounds: ${e} < 0.`);
                if (e > r.length - 1) throw new jr(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e === Math.floor(e)) return r[e];
                const n = Math.floor(e), i = Math.ceil(e), s = r[n], o = r[i];
                if ("number" != typeof s || "number" != typeof o) throw new jr(`Cannot interpolate between non-number values at index ${e}.`);
                const a = e - n;
                return s * (1 - a) + o * a;
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at-interpolated",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class Zi {
            constructor(t1, e){
                this.type = xr, this.needle = t1, this.haystack = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, wr), n = e.parse(t1[2], 2, wr);
                return r && n ? kr(r.type, [
                    xr,
                    gr,
                    yr,
                    mr,
                    wr
                ]) ? new Zi(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Sr(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!zr(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new jr(`Expected first argument to be of type boolean, string, number or null, but found ${Sr(Or(e))} instead.`);
                if (!zr(r, [
                    "string",
                    "array"
                ])) throw new jr(`Expected second argument to be of type array or string, but found ${Sr(Or(r))} instead.`);
                return r.indexOf(e) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class Wi {
            constructor(t1, e, r){
                this.type = yr, this.needle = t1, this.haystack = e, this.fromIndex = r;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, wr), n = e.parse(t1[2], 2, wr);
                if (!r || !n) return null;
                if (!kr(r.type, [
                    xr,
                    gr,
                    yr,
                    mr,
                    wr
                ])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Sr(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, yr);
                    return i ? new Wi(r, n, i) : null;
                }
                return new Wi(r, n);
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!zr(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new jr(`Expected first argument to be of type boolean, string, number or null, but found ${Sr(Or(e))} instead.`);
                if (!zr(r, [
                    "string",
                    "array"
                ])) throw new jr(`Expected second argument to be of type array or string, but found ${Sr(Or(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e, n);
                }
                return r.indexOf(e);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class Yi {
            constructor(t1, e, r, n, i, s){
                this.inputType = t1, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }
            static parse(t1, e) {
                if (t1.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e.error("Expected an even number of arguments.");
                let r, n;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                const i = {}, s = [];
                for(let o = 2; o < t1.length - 1; o += 2){
                    let a = t1[o];
                    const l = t1[o + 1];
                    Array.isArray(a) || (a = [
                        a
                    ]);
                    const u = e.concat(o);
                    if (0 === a.length) return u.error("Expected at least one branch label.");
                    for (const t1 of a){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, Or(t1))) return null;
                        } else r = Or(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = s.length;
                    }
                    const c = e.parse(l, o, n);
                    if (!c) return null;
                    n = n || c.type, s.push(c);
                }
                const o = e.parse(t1[1], 1, wr);
                if (!o) return null;
                const a = e.parse(t1[t1.length - 1], t1.length - 1, n);
                return a ? "value" !== o.type.kind && e.concat(1).checkSubtype(r, o.type) ? null : new Yi(r, n, o, i, s, a) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                return (Tr(Or(e), this.inputType) && this.outputs[this.cases[e]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e){
                    const e = n[this.cases[t1]];
                    void 0 === e ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        class Ki {
            constructor(t1, e, r){
                this.type = t1, this.branches = e, this.otherwise = r;
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e.error("Expected an odd number of arguments.");
                let r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const s = e.parse(t1[i], i, xr);
                    if (!s) return null;
                    const o = e.parse(t1[i + 1], i + 1, r);
                    if (!o) return null;
                    n.push([
                        s,
                        o
                    ]), r = r || o.type;
                }
                const i = e.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new Ki(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e, r] of this.branches)if (e.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e, r] of this.branches)t1(e), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e])=>e.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class Ji {
            constructor(t1, e, r, n){
                this.type = t1, this.input = e, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, wr), n = e.parse(t1[2], 2, yr);
                if (!r || !n) return null;
                if (!kr(r.type, [
                    Ir(wr),
                    gr,
                    wr
                ])) return e.error(`Expected first argument to be of type array or string, but found ${Sr(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, yr);
                    return i ? new Ji(r.type, r, n, i) : null;
                }
                return new Ji(r.type, r, n);
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!zr(e, [
                    "string",
                    "array"
                ])) throw new jr(`Expected first argument to be of type array or string, but found ${Sr(Or(e))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e.slice(r, n);
                }
                return e.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        class Qi {
            constructor(t1, e){
                this.type = Ir(gr), this.str = t1, this.delimiter = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, gr), n = e.parse(t1[2], 2, gr);
                return r && n ? new Qi(r, n) : void 0;
            }
            evaluate(t1) {
                const e = this.str.evaluate(t1), r = this.delimiter.evaluate(t1);
                return e.split(r);
            }
            eachChild(t1) {
                t1(this.str), t1(this.delimiter);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "split",
                    this.str.serialize(),
                    this.delimiter.serialize()
                ];
            }
        }
        function ts(t1, e) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
        }
        function es(t1, e, r, n) {
            return 0 === n.compare(e, r);
        }
        function rs(t1, e, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e, r){
                    this.type = xr, this.lhs = t1, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e.type.kind;
                }
                static parse(t1, e) {
                    if (3 !== t1.length && 4 !== t1.length) return e.error("Expected two or three arguments.");
                    const r = t1[0];
                    let s = e.parse(t1[1], 1, wr);
                    if (!s) return null;
                    if (!ts(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${Sr(s.type)}'.`);
                    let o = e.parse(t1[2], 2, wr);
                    if (!o) return null;
                    if (!ts(r, o.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${Sr(o.type)}'.`);
                    if (s.type.kind !== o.type.kind && "value" !== s.type.kind && "value" !== o.type.kind) return e.error(`Cannot compare types '${Sr(s.type)}' and '${Sr(o.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== o.type.kind ? s = new Gr(o.type, [
                        s
                    ]) : "value" !== s.type.kind && "value" === o.type.kind && (o = new Gr(s.type, [
                        o
                    ])));
                    let a = null;
                    if (4 === t1.length) {
                        if ("string" !== s.type.kind && "string" !== o.type.kind && "value" !== s.type.kind && "value" !== o.type.kind) return e.error("Cannot use collator to compare non-string types.");
                        if (a = e.parse(t1[3], 3, _r), !a) return null;
                    }
                    return new i(s, o, a);
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i), o = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e = Or(s), r = Or(o);
                        if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new jr(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = Or(s), r = Or(o);
                        if ("string" !== t1.kind || "string" !== r.kind) return e(i, s, o);
                    }
                    return this.collator ? r(i, s, o, this.collator.evaluate(i)) : e(i, s, o);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e.push(t1.serialize());
                    }), e;
                }
            };
        }
        const ns = rs("==", function(t1, e, r) {
            return e === r;
        }, es), is = rs("!=", function(t1, e, r) {
            return e !== r;
        }, function(t1, e, r, n) {
            return !es(0, e, r, n);
        }), ss = rs("<", function(t1, e, r) {
            return e < r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) < 0;
        }), os = rs(">", function(t1, e, r) {
            return e > r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) > 0;
        }), as = rs("<=", function(t1, e, r) {
            return e <= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) <= 0;
        }), ls = rs(">=", function(t1, e, r) {
            return e >= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) >= 0;
        });
        class us {
            constructor(t1, e, r, n, i, s){
                this.type = gr, this.number = t1, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error("Expected two arguments.");
                const r = e.parse(t1[1], 1, yr);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e.parseObjectValue(n.locale, 2, "locale", gr), !i)) return null;
                let s = null;
                if (n.currency && (s = e.parseObjectValue(n.currency, 2, "currency", gr), !s)) return null;
                let o = null;
                if (n.unit && (o = e.parseObjectValue(n.unit, 2, "unit", gr), !o)) return null;
                let a = null;
                if (n["min-fraction-digits"] && (a = e.parseObjectValue(n["min-fraction-digits"], 2, "min-fraction-digits", yr), !a)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e.parseObjectValue(n["max-fraction-digits"], 2, "max-fraction-digits", yr), !l) ? null : new us(r, i, s, o, a, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class cs {
            constructor(t1){
                this.type = yr, this.input = t1;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Sr(r.type)} instead.`) : new cs(r) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                if ("string" == typeof e) return e.length;
                if (Array.isArray(e)) return e.length;
                throw new jr(`Expected value to be of type string or array, but found ${Sr(Or(e))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        function hs(t1) {
            return function() {
                t1 = 1831565813 + (t1 |= 0) | 0;
                let e = Math.imul(t1 ^ t1 >>> 15, 1 | t1);
                return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
            };
        }
        const ps = {
            "==": ns,
            "!=": is,
            ">": os,
            "<": ss,
            ">=": ls,
            "<=": as,
            array: Gr,
            at: qi,
            "at-interpolated": Xi,
            boolean: Gr,
            case: Ki,
            coalesce: Gi,
            collator: tn,
            format: Hr,
            image: qr,
            in: Zi,
            "index-of": Wi,
            interpolate: ji,
            "interpolate-hcl": ji,
            "interpolate-lab": ji,
            length: cs,
            let: Hi,
            literal: Nr,
            match: Yi,
            number: Gr,
            "number-format": us,
            object: Gr,
            slice: Ji,
            step: Ai,
            string: Gr,
            "to-boolean": Wr,
            "to-color": Wr,
            "to-number": Wr,
            "to-string": Wr,
            var: vi,
            within: Mn,
            distance: ci,
            config: xi,
            split: Qi
        };
        function ds(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, o = Lr(e, r, n, s);
            if (o) throw new jr(o);
            return new sr(e / 255, r / 255, n / 255, s);
        }
        function fs(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, o = function(t1, e, r, n) {
                return "number" == typeof t1 && t1 >= 0 && t1 <= 360 ? "number" == typeof e && e >= 0 && e <= 100 && "number" == typeof r && r >= 0 && r <= 100 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[
                    t1,
                    e,
                    r,
                    n
                ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e, r, n, s);
            if (o) throw new jr(o);
            const a = `hsla(${e}, ${r}%, ${n}%, ${s})`, l = sr.parse(a);
            if (!l) throw new jr(`Failed to parse HSLA color: ${a}`);
            return l;
        }
        function ms(t1, e) {
            return t1 in e;
        }
        function ys(t1, e) {
            const r = e[t1];
            return void 0 === r ? null : r;
        }
        function gs(t1) {
            return {
                type: t1
            };
        }
        function xs(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function vs(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function bs(t1, e) {
            return !!t1 && !!t1.parameters && t1.parameters.indexOf(e) > -1;
        }
        function ws(t1) {
            return "data-driven" === t1["property-type"];
        }
        function _s(t1) {
            return bs(t1.expression, "measure-light");
        }
        function As(t1) {
            return bs(t1.expression, "zoom");
        }
        function Ms(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Is(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function Ss(t1) {
            return t1;
        }
        function Ps(t1, e) {
            const r = "color" === e.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), s = t1.type || (Ms(e) ? "exponential" : "interval");
            if (r && ((t1 = pr({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    sr.parse(t1[1])
                ])), t1.default = sr.parse(t1.default ? t1.default : e.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !Ni[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let o, a, l;
            if ("exponential" === s) o = Ts;
            else if ("interval" === s) o = zs;
            else if ("categorical" === s) {
                o = ks, a = Object.create(null);
                for (const e of t1.stops)a[e[0]] = e[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
                o = Bs;
            }
            if (n) {
                const r = {}, n = [];
                for(let e = 0; e < t1.stops.length; e++){
                    const i = t1.stops[e], s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(s)), r[s].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    Ps(r[t1], e)
                ]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: ji.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>Ts({
                            stops: i,
                            base: t1.base
                        }, e, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: ji.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>o(t1, e, r, a, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? Es(t1.default, e.default) : o(t1, e, i, a, l);
                }
            };
        }
        function Es(t1, e, r) {
            return void 0 !== t1 ? t1 : void 0 !== e ? e : void 0 !== r ? r : void 0;
        }
        function ks(t1, e, r, n, i) {
            return Es(typeof r === i ? n[r] : void 0, t1.default, e.default);
        }
        function zs(t1, e, r) {
            if ("number" !== Xr(r)) return Es(t1.default, e.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = _i(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function Ts(t1, e, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== Xr(r)) return Es(t1.default, e.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const s = _i(t1.stops.map((t1)=>t1[0]), r), o = function(t1, e, r, n) {
                const i = n - r, s = t1 - r;
                return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
            }(r, n, t1.stops[s][0], t1.stops[s + 1][0]), a = t1.stops[s][1], l = t1.stops[s + 1][1];
            let u = hr[e.type] || Ss;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e = Ni[t1.colorSpace];
                u = (t1, r)=>e.reverse(e.interpolate(e.forward(t1), e.forward(r), o));
            }
            return "function" == typeof a.evaluate ? {
                evaluate (...t1) {
                    const e = a.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e && void 0 !== r) return u(e, r, o);
                }
            } : u(a, l, o);
        }
        function Bs(t1, e, r) {
            return "color" === e.type ? r = sr.parse(r) : "formatted" === e.type ? r = Cr.fromString(r.toString()) : "resolvedImage" === e.type ? r = Dr.build(r.toString()) : Xr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Es(r, t1.default, e.default);
        }
        Jr.register(ps, {
            error: [
                {
                    kind: "error"
                },
                [
                    gr
                ],
                (t1, [e])=>{
                    throw new jr(e.evaluate(t1));
                }
            ],
            typeof: [
                gr,
                [
                    wr
                ],
                (t1, [e])=>Sr(Or(e.evaluate(t1)))
            ],
            "to-rgba": [
                Ir(yr, 4),
                [
                    vr
                ],
                (t1, [e])=>e.evaluate(t1).toNonPremultipliedRenderColor(null).toArray()
            ],
            "to-hsla": [
                Ir(yr, 4),
                [
                    vr
                ],
                (t1, [e])=>e.evaluate(t1).toNonPremultipliedRenderColor(null).toHslaArray()
            ],
            rgb: [
                vr,
                [
                    yr,
                    yr,
                    yr
                ],
                ds
            ],
            rgba: [
                vr,
                [
                    yr,
                    yr,
                    yr,
                    yr
                ],
                ds
            ],
            hsl: [
                vr,
                [
                    yr,
                    yr,
                    yr
                ],
                fs
            ],
            hsla: [
                vr,
                [
                    yr,
                    yr,
                    yr,
                    yr
                ],
                fs
            ],
            has: {
                type: xr,
                overloads: [
                    [
                        [
                            gr
                        ],
                        (t1, [e])=>ms(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            gr,
                            br
                        ],
                        (t1, [e, r])=>ms(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: wr,
                overloads: [
                    [
                        [
                            gr
                        ],
                        (t1, [e])=>ys(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            gr,
                            br
                        ],
                        (t1, [e, r])=>ys(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                wr,
                [
                    gr
                ],
                (t1, [e])=>ys(e.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                br,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                gr,
                [],
                (t1)=>t1.geometryType()
            ],
            worldview: [
                gr,
                [],
                (t1)=>t1.globals.worldview || ""
            ],
            id: [
                wr,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                yr,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                yr,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                yr,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "measure-light": [
                yr,
                [
                    gr
                ],
                (t1, [e])=>t1.measureLight(e.evaluate(t1))
            ],
            "heatmap-density": [
                yr,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                yr,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "raster-value": [
                yr,
                [],
                (t1)=>t1.globals.rasterValue || 0
            ],
            "raster-particle-speed": [
                yr,
                [],
                (t1)=>t1.globals.rasterParticleSpeed || 0
            ],
            "sky-radial-progress": [
                yr,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                wr,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                yr,
                gs(yr),
                (t1, e)=>{
                    let r = 0;
                    for (const n of e)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                yr,
                gs(yr),
                (t1, e)=>{
                    let r = 1;
                    for (const n of e)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: yr,
                overloads: [
                    [
                        [
                            yr,
                            yr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            yr
                        ],
                        (t1, [e])=>-e.evaluate(t1)
                    ]
                ]
            },
            "/": [
                yr,
                [
                    yr,
                    yr
                ],
                (t1, [e, r])=>e.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                yr,
                [
                    yr,
                    yr
                ],
                (t1, [e, r])=>e.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                yr,
                [],
                ()=>Math.LN2
            ],
            pi: [
                yr,
                [],
                ()=>Math.PI
            ],
            e: [
                yr,
                [],
                ()=>Math.E
            ],
            "^": [
                yr,
                [
                    yr,
                    yr
                ],
                (t1, [e, r])=>Math.pow(e.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.sqrt(e.evaluate(t1))
            ],
            log10: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN10
            ],
            ln: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.log(e.evaluate(t1))
            ],
            log2: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN2
            ],
            sin: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.sin(e.evaluate(t1))
            ],
            cos: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.cos(e.evaluate(t1))
            ],
            tan: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.tan(e.evaluate(t1))
            ],
            asin: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.asin(e.evaluate(t1))
            ],
            acos: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.acos(e.evaluate(t1))
            ],
            atan: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.atan(e.evaluate(t1))
            ],
            min: [
                yr,
                gs(yr),
                (t1, e)=>Math.min(...e.map((e)=>e.evaluate(t1)))
            ],
            max: [
                yr,
                gs(yr),
                (t1, e)=>Math.max(...e.map((e)=>e.evaluate(t1)))
            ],
            abs: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.abs(e.evaluate(t1))
            ],
            round: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>{
                    const r = e.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.floor(e.evaluate(t1))
            ],
            ceil: [
                yr,
                [
                    yr
                ],
                (t1, [e])=>Math.ceil(e.evaluate(t1))
            ],
            "filter-==": [
                xr,
                [
                    gr,
                    wr
                ],
                (t1, [e, r])=>t1.properties()[e.value] === r.value
            ],
            "filter-id-==": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>t1.id() === e.value
            ],
            "filter-type-==": [
                xr,
                [
                    gr
                ],
                (t1, [e])=>t1.geometryType() === e.value
            ],
            "filter-<": [
                xr,
                [
                    gr,
                    wr
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                xr,
                [
                    gr,
                    wr
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                xr,
                [
                    gr,
                    wr
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                xr,
                [
                    gr,
                    wr
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                xr,
                [
                    wr
                ],
                (t1, [e])=>e.value in t1.properties()
            ],
            "filter-has-id": [
                xr,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                xr,
                [
                    Ir(gr)
                ],
                (t1, [e])=>e.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                xr,
                [
                    Ir(wr)
                ],
                (t1, [e])=>e.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                xr,
                [
                    gr,
                    Ir(wr)
                ],
                (t1, [e, r])=>r.value.indexOf(t1.properties()[e.value]) >= 0
            ],
            "filter-in-large": [
                xr,
                [
                    gr,
                    Ir(wr)
                ],
                (t1, [e, r])=>(function(t1, e, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e[i] === t1) return !0;
                            e[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: xr,
                overloads: [
                    [
                        [
                            xr,
                            xr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        gs(xr),
                        (t1, e)=>{
                            for (const r of e)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: xr,
                overloads: [
                    [
                        [
                            xr,
                            xr
                        ],
                        (t1, [e, r])=>e.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        gs(xr),
                        (t1, e)=>{
                            for (const r of e)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                xr,
                [
                    xr
                ],
                (t1, [e])=>!e.evaluate(t1)
            ],
            "is-supported-script": [
                xr,
                [
                    gr
                ],
                (t1, [e])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e.evaluate(t1));
                }
            ],
            upcase: [
                gr,
                [
                    gr
                ],
                (t1, [e])=>e.evaluate(t1).toUpperCase()
            ],
            downcase: [
                gr,
                [
                    gr
                ],
                (t1, [e])=>e.evaluate(t1).toLowerCase()
            ],
            concat: [
                gr,
                gs(wr),
                (t1, e)=>e.map((e)=>Ur(e.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                gr,
                [
                    _r
                ],
                (t1, [e])=>e.evaluate(t1).resolvedLocale()
            ],
            random: [
                yr,
                [
                    yr,
                    yr,
                    wr
                ],
                (t1, e)=>{
                    const [r, n, i] = e.map((e)=>e.evaluate(t1));
                    if (r > n) return r;
                    if (r === n) return r;
                    let s;
                    if ("string" == typeof i) s = function(t1) {
                        let e = 0;
                        if (0 === t1.length) return e;
                        for(let r = 0; r < t1.length; r++)e = (e << 5) - e + t1.charCodeAt(r), e |= 0;
                        return e;
                    }(i);
                    else {
                        if ("number" != typeof i) throw new jr(`Invalid seed input: ${i}`);
                        s = i;
                    }
                    return r + hs(s)() * (n - r);
                }
            ]
        });
        class Vs {
            constructor(t1, e, r, n){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new Kr(r, n), this._defaultValue = e ? function(t1) {
                    return "color" === t1.type && (Is(t1.default) || Array.isArray(t1.default)) ? new sr(0, 0, 0, 0) : "color" === t1.type ? sr.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null, this.configDependencies = di(t1);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s, o, a) {
                return this._evaluator.globals = t1, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = a || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e, r, n, i, s, o, a) {
                this._evaluator.globals = t1, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = a || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new jr(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${t1.message}`)), this._defaultValue;
                }
            }
        }
        function Cs(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in ps;
        }
        function Fs(t1, e, r, n) {
            const i = new bi(ps, [], e ? function(t1) {
                const e = {
                    color: vr,
                    string: gr,
                    number: yr,
                    enum: gr,
                    boolean: xr,
                    formatted: Ar,
                    resolvedImage: Mr
                };
                return "array" === t1.type ? Ir(e[t1.value] || wr, t1.length) : e[t1.type];
            }(e) : void 0, void 0, void 0, r, n), s = i.parse(t1, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return s ? xs(new Vs(s, e, r, n)) : vs(i.errors);
        }
        class Ds {
            constructor(t1, e, r, n){
                this.kind = t1, this._styleExpression = e, this.isLightConstant = r, this.isLineProgressConstant = n, this.isStateDependent = "constant" !== t1 && !pi(e.expression), this.configDependencies = di(e.expression);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s);
            }
        }
        class Ls {
            constructor(t1, e, r, n, i, s){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t1 && !pi(e.expression), this.isLightConstant = i, this.isLineProgressConstant = s, this.configDependencies = di(e.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s);
            }
            interpolationFactor(t1, e, r) {
                return this.interpolationType ? ji.interpolationFactor(this.interpolationType, t1, e, r) : 0;
            }
        }
        function Rs(t1, e, r, n) {
            if ("error" === (t1 = Fs(t1, e, r, n)).result) return t1;
            const i = t1.value.expression, s = hi(i);
            if (!s && !ws(e)) return vs([
                new dr("", "data expressions not supported")
            ]);
            const o = fi(i, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!o && !As(e)) return vs([
                new dr("", "zoom expressions not supported")
            ]);
            const a = fi(i, [
                "measure-light"
            ]);
            if (!a && !_s(e)) return vs([
                new dr("", "measure-light expression not supported")
            ]);
            const l = fi(i, [
                "line-progress"
            ]);
            if (!l && !function(t1) {
                return bs(t1.expression, "line-progress");
            }(e)) return vs([
                new dr("", "line-progress expression not supported")
            ]);
            const u = e.expression && e.expression.relaxZoomRestriction, c = Us(i);
            return c || o || u ? c instanceof dr ? vs([
                c
            ]) : c instanceof ji && !Ms(e) ? vs([
                new dr("", '"interpolate" expressions cannot be used with this property')
            ]) : xs(c ? new Ls(s && l ? "camera" : "composite", t1.value, c.labels, c instanceof ji ? c.interpolation : void 0, a, l) : new Ds(s && l ? "constant" : "source", t1.value, a, l)) : vs([
                new dr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')
            ]);
        }
        class Os {
            constructor(t1, e){
                this._parameters = t1, this._specification = e, pr(this, Ps(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new Os(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function Us(t1) {
            let e = null;
            if (t1 instanceof Hi) e = Us(t1.result);
            else if (t1 instanceof Gi) {
                for (const r of t1.args)if (e = Us(r), e) break;
            } else (t1 instanceof Ai || t1 instanceof ji) && t1.input instanceof Jr && "zoom" === t1.input.name && (e = t1);
            return e instanceof dr || t1.eachChild((t1)=>{
                const r = Us(t1);
                r instanceof dr ? e = r : e && r && e !== r && (e = new dr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e;
        }
        var Ns, js, $s = function() {
            if (js) return Ns;
            js = 1, Ns = e;
            var t1 = 3;
            function e(e, r, n) {
                var i = this.cells = [];
                if (e instanceof ArrayBuffer) {
                    this.arrayBuffer = e;
                    var s = new Int32Array(this.arrayBuffer);
                    e = s[0], this.d = (r = s[1]) + 2 * (n = s[2]);
                    for(var o = 0; o < this.d * this.d; o++){
                        var a = s[t1 + o], l = s[t1 + o + 1];
                        i.push(a === l ? null : s.subarray(a, l));
                    }
                    var u = s[t1 + i.length + 1];
                    this.keys = s.subarray(s[t1 + i.length], u), this.bboxes = s.subarray(u), this.insert = this._insertReadonly;
                } else {
                    this.d = r + 2 * n;
                    for(var c = 0; c < this.d * this.d; c++)i.push([]);
                    this.keys = [], this.bboxes = [];
                }
                this.n = r, this.extent = e, this.padding = n, this.scale = r / e, this.uid = 0;
                var h = n / r * e;
                this.min = -h, this.max = e + h;
            }
            return e.prototype.insert = function(t1, e, r, n, i) {
                this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
            }, e.prototype._insertReadonly = function() {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
            }, e.prototype._insertCell = function(t1, e, r, n, i, s) {
                this.cells[i].push(s);
            }, e.prototype.query = function(t1, e, r, n, i) {
                var s = this.min, o = this.max;
                if (t1 <= s && e <= s && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);
                var a = [];
                return this._forEachCell(t1, e, r, n, this._queryCell, a, {}, i), a;
            }, e.prototype._queryCell = function(t1, e, r, n, i, s, o, a) {
                var l = this.cells[i];
                if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                    var p = l[h];
                    if (void 0 === o[p]) {
                        var d = 4 * p;
                        (a ? a(c[d + 0], c[d + 1], c[d + 2], c[d + 3]) : t1 <= c[d + 2] && e <= c[d + 3] && r >= c[d + 0] && n >= c[d + 1]) ? (o[p] = !0, s.push(u[p])) : o[p] = !1;
                    }
                }
            }, e.prototype._forEachCell = function(t1, e, r, n, i, s, o, a) {
                for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var d = u; d <= h; d++){
                    var f = this.d * d + p;
                    if ((!a || a(this._convertFromCellCoord(p), this._convertFromCellCoord(d), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(d + 1))) && i.call(this, t1, e, r, n, f, s, o, a)) return;
                }
            }, e.prototype._convertFromCellCoord = function(t1) {
                return (t1 - this.padding) / this.scale;
            }, e.prototype._convertToCellCoord = function(t1) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
            }, e.prototype.toArrayBuffer = function() {
                if (this.arrayBuffer) return this.arrayBuffer;
                for(var e = this.cells, r = t1 + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++)n += this.cells[i].length;
                var s = new Int32Array(r + n + this.keys.length + this.bboxes.length);
                s[0] = this.extent, s[1] = this.n, s[2] = this.padding;
                for(var o = r, a = 0; a < e.length; a++){
                    var l = e[a];
                    s[t1 + a] = o, s.set(l, o), o += l.length;
                }
                return s[t1 + e.length] = o, s.set(this.keys, o), s[t1 + e.length + 1] = o += this.keys.length, s.set(this.bboxes, o), o += this.bboxes.length, s.buffer;
            }, Ns;
        }(), Gs = gt($s);
        const Hs = {};
        function qs(t1, e, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e,
                writable: !1
            }), Hs[e] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        qs(Object, "Object"), Gs.serialize = function(t1, e) {
            const r = t1.toArrayBuffer();
            return e && e.add(r), {
                buffer: r
            };
        }, Gs.deserialize = function(t1) {
            return new Gs(t1.buffer);
        }, Object.defineProperty(Gs, "name", {
            value: "Grid"
        }), qs(Gs, "Grid"), delete bt.prototype.constructor, "undefined" != typeof DOMMatrix && qs(DOMMatrix, "DOMMatrix"), qs(sr, "Color"), qs(Error, "Error"), qs(Cr, "Formatted"), qs(Vr, "FormattedSection"), qs(Ve, "AJAXError"), qs(Dr, "ResolvedImage"), qs(Os, "StylePropertyFunction"), qs(Vs, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), qs(er, "ImageId"), qs(Fr, "ImageVariant"), qs(Ls, "ZoomDependentExpression"), qs(Ds, "ZoomConstantExpression"), qs(Jr, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in ps)Hs[ps[t1]._classRegistryKey] || qs(ps[t1], `Expression${t1}`);
        function Xs(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function Zs(t1) {
            return self.ImageBitmap && t1 instanceof ImageBitmap;
        }
        function Ws(t1, e) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (Xs(t1) || Zs(t1)) return e && e.add(t1), t1;
            if (ArrayBuffer.isView(t1)) return e && e.add(t1.buffer), t1;
            if (t1 instanceof ImageData) return e && e.add(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const r = [];
                for (const n of t1)r.push(Ws(n, e));
                return r;
            }
            if (t1 instanceof Map) {
                const r = {
                    $name: "Map",
                    entries: []
                };
                for (const [n, i] of t1.entries())r.entries.push(Ws(n), Ws(i, e));
                return r;
            }
            if (t1 instanceof Set) {
                const e = {
                    $name: "Set"
                };
                let r = 0;
                for (const n of t1.values())e[++r] = Ws(n);
                return e;
            }
            if (t1 instanceof DOMMatrix) {
                const e = {
                    $name: "DOMMatrix"
                }, r = [
                    "is2D",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m21",
                    "m22",
                    "m23",
                    "m24",
                    "m31",
                    "m32",
                    "m33",
                    "m34",
                    "m41",
                    "m42",
                    "m43",
                    "m44",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ];
                for (const n of r)e[n] = t1[n];
                return e;
            }
            if ("bigint" == typeof t1) return {
                $name: "BigInt",
                value: t1.toString()
            };
            if ("object" == typeof t1) {
                const r = t1.constructor, n = r._classRegistryKey;
                if (!n) throw new Error(`Can't serialize object of unregistered class "${r.name}".`);
                const i = r.serialize ? r.serialize(t1, e) : {};
                if (!r.serialize) {
                    for(const r in t1)t1.hasOwnProperty(r) && (Hs[n].omit.indexOf(r) >= 0 || (i[r] = Ws(t1[r], e)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function Ys(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || Xs(t1) || Zs(t1) || ArrayBuffer.isView(t1) || t1 instanceof ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(Ys);
            if ("object" == typeof t1) {
                const e = t1.$name || "Object";
                if ("Map" === e) {
                    const e = t1.entries || [], r = new Map;
                    for(let t1 = 0; t1 < e.length; t1 += 2)r.set(Ys(e[t1]), Ys(e[t1 + 1]));
                    return r;
                }
                if ("Set" === e) {
                    const e = new Set;
                    for (const r of Object.keys(t1))"$name" !== r && e.add(Ys(t1[r]));
                    return e;
                }
                if ("DOMMatrix" === e) {
                    let e;
                    return e = t1.is2D ? [
                        t1.a,
                        t1.b,
                        t1.c,
                        t1.d,
                        t1.e,
                        t1.f
                    ] : [
                        t1.m11,
                        t1.m12,
                        t1.m13,
                        t1.m14,
                        t1.m21,
                        t1.m22,
                        t1.m23,
                        t1.m24,
                        t1.m31,
                        t1.m32,
                        t1.m33,
                        t1.m34,
                        t1.m41,
                        t1.m42,
                        t1.m43,
                        t1.m44
                    ], new DOMMatrix(e);
                }
                if ("BigInt" === e) return BigInt(t1.value);
                const { klass: r } = Hs[e];
                if (!r) throw new Error(`Can't deserialize unregistered class "${e}".`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e of Object.keys(t1))"$name" !== e && (n[e] = Ys(t1[e]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const Ks = {
            "Latin-1 Supplement": (t1)=>t1 >= 128 && t1 <= 255,
            Arabic: (t1)=>t1 >= 1536 && t1 <= 1791,
            "Arabic Supplement": (t1)=>t1 >= 1872 && t1 <= 1919,
            "Arabic Extended-A": (t1)=>t1 >= 2208 && t1 <= 2303,
            "Hangul Jamo": (t1)=>t1 >= 4352 && t1 <= 4607,
            "Unified Canadian Aboriginal Syllabics": (t1)=>t1 >= 5120 && t1 <= 5759,
            Khmer: (t1)=>t1 >= 6016 && t1 <= 6143,
            "Unified Canadian Aboriginal Syllabics Extended": (t1)=>t1 >= 6320 && t1 <= 6399,
            "General Punctuation": (t1)=>t1 >= 8192 && t1 <= 8303,
            "Letterlike Symbols": (t1)=>t1 >= 8448 && t1 <= 8527,
            "Number Forms": (t1)=>t1 >= 8528 && t1 <= 8591,
            "Miscellaneous Technical": (t1)=>t1 >= 8960 && t1 <= 9215,
            "Control Pictures": (t1)=>t1 >= 9216 && t1 <= 9279,
            "Optical Character Recognition": (t1)=>t1 >= 9280 && t1 <= 9311,
            "Enclosed Alphanumerics": (t1)=>t1 >= 9312 && t1 <= 9471,
            "Geometric Shapes": (t1)=>t1 >= 9632 && t1 <= 9727,
            "Miscellaneous Symbols": (t1)=>t1 >= 9728 && t1 <= 9983,
            "Miscellaneous Symbols and Arrows": (t1)=>t1 >= 11008 && t1 <= 11263,
            "CJK Radicals Supplement": (t1)=>t1 >= 11904 && t1 <= 12031,
            "Kangxi Radicals": (t1)=>t1 >= 12032 && t1 <= 12255,
            "Ideographic Description Characters": (t1)=>t1 >= 12272 && t1 <= 12287,
            "CJK Symbols and Punctuation": (t1)=>t1 >= 12288 && t1 <= 12351,
            Hiragana: (t1)=>t1 >= 12352 && t1 <= 12447,
            Katakana: (t1)=>t1 >= 12448 && t1 <= 12543,
            Bopomofo: (t1)=>t1 >= 12544 && t1 <= 12591,
            "Hangul Compatibility Jamo": (t1)=>t1 >= 12592 && t1 <= 12687,
            Kanbun: (t1)=>t1 >= 12688 && t1 <= 12703,
            "Bopomofo Extended": (t1)=>t1 >= 12704 && t1 <= 12735,
            "CJK Strokes": (t1)=>t1 >= 12736 && t1 <= 12783,
            "Katakana Phonetic Extensions": (t1)=>t1 >= 12784 && t1 <= 12799,
            "Enclosed CJK Letters and Months": (t1)=>t1 >= 12800 && t1 <= 13055,
            "CJK Compatibility": (t1)=>t1 >= 13056 && t1 <= 13311,
            "CJK Unified Ideographs Extension A": (t1)=>t1 >= 13312 && t1 <= 19903,
            "Yijing Hexagram Symbols": (t1)=>t1 >= 19904 && t1 <= 19967,
            "CJK Unified Ideographs": (t1)=>t1 >= 19968 && t1 <= 40959,
            "Yi Syllables": (t1)=>t1 >= 40960 && t1 <= 42127,
            "Yi Radicals": (t1)=>t1 >= 42128 && t1 <= 42191,
            "Hangul Jamo Extended-A": (t1)=>t1 >= 43360 && t1 <= 43391,
            "Hangul Syllables": (t1)=>t1 >= 44032 && t1 <= 55215,
            "Hangul Jamo Extended-B": (t1)=>t1 >= 55216 && t1 <= 55295,
            "Private Use Area": (t1)=>t1 >= 57344 && t1 <= 63743,
            "CJK Compatibility Ideographs": (t1)=>t1 >= 63744 && t1 <= 64255,
            "Arabic Presentation Forms-A": (t1)=>t1 >= 64336 && t1 <= 65023,
            "Vertical Forms": (t1)=>t1 >= 65040 && t1 <= 65055,
            "CJK Compatibility Forms": (t1)=>t1 >= 65072 && t1 <= 65103,
            "Small Form Variants": (t1)=>t1 >= 65104 && t1 <= 65135,
            "Arabic Presentation Forms-B": (t1)=>t1 >= 65136 && t1 <= 65279,
            "Halfwidth and Fullwidth Forms": (t1)=>t1 >= 65280 && t1 <= 65519,
            Osage: (t1)=>t1 >= 66736 && t1 <= 66815,
            "CJK Unified Ideographs Extension B": (t1)=>t1 >= 131072 && t1 <= 173791
        };
        function Js(t1) {
            for (const e of t1)if (eo(e.charCodeAt(0))) return !0;
            return !1;
        }
        function Qs(t1) {
            for (const e of t1)if (!to(e.charCodeAt(0))) return !1;
            return !0;
        }
        function to(t1) {
            return !(Ks.Arabic(t1) || Ks["Arabic Supplement"](t1) || Ks["Arabic Extended-A"](t1) || Ks["Arabic Presentation Forms-A"](t1) || Ks["Arabic Presentation Forms-B"](t1));
        }
        function eo(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(Ks["Bopomofo Extended"](t1) || Ks.Bopomofo(t1) || Ks["CJK Compatibility Forms"](t1) && !(t1 >= 65097 && t1 <= 65103) || Ks["CJK Compatibility Ideographs"](t1) || Ks["CJK Compatibility"](t1) || Ks["CJK Radicals Supplement"](t1) || Ks["CJK Strokes"](t1) || !(!Ks["CJK Symbols and Punctuation"](t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || Ks["CJK Unified Ideographs Extension A"](t1) || Ks["CJK Unified Ideographs"](t1) || Ks["Enclosed CJK Letters and Months"](t1) || Ks["Hangul Compatibility Jamo"](t1) || Ks["Hangul Jamo Extended-A"](t1) || Ks["Hangul Jamo Extended-B"](t1) || Ks["Hangul Jamo"](t1) || Ks["Hangul Syllables"](t1) || Ks.Hiragana(t1) || Ks["Ideographic Description Characters"](t1) || Ks.Kanbun(t1) || Ks["Kangxi Radicals"](t1) || Ks["Katakana Phonetic Extensions"](t1) || Ks.Katakana(t1) && 12540 !== t1 || !(!Ks["Halfwidth and Fullwidth Forms"](t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!Ks["Small Form Variants"](t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || Ks["Unified Canadian Aboriginal Syllabics"](t1) || Ks["Unified Canadian Aboriginal Syllabics Extended"](t1) || Ks["Vertical Forms"](t1) || Ks["Yijing Hexagram Symbols"](t1) || Ks["Yi Syllables"](t1) || Ks["Yi Radicals"](t1))));
        }
        function ro(t1) {
            return !(eo(t1) || function(t1) {
                return !!(Ks["Latin-1 Supplement"](t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || Ks["General Punctuation"](t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || Ks["Letterlike Symbols"](t1) || Ks["Number Forms"](t1) || Ks["Miscellaneous Technical"](t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || Ks["Control Pictures"](t1) && 9251 !== t1 || Ks["Optical Character Recognition"](t1) || Ks["Enclosed Alphanumerics"](t1) || Ks["Geometric Shapes"](t1) || Ks["Miscellaneous Symbols"](t1) && !(t1 >= 9754 && t1 <= 9759) || Ks["Miscellaneous Symbols and Arrows"](t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || Ks["CJK Symbols and Punctuation"](t1) || Ks.Katakana(t1) || Ks["Private Use Area"](t1) || Ks["CJK Compatibility Forms"](t1) || Ks["Small Form Variants"](t1) || Ks["Halfwidth and Fullwidth Forms"](t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function no(t1) {
            return Ks.Arabic(t1) || Ks["Arabic Supplement"](t1) || Ks["Arabic Extended-A"](t1) || Ks["Arabic Presentation Forms-A"](t1) || Ks["Arabic Presentation Forms-B"](t1);
        }
        function io(t1) {
            return t1 >= 1424 && t1 <= 2303 || Ks["Arabic Presentation Forms-A"](t1) || Ks["Arabic Presentation Forms-B"](t1);
        }
        function so(t1, e) {
            return !(!e && io(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || Ks.Khmer(t1));
        }
        function oo(t1) {
            for (const e of t1)if (io(e.charCodeAt(0))) return !0;
            return !1;
        }
        const ao = {
            unavailable: "unavailable",
            deferred: "deferred",
            loading: "loading",
            parsing: "parsing",
            parsed: "parsed",
            loaded: "loaded",
            error: "error"
        };
        let lo = null, uo = ao.unavailable, co = null;
        const ho = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (uo = ao.error), lo && lo(t1);
        };
        function po() {
            fo.fire(new Ye("pluginStateChange", {
                pluginStatus: uo,
                pluginURL: co
            }));
        }
        const fo = new tr, mo = function() {
            return uo;
        }, yo = function() {
            if (uo !== ao.deferred || !co) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            uo = ao.loading, po(), co && De({
                url: co
            }, (t1)=>{
                t1 ? ho(t1) : (uo = ao.loaded, po());
            });
        }, go = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>uo === ao.loaded || null != go.applyArabicShaping,
            isLoading: ()=>uo === ao.loading,
            setState (t1) {
                uo = t1.pluginStatus, co = t1.pluginURL;
            },
            isParsing: ()=>uo === ao.parsing,
            isParsed: ()=>uo === ao.parsed,
            getPluginURL: ()=>co
        };
        class xo {
            constructor(t1, e){
                this.zoom = t1, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness, this.worldview = e.worldview) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e) {
                    for (const r of t1)if (!so(r.charCodeAt(0), e)) return !1;
                    return !0;
                }(t1, go.isLoaded());
            }
        }
        class vo {
            constructor(t1, e, r, n){
                this.property = t1, this.value = e, this.expression = function(t1, e, r, n) {
                    if (Is(t1)) return new Os(t1, e);
                    if (Cs(t1) || Array.isArray(t1) && t1.length > 0) {
                        const i = Rs(t1, e, r, n);
                        if ("error" === i.result) throw new Error(i.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return i.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e.type && (r = sr.parse(t1)), {
                            kind: "constant",
                            configDependencies: new Set,
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e ? t1.specification.default : e, t1.specification, r, n);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e, r) {
                return this.property.possiblyEvaluate(this, t1, e, r);
            }
        }
        class bo {
            constructor(t1, e, r){
                this.property = t1, this.value = new vo(t1, void 0, e, r);
            }
            transitioned(t1, e) {
                return new _o(this.property, this.value, e, Ct({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new _o(this.property, this.value, null, {}, 0);
            }
        }
        class wo {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set;
            }
            getValue(t1) {
                return Nt(this._values[t1].value.value);
            }
            setValue(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new bo(this._values[t1].property, this._scope, this._options)), this._values[t1].value = new vo(this._values[t1].property, null === e ? void 0 : Nt(e), this._scope, this._options), this._values[t1].value.expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].value.expression.configDependencies
                ]));
            }
            setTransitionOrValue(t1, e) {
                e && (this._options = e);
                const r = this._properties.properties;
                if (t1) for(const e in t1){
                    const n = t1[e];
                    if (e.endsWith("-transition")) {
                        const t1 = e.slice(0, -11);
                        r[t1] && this.setTransition(t1, n);
                    } else r.hasOwnProperty(e) && this.setValue(e, n);
                }
            }
            getTransition(t1) {
                return Nt(this._values[t1].transition);
            }
            setTransition(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new bo(this._values[t1].property)), this._values[t1].transition = Nt(e) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                    const n = this.getTransition(e);
                    void 0 !== n && (t1[`${e}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e) {
                const r = new Ao(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new Ao(this._properties);
                for (const e of Object.keys(this._values))t1._values[e] = this._values[e].untransitioned();
                return t1;
            }
        }
        class _o {
            constructor(t1, e, r, n, i){
                const s = n.delay || 0, o = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e, this.begin = i + s, this.end = this.begin + o, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e, r), s = this.prior;
                if (s) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return s.possiblyEvaluate(t1, e, r);
                    {
                        const o = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t1, e, r), i, Pt(o));
                    }
                }
                return i;
            }
        }
        class Ao {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e, r) {
                const n = new So(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class Mo {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set;
            }
            getValue(t1) {
                return Nt(this._values[t1].value);
            }
            setValue(t1, e) {
                this._values[t1] = new vo(this._values[t1].property, null === e ? void 0 : Nt(e), this._scope, this._options), this._values[t1].expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].expression.configDependencies
                ]));
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e, r) {
                const n = new So(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
        }
        class Io {
            constructor(t1, e, r){
                this.property = t1, this.value = e, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e, r, n);
            }
        }
        class So {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class Po {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return t1.expression.evaluate(e);
            }
            interpolate(t1, e, r) {
                const n = hr[this.specification.type];
                return n ? n(t1, e, r) : t1;
            }
        }
        class Eo {
            constructor(t1, e){
                this.specification = t1, this.overrides = e;
            }
            possiblyEvaluate(t1, e, r, n) {
                return new Io(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e, null, {}, r, n)
                } : t1.expression, e);
            }
            interpolate(t1, e, r) {
                if ("constant" !== t1.value.kind || "constant" !== e.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e.value.value) return new Io(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = hr[this.specification.type];
                return n ? new Io(this, {
                    kind: "constant",
                    value: n(t1.value.value, e.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e, r, n, i, s) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e, r, n, i, s);
            }
        }
        class ko {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e, r, n) {
                return !!t1.expression.evaluate(e, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class zo {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e = new xo(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new vo(n, void 0), s = this.defaultTransitionablePropertyValues[r] = new bo(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }
        qs(Eo, "DataDrivenProperty"), qs(Po, "DataConstantProperty"), qs(ko, "ColorRampProperty");
        var To = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"appearances":{"type":"array","value":"appearance","supported-layer-types":["symbol"]}},"appearance":{"condition":{"type":"expression"},"name":{"type":"string"},"properties":{"type":"*"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-facade":{"type":"boolean","default":false,"expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-facade-floors":{"type":"number","minimum":1,"maximum":200,"default":3,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-window":{"type":"array","length":2,"value":"number","minimum":0.1,"maximum":1,"default":[0.9,0.9],"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"appearance":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","expression":{}},"buildingFeaturesetId":{"type":"string","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"parameters":[]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","use-theme":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-facade-emissive-chance":{"type":"number","default":0.35,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["measure-light","zoom"]}},"building-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-gradient":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"use-theme":true,"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"use-theme":true,"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white","use-theme":true},"sky-atmosphere-color":{"type":"color","default":"white","use-theme":true},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"use-theme":true,"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');
        function Bo(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function Vo(t1) {
            if (Array.isArray(t1)) return t1.map(Vo);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e = {};
                for(const r in t1)e[r] = Vo(t1[r]);
                return e;
            }
            return Bo(t1);
        }
        function Co(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e of t1.slice(1))if (!Co(e) && "boolean" != typeof e) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function Fo(t1, e = "", r = null, n = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            Co(t1) || (t1 = jo(t1));
            const i = t1;
            let s = !0;
            try {
                s = function(t1) {
                    if (!Ro(t1)) return t1;
                    let e = Vo(t1);
                    return Lo(e), e = Do(e), e;
                }(i);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i, null, 2)}\n        `);
            }
            let o = null, a = null;
            if ("background" !== n && "sky" !== n && "slot" !== n) {
                a = To[`filter_${n}`];
                const t1 = Fs(s, a, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                o = (e, r, n)=>t1.value.evaluate(e, r, {}, n);
            }
            let l = null, u = null;
            if (s !== i) {
                const t1 = Fs(i, a, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                l = (e, r, n, i, s)=>t1.value.evaluate(e, r, {}, n, void 0, void 0, i, s), u = !hi(t1.value.expression);
            }
            return {
                filter: o,
                dynamicFilter: l || void 0,
                needGeometry: No(s),
                needFeature: !!u
            };
        }
        function Do(t1) {
            if (!Array.isArray(t1)) return t1;
            const e = function(t1) {
                if (Oo.has(t1[0])) {
                    for(let e = 1; e < t1.length; e++)if (Ro(t1[e])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e ? e : e.map((t1)=>Do(t1));
        }
        function Lo(t1) {
            let e = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e = e || Ro(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e = e || Ro(t1[1]);
                for(let e = 2; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e = e || Ro(t1[1]);
                for(let e = 1; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
            }
            e && (t1.length = 0, t1.push("any", ...r));
            for(let e = 1; e < t1.length; e++)Lo(t1[e]);
        }
        function Ro(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e = t1[0]) || "distance-from-center" === e) return !0;
            var e;
            for(let e = 1; e < t1.length; e++)if (Ro(t1[e])) return !0;
            return !1;
        }
        const Oo = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function Uo(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function No(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0] || "distance" === t1[0]) return !0;
            for(let e = 1; e < t1.length; e++)if (No(t1[e])) return !0;
            return !1;
        }
        function jo(t1) {
            if (!t1) return !0;
            const e = t1[0];
            return t1.length <= 1 ? "any" !== e : "==" === e ? $o(t1[1], t1[2], "==") : "!=" === e ? qo($o(t1[1], t1[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? $o(t1[1], t1[2], e) : "any" === e ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(jo))) : "all" === e ? [
                "all"
            ].concat(t1.slice(1).map(jo)) : "none" === e ? [
                "all"
            ].concat(t1.slice(1).map(jo).map(qo)) : "in" === e ? Go(t1[1], t1.slice(2)) : "!in" === e ? qo(Go(t1[1], t1.slice(2))) : "has" === e ? Ho(t1[1]) : "!has" !== e || qo(Ho(t1[1]));
            //TURBOPACK unreachable
            ;
            var r;
        }
        function $o(t1, e, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e
                    ];
            }
        }
        function Go(t1, e) {
            if (0 === e.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                default:
                    return e.length > 200 && !e.some((t1)=>typeof t1 != typeof e[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e.sort(Uo)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e
                        ]
                    ];
            }
        }
        function Ho(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function qo(t1) {
            return [
                "!",
                t1
            ];
        }
        const Xo = "";
        function Zo(t1, e) {
            return e ? `${t1}${Xo}${e}` : t1;
        }
        const Wo = "-transition", Yo = new Set([
            "fill",
            "line",
            "background",
            "hillshade",
            "raster"
        ]);
        class Ko extends tr {
            constructor(t1, e, r, n, i){
                if (super(), this.id = t1.id, this.fqid = Zo(this.id, r), this.type = t1.type, this.scope = r, this.lut = n, this.options = i, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, this.configDependencies = new Set, "custom" !== t1.type) {
                    if (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, t1.type && "background" !== t1.type && "sky" !== t1.type && "slot" !== t1.type) {
                        this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter;
                        const e = Fs(this.filter, To[`filter_${t1.type}`]);
                        "error" !== e.result && (this.configDependencies = new Set([
                            ...this.configDependencies,
                            ...e.value.configDependencies
                        ]));
                    }
                    if (t1.slot && (this.slot = t1.slot), e.layout && (this._unevaluatedLayout = new Mo(e.layout, this.scope, i), this.configDependencies = new Set([
                        ...this.configDependencies,
                        ...this._unevaluatedLayout.configDependencies
                    ])), e.paint) {
                        this._transitionablePaint = new wo(e.paint, this.scope, i);
                        for(const e in t1.paint)this.setPaintProperty(e, t1.paint[e]);
                        for(const e in t1.layout)this.setLayoutProperty(e, t1.layout[e]);
                        this.configDependencies = new Set([
                            ...this.configDependencies,
                            ...this._transitionablePaint.configDependencies
                        ]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new So(e.paint);
                    }
                }
            }
            onAdd(t1) {}
            onRemove(t1) {}
            isDraped(t1) {
                return !this.is3D(!0) && Yo.has(this.type);
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e) {
                if ("custom" === this.type && "visibility" === t1) return void (this.visibility = e);
                const r = this._unevaluatedLayout;
                r._properties.properties[t1] && (r.setValue(t1, e), this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...r.configDependencies
                ]), "visibility" === t1 && this.possiblyEvaluateVisibility());
            }
            possiblyEvaluateVisibility() {
                this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                    zoom: 0
                }));
            }
            getPaintProperty(t1) {
                return t1.endsWith(Wo) ? this._transitionablePaint.getTransition(t1.slice(0, -11)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e) {
                const r = this._transitionablePaint, n = r._properties.properties;
                if (t1.endsWith(Wo)) {
                    const i = t1.slice(0, -11);
                    return n[i] && r.setTransition(i, e || void 0), !1;
                }
                if (!n[t1]) return !1;
                const i = r._values[t1], s = i.value.isDataDriven(), o = i.value;
                r.setValue(t1, e), this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...r.configDependencies
                ]), this._handleSpecialPaintPropertyUpdate(t1);
                const a = r._values[t1].value, l = a.isDataDriven(), u = t1.endsWith("pattern") || "line-dasharray" === t1;
                return l || s || u || this._handleOverridablePaintPropertyUpdate(t1, o, a);
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getDefaultProgramParams(t1, e, r) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e);
            }
            serialize() {
                return Ut({
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                }, (t1, e)=>!(void 0 === t1 || "layout" === e && !Object.keys(t1).length || "paint" === e && !Object.keys(t1).length));
            }
            is3D(t1) {
                return !1;
            }
            hasElevation() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            hasShadowPass() {
                return !1;
            }
            canCastShadows() {
                return !1;
            }
            hasLightBeamPass() {
                return !1;
            }
            cutoffRange() {
                return 0;
            }
            tileCoverLift() {
                return 0;
            }
            resize() {}
            _clear() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e = this.paint.get(t1);
                    if (e instanceof Io && ws(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter(t1) {
                this._filterCompiled || (this._featureFilter = Fo(this.filter, this.scope, t1), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
                return this._stats;
            }
            resetLayerRenderingStats(t1) {
                this._stats && ("shadow" === t1.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            queryRadius(t1) {}
            queryIntersectsFeature(t1, e, r, n, i, s, o, a, l) {}
        }
        const Jo = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class Qo {
            constructor(t1, e){
                this._structArray = t1, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class ta {
            constructor(){
                this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e) {
                return t1._trim(), e && e.add(t1.arrayBuffer), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t1.arrayBuffer, e.length = t1.length, e.capacity = t1.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(), e && this.uint8.set(e);
                }
            }
            _refreshViews() {
                throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t1) {
                throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t1) {
                throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function ea(t1, e = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = Jo[t1.type].BYTES_PER_ELEMENT, s = r = ra(r, Math.max(e, i)), o = t1.components || 1;
                    return n = Math.max(n, i), r += i * o, {
                        name: t1.name,
                        type: t1.type,
                        components: o,
                        offset: s
                    };
                }),
                size: ra(r, Math.max(n, e)),
                alignment: e
            };
        }
        function ra(t1, e) {
            return Math.ceil(t1 / e) * e;
        }
        class na extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e, this.int16[n + 1] = r, t1;
            }
        }
        na.prototype.bytesPerElement = 4, qs(na, "StructArrayLayout2i4");
        class ia extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        ia.prototype.bytesPerElement = 6, qs(ia, "StructArrayLayout3i6");
        class sa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t1;
            }
        }
        sa.prototype.bytesPerElement = 8, qs(sa, "StructArrayLayout4i8");
        class oa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.float32[1 * t1 + 0] = e, t1;
            }
        }
        oa.prototype.bytesPerElement = 4, qs(oa, "StructArrayLayout1f4");
        class aa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 4 * t1, s = 2 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.float32[s + 1] = n, t1;
            }
        }
        aa.prototype.bytesPerElement = 8, qs(aa, "StructArrayLayout2i1f8");
        class la extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 4 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        la.prototype.bytesPerElement = 8, qs(la, "StructArrayLayout3i8");
        class ua extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const o = 5 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, t1;
            }
        }
        ua.prototype.bytesPerElement = 10, qs(ua, "StructArrayLayout5i10");
        class ca extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s, o);
            }
            emplace(t1, e, r, n, i, s, o, a) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = o, this.float32[c + 2] = a, t1;
            }
        }
        ca.prototype.bytesPerElement = 12, qs(ca, "StructArrayLayout2i4ub1f12");
        class ha extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        ha.prototype.bytesPerElement = 12, qs(ha, "StructArrayLayout3f12");
        class pa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const o = 6 * t1, a = 3 * t1;
                return this.uint16[o + 0] = e, this.uint16[o + 1] = r, this.uint16[o + 2] = n, this.uint16[o + 3] = i, this.float32[a + 2] = s, t1;
            }
        }
        pa.prototype.bytesPerElement = 12, qs(pa, "StructArrayLayout4ui1f12");
        class da extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t1;
            }
        }
        da.prototype.bytesPerElement = 8, qs(da, "StructArrayLayout4ui8");
        class fa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, o) {
                const a = 6 * t1;
                return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, this.int16[a + 5] = o, t1;
            }
        }
        fa.prototype.bytesPerElement = 12, qs(fa, "StructArrayLayout6i12");
        class ma extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e, r, n, i, s, o, a, l, u, c, h);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h, p) {
                const d = 12 * t1;
                return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.uint16[d + 4] = s, this.uint16[d + 5] = o, this.uint16[d + 6] = a, this.uint16[d + 7] = l, this.int16[d + 8] = u, this.int16[d + 9] = c, this.int16[d + 10] = h, this.int16[d + 11] = p, t1;
            }
        }
        ma.prototype.bytesPerElement = 24, qs(ma, "StructArrayLayout4i4ui4i24");
        class ya extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, o) {
                const a = 10 * t1, l = 5 * t1;
                return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = o, t1;
            }
        }
        ya.prototype.bytesPerElement = 20, qs(ya, "StructArrayLayout3i3f20");
        class ga extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t1;
            }
        }
        ga.prototype.bytesPerElement = 16, qs(ga, "StructArrayLayout4f16");
        class xa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint32[1 * t1 + 0] = e, t1;
            }
        }
        xa.prototype.bytesPerElement = 4, qs(xa, "StructArrayLayout1ul4");
        class va extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t1;
            }
        }
        va.prototype.bytesPerElement = 4, qs(va, "StructArrayLayout2ui4");
        class ba extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c, h, p) {
                const d = this.length;
                return this.resize(d + 1), this.emplace(d, t1, e, r, n, i, s, o, a, l, u, c, h, p);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h, p, d) {
                const f = 20 * t1, m = 10 * t1;
                return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = s, this.float32[m + 3] = o, this.float32[m + 4] = a, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[f + 14] = c, this.uint32[m + 8] = h, this.uint16[f + 18] = p, this.uint16[f + 19] = d, t1;
            }
        }
        ba.prototype.bytesPerElement = 40, qs(ba, "StructArrayLayout5i4f1i1ul2ui40");
        class wa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s, o);
            }
            emplace(t1, e, r, n, i, s, o, a) {
                const l = 8 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = o, this.int16[l + 7] = a, t1;
            }
        }
        wa.prototype.bytesPerElement = 16, qs(wa, "StructArrayLayout3i2i2i16");
        class _a extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const o = 4 * t1, a = 8 * t1;
                return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[a + 6] = i, this.int16[a + 7] = s, t1;
            }
        }
        _a.prototype.bytesPerElement = 16, qs(_a, "StructArrayLayout2f1f2i16");
        class Aa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, o) {
                const a = 20 * t1, l = 5 * t1;
                return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = o, t1;
            }
        }
        Aa.prototype.bytesPerElement = 20, qs(Aa, "StructArrayLayout2ub4f20");
        class Ma extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        Ma.prototype.bytesPerElement = 6, qs(Ma, "StructArrayLayout3ui6");
        class Ia extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b) {
                const w = this.length;
                return this.resize(w + 1), this.emplace(w, t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w) {
                const _ = 30 * t1, A = 15 * t1, M = 60 * t1;
                return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = o, this.uint16[_ + 9] = a, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = d, this.float32[A + 10] = f, this.float32[A + 11] = m, this.uint8[M + 48] = y, this.uint8[M + 49] = g, this.uint8[M + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[M + 58] = w, t1;
            }
        }
        Ia.prototype.bytesPerElement = 60, qs(Ia, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Sa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, E, k, z, T, B) {
                const V = this.length;
                return this.resize(V + 1), this.emplace(V, t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, E, k, z, T, B);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, E, k, z, T, B, V) {
                const C = 20 * t1, F = 40 * t1, D = 80 * t1;
                return this.float32[C + 0] = e, this.float32[C + 1] = r, this.int16[F + 4] = n, this.int16[F + 5] = i, this.int16[F + 6] = s, this.int16[F + 7] = o, this.int16[F + 8] = a, this.int16[F + 9] = l, this.int16[F + 10] = u, this.int16[F + 11] = c, this.int16[F + 12] = h, this.uint16[F + 13] = p, this.uint16[F + 14] = d, this.uint16[F + 15] = f, this.uint16[F + 16] = m, this.uint16[F + 17] = y, this.uint16[F + 18] = g, this.uint16[F + 19] = x, this.uint16[F + 20] = v, this.uint16[F + 21] = b, this.uint16[F + 22] = w, this.uint16[F + 23] = _, this.uint16[F + 24] = A, this.uint16[F + 25] = M, this.uint16[F + 26] = I, this.uint16[F + 27] = S, this.uint32[C + 14] = P, this.float32[C + 15] = E, this.float32[C + 16] = k, this.float32[C + 17] = z, this.float32[C + 18] = T, this.uint8[D + 76] = B, this.uint16[F + 39] = V, t1;
            }
        }
        Sa.prototype.bytesPerElement = 80, qs(Sa, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
        class Pa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, o) {
                const a = 6 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, this.float32[a + 5] = o, t1;
            }
        }
        Pa.prototype.bytesPerElement = 24, qs(Pa, "StructArrayLayout6f24");
        class Ea extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const o = 5 * t1;
                return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.float32[o + 3] = i, this.float32[o + 4] = s, t1;
            }
        }
        Ea.prototype.bytesPerElement = 20, qs(Ea, "StructArrayLayout5f20");
        class ka extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s, o);
            }
            emplace(t1, e, r, n, i, s, o, a) {
                const l = 7 * t1;
                return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = o, this.float32[l + 6] = a, t1;
            }
        }
        ka.prototype.bytesPerElement = 28, qs(ka, "StructArrayLayout7f28");
        class za extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, t1, e, r, n, i, s, o, a, l, u, c);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h) {
                const p = 11 * t1;
                return this.float32[p + 0] = e, this.float32[p + 1] = r, this.float32[p + 2] = n, this.float32[p + 3] = i, this.float32[p + 4] = s, this.float32[p + 5] = o, this.float32[p + 6] = a, this.float32[p + 7] = l, this.float32[p + 8] = u, this.float32[p + 9] = c, this.float32[p + 10] = h, t1;
            }
        }
        za.prototype.bytesPerElement = 44, qs(za, "StructArrayLayout11f44");
        class Ta extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l) {
                const u = this.length;
                return this.resize(u + 1), this.emplace(u, t1, e, r, n, i, s, o, a, l);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u) {
                const c = 9 * t1;
                return this.float32[c + 0] = e, this.float32[c + 1] = r, this.float32[c + 2] = n, this.float32[c + 3] = i, this.float32[c + 4] = s, this.float32[c + 5] = o, this.float32[c + 6] = a, this.float32[c + 7] = l, this.float32[c + 8] = u, t1;
            }
        }
        Ta.prototype.bytesPerElement = 36, qs(Ta, "StructArrayLayout9f36");
        class Ba extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e, this.float32[n + 1] = r, t1;
            }
        }
        Ba.prototype.bytesPerElement = 8, qs(Ba, "StructArrayLayout2f8");
        class Va extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 6 * t1;
                return this.uint32[3 * t1 + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t1;
            }
        }
        Va.prototype.bytesPerElement = 12, qs(Va, "StructArrayLayout1ul3ui12");
        class Ca extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint16[1 * t1 + 0] = e, t1;
            }
        }
        Ca.prototype.bytesPerElement = 2, qs(Ca, "StructArrayLayout1ui2");
        class Fa extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m) {
                const y = this.length;
                return this.resize(y + 1), this.emplace(y, t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m);
            }
            emplace(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y) {
                const g = 16 * t1;
                return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = s, this.float32[g + 5] = o, this.float32[g + 6] = a, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = d, this.float32[g + 13] = f, this.float32[g + 14] = m, this.float32[g + 15] = y, t1;
            }
        }
        Fa.prototype.bytesPerElement = 64, qs(Fa, "StructArrayLayout16f64");
        class Da extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, o) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s, o);
            }
            emplace(t1, e, r, n, i, s, o, a) {
                const l = 10 * t1, u = 5 * t1;
                return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = s, this.float32[u + 3] = o, this.float32[u + 4] = a, t1;
            }
        }
        Da.prototype.bytesPerElement = 20, qs(Da, "StructArrayLayout4ui3f20");
        class La extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.int16[1 * t1 + 0] = e, t1;
            }
        }
        La.prototype.bytesPerElement = 2, qs(La, "StructArrayLayout1i2");
        class Ra extends ta {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint8[1 * t1 + 0] = e, t1;
            }
        }
        Ra.prototype.bytesPerElement = 1, qs(Ra, "StructArrayLayout1ub1");
        class Oa extends Qo {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        Oa.prototype.size = 40;
        class Ua extends ba {
            get(t1) {
                return new Oa(this, t1);
            }
        }
        qs(Ua, "CollisionBoxArray");
        class Na extends Qo {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        Na.prototype.size = 60;
        class ja extends Ia {
            get(t1) {
                return new Na(this, t1);
            }
        }
        qs(ja, "PlacedSymbolArray");
        class $a extends Qo {
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 14] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t1) {
                this._structArray.float32[this._pos4 + 18] = t1;
            }
            get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 76];
            }
            get elevationFeatureIndex() {
                return this._structArray.uint16[this._pos2 + 39];
            }
        }
        $a.prototype.size = 80;
        class Ga extends Sa {
            get(t1) {
                return new $a(this, t1);
            }
        }
        qs(Ga, "SymbolInstanceArray");
        class Ha extends oa {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        qs(Ha, "GlyphOffsetArray");
        class qa extends na {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        qs(qa, "SymbolLineVertexArray");
        class Xa extends Qo {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        Xa.prototype.size = 12;
        class Za extends Va {
            get(t1) {
                return new Xa(this, t1);
            }
        }
        qs(Za, "FeatureIndexArray");
        class Wa extends va {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        qs(Wa, "FillExtrusionCentroidArray");
        class Ya extends Qo {
            get a_join_normal_inside0() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get a_join_normal_inside1() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get a_join_normal_inside2() {
                return this._structArray.int16[this._pos2 + 2];
            }
        }
        Ya.prototype.size = 6;
        class Ka extends ia {
            get(t1) {
                return new Ya(this, t1);
            }
        }
        qs(Ka, "FillExtrusionWallArray");
        const Ja = ea([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), Qa = ea([
            {
                name: "a_circle_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), tl = ea([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class el {
            constructor(t1 = []){
                this.segments = t1;
            }
            _prepareSegment(t1, e, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > el.MAX_VERTEX_ARRAY_LENGTH && Gt(`Max vertices per segment is ${el.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > el.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e,
                    primitiveOffset: r,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            prepareSegment(t1, e, r, n) {
                return this._prepareSegment(t1, e.length, r.length, n);
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e in t1.vaos)t1.vaos[e].destroy();
            }
            static simpleSegment(t1, e, r, n) {
                return new el([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        function rl(t1, e) {
            return 256 * (t1 = zt(Math.floor(t1), 0, 255)) + zt(Math.floor(e), 0, 255);
        }
        el.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, qs(el, "SegmentVector");
        const nl = ea([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), il = ea([
            {
                name: "a_pattern_b",
                components: 4,
                type: "Uint16"
            }
        ]), sl = ea([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        class ol {
            constructor(){
                this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e, r, n) {
                this.ids.push(al(t1)), this.positions.push(e, r, n);
            }
            eachPosition(t1, e) {
                const r = al(t1);
                let n = 0, i = this.ids.length - 1;
                for(; n < i;){
                    const t1 = n + i >> 1;
                    this.ids[t1] >= r ? i = t1 : n = t1 + 1;
                }
                for(; this.ids[n] === r;)e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;
            }
            static serialize(t1, e) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return ll(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e = new ol;
                let r;
                e.ids = t1.ids, e.positions = t1.positions;
                for (const t1 of e.ids)t1 !== r && e.uniqueIds.push(t1), r = t1;
                return e.indexed = !0, e;
            }
        }
        function al(t1) {
            const e = +t1;
            return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : We(String(t1));
        }
        function ll(t1, e, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let s = r - 1, o = n + 1;
                for(;;){
                    do {
                        s++;
                    }while (t1[s] < i)
                    do {
                        o--;
                    }while (t1[o] > i)
                    if (s >= o) break;
                    ul(t1, s, o), ul(e, 3 * s, 3 * o), ul(e, 3 * s + 1, 3 * o + 1), ul(e, 3 * s + 2, 3 * o + 2);
                }
                o - r < n - o ? (ll(t1, e, r, o), r = o + 1) : (ll(t1, e, o + 1, n), n = o);
            }
        }
        function ul(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        qs(ol, "FeaturePositionMap");
        class cl {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e), this.initialized = !0), !!this.location;
            }
            set(t1, e, r) {
                throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
        }
        class hl extends cl {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }
        class pl extends cl {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class dl extends cl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }
        class fl extends cl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }
        class ml extends cl {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class yl extends cl {
            constructor(t1){
                super(t1), this.current = sr.transparent.toPremultipliedRenderColor(null);
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const gl = new Float32Array(16);
        class xl extends cl {
            constructor(t1){
                super(t1), this.current = gl;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        const vl = new Float32Array(9), bl = new Float32Array(4);
        class wl extends cl {
            constructor(t1){
                super(t1), this.current = bl;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        function _l(t1) {
            return [
                rl(255 * t1.r, 255 * t1.g),
                rl(255 * t1.b, 255 * t1.a)
            ];
        }
        class Al {
            constructor(t1, e, r, n){
                this.value = t1, this.uniformNames = e.map((t1)=>`u_${t1}`), this.type = r, this.context = n;
            }
            setUniform(t1, e, r, n, i) {
                const s = n.constantOr(this.value);
                e.set(t1, i, s instanceof sr ? s.toPremultipliedRenderColor(this.lutExpression && "none" === this.lutExpression.value ? null : this.context.lut) : s);
            }
            getBinding(t1, e) {
                return "color" === this.type ? new yl(t1) : new pl(t1);
            }
        }
        class Ml {
            constructor(t1, e){
                this.uniformNames = e.map((t1)=>`u_${t1}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1, e) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br), this.patternTransition = e ? e.tl.concat(e.br) : this.pattern;
            }
            setUniform(t1, e, r, n, i) {
                let s = null;
                "u_pattern" !== i && "u_dash" !== i || (s = this.pattern), "u_pattern_b" === i && (s = this.patternTransition), "u_pixel_ratio" === i && (s = this.pixelRatio), s && e.set(t1, i, s);
            }
            getBinding(t1, e) {
                return "u_pattern" === e || "u_pattern_b" === e || "u_dash" === e ? new ml(t1) : new pl(t1);
            }
        }
        class Il {
            constructor(t1, e, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n, i, s, o, a) {
                const l = this.paintVertexArray.length, u = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new xo(0, {
                    brightness: s,
                    worldview: a
                }), e, {}, i, n, o) : "constant" === this.expression.kind && this.expression.value, c = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new xo(0, {
                    brightness: s,
                    worldview: a
                }), e, {}, i, n, o) : this.lutExpression.value);
                this.paintVertexArray.resize(t1), this._setPaintValue(l, t1, u, c ? null : this.context.lut);
            }
            updatePaintArray(t1, e, r, n, i, s, o, a) {
                const l = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({
                    zoom: 0,
                    brightness: o,
                    worldview: a
                }, r, n, void 0, i) : "constant" === this.expression.kind && this.expression.value, u = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new xo(0, {
                    brightness: o,
                    worldview: a
                }), r, n, void 0, i) : this.lutExpression.value);
                this._setPaintValue(t1, e, l, u ? null : this.context.lut);
            }
            _setPaintValue(t1, e, r, n) {
                if ("color" === this.type) {
                    const i = _l(r.toPremultipliedRenderColor(n));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, i[0], i[1]);
                } else {
                    for(let n = t1; n < e; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Sl {
            constructor(t1, e, r, n, i, s){
                this.expression = t1, this.uniformNames = e.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new s;
            }
            populatePaintArray(t1, e, r, n, i, s, o, a) {
                const l = this.expression.evaluate(new xo(this.context.zoom, {
                    brightness: s,
                    worldview: a
                }), e, {}, i, n, o), u = this.expression.evaluate(new xo(this.context.zoom + 1, {
                    brightness: s,
                    worldview: a
                }), e, {}, i, n, o), c = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new xo(0, {
                    brightness: s,
                    worldview: a
                }), e, {}, i, n, o) : this.lutExpression.value), h = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(h, t1, l, u, c ? null : this.context.lut);
            }
            updatePaintArray(t1, e, r, n, i, s, o, a) {
                const l = this.expression.evaluate({
                    zoom: this.context.zoom,
                    brightness: o,
                    worldview: a
                }, r, n, void 0, i), u = this.expression.evaluate({
                    zoom: this.context.zoom + 1,
                    brightness: o,
                    worldview: a
                }, r, n, void 0, i), c = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new xo(0, {
                    brightness: o,
                    worldview: a
                }), r, n, void 0, i) : this.lutExpression.value);
                this._setPaintValue(t1, e, l, u, c ? null : this.context.lut);
            }
            _setPaintValue(t1, e, r, n, i) {
                if ("color" === this.type) {
                    const n = _l(r.toPremultipliedRenderColor(i)), s = _l(r.toPremultipliedRenderColor(i));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, n[0], n[1], s[0], s[1]);
                } else {
                    for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, o = zt(this.expression.interpolationFactor(s, this.context.zoom, this.context.zoom + 1), 0, 1);
                e.set(t1, i, o);
            }
            getBinding(t1, e) {
                return new pl(t1);
            }
        }
        class Pl {
            constructor(t1, e, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? sl : nl).members;
                for(let t1 = 0; t1 < e.length; ++t1);
                this.paintVertexArray = new n, this.paintTransitionVertexArray = new da;
            }
            populatePaintArray(t1, e, r, n) {
                const i = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(i, t1, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e, r, n, i, s, o) {
                this._setPaintValues(t1, e, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t1, e, r, n) {
                if (!n || !r) return;
                const i = n[r[0]], s = n[r[1]];
                if (i) {
                    if (i) {
                        const { tl: r, br: n, pixelRatio: s } = i;
                        for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r[0], r[1], n[0], n[1], s);
                    }
                    if (s) {
                        this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                        const { tl: r, br: n } = s;
                        for(let i = t1; i < e; i++)this.paintTransitionVertexArray.emplace(i, r[0], r[1], n[0], n[1]);
                    }
                }
            }
            upload(t1) {
                const e = this.expression.isStateDependent || !this.expression.isLightConstant;
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t1.createVertexBuffer(this.paintTransitionVertexArray, il.members, e));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
            }
        }
        class El {
            constructor(t1, e, r = ()=>!0){
                this.binders = {}, this._buffers = [], this.context = e;
                const n = [];
                for(const i in t1.paint._values){
                    const s = t1.paint.get(i);
                    if (i.endsWith("-use-theme")) continue;
                    if (!r(i)) continue;
                    if (!(s instanceof Io && ws(s.property.specification))) continue;
                    const o = Tl(i, t1.type), a = s.value, l = s.property.specification.type, u = !!s.property.useIntegerZoom, c = "line-dasharray" === i || i.endsWith("pattern"), h = t1.paint.get(`${i}-use-theme`), p = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind || h && "constant" !== h.value.kind;
                    if ("constant" !== a.kind || p) if ("source" === a.kind || p || c) {
                        const e = Cl(i, l, "source");
                        this.binders[i] = c ? new Pl(a, o, l, e, t1.id) : new Il(a, o, l, e), n.push(`/a_${i}`);
                    } else {
                        const t1 = Cl(i, l, "composite");
                        this.binders[i] = new Sl(a, o, l, u, e, t1), n.push(`/z_${i}`);
                    }
                    else this.binders[i] = c ? new Ml(a.value, o) : new Al(a.value, o, l, e), n.push(`/u_${i}`);
                    h && (this.binders[i].lutExpression = h.value);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e = this.binders[t1];
                return e instanceof Il || e instanceof Sl ? e.maxValue : 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, o, a) {
                for(const l in this.binders){
                    const u = this.binders[l];
                    u.context = this.context, (u instanceof Il || u instanceof Sl || u instanceof Pl) && u.populatePaintArray(t1, e, r, n, i, s, o, a);
                }
            }
            setConstantPatternPositions(t1, e) {
                for(const r in this.binders){
                    const n = this.binders[r];
                    n instanceof Ml && n.setConstantPatternPositions(t1, e);
                }
            }
            getPatternTransitionVertexBuffer(t1) {
                const e = this.binders[t1];
                return e instanceof Pl ? e.paintTransitionVertexBuffer : null;
            }
            updatePaintArrays(t1, e, r, n, i, s, o, a, l, u) {
                let c = !1;
                const h = Object.keys(t1), p = 0 !== h.length && !a, d = p ? h : e.uniqueIds;
                this.context.lut = i.lut;
                for(const a in this.binders){
                    const h = this.binders[a];
                    if (h.context = this.context, (h instanceof Il || h instanceof Sl || h instanceof Pl) && h.expression && h.expression.kind && "constant" !== h.expression.kind && (!0 === h.expression.isStateDependent || !1 === h.expression.isLightConstant)) {
                        const f = i.paint.get(a);
                        h.expression = f.value;
                        for (const r of d){
                            const i = t1[r.toString()];
                            e.eachPosition(r, (t1, e, r)=>{
                                const a = n.feature(t1);
                                h.updatePaintArray(e, r, a, i, s, o, l, u);
                            });
                        }
                        if (!p) for (const e of r.uniqueIds){
                            const i = t1[e.toString()];
                            r.eachPosition(e, (t1, e, r)=>{
                                const a = n.feature(t1);
                                h.updatePaintArray(e, r, a, i, s, o, l, u);
                            });
                        }
                        c = !0;
                    }
                }
                return c;
            }
            defines() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Al || r instanceof Ml) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Il || r instanceof Sl || r instanceof Pl) for(let e = 0; e < r.paintVertexAttributes.length; e++)t1.push(r.paintVertexAttributes[e].name);
                    if (r instanceof Pl) for(let e = 0; e < il.members.length; e++)t1.push(il.members[e].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Al || r instanceof Ml || r instanceof Sl) for (const e of r.uniformNames)t1.push(e);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof Al || n instanceof Ml || n instanceof Sl) for (const i of n.uniformNames)e.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e;
            }
            setUniforms(t1, e, r, n, i) {
                for (const { name: e, property: s, binding: o } of r)this.binders[s].setUniform(t1, o, i, n.get(s), e);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Il || e instanceof Sl || e instanceof Pl) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer), e instanceof Pl && e.paintTransitionVertexBuffer && this._buffers.push(e.paintTransitionVertexBuffer);
                }
            }
            upload(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Il || r instanceof Sl || r instanceof Pl) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Il || e instanceof Sl || e instanceof Pl) && e.destroy();
                }
            }
        }
        class kl {
            constructor(t1, e, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new El(n, e, r);
                this.needsUpload = !1, this._featureMap = new ol, this._featureMapWithoutIds = new ol, this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, o, a, l) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e, n, i, s, o, a, l);
                void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t1) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t1), this._idlessCounter += 1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e, r, n, i, s, o, a) {
                for (const l of r)this.needsUpload = this.programConfigurations[l.id].updatePaintArrays(t1, this._featureMap, this._featureMapWithoutIds, e, l, n, i, s, o || 0, a) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e in this.programConfigurations)this.programConfigurations[e].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const zl = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "icon-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-emissive-strength": [
                "emissive_strength"
            ],
            "icon-emissive-strength": [
                "emissive_strength"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "symbol-z-offset": [
                "z_offset"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio",
                "pattern_b"
            ],
            "line-dasharray": [
                "dash"
            ],
            "fill-bridge-guard-rail-color": [
                "structure_color"
            ],
            "fill-tunnel-structure-color": [
                "structure_color"
            ]
        };
        function Tl(t1, e) {
            return zl[t1] || [
                t1.replace(`${e}-`, "").replace(/-/g, "_")
            ];
        }
        const Bl = {
            "line-pattern": {
                source: pa,
                composite: pa
            },
            "fill-pattern": {
                source: pa,
                composite: pa
            },
            "fill-extrusion-pattern": {
                source: pa,
                composite: pa
            },
            "line-dasharray": {
                source: da,
                composite: da
            }
        }, Vl = {
            color: {
                source: Ba,
                composite: ga
            },
            number: {
                source: oa,
                composite: Ba
            }
        };
        function Cl(t1, e, r) {
            const n = Bl[t1];
            return n && n[r] || Vl[e][r];
        }
        qs(Al, "ConstantBinder"), qs(Ml, "PatternConstantBinder"), qs(Il, "SourceExpressionBinder"), qs(Pl, "PatternCompositeBinder"), qs(Sl, "CompositeExpressionBinder"), qs(El, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), qs(kl, "ProgramConfigurationSet");
        const Fl = Cn / Math.PI / 2, Dl = 5, Ll = 6, Rl = 16383, Ol = 64, Ul = [
            Ol,
            32,
            16
        ], Nl = -Fl, jl = Fl;
        function $l(t1, e, r, n = Fl) {
            return r = Mt(r), [
                t1 * Math.sin(r) * n,
                -e * n,
                t1 * Math.cos(r) * n
            ];
        }
        function Gl(t1, e, r) {
            return $l(Math.cos(Mt(t1)), Math.sin(Mt(t1)), e, r);
        }
        const Hl = 6371008.8, ql = 2 * Math.PI * Hl;
        class Xl {
            constructor(t1, e){
                if (isNaN(t1) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t1}, ${e})`);
                if (this.lng = +t1, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new Xl(Bt(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e = Math.PI / 180, r = this.lat * e, n = t1.lat * e, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e);
                return Hl * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e = 360 * t1 / 40075017, r = e / Math.cos(Math.PI / 180 * this.lat);
                return new Zl({
                    lng: this.lng - r,
                    lat: this.lat - e
                }, {
                    lng: this.lng + r,
                    lat: this.lat + e
                });
            }
            toEcef(t1) {
                return Gl(this.lat, this.lng, Fl + t1 * Fl / Hl);
            }
            static convert(t1) {
                if (t1 instanceof Xl) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new Xl(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new Xl(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        class Zl {
            constructor(t1, e){
                if (t1) if (e) this.setSouthWest(t1).setNorthEast(e);
                else if (4 === t1.length) {
                    const e = t1;
                    this.setSouthWest([
                        e[0],
                        e[1]
                    ]).setNorthEast([
                        e[2],
                        e[3]
                    ]);
                } else {
                    const e = t1;
                    this.setSouthWest(e[0]).setNorthEast(e[1]);
                }
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof Xl ? new Xl(t1.lng, t1.lat) : Xl.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof Xl ? new Xl(t1.lng, t1.lat) : Xl.convert(t1), this;
            }
            extend(t1) {
                const e = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof Xl) n = t1, i = t1;
                else {
                    if (!(t1 instanceof Zl)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(Zl.convert(t1)) : this.extend(Xl.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && (t1.hasOwnProperty("lon") || t1.hasOwnProperty("lng")) ? this.extend(Xl.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Xl(n.lng, n.lat), this._ne = new Xl(i.lng, i.lat)), this;
            }
            getCenter() {
                return new Xl((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new Xl(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new Xl(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e, lat: r } = Xl.convert(t1);
                let n = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                if (t1) return t1 instanceof Zl ? t1 : new Zl(t1);
            }
        }
        const Wl = 0, Yl = 25.5;
        function Kl(t1) {
            return ql * Math.cos(t1 * Math.PI / 180);
        }
        function Jl(t1) {
            return (180 + t1) / 360;
        }
        function Ql(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function tu(t1, e) {
            return t1 / Kl(e);
        }
        function eu(t1) {
            return 360 * t1 - 180;
        }
        function ru(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function nu(t1, e) {
            return t1 * Kl(ru(e));
        }
        const iu = 85.051129;
        function su(t1) {
            return Math.cos(Mt(zt(t1, -iu, iu)));
        }
        function ou(t1, e) {
            const r = zt(e, Wl, Yl), n = Math.pow(2, r);
            return su(t1) * ql / (512 * n);
        }
        function au(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        function lu(t1, e = 0) {
            const r = Math.exp(Math.PI * (1 - (t1.y + e / Cn) / (1 << t1.z) * 2));
            return 80150034 * r / (r * r + 1) / Cn / (1 << t1.z);
        }
        class uu {
            constructor(t1, e, r = 0){
                this.x = +t1, this.y = +e, this.z = +r;
            }
            static fromLngLat(t1, e = 0) {
                const r = Xl.convert(t1);
                return new uu(Jl(r.lng), Ql(r.lat), tu(e, r.lat));
            }
            toLngLat() {
                return new Xl(eu(this.x), ru(this.y));
            }
            toAltitude() {
                return nu(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / ql * au(ru(this.y));
            }
        }
        function cu(t1, e, r, n, i, s, o, a, l) {
            const u = (e + n) / 2, c = (r + i) / 2, h = new bt(u, c);
            a(h), function(t1, e, r, n, i, s) {
                const o = r - i, a = n - s;
                return Math.abs((n - e) * o - (r - t1) * a) / Math.hypot(o, a);
            }(h.x, h.y, s.x, s.y, o.x, o.y) >= l ? (cu(t1, e, r, u, c, s, h, a, l), cu(t1, u, c, n, i, h, o, a, l)) : t1.push(o);
        }
        function hu(t1, e, r) {
            let n = t1[0], i = n.x, s = n.y;
            e(n);
            const o = [
                n
            ];
            for(let a = 1; a < t1.length; a++){
                const l = t1[a], { x: u, y: c } = l;
                e(l), cu(o, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
            }
            return o;
        }
        function pu(t1, e, r, n) {
            if (n(e, r)) {
                const i = e.add(r)._mult(.5);
                pu(t1, e, i, n), pu(t1, i, r, n);
            } else t1.push(r);
        }
        function du(t1, e) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const s = t1[i];
                pu(n, r, s, e), r = s;
            }
            return n;
        }
        const fu = Math.pow(2, 14) - 1, mu = -fu - 1;
        function yu(t1, e) {
            const r = Math.round(t1.x * e), n = Math.round(t1.y * e);
            return t1.x = zt(r, mu, fu), t1.y = zt(n, mu, fu), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && Gt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function gu(t1, e, r) {
            const n = t1.loadGeometry(), i = t1.extent, s = Cn / i;
            if (e && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e.z, { scale: o, x: a, y: l, projection: u } = r, c = (t1)=>{
                    const r = eu((e.x + t1.x / i) / s), n = ru((e.y + t1.y / i) / s), c = u.project(r, n);
                    t1.x = (c.x * o - a) * i, t1.y = (c.y * o - l) * i;
                };
                for(let e = 0; e < n.length; e++)if (1 !== t1.type) n[e] = hu(n[e], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e] = t1;
                }
            }
            for (const t1 of n)for (const e of t1)yu(e, s);
            return n;
        }
        function xu(t1, e) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e ? gu(t1) : []
            };
        }
        class vu {
            constructor(t1, e, r, n, i){
                this.properties = {}, this.extent = r, this.type = 0, this.id = void 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(bu, this, e);
            }
            loadGeometry() {
                const t1 = this._pbf;
                t1.pos = this._geometry;
                const e = t1.readVarint() + t1.pos, r = [];
                let n, i = 1, s = 0, o = 0, a = 0;
                for(; t1.pos < e;){
                    if (s <= 0) {
                        const e = t1.readVarint();
                        i = 7 & e, s = e >> 3;
                    }
                    if (s--, 1 === i || 2 === i) o += t1.readSVarint(), a += t1.readSVarint(), 1 === i && (n && r.push(n), n = []), n && n.push(new bt(o, a));
                    else {
                        if (7 !== i) throw new Error(`unknown command ${i}`);
                        n && n.push(n[0].clone());
                    }
                }
                return n && r.push(n), r;
            }
            bbox() {
                const t1 = this._pbf;
                t1.pos = this._geometry;
                const e = t1.readVarint() + t1.pos;
                let r = 1, n = 0, i = 0, s = 0, o = 1 / 0, a = -1 / 0, l = 1 / 0, u = -1 / 0;
                for(; t1.pos < e;){
                    if (n <= 0) {
                        const e = t1.readVarint();
                        r = 7 & e, n = e >> 3;
                    }
                    if (n--, 1 === r || 2 === r) i += t1.readSVarint(), s += t1.readSVarint(), i < o && (o = i), i > a && (a = i), s < l && (l = s), s > u && (u = s);
                    else if (7 !== r) throw new Error(`unknown command ${r}`);
                }
                return [
                    o,
                    l,
                    a,
                    u
                ];
            }
            toGeoJSON(t1, e, r) {
                const n = this.extent * Math.pow(2, r), i = this.extent * t1, s = this.extent * e, o = this.loadGeometry();
                function a(t1) {
                    return [
                        360 * (t1.x + i) / n - 180,
                        360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t1.y + s) / n) * Math.PI)) - 90
                    ];
                }
                function l(t1) {
                    return t1.map(a);
                }
                let u;
                if (1 === this.type) {
                    const t1 = [];
                    for (const e of o)t1.push(e[0]);
                    const e = l(t1);
                    u = 1 === t1.length ? {
                        type: "Point",
                        coordinates: e[0]
                    } : {
                        type: "MultiPoint",
                        coordinates: e
                    };
                } else if (2 === this.type) {
                    const t1 = o.map(l);
                    u = 1 === t1.length ? {
                        type: "LineString",
                        coordinates: t1[0]
                    } : {
                        type: "MultiLineString",
                        coordinates: t1
                    };
                } else {
                    if (3 !== this.type) throw new Error("unknown feature type");
                    {
                        const t1 = function(t1) {
                            const e = t1.length;
                            if (e <= 1) return [
                                t1
                            ];
                            const r = [];
                            let n, i;
                            for(let s = 0; s < e; s++){
                                const e = wu(t1[s]);
                                0 !== e && (void 0 === i && (i = e < 0), i === e < 0 ? (n && r.push(n), n = [
                                    t1[s]
                                ]) : n && n.push(t1[s]));
                            }
                            return n && r.push(n), r;
                        }(o), e = [];
                        for (const r of t1)e.push(r.map(l));
                        u = 1 === e.length ? {
                            type: "Polygon",
                            coordinates: e[0]
                        } : {
                            type: "MultiPolygon",
                            coordinates: e
                        };
                    }
                }
                const c = {
                    type: "Feature",
                    geometry: u,
                    properties: this.properties
                };
                return null != this.id && (c.id = this.id), c;
            }
        }
        function bu(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? function(t1, e) {
                const r = t1.readVarint() + t1.pos;
                for(; t1.pos < r;){
                    const r = e._keys[t1.readVarint()], n = e._values[t1.readVarint()];
                    e.properties[r] = n;
                }
            }(r, e) : 3 === t1 ? e.type = r.readVarint() : 4 === t1 && (e._geometry = r.pos);
        }
        function wu(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, o = s - 1; i < s; o = i++)r = t1[i], n = t1[o], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        vu.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class _u {
            constructor(t1, e){
                this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(Au, this, e), this.length = this._features.length;
            }
            feature(t1) {
                if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[t1];
                const e = this._pbf.readVarint() + this._pbf.pos;
                return new vu(this._pbf, e, this.extent, this._keys, this._values);
            }
        }
        function Au(t1, e, r) {
            15 === t1 ? e.version = r.readVarint() : 1 === t1 ? e.name = r.readString() : 5 === t1 ? e.extent = r.readVarint() : 2 === t1 ? e._features.push(r.pos) : 3 === t1 ? e._keys.push(r.readString()) : 4 === t1 && e._values.push(function(t1) {
                let e = null;
                const r = t1.readVarint() + t1.pos;
                for(; t1.pos < r;){
                    const r = t1.readVarint() >> 3;
                    e = 1 === r ? t1.readString() : 2 === r ? t1.readFloat() : 3 === r ? t1.readDouble() : 4 === r ? t1.readVarint64() : 5 === r ? t1.readVarint() : 6 === r ? t1.readSVarint() : 7 === r ? t1.readBoolean() : null;
                }
                if (null == e) throw new Error("unknown feature value");
                return e;
            }(r));
        }
        class Mu {
            constructor(t1, e){
                this.layers = t1.readFields(Iu, {}, e);
            }
        }
        function Iu(t1, e, r) {
            if (3 === t1) {
                const t1 = new _u(r, r.readVarint() + r.pos);
                t1.length && (e[t1.name] = t1);
            }
        }
        const Su = "3d_elevation_id", Pu = "level";
        class Eu {
            constructor(){
                this._valid = !1;
            }
            reset(t1) {
                return this.feature = t1, this._valid = !0, this._geometry = t1.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = !1), this;
            }
            geometry(t1, e) {
                return this._valid && t1(e(this._geometry)), this;
            }
            require(t1, e, r) {
                return this.get(t1, !0, e, r);
            }
            optional(t1, e, r) {
                return this.get(t1, !1, e, r);
            }
            success() {
                return this._valid;
            }
            get(t1, e, r, n) {
                const i = this.feature.properties.hasOwnProperty(t1) ? +this.feature.properties[t1] : void 0;
                return this._valid && void 0 !== i && !Number.isNaN(i) ? r(n ? n(i) : i) : e && (this._valid = !1), this;
            }
        }
        class ku {
            constructor(t1, e){
                this.featureFunc = t1, this.vertexFunc = e;
            }
            parseFeature(t1, e, r) {
                return this.featureFunc(t1, e, r);
            }
            parseVertex(t1, e, r) {
                return this.vertexFunc(t1, e, r);
            }
        }
        const zu = new ku((t1, e, r)=>t1.reset(e).require(Su, (t1)=>{
                r.id = t1;
            }).optional("fixed_height_relative", (t1)=>{
                r.constantHeight = t1;
            }, Bu.decodeRelativeHeight).geometry((t1)=>{
                r.bounds = t1;
            }, pn).success(), (t1, e, r)=>t1.reset(e).require(Su, (t1)=>{
                r.id = t1;
            }).require("elevation_idx", (t1)=>{
                r.idx = t1;
            }).require("extent", (t1)=>{
                r.extent = t1;
            }).require("height_relative", (t1)=>{
                r.height = t1;
            }, Bu.decodeRelativeHeight).geometry((t1)=>{
                r.position = t1;
            }, Bu.getPoint).success()), Tu = new ku((t1, e, r)=>t1.reset(e).require(Su, (t1)=>{
                r.id = t1;
            }).optional("fixed_height", (t1)=>{
                r.constantHeight = t1;
            }, Bu.decodeMetricHeight).geometry((t1)=>{
                r.bounds = t1;
            }, pn).success(), (t1, e, r)=>t1.reset(e).require(Su, (t1)=>{
                r.id = t1;
            }).require("elevation_idx", (t1)=>{
                r.idx = t1;
            }).require("extent", (t1)=>{
                r.extent = t1;
            }).require("height", (t1)=>{
                r.height = t1;
            }, Bu.decodeMetricHeight).geometry((t1)=>{
                r.position = t1;
            }, Bu.getPoint).success());
        class Bu {
            static getPoint(t1) {
                return at(t1[0][0].x, t1[0][0].y);
            }
            static decodeRelativeHeight(t1) {
                return 1e-4 * t1 * 5;
            }
            static decodeMetricHeight(t1) {
                return 1e-4 * t1;
            }
            static parse(t1) {
                const e = [], r = [], n = t1.length, i = new Eu;
                for(let o = 0; o < n; o++){
                    const n = t1.feature(o), a = n.properties.version, l = (s = a) ? "1.0.1" === s ? Tu : void 0 : zu;
                    if (void 0 === l) {
                        Gt(`Unknown elevation feature version number ${a || "(unknown)"}`);
                        continue;
                    }
                    const u = n.properties.hasOwnProperty("type") ? n.properties.type : void 0;
                    if (u) {
                        if ("Point" === vu.types[n.type] && "curve_point" === u) {
                            const t1 = {};
                            l.parseVertex(i, n, t1) && e.push(t1);
                        } else if ("Polygon" === vu.types[n.type] && "curve_meta" === u) {
                            const t1 = {};
                            l.parseFeature(i, n, t1) && r.push(t1);
                        }
                    }
                }
                var s;
                return {
                    vertices: e,
                    features: r
                };
            }
        }
        class Vu {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(t1, e, r) {
                const n = dt(e, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e[0] + (t1[1] - this.pos[1]) * e[1]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, !0;
            }
        }
        class Cu {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(t1, e, r) {
                const n = D(e, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e[0] + (t1[1] - this.pos[1]) * e[1] + (t1[2] - this.pos[2]) * e[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }
            closestPointOnSphere(t1, r, n) {
                if (function(t1, r) {
                    var n = t1[0], i = t1[1], s = t1[2], o = r[0], a = r[1], l = r[2];
                    return Math.abs(n - o) <= e * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - a) <= e * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(s - l) <= e * Math.max(1, Math.abs(s), Math.abs(l));
                }(this.pos, t1) || 0 === r) return n[0] = n[1] = n[2] = 0, !1;
                const [i, s, o] = this.dir, a = this.pos[0] - t1[0], l = this.pos[1] - t1[1], u = this.pos[2] - t1[2], c = i * i + s * s + o * o, h = 2 * (a * i + l * s + u * o), p = h * h - 4 * c * (a * a + l * l + u * u - r * r);
                if (p < 0) {
                    const t1 = Math.max(-h / 2, 0), e = a + i * t1, c = l + s * t1, p = u + o * t1, d = Math.hypot(e, c, p);
                    return n[0] = e * r / d, n[1] = c * r / d, n[2] = p * r / d, !1;
                }
                {
                    const t1 = (-h - Math.sqrt(p)) / (2 * c);
                    if (t1 < 0) {
                        const t1 = Math.hypot(a, l, u);
                        return n[0] = a * r / t1, n[1] = l * r / t1, n[2] = u * r / t1, !1;
                    }
                    return n[0] = a + i * t1, n[1] = l + s * t1, n[2] = u + o * t1, !0;
                }
            }
        }
        class Fu {
            constructor(t1, e, r, n, i){
                this.TL = t1, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(t1, e, r) {
                const n = [
                    -1,
                    1,
                    1
                ], i = [
                    1,
                    1,
                    1
                ], s = [
                    1,
                    -1,
                    1
                ], o = [
                    -1,
                    -1,
                    1
                ], a = O(n, n, t1), l = O(i, i, t1), u = O(s, s, t1), c = O(o, o, t1);
                return new Fu(a, l, u, c, e / r);
            }
        }
        function Du(t1, e, r) {
            let n = 1 / 0, i = -1 / 0;
            const s = [];
            for (const o of t1){
                G(s, o, e);
                const t1 = D(s, r);
                n = Math.min(n, t1), i = Math.max(i, t1);
            }
            return [
                n,
                i
            ];
        }
        function Lu(t1, e) {
            let r = !0;
            for(let n = 0; n < t1.planes.length; n++){
                const i = t1.planes[n];
                let s = 0;
                for(let t1 = 0; t1 < e.length; t1++)s += D(i, e[t1]) + i[3] >= 0;
                if (0 === s) return 0;
                s !== e.length && (r = !1);
            }
            return r ? 2 : 1;
        }
        function Ru(t1, e) {
            for (const r of t1.projections){
                const n = Du(e, t1.points[0], r.axis);
                if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;
            }
            return 1;
        }
        function Ou(t1, e) {
            let r = 0;
            const n = [
                0,
                0,
                0,
                0
            ];
            for(let o = 0; o < t1.length; o++)n[0] = t1[o][0], n[1] = t1[o][1], n[2] = t1[o][2], n[3] = 1, (i = n)[0] * (s = e)[0] + i[1] * s[1] + i[2] * s[2] + i[3] * s[3] >= 0 && r++;
            var i, s;
            return r;
        }
        class Uu {
            constructor(t1, e){
                this.points = t1 || new Array(8).fill([
                    0,
                    0,
                    0
                ]), this.planes = e || new Array(6).fill([
                    0,
                    0,
                    0,
                    0
                ]), this.bounds = Nu.fromPoints(this.points), this.projections = [], this.frustumEdges = [
                    G([], this.points[2], this.points[3]),
                    G([], this.points[0], this.points[3]),
                    G([], this.points[4], this.points[0]),
                    G([], this.points[5], this.points[1]),
                    G([], this.points[6], this.points[2]),
                    G([], this.points[7], this.points[3])
                ];
                for (const t1 of this.frustumEdges){
                    const e = [
                        0,
                        -t1[2],
                        t1[1]
                    ], r = [
                        t1[2],
                        0,
                        -t1[0]
                    ];
                    this.projections.push({
                        axis: e,
                        projection: Du(this.points, this.points[0], e)
                    }), this.projections.push({
                        axis: r,
                        projection: Du(this.points, this.points[0], r)
                    });
                }
            }
            static fromInvProjectionMatrix(t1, e, r, n) {
                const i = Math.pow(2, r), s = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r)=>{
                    const s = Y([], r, t1), o = 1 / s[3] / e * i;
                    return (a = s)[0] = (l = s)[0] * (u = [
                        o,
                        o,
                        n ? 1 / s[3] : o,
                        o
                    ])[0], a[1] = l[1] * u[1], a[2] = l[2] * u[2], a[3] = l[3] * u[3], a;
                    //TURBOPACK unreachable
                    ;
                    var a, l, u;
                }), o = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t1)=>{
                    const e = F([], L([], G([], s[t1[0]], s[t1[1]]), G([], s[t1[2]], s[t1[1]]))), r = -D(e, s[t1[1]]);
                    return e.concat(r);
                }), a = [];
                for(let t1 = 0; t1 < s.length; t1++)a.push([
                    s[t1][0],
                    s[t1][1],
                    s[t1][2]
                ]);
                return new Uu(a, o);
            }
            intersectsPrecise(t1, e, r) {
                for(let r = 0; r < e.length; r++)if (!Ou(t1, e[r])) return 0;
                for(let e = 0; e < this.planes.length; e++)if (!Ou(t1, this.planes[e])) return 0;
                for (const e of r)for (const r of this.frustumEdges){
                    const n = L([], e, r), i = _(n);
                    if (0 === i) continue;
                    z(n, n, 1 / i);
                    const s = Du(this.points, this.points[0], n), o = Du(t1, this.points[0], n);
                    if (s[0] > o[1] || o[0] > s[1]) return 0;
                }
                return 1;
            }
            containsPoint(t1) {
                for (const e of this.planes){
                    const r = e[3];
                    if (D([
                        e[0],
                        e[1],
                        e[2]
                    ], t1) + r < 0) return !1;
                }
                return !0;
            }
        }
        class Nu {
            static fromPoints(t1) {
                const e = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n of t1)E(e, e, n), k(r, r, n);
                return new Nu(e, r);
            }
            static fromTileIdAndHeight(t1, e, r) {
                const n = 1 << t1.canonical.z, i = t1.canonical.x, s = t1.canonical.y;
                return new Nu([
                    i / n,
                    s / n,
                    e
                ], [
                    (i + 1) / n,
                    (s + 1) / n,
                    r
                ]);
            }
            static applyTransform(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)O(r[t1], r[t1], e);
                return Nu.fromPoints(r);
            }
            static applyTransformFast(t1, e) {
                const r = [
                    e[12],
                    e[13],
                    e[14]
                ], n = [
                    ...r
                ];
                for(let i = 0; i < 3; i++)for(let s = 0; s < 3; s++){
                    const o = e[4 * s + i], a = o * t1.min[s], l = o * t1.max[s];
                    r[i] += Math.min(a, l), n[i] += Math.max(a, l);
                }
                return new Nu(r, n);
            }
            static projectAabbCorners(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)O(r[t1], r[t1], e);
                return r;
            }
            constructor(t1, e){
                this.min = t1, this.max = e, this.center = z([], I([], this.min, this.max), .5);
            }
            quadrant(t1) {
                const e = [
                    t1 % 2 == 0,
                    t1 < 2
                ], r = w(this.min), n = w(this.max);
                for(let t1 = 0; t1 < e.length; t1++)r[t1] = e[t1] ? this.min[t1] : this.center[t1], n[t1] = e[t1] ? this.center[t1] : this.max[t1];
                return n[2] = this.max[2], new Nu(r, n);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        e[1],
                        e[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        e[2]
                    ]
                ];
            }
            intersects(t1) {
                return this.intersectsAabb(t1.bounds) ? Lu(t1, this.getCorners()) : 0;
            }
            intersectsFlat(t1) {
                return this.intersectsAabb(t1.bounds) ? Lu(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsPrecise(t1, e) {
                return e || this.intersects(t1) ? Ru(t1, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t1, e) {
                return e || this.intersectsFlat(t1) ? Ru(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsAabb(t1) {
                for(let e = 0; e < 3; ++e)if (this.min[e] > t1.max[e] || t1.min[e] > this.max[e]) return !1;
                return !0;
            }
            intersectsAabbXY(t1) {
                return !(this.min[0] > t1.max[0] || t1.min[0] > this.max[0] || this.min[1] > t1.max[1] || t1.min[1] > this.max[1]);
            }
            encapsulate(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1.min[e]), this.max[e] = Math.max(this.max[e], t1.max[e]);
            }
            encapsulatePoint(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1[e]), this.max[e] = Math.max(this.max[e], t1[e]);
            }
            closestPoint(t1) {
                return [
                    Math.max(Math.min(this.max[0], t1[0]), this.min[0]),
                    Math.max(Math.min(this.max[1], t1[1]), this.min[1]),
                    Math.max(Math.min(this.max[2], t1[2]), this.min[2])
                ];
            }
        }
        qs(Nu, "Aabb");
        class ju {
            constructor(t1, e){
                this.feature = t1, this.metersToTile = e, this.index = 0;
            }
            get() {
                const t1 = this.feature.vertices[this.index], e = this.feature.vertexProps[this.index].dir, r = e[1], n = -e[0], i = (t1.extent + 1) * this.metersToTile;
                return [
                    new bt(Math.trunc(t1.position[0] + r * i), Math.trunc(t1.position[1] + n * i)),
                    new bt(Math.trunc(t1.position[0] - r * i), Math.trunc(t1.position[1] - n * i))
                ];
            }
            next() {
                this.index++;
            }
            valid() {
                return this.index < this.feature.vertices.length;
            }
        }
        class $u {
            constructor(t1, e, r, n, i, s){
                if (this.vertices = new Array, this.vertexProps = new Array, this.edges = new Array, this.edgeProps = new Array, this.id = t1, this.heightRange = {
                    min: r,
                    max: r
                }, this.safeArea = e, this.constantHeight = r, null == this.constantHeight && (null != this.constantHeight || 0 !== n.length)) {
                    this.vertices = n, this.edges = i, this.edges = this.edges.filter((t1)=>{
                        return t1.a < this.vertices.length && t1.b < this.vertices.length && !((e = this.vertices[t1.a].position)[0] === (r = this.vertices[t1.b].position)[0] && e[1] === r[1]);
                        //TURBOPACK unreachable
                        ;
                        var e, r;
                    }), this.heightRange = {
                        min: Number.POSITIVE_INFINITY,
                        max: Number.NEGATIVE_INFINITY
                    };
                    for (const t1 of this.vertices)this.vertexProps.push({
                        dir: at(0, 0)
                    }), this.heightRange.min = Math.min(this.heightRange.min, t1.height), this.heightRange.max = Math.max(this.heightRange.max, t1.height);
                    for (const t1 of this.edges){
                        const e = this.vertices[t1.a].position, r = this.vertices[t1.b].position, n = ut(ot(), r, e), i = ht(n), s = ct(ot(), n, 1 / i);
                        this.edgeProps.push({
                            vec: n,
                            dir: s,
                            len: i
                        });
                        const o = this.vertexProps[t1.a].dir, a = this.vertexProps[t1.b].dir;
                        lt(o, o, s), lt(a, a, s);
                    }
                    for (const t1 of this.vertexProps)0 === t1.dir[0] && 0 === t1.dir[1] || pt(t1.dir, t1.dir);
                    this.tessellate(s);
                }
            }
            pointElevation(t1) {
                if (null != this.constantHeight) return this.constantHeight;
                const e = this.getClosestEdge(t1);
                if (null == e) return 0;
                const [r, n] = e;
                return ur(this.vertices[this.edges[r].a].height, this.vertices[this.edges[r].b].height, n);
            }
            computeSlopeNormal(t1, e) {
                const r = this.getClosestEdge(t1);
                if (!r) return A(0, 0, 1);
                const n = r[0], i = this.edges[n], s = this.edgeProps[n].vec, o = A(s[0], s[1], (this.vertices[i.b].height - this.vertices[i.a].height) * e), a = A(o[1], -o[0], 0);
                L(a, a, o);
                const l = _(a);
                return l > 0 ? z(a, a, 1 / l) : A(0, 0, 1);
            }
            getSafeArea() {
                return this.safeArea;
            }
            isTunnel() {
                return this.heightRange.max <= -5;
            }
            getClosestEdge(t1) {
                if (0 === this.edges.length) return;
                let e = 0, r = Number.POSITIVE_INFINITY, n = 0;
                const i = at(t1.x, t1.y);
                for(let t1 = 0; t1 < this.edges.length; t1++){
                    const s = this.edges[t1], o = this.edgeProps[t1].dir, a = new Vu(i, this.edgeProps[t1].dir), l = this.vertices[s.a].position, u = this.vertices[s.b].position, c = ot(), h = ot(), p = a.intersectsPlane(l, this.vertexProps[s.a].dir, c), d = a.intersectsPlane(u, this.vertexProps[s.b].dir, h);
                    if (!p || !d) continue;
                    const f = ut(ot(), h, c), m = ut(ot(), i, c), y = dt(f, f), g = y > 0 ? dt(m, f) / y : 0, x = zt(g, 0, 1), v = Math.abs((g - x) * this.edgeProps[t1].len), b = ut(ot(), i, l), w = v + Math.abs(dt(b, at(o[1], -o[0])));
                    w < r && (e = t1, r = w, n = x);
                }
                return [
                    e,
                    n
                ];
            }
            tessellate(t1) {
                for(let e = this.edges.length - 1; e >= 0; --e){
                    const r = this.edges[e].a, n = this.edges[e].b, { position: i, height: s, extent: o } = this.vertices[r], { position: a, height: l, extent: u } = this.vertices[n], c = this.vertexProps[r].dir, h = this.vertexProps[n].dir, p = A(i[0] / t1, i[1] / t1, s), d = A(a[0] / t1, a[1] / t1, l), f = A(c[1], -c[0], 0);
                    z(f, f, o);
                    const m = A(h[1], -h[0], 0);
                    if (z(m, m, u), this.distSqLines(A(p[0] + .5 * f[0], p[1] + .5 * f[1], p[2] + .5 * f[2]), A(d[0] - .5 * m[0], d[1] - .5 * m[1], d[2] - .5 * m[2]), A(p[0] - .5 * f[0], p[1] - .5 * f[1], p[2] - .5 * f[2]), A(d[0] + .5 * m[0], d[1] + .5 * m[1], d[2] + .5 * m[2])) <= .0025000000000000005) continue;
                    const y = this.vertices.length, g = lt(ot(), i, a);
                    this.vertices.push({
                        position: ct(g, g, .5),
                        height: .5 * (s + l),
                        extent: .5 * (o + u)
                    });
                    const x = lt(ot(), c, h);
                    this.vertexProps.push({
                        dir: pt(x, x)
                    }), this.edges.splice(e, 1), this.edgeProps.splice(e, 1), this.edges.push({
                        a: r,
                        b: y
                    }), this.edges.push({
                        a: y,
                        b: n
                    });
                    const v = ut(ot(), this.vertices[y].position, i), b = ht(v), w = {
                        vec: v,
                        dir: ct(ot(), v, 1 / b),
                        len: b
                    };
                    this.edgeProps.push(w), this.edgeProps.push(w);
                }
            }
            distSqLines(t1, e, r, n) {
                const i = S(b(), e, t1), s = S(b(), n, r), o = S(b(), t1, r), a = D(i, i), l = D(i, s), u = D(i, o), c = D(s, s), h = D(s, o), p = a * c - l * l;
                if (0 === p) {
                    const e = D(o, s) / D(s, s);
                    return B(R(b(), r, n, e), t1);
                }
                const d = (l * h - u * c) / p, f = (a * h - l * u) / p;
                return B(R(b(), t1, e, d), R(b(), r, n, f));
            }
        }
        class Gu {
            static parseFrom(t1, e) {
                const r = Bu.parse(t1);
                if (!r) return [];
                let { vertices: n, features: i } = r;
                const s = 1 / lu(e);
                i.sort((t1, e)=>t1.id - e.id), n.sort((t1, e)=>t1.id - e.id || t1.idx - e.idx), n = n.filter((t1, e, r)=>e === r.findIndex((e)=>e.id === t1.id && e.idx === t1.idx));
                const o = new Array;
                let a = 0;
                const l = n.length;
                for (const t1 of i){
                    if (t1.constantHeight) {
                        o.push(new $u(t1.id, t1.bounds, t1.constantHeight));
                        continue;
                    }
                    for(; a !== l && n[a].id < t1.id;)a++;
                    if (a === l || n[a].id !== t1.id) continue;
                    const e = new Array, r = new Array, i = a;
                    for(; a !== l && n[a].id === t1.id;){
                        const t1 = n[a];
                        if (e.push({
                            position: t1.position,
                            height: t1.height,
                            extent: t1.extent
                        }), a !== i && n[a - 1].idx === t1.idx - 1) {
                            const t1 = a - i;
                            r.push({
                                a: t1 - 1,
                                b: t1
                            });
                        }
                        a++;
                    }
                    o.push(new $u(t1.id, t1.bounds, void 0, e, r, s));
                }
                return o;
            }
            static getElevationFeature(t1, e) {
                if (!e) return;
                const r = +t1.properties[Su];
                return Number.isNaN(r) ? void 0 : e.find((t1)=>t1.id === r);
            }
        }
        class Hu {
            constructor(t1, e){
                this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t1.equals(e) || (this.zScale = Math.pow(2, e.z - t1.z), this.xOffset = (t1.x * this.zScale - e.x) * Cn, this.yOffset = (t1.y * this.zScale - e.y) * Cn);
            }
            constantElevation(t1, e) {
                if (null != t1.constantHeight) return this.computeBiasedHeight(t1.constantHeight, e);
            }
            pointElevation(t1, e, r) {
                const n = this.constantElevation(e, r);
                return null != n ? n : (t1.x = t1.x * this.zScale + this.xOffset, t1.y = t1.y * this.zScale + this.yOffset, this.computeBiasedHeight(e.pointElevation(t1), r));
            }
            computeBiasedHeight(t1, e) {
                return e <= 0 ? t1 : t1 + e * Tt(0, e, t1 >= 0 ? t1 : Math.abs(.5 * t1));
            }
        }
        qs($u, "ElevationFeature");
        class qu {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new na, this.indexArray = new Ma, this.segments = new el, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.elevationMode = this.layers[0].layout.get("circle-elevation-reference"), this.hasElevation = !1, "none" !== this.elevationMode && (this.elevatedLayoutVertexArray = new oa), this.worldview = t1.worldview;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                const i = this.layers[0], s = [];
                let o = null;
                "circle" === i.type && (o = i.layout.get("circle-sort-key"));
                for (const { feature: e, id: i, index: a, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = xu(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), u, r)) continue;
                    const c = o ? o.evaluate(u, {}, r) : void 0, h = {
                        id: i,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: a,
                        geometry: t1 ? u.geometry : gu(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                o && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                let a = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new fa, a = n.projection);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: o } = n, l = t1[s].feature;
                    this.addFeature(n, i, s, e.availableImages, r, a, e.brightness, e.elevationFeatures), e.featureIndex.insert(l, i, s, o, this.index);
                }
                this.hasElevation || (this.elevatedLayoutVertexArray = void 0);
            }
            update(t1, e, r, n, i, s, o) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, this.worldview);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Ja.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, tl.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = t1.createVertexBuffer(this.elevatedLayoutVertexArray, Qa.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy());
            }
            addFeature(t1, e, r, n, i, s, o, a) {
                let l;
                "none" !== this.elevationMode && (l = Gu.getElevationFeature(t1, a));
                for (const r of e)for (const e of r){
                    const r = e.x, n = e.y;
                    if (r < 0 || r >= Cn || n < 0 || n >= Cn) continue;
                    if (s) {
                        const t1 = s.projectTilePoint(r, n, i), e = s.upVector(i, r, n);
                        this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e), this.addGlobeExtVertex(t1, e);
                    }
                    const o = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), a = o.vertexLength;
                    if (this.addCircleVertex(r, n, -1, -1), this.addCircleVertex(r, n, 1, -1), this.addCircleVertex(r, n, 1, 1), this.addCircleVertex(r, n, -1, 1), "none" !== this.elevationMode) {
                        const t1 = l ? l.pointElevation(new bt(r, n)) : 0;
                        this.hasElevation = this.hasElevation || 0 !== t1;
                        for(let e = 0; e < 4; e++)this.elevatedLayoutVertexArray.emplaceBack(t1);
                    }
                    this.indexArray.emplaceBack(a, a + 1, a + 2), this.indexArray.emplaceBack(a, a + 2, a + 3), o.vertexLength += 4, o.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i, o, void 0, this.worldview);
            }
            addCircleVertex(t1, e, r, n) {
                this.layoutVertexArray.emplaceBack(2 * t1 + (r + 1) / 2, 2 * e + (n + 1) / 2);
            }
            addGlobeExtVertex(t1, e) {
                const r = 16384;
                this.globeExtVertexArray.emplaceBack(t1.x, t1.y, t1.z, e[0] * r, e[1] * r, e[2] * r);
            }
        }
        function Xu(t1, e) {
            for(let r = 0; r < t1.length; r++)if (ic(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (ic(t1, e[r])) return !0;
            return !!Ku(t1, e);
        }
        function Zu(t1, e, r) {
            return !!ic(t1, e) || !!ec(e, t1, r);
        }
        function Wu(t1, e) {
            if (1 === t1.length) return nc(e, t1[0]);
            for(let r = 0; r < e.length; r++){
                const n = e[r];
                for(let e = 0; e < n.length; e++)if (ic(t1, n[e])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (nc(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (Ku(t1, e[r])) return !0;
            return !1;
        }
        function Yu(t1, e, r) {
            if (t1.length > 1) {
                if (Ku(t1, e)) return !0;
                for(let n = 0; n < e.length; n++)if (ec(e[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (ec(t1[n], e, r)) return !0;
            return !1;
        }
        function Ku(t1, e) {
            if (0 === t1.length || 0 === e.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e.length - 1; t1++)if (Ju(n, i, e[t1], e[t1 + 1])) return !0;
            }
            return !1;
        }
        function Ju(t1, e, r, n) {
            return Ht(t1, r, n) !== Ht(e, r, n) && Ht(t1, e, r) !== Ht(t1, e, n);
        }
        function Qu(t1, e, r) {
            return (t1.x - r.x) * (e.y - r.y) - (t1.y - r.y) * (e.x - r.x);
        }
        function tc(t1, e, r, n) {
            const i = Qu(t1, e, n), s = Qu(t1, e, r);
            if (Math.sign(i) === Math.sign(s)) return;
            const o = Qu(r, n, t1), a = o + s - i;
            return Math.sign(o) !== Math.sign(a) ? [
                o / (o - a),
                s / (s - i)
            ] : void 0;
        }
        function ec(t1, e, r) {
            const n = r * r;
            if (1 === e.length) return t1.distSqr(e[0]) < n;
            for(let r = 1; r < e.length; r++)if (rc(t1, e[r - 1], e[r]) < n) return !0;
            return !1;
        }
        function rc(t1, e, r) {
            const n = e.distSqr(r);
            if (0 === n) return t1.distSqr(e);
            const i = ((t1.x - e.x) * (r.x - e.x) + (t1.y - e.y) * (r.y - e.y)) / n;
            return t1.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
        }
        function nc(t1, e) {
            let r, n, i, s = !1;
            for(let o = 0; o < t1.length; o++){
                r = t1[o];
                for(let t1 = 0, o = r.length - 1; t1 < r.length; o = t1++)n = r[t1], i = r[o], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s;
        }
        function ic(t1, e) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const s = t1[n], o = t1[i];
                s.y > e.y != o.y > e.y && e.x < (o.x - s.x) * (e.y - s.y) / (o.y - s.y) + s.x && (r = !r);
            }
            return r;
        }
        function sc(t1, e, r, n, i) {
            for (const s of t1)if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
            const s = [
                new bt(e, r),
                new bt(e, i),
                new bt(n, i),
                new bt(n, r)
            ];
            if (t1.length > 2) {
                for (const e of s)if (ic(t1, e)) return !0;
            }
            for(let e = 0; e < t1.length - 1; e++)if (oc(t1[e], t1[e + 1], s)) return !0;
            return !1;
        }
        function oc(t1, e, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e.x < n.x || t1.x > i.x && e.x > i.x || t1.y < n.y && e.y < n.y || t1.y > i.y && e.y > i.y) return !1;
            const s = Ht(t1, e, r[0]);
            return s !== Ht(t1, e, r[1]) || s !== Ht(t1, e, r[2]) || s !== Ht(t1, e, r[3]);
        }
        function ac(t1, e, r, n, i, s) {
            let o = e.y - t1.y, a = t1.x - e.x;
            if (s = s || 0) {
                const t1 = o * o + a * a;
                if (0 === t1) return !0;
                const e = Math.sqrt(t1);
                o /= e, a /= e;
            }
            return !((r.x - t1.x) * o + (r.y - t1.y) * a - s < 0 || (n.x - t1.x) * o + (n.y - t1.y) * a - s < 0 || (i.x - t1.x) * o + (i.y - t1.y) * a - s < 0);
        }
        function lc(t1, e, r, n, i, s, o) {
            return !(ac(t1, e, n, i, s, o) || ac(e, r, n, i, s, o) || ac(r, t1, n, i, s, o) || ac(n, i, t1, e, r, o) || ac(i, s, t1, e, r, o) || ac(s, n, t1, e, r, o));
        }
        function uc(t1, e, r) {
            const n = e.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t1);
        }
        function cc(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function hc(t1, e, r, n, i) {
            if (!e[0] && !e[1]) return t1;
            const s = bt.convert(e)._mult(i);
            "viewport" === r && s._rotate(-n);
            const o = [];
            for(let e = 0; e < t1.length; e++)o.push(t1[e].sub(s));
            return o;
        }
        function pc(t1, e, r, n) {
            const i = bt.convert(t1)._mult(n);
            return "viewport" === e && i._rotate(-r), i;
        }
        let dc, fc;
        function mc(t1, e, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [
                t1 * n - 2 * Math.PI * 6378137 / 2,
                e * n - 2 * Math.PI * 6378137 / 2
            ];
        }
        qs(qu, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        class yc {
            constructor(t1, e, r){
                this.z = t1, this.x = e, this.y = r, this.key = vc(0, t1, t1, e, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            isChildOf(t1) {
                const e = this.z - t1.z;
                return 0 === t1.z || t1.z < this.z && t1.x === this.x >> e && t1.y === this.y >> e;
            }
            url(t1, e) {
                const r = function(t1, e, r) {
                    var n = mc(256 * t1, 256 * (e = Math.pow(2, r) - e - 1), r), i = mc(256 * (t1 + 1), 256 * (e + 1), r);
                    return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
                }(this.x, this.y, this.z), n = function(t1, e, r) {
                    let n, i = "";
                    for(let s = t1; s > 0; s--)n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class gc {
            constructor(t1, e){
                this.wrap = t1, this.canonical = e, this.key = vc(t1, e.z, e.z, e.x, e.y);
            }
        }
        class xc {
            constructor(t1, e, r, n, i){
                this.overscaledZ = t1, this.wrap = e, this.canonical = new yc(r, +n, +i), this.key = 0 === e && t1 === r ? this.canonical.key : vc(e, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e = this.canonical.z - t1;
                return t1 > this.canonical.z ? new xc(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new xc(t1, this.wrap, t1, this.canonical.x >> e, this.canonical.y >> e);
            }
            calculateScaledKey(t1, e = !0) {
                if (this.overscaledZ === t1 && e) return this.key;
                if (t1 > this.canonical.z) return vc(this.wrap * +e, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return vc(this.wrap * +e, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.z < this.canonical.z && t1.canonical.x === this.canonical.x >> e && t1.canonical.y === this.canonical.y >> e;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new xc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new xc(e, this.wrap, e, r, n),
                    new xc(e, this.wrap, e, r + 1, n),
                    new xc(e, this.wrap, e, r, n + 1),
                    new xc(e, this.wrap, e, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new xc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new xc(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new gc(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function vc(t1, e, r, n, i) {
            const s = 1 << Math.min(r, 22);
            let o = s * (i % s) + n % s;
            return t1 && r < 22 && (o += s * s * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * o + r) + (e - r);
        }
        const bc = [
            (t1)=>{
                let e = t1.canonical.x - 1, r = t1.wrap;
                return e < 0 && (e = (1 << t1.canonical.z) - 1, r--), new xc(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>{
                let e = t1.canonical.x + 1, r = t1.wrap;
                return e === 1 << t1.canonical.z && (e = 0, r++), new xc(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>new xc(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
            (t1)=>new xc(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
        ];
        qs(yc, "CanonicalTileID"), qs(xc, "OverscaledTileID", {
            omit: [
                "projMatrix",
                "expandedProjMatrix"
            ]
        });
        const wc = ea([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: _c } = wc, Ac = ea([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var Mc = ea([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function Ic(t1) {
            return t1 * Fl / Hl;
        }
        const Sc = [
            new Nu([
                Nl,
                Nl,
                Nl
            ], [
                jl,
                jl,
                jl
            ]),
            new Nu([
                Nl,
                Nl,
                Nl
            ], [
                0,
                0,
                jl
            ]),
            new Nu([
                0,
                Nl,
                Nl
            ], [
                jl,
                0,
                jl
            ]),
            new Nu([
                Nl,
                0,
                Nl
            ], [
                0,
                jl,
                jl
            ]),
            new Nu([
                0,
                0,
                Nl
            ], [
                jl,
                jl,
                jl
            ])
        ];
        function Pc(t1, e, r, n = !0) {
            const i = z([], t1._camera.position, t1.worldSize), s = [
                e,
                r,
                1,
                1
            ];
            Y(s, s, t1.pixelMatrixInverse), Z(s, s, 1 / s[3]);
            const o = F([], G([], s, i)), a = t1.globeMatrix, l = [
                a[12],
                a[13],
                a[14]
            ], u = G([], l, i), c = _(u), h = F([], u), p = t1.worldSize / (2 * Math.PI), d = D(h, o), f = Math.asin(p / c);
            if (f < Math.acos(d)) {
                if (!n) return null;
                const t1 = [], e = [];
                z(t1, o, c / d), F(e, G(e, t1, u)), F(o, I(o, u, z(o, e, Math.tan(f) * c)));
            }
            const m = [];
            new Cu(i, o).closestPointOnSphere(l, p, m);
            const y = F([], Kt(a, 0)), g = F([], Kt(a, 1)), x = F([], Kt(a, 2)), v = D(y, m), b = D(g, m), w = D(x, m), A = It(Math.asin(-b / p));
            let M = It(Math.atan2(v, w));
            M = t1.center.lng + function(t1, e) {
                const r = (e - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(t1.center.lng, M);
            const S = Jl(M), P = zt(Ql(A), 0, 1);
            return new uu(S, P);
        }
        class Ec {
            constructor(t1, e, r){
                this.a = G([], t1, r), this.b = G([], e, r), this.center = r;
                const n = F([], this.a), i = F([], this.b);
                this.angle = Math.acos(D(n, i));
            }
        }
        function kc(t1, e) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e] / t1.a[e] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
            }(t1.a[e], t1.b[e], t1.angle, zt(r, 0, 1)) + t1.center[e];
        }
        function zc(t1) {
            if (t1.z <= 1) return Sc[t1.z + 2 * t1.y + t1.x];
            const e = Fc(Cc(t1));
            return Nu.fromPoints(e);
        }
        function Tc(t1, e, r) {
            return z(t1, t1, 1 - r), T(t1, t1, e, r);
        }
        function Bc(t1, e, r) {
            for (const n of t1)O(n, n, e), z(n, n, r);
        }
        function Vc(t1, e, r, n) {
            const i = e / t1.worldSize, s = t1.globeMatrix;
            if (r.z <= 1) {
                const t1 = zc(r).getCorners();
                return Bc(t1, s, i), Nu.fromPoints(t1);
            }
            const o = Cc(r, n), a = Fc(o, Fl + Ic(t1._tileCoverLift));
            Bc(a, s, i);
            const l = Number.MAX_VALUE, u = [
                -l,
                -l,
                -l
            ], c = [
                l,
                l,
                l
            ];
            if (o.contains(t1.center)) {
                for (const t1 of a)E(c, c, t1), k(u, u, t1);
                u[2] = 0;
                const e = t1.point, r = [
                    e.x * i,
                    e.y * i,
                    0
                ];
                return E(c, c, r), k(u, u, r), new Nu(c, u);
            }
            if (t1._tileCoverLift > 0) {
                for (const t1 of a)E(c, c, t1), k(u, u, t1);
                return new Nu(c, u);
            }
            const h = [
                s[12] * i,
                s[13] * i,
                s[14] * i
            ], p = o.getCenter(), d = zt(t1.center.lat, -iu, iu), f = zt(p.lat, -iu, iu), m = Jl(t1.center.lng), y = Ql(d);
            let g = m - Jl(p.lng);
            const x = y - Ql(f);
            g > .5 ? g -= 1 : g < -.5 && (g += 1);
            let v = 0;
            Math.abs(g) > Math.abs(x) ? v = g >= 0 ? 1 : 3 : (v = x >= 0 ? 0 : 2, T(h, h, [
                s[4] * i,
                s[5] * i,
                s[6] * i
            ], -Math.sin(Mt(x >= 0 ? o.getSouth() : o.getNorth())) * Fl));
            const b = a[v], w = a[(v + 1) % 4], _ = new Ec(b, w, h), A = [
                kc(_, 0) || b[0],
                kc(_, 1) || b[1],
                kc(_, 2) || b[2]
            ], M = Gc(t1.zoom);
            if (M > 0) {
                const n = function({ x: t1, y: e, z: r }, n, i, s, o) {
                    const a = 1 / (1 << r);
                    let l = t1 * a, u = l + a, c = e * a, h = c + a, p = 0;
                    const d = (l + u) / 2 - s;
                    return d > .5 ? p = -1 : d < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (o *= n)) * i + o, h = (h * n - o) * i + o, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(r, e, t1._pixelsPerMercatorPixel, m, y);
                for(let t1 = 0; t1 < a.length; t1++)Tc(a[t1], n[t1], M);
                const i = I([], n[v], n[(v + 1) % 4]);
                z(i, i, .5), Tc(A, i, M);
            }
            for (const t1 of a)E(c, c, t1), k(u, u, t1);
            return c[2] = Math.min(b[2], w[2]), E(c, c, A), k(u, u, A), new Nu(c, u);
        }
        function Cc({ x: t1, y: e, z: r }, n = !1) {
            const i = 1 / (1 << r), s = new Xl(eu(t1 * i), e === (1 << r) - 1 && n ? -90 : ru((e + 1) * i)), o = new Xl(eu((t1 + 1) * i), 0 === e && n ? 90 : ru(e * i));
            return new Zl(s, o);
        }
        function Fc(t1, e = Fl) {
            const r = Mt(t1.getNorth()), n = Mt(t1.getSouth()), i = Math.cos(r), s = Math.cos(n), o = Math.sin(r), a = Math.sin(n), l = t1.getWest(), u = t1.getEast();
            return [
                $l(s, a, l, e),
                $l(s, a, u, e),
                $l(i, o, u, e),
                $l(i, o, l, e)
            ];
        }
        function Dc(t1, e, r, n) {
            const i = 1 << r.z, s = (t1 / Cn + r.x) / i;
            return Gl(ru((e / Cn + r.y) / i), eu(s), n);
        }
        function Lc({ min: t1, max: e }) {
            return Rl / Math.max(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }
        const Rc = new Float64Array(16);
        function Oc(t1) {
            const e = Lc(t1), r = y(Rc, [
                e,
                e,
                e
            ]);
            return h(r, r, C([], t1.min));
        }
        function Uc(t1) {
            const e = (n = t1.min, (r = Rc)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);
            var r, n;
            const i = 1 / Lc(t1);
            return p(e, e, [
                i,
                i,
                i
            ]);
        }
        function Nc(t1) {
            const e = Cn / (2 * Math.PI);
            return t1 / (2 * Math.PI) / e;
        }
        function jc(t1, e) {
            return Cn / (512 * Math.pow(2, t1)) * Lc(zc(e));
        }
        function $c(t1, e, r, n, i) {
            const s = Nc(r), o = [
                t1,
                e,
                -r / (2 * Math.PI)
            ], a = l(new Float64Array(16));
            return h(a, a, o), p(a, a, [
                s,
                s,
                s
            ]), d(a, a, Mt(-i)), f(a, a, Mt(-n)), a;
        }
        function Gc(t1) {
            return Tt(Dl, Ll, t1);
        }
        function Hc(t1, e) {
            const r = Gl(e.lat, e.lng), n = function(t1) {
                const e = Gl(t1._center.lat, t1._center.lng);
                let r = L([], A(0, 1, 0), e);
                const n = g([], -t1.angle, e);
                r = O(r, r, n), g(n, -t1._pitch, r);
                const i = F([], e);
                return z(i, i, Ic(t1.cameraToCenterDistance / t1.pixelsPerMeter)), O(i, i, n), I([], e, i);
            }(t1);
            return o = (i = S([], n, r))[0], a = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], d = (p = Math.sqrt(o * o + a * a + l * l) * Math.sqrt(u * u + c * c + h * h)) && D(i, s) / p, Math.acos(Math.min(Math.max(d, -1), 1));
            //TURBOPACK unreachable
            ;
            var i, s, o, a, l, u, c, h, p, d;
        }
        function qc(t1, e) {
            return Hc(t1, e) > Math.PI / 2 * 1.01;
        }
        const Xc = Mt(85), Zc = Math.cos(Xc), Wc = Math.sin(Xc), Yc = a(), Kc = (t1)=>{
            const e = [];
            return "map" === t1.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"), "map" === t1.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"), e;
        };
        function Jc(t1, e, r, n, i, s, o, a, l) {
            if (s && t1.queryGeometry.isAboveHorizon) return !1;
            s && (l *= t1.pixelToTileUnitsFactor);
            const u = t1.tileID.canonical, c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e)for (const e of h){
                const h = e.add(a), p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, d = r.projection.projectTilePoint(h.x, h.y, u);
                if (p > 0) {
                    const t1 = r.projection.upVector(u, h.x, h.y);
                    d.x += t1[0] * c * p, d.y += t1[1] * c * p, d.z += t1[2] * c * p;
                }
                const f = s ? h : Qc(d.x, d.y, d.z, n), m = s ? t1.tilespaceRays.map((t1)=>rh(t1, p)) : t1.queryGeometry.screenGeometry, y = Y([], [
                    d.x,
                    d.y,
                    d.z,
                    1
                ], n);
                if (!o && s ? l *= y[3] / r.cameraToCenterDistance : o && !s && (l *= r.cameraToCenterDistance / y[3]), s) {
                    const t1 = ru((e.y / Cn + u.y) / (1 << u.z));
                    l /= r.projection.pixelsPerMeter(t1, 1) / tu(1, t1);
                }
                if (Zu(m, f, l)) return !0;
            }
            return !1;
        }
        function Qc(t1, e, r, n) {
            const i = Y([], [
                t1,
                e,
                r,
                1
            ], n);
            return new bt(i[0] / i[3], i[1] / i[3]);
        }
        const th = A(0, 0, 0), eh = A(0, 0, 1);
        function rh(t1, e) {
            const r = b();
            return th[2] = e, t1.intersectsPlane(th, eh, r), new bt(r[0], r[1]);
        }
        class nh extends qu {
        }
        let ih, sh, oh, ah;
        function lh(t1, { width: e, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e * r * n);
            return t1.width = e, t1.height = r, t1.data = i, t1;
        }
        function uh(t1, e, r) {
            const { width: n, height: i } = e;
            n === t1.width && i === t1.height || (ch(t1, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r, null), t1.width = n, t1.height = i, t1.data = e.data);
        }
        function ch(t1, e, r, n, i, s, o, a) {
            if (0 === i.width || 0 === i.height) return e;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const l = t1.data, u = e.data, c = 4 === s && a;
            for(let a = 0; a < i.height; a++){
                const h = ((r.y + a) * t1.width + r.x) * s, p = ((n.y + a) * e.width + n.x) * s;
                if (c) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s + 3, r = p + t1 * s;
                    u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];
                }
                else if (o) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s, r = p + t1 * s, n = new sr(l[e + 0] / 255, l[e + 1] / 255, l[e + 2] / 255, l[e + 3]).toNonPremultipliedRenderColor(o).toArray();
                    u[r + 0] = n[0], u[r + 1] = n[1], u[r + 2] = n[2], u[r + 3] = n[3];
                }
                else for(let t1 = 0; t1 < i.width * s; t1++)u[p + t1] = l[h + t1];
            }
            return e;
        }
        qs(nh, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class hh {
            constructor(t1, e){
                lh(this, t1, 1, e);
            }
            resize(t1) {
                uh(this, new hh(t1), 1);
            }
            clone() {
                return new hh({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i) {
                ch(t1, e, r, n, i, 1, null);
            }
        }
        class ph {
            constructor(t1, e){
                lh(this, t1, 4, e);
            }
            resize(t1) {
                uh(this, new ph(t1), 4);
            }
            replace(t1, e) {
                e ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new ph({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i, s, o) {
                ch(t1, e, r, n, i, 4, s, o);
            }
        }
        class dh {
            constructor(t1, e){
                this.width = t1.width, this.height = t1.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;
            }
        }
        function fh(t1) {
            const e = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new ph({
                width: r,
                height: n
            }), s = (r, n, s)=>{
                e[t1.evaluationKey] = s;
                const o = t1.expression.evaluate(e), a = o ? o.toNonPremultipliedRenderColor(null) : null;
                a && (i.data[r + n + 0] = Math.floor(255 * a.r), i.data[r + n + 1] = Math.floor(255 * a.g), i.data[r + n + 2] = Math.floor(255 * a.b), i.data[r + n + 3] = Math.floor(255 * a.a));
            };
            if (t1.clips) for(let e = 0, i = 0; e < n; ++e, i += 4 * r)for(let n = 0, o = 0; n < r; n++, o += 4){
                const a = n / (r - 1), { start: l, end: u } = t1.clips[e];
                s(i, o, l * (1 - a) + u * a);
            }
            else for(let t1 = 0, e = 0; t1 < r; t1++, e += 4)s(0, e, t1 / (r - 1));
            return i;
        }
        qs(hh, "AlphaImage"), qs(ph, "RGBAImage");
        const mh = ea([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), yh = ea([
            {
                name: "a_road_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), gh = ea([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_height",
                components: 1,
                type: "Float32"
            }
        ], 4), xh = ea([
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ], 4);
        function vh(t1, e, r = 2) {
            const n = e && e.length, i = n ? e[0] * r : t1.length;
            let s = bh(t1, 0, i, r, !0);
            const o = [];
            if (!s || s.next === s.prev) return o;
            let a, l, u;
            if (n && (s = function(t1, e, r, n) {
                const i = [];
                for(let r = 0, s = e.length; r < s; r++){
                    const o = bh(t1, e[r] * n, r < s - 1 ? e[r + 1] * n : t1.length, n, !1);
                    o === o.next && (o.steiner = !0), i.push(Th(o));
                }
                i.sort(Ph);
                for(let t1 = 0; t1 < i.length; t1++)r = Eh(i[t1], r);
                return r;
            }(t1, e, s, r)), t1.length > 80 * r) {
                a = t1[0], l = t1[1];
                let e = a, n = l;
                for(let s = r; s < i; s += r){
                    const r = t1[s], i = t1[s + 1];
                    r < a && (a = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);
                }
                u = Math.max(e - a, n - l), u = 0 !== u ? 32767 / u : 0;
            }
            return _h(s, o, r, a, l, u, 0), o;
        }
        function bh(t1, e, r, n, i) {
            let s;
            if (i === function(t1, e, r, n) {
                let i = 0;
                for(let s = e, o = r - n; s < r; s += n)i += (t1[o] - t1[s]) * (t1[s + 1] + t1[o + 1]), o = s;
                return i;
            }(t1, e, r, n) > 0) for(let i = e; i < r; i += n)s = jh(i / n | 0, t1[i], t1[i + 1], s);
            else for(let i = r - n; i >= e; i -= n)s = jh(i / n | 0, t1[i], t1[i + 1], s);
            return s && Dh(s, s.next) && ($h(s), s = s.next), s;
        }
        function wh(t1, e) {
            if (!t1) return t1;
            e || (e = t1);
            let r, n = t1;
            do {
                if (r = !1, n.steiner || !Dh(n, n.next) && 0 !== Fh(n.prev, n, n.next)) n = n.next;
                else {
                    if ($h(n), n = e = n.prev, n === n.next) break;
                    r = !0;
                }
            }while (r || n !== e)
            return e;
        }
        function _h(t1, e, r, n, i, s, o) {
            if (!t1) return;
            !o && s && function(t1, e, r, n) {
                let i = t1;
                do {
                    0 === i.z && (i.z = zh(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                }while (i !== t1)
                i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                    let e, r = 1;
                    do {
                        let n, i = t1;
                        t1 = null;
                        let s = null;
                        for(e = 0; i;){
                            e++;
                            let o = i, a = 0;
                            for(let t1 = 0; t1 < r && (a++, o = o.nextZ, o); t1++);
                            let l = r;
                            for(; a > 0 || l > 0 && o;)0 !== a && (0 === l || !o || i.z <= o.z) ? (n = i, i = i.nextZ, a--) : (n = o, o = o.nextZ, l--), s ? s.nextZ = n : t1 = n, n.prevZ = s, s = n;
                            i = o;
                        }
                        s.nextZ = null, r *= 2;
                    }while (e > 1)
                }(i);
            }(t1, n, i, s);
            let a = t1;
            for(; t1.prev !== t1.next;){
                const l = t1.prev, u = t1.next;
                if (s ? Mh(t1, n, i, s) : Ah(t1)) e.push(l.i, t1.i, u.i), $h(t1), t1 = u.next, a = u.next;
                else if ((t1 = u) === a) {
                    o ? 1 === o ? _h(t1 = Ih(wh(t1), e), e, r, n, i, s, 2) : 2 === o && Sh(t1, e, r, n, i, s) : _h(wh(t1), e, r, n, i, s, 1);
                    break;
                }
            }
        }
        function Ah(t1) {
            const e = t1.prev, r = t1, n = t1.next;
            if (Fh(e, r, n) >= 0) return !1;
            const i = e.x, s = r.x, o = n.x, a = e.y, l = r.y, u = n.y, c = Math.min(i, s, o), h = Math.min(a, l, u), p = Math.max(i, s, o), d = Math.max(a, l, u);
            let f = n.next;
            for(; f !== e;){
                if (f.x >= c && f.x <= p && f.y >= h && f.y <= d && Vh(i, a, s, l, o, u, f.x, f.y) && Fh(f.prev, f, f.next) >= 0) return !1;
                f = f.next;
            }
            return !0;
        }
        function Mh(t1, e, r, n) {
            const i = t1.prev, s = t1, o = t1.next;
            if (Fh(i, s, o) >= 0) return !1;
            const a = i.x, l = s.x, u = o.x, c = i.y, h = s.y, p = o.y, d = Math.min(a, l, u), f = Math.min(c, h, p), m = Math.max(a, l, u), y = Math.max(c, h, p), g = zh(d, f, e, r, n), x = zh(m, y, e, r, n);
            let v = t1.prevZ, b = t1.nextZ;
            for(; v && v.z >= g && b && b.z <= x;){
                if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== o && Vh(a, c, l, h, u, p, v.x, v.y) && Fh(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== o && Vh(a, c, l, h, u, p, b.x, b.y) && Fh(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== o && Vh(a, c, l, h, u, p, v.x, v.y) && Fh(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== o && Vh(a, c, l, h, u, p, b.x, b.y) && Fh(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function Ih(t1, e) {
            let r = t1;
            do {
                const n = r.prev, i = r.next.next;
                !Dh(n, i) && Lh(n, r, r.next, i) && Uh(n, i) && Uh(i, n) && (e.push(n.i, r.i, i.i), $h(r), $h(r.next), r = t1 = i), r = r.next;
            }while (r !== t1)
            return wh(r);
        }
        function Sh(t1, e, r, n, i, s) {
            let o = t1;
            do {
                let t1 = o.next.next;
                for(; t1 !== o.prev;){
                    if (o.i !== t1.i && Ch(o, t1)) {
                        let a = Nh(o, t1);
                        return o = wh(o, o.next), a = wh(a, a.next), _h(o, e, r, n, i, s, 0), void _h(a, e, r, n, i, s, 0);
                    }
                    t1 = t1.next;
                }
                o = o.next;
            }while (o !== t1)
        }
        function Ph(t1, e) {
            let r = t1.x - e.x;
            return 0 === r && (r = t1.y - e.y, 0 === r) && (r = (t1.next.y - t1.y) / (t1.next.x - t1.x) - (e.next.y - e.y) / (e.next.x - e.x)), r;
        }
        function Eh(t1, e) {
            const r = function(t1, e) {
                let r = e;
                const n = t1.x, i = t1.y;
                let s, o = -1 / 0;
                if (Dh(t1, r)) return r;
                do {
                    if (Dh(t1, r.next)) return r.next;
                    if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
                        const t1 = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (t1 <= n && t1 > o && (o = t1, s = r.x < r.next.x ? r : r.next, t1 === n)) return s;
                    }
                    r = r.next;
                }while (r !== e)
                if (!s) return null;
                const a = s, l = s.x, u = s.y;
                let c = 1 / 0;
                r = s;
                do {
                    if (n >= r.x && r.x >= l && n !== r.x && Bh(i < u ? n : o, i, l, u, i < u ? o : n, i, r.x, r.y)) {
                        const e = Math.abs(i - r.y) / (n - r.x);
                        Uh(r, t1) && (e < c || e === c && (r.x > s.x || r.x === s.x && kh(s, r))) && (s = r, c = e);
                    }
                    r = r.next;
                }while (r !== a)
                return s;
            }(t1, e);
            if (!r) return e;
            const n = Nh(r, t1);
            return wh(n, n.next), wh(r, r.next);
        }
        function kh(t1, e) {
            return Fh(t1.prev, t1, e.prev) < 0 && Fh(e.next, t1, t1.next) < 0;
        }
        function zh(t1, e, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function Th(t1) {
            let e = t1, r = t1;
            do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
            }while (e !== t1)
            return r;
        }
        function Bh(t1, e, r, n, i, s, o, a) {
            return (i - o) * (e - a) >= (t1 - o) * (s - a) && (t1 - o) * (n - a) >= (r - o) * (e - a) && (r - o) * (s - a) >= (i - o) * (n - a);
        }
        function Vh(t1, e, r, n, i, s, o, a) {
            return !(t1 === o && e === a) && Bh(t1, e, r, n, i, s, o, a);
        }
        function Ch(t1, e) {
            return t1.next.i !== e.i && t1.prev.i !== e.i && !function(t1, e) {
                let r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e.i && r.next.i !== e.i && Lh(r, r.next, t1, e)) return !0;
                    r = r.next;
                }while (r !== t1)
                return !1;
            }(t1, e) && (Uh(t1, e) && Uh(e, t1) && function(t1, e) {
                let r = t1, n = !1;
                const i = (t1.x + e.x) / 2, s = (t1.y + e.y) / 2;
                do {
                    r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                }while (r !== t1)
                return n;
            }(t1, e) && (Fh(t1.prev, t1, e.prev) || Fh(t1, e.prev, e)) || Dh(t1, e) && Fh(t1.prev, t1, t1.next) > 0 && Fh(e.prev, e, e.next) > 0);
        }
        function Fh(t1, e, r) {
            return (e.y - t1.y) * (r.x - e.x) - (e.x - t1.x) * (r.y - e.y);
        }
        function Dh(t1, e) {
            return t1.x === e.x && t1.y === e.y;
        }
        function Lh(t1, e, r, n) {
            const i = Oh(Fh(t1, e, r)), s = Oh(Fh(t1, e, n)), o = Oh(Fh(r, n, t1)), a = Oh(Fh(r, n, e));
            return i !== s && o !== a || !(0 !== i || !Rh(t1, r, e)) || !(0 !== s || !Rh(t1, n, e)) || !(0 !== o || !Rh(r, t1, n)) || !(0 !== a || !Rh(r, e, n));
        }
        function Rh(t1, e, r) {
            return e.x <= Math.max(t1.x, r.x) && e.x >= Math.min(t1.x, r.x) && e.y <= Math.max(t1.y, r.y) && e.y >= Math.min(t1.y, r.y);
        }
        function Oh(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function Uh(t1, e) {
            return Fh(t1.prev, t1, t1.next) < 0 ? Fh(t1, e, t1.next) >= 0 && Fh(t1, t1.prev, e) >= 0 : Fh(t1, e, t1.prev) < 0 || Fh(t1, t1.next, e) < 0;
        }
        function Nh(t1, e) {
            const r = Gh(t1.i, t1.x, t1.y), n = Gh(e.i, e.x, e.y), i = t1.next, s = e.prev;
            return t1.next = e, e.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }
        function jh(t1, e, r, n) {
            const i = Gh(t1, e, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function $h(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function Gh(t1, e, r) {
            return {
                i: t1,
                x: e,
                y: r,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1
            };
        }
        function Hh(t1, e) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, s;
            for(let e = 0; e < r; e++){
                const r = qt(t1[e]);
                0 !== r && (t1[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                    t1[e]
                ]) : i.push(t1[e]));
            }
            if (i && n.push(i), e > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e || (en(n[t1], e, 1, n[t1].length - 1, qh), n[t1] = n[t1].slice(0, e));
            return n;
        }
        function qh(t1, e) {
            return e.area - t1.area;
        }
        function Xh(t1, e, r = 1) {
            if (!t1) return null;
            const n = "string" == typeof t1 ? Dr.from(t1).getPrimary() : t1.getPrimary(), i = "string" == typeof t1 ? null : t1.getSecondary();
            for (const t1 of [
                n,
                i
            ]){
                if (!t1) continue;
                const n = t1.id.toString();
                e.has(n) || e.set(n, []), t1.scaleSelf(r), e.get(n).push(t1);
            }
            return {
                primary: n.toString(),
                secondary: i ? i.toString() : null
            };
        }
        function Zh(t1, e, r, n) {
            const i = n.patternDependencies;
            let s = !1;
            for (const n of e){
                const e = n.paint.get(`${t1}-pattern`);
                e.isConstant() || (s = !0), Xh(e.constantOr(null), i, r) && (s = !0);
            }
            return s;
        }
        function Wh(t1, e, r, n, i, s) {
            const o = s.patternDependencies;
            for (const a of e){
                const e = a.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t1 = e.evaluate({
                        zoom: n
                    }, r, {}, s.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1;
                    const l = Xh(t1, o, i);
                    if (!l) continue;
                    const { primary: u, secondary: c } = l;
                    u && (r.patterns[a.id] = [
                        u,
                        c
                    ].filter(Boolean));
                }
            }
            return r;
        }
        class Yh {
            constructor(){
                this.polygons = new Map;
            }
            add(t1, ...e) {
                this.polygons.has(t1) ? this.polygons.get(t1).push(...e) : this.polygons.set(t1, e);
            }
            merge(t1) {
                for (const [e, r] of t1.polygons)this.add(e, ...r);
            }
        }
        class Kh {
            constructor(){
                this.portals = [];
            }
            static evaluate(t1) {
                if (0 === t1.length) return new Kh;
                let e = [];
                for (const r of t1)e.push(...r.portals);
                if (0 === e.length) return new Kh;
                const r = (t1, e)=>t1 <= 0 && e <= 0 || t1 >= Cn && e >= Cn;
                for (const t1 of e){
                    const e = t1.va, n = t1.vb;
                    (r(e.x, n.x) || r(e.y, n.y)) && (t1.type = "border");
                }
                const n = e.filter((t1)=>"unevaluated" !== t1.type), i = e.filter((t1)=>"unevaluated" === t1.type);
                if (0 === i.length) return new Kh;
                i.sort((t1, e)=>t1.hash === e.hash ? t1.isTunnel === e.isTunnel ? 0 : t1.isTunnel ? -1 : 1 : t1.hash < e.hash ? 1 : -1), e = n.concat(i);
                let s = n.length, o = s, a = s;
                do {
                    if (o++, o === e.length || e[s].hash !== e[o].hash) {
                        if (o - s == 2) {
                            a < s && (e[a] = e[s], e[s] = null);
                            const t1 = e[a], r = e[o - 1];
                            t1.type = t1.isTunnel !== r.isTunnel ? "tunnel" : "polygon", t1.connection = {
                                a: t1.connection.a,
                                b: r.connection.a
                            }, a++;
                        }
                        s = o;
                    }
                }while (s !== e.length)
                return e.splice(a), e.sort((t1, e)=>t1.hash < e.hash ? 1 : -1), {
                    portals: e
                };
            }
        }
        qs(Kh, "ElevationPortalGraph"), qs(Yh, "ElevationPolygons");
        class Jh {
            constructor(t1, e, r){
                this.outPositions = t1, this.outNormals = e, this.outIndices = r, this.vertexLookup = new Map, this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer);
            }
            addVertex(t1, e, r) {
                let n = t1[2];
                null != r && (n *= r);
                const i = this.getVec3Bits(t1) << 96n | this.getVec3Bits(e), s = this.vertexLookup.get(i);
                if (null != s) return s;
                const o = this.outPositions.length;
                this.vertexLookup.set(i, o);
                const a = Math.trunc(16384 * e[0]), l = Math.trunc(16384 * e[1]), u = Math.trunc(16384 * e[2]);
                return this.outPositions.emplaceBack(t1[0], t1[1], n), this.outNormals.emplaceBack(a, l, u), o;
            }
            addTriangle(t1, e, r) {
                this.outIndices.emplaceBack(t1, e, r);
            }
            addTriangles(t1, e, r) {
                if (0 === t1.length) return;
                const n = 1 === r.length, i = b(), s = b();
                for(let o = 0; o < t1.length; o += 3){
                    const a = e[t1[o + 0]], l = e[t1[o + 1]], u = e[t1[o + 2]], c = n ? r[0] : r[t1[o + 1]], h = n ? r[0] : r[t1[o + 2]];
                    M(i, a.x, a.y, n ? r[0] : r[t1[o + 0]]);
                    const p = this.addVertex(i, s);
                    M(i, l.x, l.y, c);
                    const d = this.addVertex(i, s);
                    M(i, u.x, u.y, h);
                    const f = this.addVertex(i, s);
                    this.outIndices.emplaceBack(p, d, f);
                }
            }
            addQuad(t1, e, r, n, i, s) {
                const o = this.addVertex(t1, i, s), a = this.addVertex(e, i, s), l = this.addVertex(r, i, s), u = this.addVertex(n, i, s);
                this.addTriangle(o, a, l), this.addTriangle(l, u, o);
            }
            getVertexCount() {
                return this.outPositions.length;
            }
            clearVertexLookup() {
                this.vertexLookup.clear();
            }
            getBits(t1) {
                return this.view.setFloat32(0, t1), BigInt(this.view.getUint32(0));
            }
            getVec3Bits(t1) {
                return this.getBits(t1[0]) << 64n | this.getBits(t1[1]) << 32n | this.getBits(t1[2]);
            }
        }
        class Qh {
            constructor(t1, e, r, n){
                this.unevaluatedPortals = new Kh, this.portalPolygons = new Yh, this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = new Map, this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new aa, this.vertexNormals = new la, this.indexArray = new Ma, this.tileToMeters = lu(t1), this.bridgeProgramConfigurations = new kl(e, {
                    zoom: r,
                    lut: n
                }, (t1)=>"fill-tunnel-structure-color" !== t1), this.tunnelProgramConfigurations = new kl(e, {
                    zoom: r,
                    lut: n
                }, (t1)=>"fill-bridge-guard-rail-color" !== t1);
            }
            addVertices(t1, e) {
                const r = this.unevalVertices.length;
                for(let r = 0; r < t1.length; r++)this.unevalVertices.push(t1[r]), this.unevalHeights.push(e[r]);
                return r;
            }
            addTriangles(t1, e, r) {
                const n = r ? this.unevalTunnelTriangles : this.unevalTriangles;
                for (const r of t1)n.push(r + e);
            }
            addRenderableRing(t1, e, r, n, i, s) {
                const o = [
                    new bt(i.min.x, i.min.y),
                    new bt(i.max.x, i.min.y),
                    new bt(i.max.x, i.max.y),
                    new bt(i.min.x, i.max.y)
                ];
                for(let a = 0; a < r - 1; a++){
                    const r = e + a, l = r + 1, u = this.unevalVertices[r], c = this.unevalVertices[l];
                    if (!(u.x >= i.min.x && u.x <= i.max.x && u.y >= i.min.y && u.y <= i.max.y || c.x >= i.min.x && c.x <= i.max.x && c.y >= i.min.y && c.y <= i.max.y || oc(u, c, o))) continue;
                    if (this.isOnBorder(u.x, c.x) || this.isOnBorder(u.y, c.y)) continue;
                    const h = Qh.computeEdgeHash(this.unevalVertices[r], this.unevalVertices[l]);
                    let p, d = this.vertexHashLookup.get(Qh.computePosHash(u));
                    null != d ? p = d.next : (d = this.vertexHashLookup.get(Qh.computePosHash(c)), p = null != d ? d.prev : h), this.unevalEdges.push({
                        polygonIdx: t1,
                        a: r,
                        b: l,
                        hash: h,
                        portalHash: p,
                        isTunnel: n,
                        type: "unevaluated",
                        featureInfo: s
                    });
                }
            }
            addPortalCandidates(t1, e, r, n, i) {
                if (0 === e.length) return;
                this.portalPolygons.add(t1, {
                    geometry: e,
                    zLevel: i
                });
                const s = e[0];
                this.vertexHashLookup.clear();
                let o = Qh.computeEdgeHash(s[s.length - 2], s[s.length - 1]);
                for(let e = 0; e < s.length - 1; e++){
                    const i = s[e + 0], a = s[e + 1], l = at(a.x - i.x, a.y - i.y), u = ht(l);
                    if (0 === u) continue;
                    let c = "unevaluated";
                    const h = n.pointElevation(i), p = n.pointElevation(a);
                    Math.abs(h) < .01 && Math.abs(p) < .01 ? c = "entrance" : (this.isOnBorder(i.x, a.x) || this.isOnBorder(i.y, a.y)) && (c = "border");
                    const d = Qh.computeEdgeHash(i, a);
                    this.unevaluatedPortals.portals.push({
                        connection: {
                            a: t1,
                            b: void 0
                        },
                        va: i,
                        vb: a,
                        vab: l,
                        length: u,
                        hash: d,
                        isTunnel: r,
                        type: c
                    });
                    const f = Qh.computePosHash(i);
                    this.vertexHashLookup.set(f, {
                        prev: o,
                        next: d
                    }), o = d;
                }
            }
            construct(t1) {
                if (0 === this.unevalVertices.length) return;
                const e = ()=>({
                        vertexOffset: 0,
                        primitiveOffset: this.indexArray.length
                    }), r = (t1)=>{
                    t1.primitiveLength = this.indexArray.length - t1.primitiveOffset;
                }, n = new Jh(this.vertexPositions, this.vertexNormals, this.indexArray);
                this.prepareEdges(t1.portals, this.unevalEdges);
                const i = e(), s = e(), o = e(), a = (t1, e)=>{
                    t1.sort((t1, r)=>t1.type === e && r.type !== e ? -1 : t1.type !== e && r.type === e ? 1 : 0);
                    const r = t1.findIndex((t1)=>t1.type !== e);
                    return r >= 0 ? r : t1.length;
                };
                let l = 0;
                this.unevalEdges.length > 0 && (l = a(this.unevalEdges, "none"), this.constructBridgeStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                    min: 0,
                    max: l
                }, this.tileToMeters)), r(o);
                const u = e(), c = e();
                if (this.unevalEdges.length > 0) {
                    const t1 = this.unevalEdges.splice(l), e = a(t1, "tunnel") + l;
                    this.unevalEdges.push(...t1), this.constructTunnelStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                        min: 0,
                        max: l
                    }, {
                        min: l,
                        max: e
                    });
                }
                r(u), n.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r(c), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r(s), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [
                    -.1
                ]), r(i), this.maskSegments = el.simpleSegment(0, c.primitiveOffset, 0, c.primitiveLength), this.depthSegments = el.simpleSegment(0, s.primitiveOffset, 0, s.primitiveLength), this.renderableBridgeSegments = el.simpleSegment(0, o.primitiveOffset, 0, o.primitiveLength), this.renderableTunnelSegments = el.simpleSegment(0, u.primitiveOffset, 0, u.primitiveLength), this.shadowCasterSegments = el.simpleSegment(0, i.primitiveOffset, 0, i.primitiveLength);
            }
            update(t1, e, r, n, i, s, o, a) {
                this.bridgeProgramConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, a), this.tunnelProgramConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, a);
            }
            upload(t1) {
                this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t1.createVertexBuffer(this.vertexPositions, gh.members), this.vertexBufferNormal = t1.createVertexBuffer(this.vertexNormals, xh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(t1), this.tunnelProgramConfigurations.upload(t1));
            }
            destroy() {
                this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy();
            }
            populatePaintArrays(t1, e, r, n, i) {
                const s = (s, o)=>{
                    for(let a = 0; a < o.length - 1; a++){
                        const l = o[a].featureIndex, u = o[a + 1].vertexStart, c = t1.feature(l);
                        s.populatePaintArrays(u, c, l, {}, r, e, n, void 0, i);
                    }
                };
                s(this.bridgeProgramConfigurations, this.bridgeFeatureSections), s(this.tunnelProgramConfigurations, this.tunnelFeatureSections);
            }
            computeVertexConnections(t1, e, r, n, i) {
                const s = new Map;
                for(let o = n; o < i; o++){
                    const n = r[o], i = n.a, a = n.b, l = Qh.computePosHash(t1[i]), u = Qh.computePosHash(t1[a]);
                    let c = s.get(l);
                    c || (c = {}, s.set(l, c));
                    let h = s.get(u);
                    h || (h = {}, s.set(u, h)), e[i] <= 0 && e[a] <= 0 || (c.to = a, h.from = i);
                }
                return s;
            }
            isTerminalVertex(t1, e) {
                const r = Qh.computePosHash(this.unevalVertices[t1]), n = e.get(r);
                return !n || !n.from || !n.to;
            }
            constructBridgeStructures(t1, e, r, n, i, s) {
                t1.clearVertexLookup();
                const o = this.computeVertexConnections(e, r, n, i.min, i.max), a = 1 / s, l = .5 * a, u = (t1, n)=>M(t1, e[n].x, e[n].y, r[n] * a), c = b(), h = b(), p = b(), d = b(), f = b(), m = (t1, r)=>{
                    const n = o.get(Qh.computePosHash(e[r])), i = n.from, s = n.to;
                    if (!i || !s) return;
                    u(c, i), u(h, r), u(p, s), j(d), $(c, h) || (G(f, h, c), F(d, f)), $(p, h) || (G(f, p, h), I(d, d, F(f, f)));
                    const a = q(d);
                    return a > 0 ? z(t1, d, 1 / a) : void 0;
                };
                let y = Number.POSITIVE_INFINITY;
                this.sortSubarray(n, i.min, i.max, (t1, e)=>t1.featureInfo.featureIndex - e.featureInfo.featureIndex);
                const g = b(), x = b(), v = b(), w = b(), _ = b(), A = b(), S = b(), P = b(), E = b(), k = [
                    b(),
                    b(),
                    b(),
                    b()
                ], T = [
                    b(),
                    b(),
                    b(),
                    b()
                ], B = [
                    {
                        coord: new bt(0, 0),
                        height: 0
                    },
                    {
                        coord: new bt(0, 0),
                        height: 0
                    }
                ], V = (t1, e)=>t1 > e;
                for(let u = i.min; u < i.max; u++){
                    const i = n[u];
                    if (!i.featureInfo.guardRailEnabled) continue;
                    if (!this.prepareEdgePoints(B, e, r, i, V)) continue;
                    const [c, h] = B;
                    if (M(g, c.coord.x, c.coord.y, a * c.height), M(x, h.coord.x, h.coord.y, a * h.height), $(g, x)) continue;
                    G(v, x, g), F(v, v);
                    const p = m(P, i.a) || v, d = m(E, i.b) || v;
                    M(w, p[1], -p[0], 0), F(w, w), M(_, d[1], -d[0], 0), F(_, _), L(P, w, p), F(A, P), L(P, _, d), F(S, P), I(k[0], g, z(P, G(P, w, A), l)), I(k[1], g, z(P, I(P, w, A), l)), I(k[2], g, z(P, A, l)), k[3] = g, I(T[0], x, z(P, G(P, _, S), l)), I(T[1], x, z(P, I(P, _, S), l)), I(T[2], x, z(P, S, l)), T[3] = x, y = this.addFeatureSection(i.featureInfo.featureIndex, y, this.bridgeFeatureSections, t1);
                    const f = t1.addVertex(k[0], w, s), b = t1.addVertex(k[1], w, s), D = t1.addVertex(T[0], _, s), R = t1.addVertex(T[1], _, s);
                    t1.addTriangle(f, b, D), t1.addTriangle(b, R, D);
                    const O = t1.addVertex(k[1], A, s), U = t1.addVertex(k[2], A, s), N = t1.addVertex(T[1], S, s), j = t1.addVertex(T[2], S, s);
                    t1.addTriangle(O, U, N), t1.addTriangle(U, j, N), C(w, w), C(_, _);
                    const H = t1.addVertex(k[2], w, s), q = t1.addVertex(k[3], w, s), X = t1.addVertex(T[2], _, s), Z = t1.addVertex(T[3], _, s);
                    t1.addTriangle(H, q, X), t1.addTriangle(q, Z, X);
                    const W = this.isTerminalVertex(i.a, o), Y = this.isTerminalVertex(i.b, o);
                    c.height < .01 && W && t1.addQuad(k[3], k[2], k[1], k[0], C(p, p), s), h.height < .01 && Y && t1.addQuad(T[0], T[1], T[2], T[3], d, s);
                }
                this.bridgeFeatureSections.push({
                    featureIndex: Number.POSITIVE_INFINITY,
                    vertexStart: t1.getVertexCount()
                });
            }
            constructTunnelStructures(t1, e, r, n, i, s) {
                t1.clearVertexLookup();
                let o = Number.POSITIVE_INFINITY;
                const a = (t1, e)=>t1.featureInfo.featureIndex - e.featureInfo.featureIndex;
                this.sortSubarray(n, i.min, i.max, a), this.sortSubarray(n, s.min, s.max, a);
                const l = (t1)=>F(t1, t1), u = [
                    {
                        coord: new bt(0, 0),
                        height: 0
                    },
                    {
                        coord: new bt(0, 0),
                        height: 0
                    }
                ], c = (t1, e)=>t1 < e, h = b(), p = b(), d = b(), f = b(), m = b();
                for(let s = i.min; s < i.max; s++){
                    if (!this.prepareEdgePoints(u, e, r, n[s], c)) continue;
                    const [i, a] = u, y = l(M(m, -(a.coord.y - i.coord.y), a.coord.x - i.coord.x, 0));
                    o = this.addFeatureSection(n[s].featureInfo.featureIndex, o, this.tunnelFeatureSections, t1), t1.addQuad(M(h, i.coord.x, i.coord.y, i.height), M(p, a.coord.x, a.coord.y, a.height), M(d, a.coord.x, a.coord.y, n[s].isTunnel ? -.1 : 0), M(f, i.coord.x, i.coord.y, n[s].isTunnel ? -.1 : 0), y);
                }
                for(let i = s.min; i < s.max; i++){
                    const s = n[i];
                    s.isTunnel && ([s.a, s.b] = [
                        s.b,
                        s.a
                    ]);
                    const a = e[s.a], u = e[s.b], c = l(M(m, -(u.y - a.y), u.x - a.x, 0));
                    o = this.addFeatureSection(s.featureInfo.featureIndex, o, this.tunnelFeatureSections, t1), t1.addQuad(M(h, u.x, u.y, 0), M(p, a.x, a.y, 0), M(d, a.x, a.y, r[s.a] + 4), M(f, u.x, u.y, r[s.b] + 4), c), t1.addQuad(M(h, a.x, a.y, 0), M(p, u.x, u.y, 0), M(d, u.x, u.y, r[s.b] + 4), M(f, a.x, a.y, r[s.a] + 4), c);
                }
                this.tunnelFeatureSections.push({
                    featureIndex: Number.POSITIVE_INFINITY,
                    vertexStart: t1.getVertexCount()
                });
            }
            setElevatedPoint(t1, e, r, n) {
                t1.coord.x = e, t1.coord.y = r, t1.height = n;
            }
            prepareEdgePoints(t1, e, r, n, i) {
                let s = e[n.a].x, o = e[n.a].y, a = e[n.b].x, l = e[n.b].y, u = r[n.a], c = r[n.b];
                const h = i(u, 0), p = i(c, 0);
                if (h && p) return this.setElevatedPoint(t1[0], s, o, u), this.setElevatedPoint(t1[1], a, l, c), !0;
                if (!h && !p) return !1;
                if (h) {
                    if (!p) {
                        const t1 = c / (c - u);
                        a = ur(a, s, t1), l = ur(l, o, t1), c = ur(c, u, t1);
                    }
                } else {
                    const t1 = u / (u - c);
                    s = ur(s, a, t1), o = ur(o, l, t1), u = ur(u, c, t1);
                }
                return this.setElevatedPoint(t1[0], s, o, u), this.setElevatedPoint(t1[1], a, l, c), !0;
            }
            prepareEdges(t1, e) {
                if (0 === e.length) return;
                e.sort((t1, e)=>t1.hash === e.hash ? e.polygonIdx - t1.polygonIdx : e.hash > t1.hash ? 1 : -1);
                let r = 0, n = 0, i = 0, s = e[r].polygonIdx;
                do {
                    n++, (n === e.length || e[r].hash !== e[n].hash) && ((1 == n - r || e[n - 1].polygonIdx !== s) && (i < r && (e[i] = e[r], e[r] = null), e[i].type = "none", i++), r = n, r !== e.length && (s = e[r].polygonIdx));
                }while (r !== e.length)
                if (e.splice(i), 0 !== e.length && 0 !== t1.length) {
                    e.sort((t1, e)=>t1.portalHash < e.portalHash ? 1 : -1);
                    let r = 0, n = 0;
                    for(; r !== e.length && n !== t1.length;){
                        const i = e[r], s = t1[n];
                        i.portalHash > s.hash ? r++ : s.hash > i.portalHash ? n++ : (i.type = s.type, r++);
                    }
                }
            }
            isOnBorder(t1, e) {
                return t1 <= 0 && e <= 0 || t1 >= Cn && e >= Cn;
            }
            addFeatureSection(t1, e, r, n) {
                return t1 !== e && (e = t1, r.push({
                    featureIndex: t1,
                    vertexStart: n.getVertexCount()
                }), n.clearVertexLookup()), e;
            }
            sortSubarray(t1, e, r, n) {
                const i = t1.slice(e, r);
                i.sort(n), t1.splice(e, i.length, ...i);
            }
            static computeEdgeHash(t1, e) {
                return (t1.y === e.y && t1.x > e.x || t1.y > e.y) && ([t1, e] = [
                    e,
                    t1
                ]), BigInt(Qh.computePosHash(t1)) << 32n | BigInt(Qh.computePosHash(e));
            }
            static computePosHash(t1) {
                return ((65535 & t1.x) << 16 | 65535 & t1.y) >>> 0;
            }
        }
        var tp, ep = {
            exports: {}
        }, rp = (tp || (tp = 1, function(t1, e) {
            !function(t1) {
                function e(t1, e) {
                    return t1 > e ? 1 : t1 < e ? -1 : 0;
                }
                var r = function(t1, r) {
                    void 0 === t1 && (t1 = e), void 0 === r && (r = !1), this._compare = t1, this._root = null, this._size = 0, this._noDuplicates = !!r;
                }, n = {
                    size: {
                        configurable: !0
                    }
                };
                function i(t1, e, r, n, s) {
                    var o = s - n;
                    if (o > 0) {
                        var a = n + Math.floor(o / 2), l = {
                            key: e[a],
                            data: r[a],
                            parent: t1
                        };
                        return l.left = i(l, e, r, n, a), l.right = i(l, e, r, a + 1, s), l;
                    }
                    return null;
                }
                function s(t1, e, r, n, i) {
                    if (!(r >= n)) {
                        for(var o = t1[r + n >> 1], a = r - 1, l = n + 1;;){
                            do {
                                a++;
                            }while (i(t1[a], o) < 0)
                            do {
                                l--;
                            }while (i(t1[l], o) > 0)
                            if (a >= l) break;
                            var u = t1[a];
                            t1[a] = t1[l], t1[l] = u, u = e[a], e[a] = e[l], e[l] = u;
                        }
                        s(t1, e, r, l, i), s(t1, e, l + 1, n, i);
                    }
                }
                r.prototype.rotateLeft = function(t1) {
                    var e = t1.right;
                    e && (t1.right = e.left, e.left && (e.left.parent = t1), e.parent = t1.parent), t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.left = t1), t1.parent = e;
                }, r.prototype.rotateRight = function(t1) {
                    var e = t1.left;
                    e && (t1.left = e.right, e.right && (e.right.parent = t1), e.parent = t1.parent), t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.right = t1), t1.parent = e;
                }, r.prototype._splay = function(t1) {
                    for(; t1.parent;){
                        var e = t1.parent;
                        e.parent ? e.left === t1 && e.parent.left === e ? (this.rotateRight(e.parent), this.rotateRight(e)) : e.right === t1 && e.parent.right === e ? (this.rotateLeft(e.parent), this.rotateLeft(e)) : e.left === t1 && e.parent.right === e ? (this.rotateRight(e), this.rotateLeft(e)) : (this.rotateLeft(e), this.rotateRight(e)) : e.left === t1 ? this.rotateRight(e) : this.rotateLeft(e);
                    }
                }, r.prototype.splay = function(t1) {
                    for(var e, r, n, i, s; t1.parent;)(r = (e = t1.parent).parent) && r.parent ? ((n = r.parent).left === r ? n.left = t1 : n.right = t1, t1.parent = n) : (t1.parent = null, this._root = t1), i = t1.left, s = t1.right, t1 === e.left ? (r && (r.left === e ? (e.right ? (r.left = e.right, r.left.parent = r) : r.left = null, e.right = r, r.parent = e) : (i ? (r.right = i, i.parent = r) : r.right = null, t1.left = r, r.parent = t1)), s ? (e.left = s, s.parent = e) : e.left = null, t1.right = e, e.parent = t1) : (r && (r.right === e ? (e.left ? (r.right = e.left, r.right.parent = r) : r.right = null, e.left = r, r.parent = e) : (s ? (r.left = s, s.parent = r) : r.left = null, t1.right = r, r.parent = t1)), i ? (e.right = i, i.parent = e) : e.right = null, t1.left = e, e.parent = t1);
                }, r.prototype.replace = function(t1, e) {
                    t1.parent ? t1 === t1.parent.left ? t1.parent.left = e : t1.parent.right = e : this._root = e, e && (e.parent = t1.parent);
                }, r.prototype.minNode = function(t1) {
                    if (void 0 === t1 && (t1 = this._root), t1) for(; t1.left;)t1 = t1.left;
                    return t1;
                }, r.prototype.maxNode = function(t1) {
                    if (void 0 === t1 && (t1 = this._root), t1) for(; t1.right;)t1 = t1.right;
                    return t1;
                }, r.prototype.insert = function(t1, e) {
                    var r = this._root, n = null, i = this._compare;
                    if (this._noDuplicates) for(; r;){
                        if (n = r, 0 === i(r.key, t1)) return;
                        r = i(r.key, t1) < 0 ? r.right : r.left;
                    }
                    else for(; r;)n = r, r = i(r.key, t1) < 0 ? r.right : r.left;
                    return r = {
                        key: t1,
                        data: e,
                        left: null,
                        right: null,
                        parent: n
                    }, n ? i(n.key, r.key) < 0 ? n.right = r : n.left = r : this._root = r, this.splay(r), this._size++, r;
                }, r.prototype.find = function(t1) {
                    for(var e = this._root, r = this._compare; e;){
                        var n = r(e.key, t1);
                        if (n < 0) e = e.right;
                        else {
                            if (!(n > 0)) return e;
                            e = e.left;
                        }
                    }
                    return null;
                }, r.prototype.contains = function(t1) {
                    for(var e = this._root, r = this._compare; e;){
                        var n = r(t1, e.key);
                        if (0 === n) return !0;
                        e = n < 0 ? e.left : e.right;
                    }
                    return !1;
                }, r.prototype.remove = function(t1) {
                    var e = this.find(t1);
                    if (!e) return !1;
                    if (this.splay(e), e.left) if (e.right) {
                        var r = this.minNode(e.right);
                        r.parent !== e && (this.replace(r, r.right), r.right = e.right, r.right.parent = r), this.replace(e, r), r.left = e.left, r.left.parent = r;
                    } else this.replace(e, e.left);
                    else this.replace(e, e.right);
                    return this._size--, !0;
                }, r.prototype.removeNode = function(t1) {
                    if (!t1) return !1;
                    if (this.splay(t1), t1.left) if (t1.right) {
                        var e = this.minNode(t1.right);
                        e.parent !== t1 && (this.replace(e, e.right), e.right = t1.right, e.right.parent = e), this.replace(t1, e), e.left = t1.left, e.left.parent = e;
                    } else this.replace(t1, t1.left);
                    else this.replace(t1, t1.right);
                    return this._size--, !0;
                }, r.prototype.erase = function(t1) {
                    var e = this.find(t1);
                    if (e) {
                        this.splay(e);
                        var r = e.left, n = e.right, i = null;
                        r && (r.parent = null, i = this.maxNode(r), this.splay(i), this._root = i), n && (r ? i.right = n : this._root = n, n.parent = i), this._size--;
                    }
                }, r.prototype.pop = function() {
                    var t1 = this._root, e = null;
                    if (t1) {
                        for(; t1.left;)t1 = t1.left;
                        e = {
                            key: t1.key,
                            data: t1.data
                        }, this.remove(t1.key);
                    }
                    return e;
                }, r.prototype.next = function(t1) {
                    var e = t1;
                    if (e) if (e.right) for(e = e.right; e && e.left;)e = e.left;
                    else for(e = t1.parent; e && e.right === t1;)t1 = e, e = e.parent;
                    return e;
                }, r.prototype.prev = function(t1) {
                    var e = t1;
                    if (e) if (e.left) for(e = e.left; e && e.right;)e = e.right;
                    else for(e = t1.parent; e && e.left === t1;)t1 = e, e = e.parent;
                    return e;
                }, r.prototype.forEach = function(t1) {
                    for(var e = this._root, r = [], n = !1, i = 0; !n;)e ? (r.push(e), e = e.left) : r.length > 0 ? (t1(e = r.pop(), i++), e = e.right) : n = !0;
                    return this;
                }, r.prototype.range = function(t1, e, r, n) {
                    for(var i = [], s = this._compare, o = this._root; 0 !== i.length || o;)if (o) i.push(o), o = o.left;
                    else {
                        if (s((o = i.pop()).key, e) > 0) break;
                        if (s(o.key, t1) >= 0 && r.call(n, o)) return this;
                        o = o.right;
                    }
                    return this;
                }, r.prototype.keys = function() {
                    for(var t1 = this._root, e = [], r = [], n = !1; !n;)t1 ? (e.push(t1), t1 = t1.left) : e.length > 0 ? (t1 = e.pop(), r.push(t1.key), t1 = t1.right) : n = !0;
                    return r;
                }, r.prototype.values = function() {
                    for(var t1 = this._root, e = [], r = [], n = !1; !n;)t1 ? (e.push(t1), t1 = t1.left) : e.length > 0 ? (t1 = e.pop(), r.push(t1.data), t1 = t1.right) : n = !0;
                    return r;
                }, r.prototype.at = function(t1) {
                    for(var e = this._root, r = [], n = !1, i = 0; !n;)if (e) r.push(e), e = e.left;
                    else if (r.length > 0) {
                        if (e = r.pop(), i === t1) return e;
                        i++, e = e.right;
                    } else n = !0;
                    return null;
                }, r.prototype.load = function(t1, e, r) {
                    if (void 0 === t1 && (t1 = []), void 0 === e && (e = []), void 0 === r && (r = !1), 0 !== this._size) throw new Error("bulk-load: tree is not empty");
                    var n = t1.length;
                    return r && s(t1, e, 0, n - 1, this._compare), this._root = i(null, t1, e, 0, n), this._size = n, this;
                }, r.prototype.min = function() {
                    var t1 = this.minNode(this._root);
                    return t1 ? t1.key : null;
                }, r.prototype.max = function() {
                    var t1 = this.maxNode(this._root);
                    return t1 ? t1.key : null;
                }, r.prototype.isEmpty = function() {
                    return null === this._root;
                }, n.size.get = function() {
                    return this._size;
                }, r.createTree = function(t1, e, n, i, s) {
                    return new r(n, s).load(t1, e, i);
                }, Object.defineProperties(r.prototype, n);
                var o = 0, a = 1, l = 2, u = 3, c = 0, h = 1, p = 2, d = 3;
                function f(t1, e, r) {
                    null === e ? (t1.inOut = !1, t1.otherInOut = !0) : (t1.isSubject === e.isSubject ? (t1.inOut = !e.inOut, t1.otherInOut = e.otherInOut) : (t1.inOut = !e.otherInOut, t1.otherInOut = e.isVertical() ? !e.inOut : e.inOut), e && (t1.prevInResult = !m(e, r) || e.isVertical() ? e.prevInResult : e));
                    var n = m(t1, r);
                    t1.resultTransition = n ? function(t1, e) {
                        var r, n = !t1.inOut, i = !t1.otherInOut;
                        switch(e){
                            case c:
                                r = n && i;
                                break;
                            case h:
                                r = n || i;
                                break;
                            case d:
                                r = n ^ i;
                                break;
                            case p:
                                r = t1.isSubject ? n && !i : i && !n;
                        }
                        return r ? 1 : -1;
                    }(t1, r) : 0;
                }
                function m(t1, e) {
                    switch(t1.type){
                        case o:
                            switch(e){
                                case c:
                                    return !t1.otherInOut;
                                case h:
                                    return t1.otherInOut;
                                case p:
                                    return t1.isSubject && t1.otherInOut || !t1.isSubject && !t1.otherInOut;
                                case d:
                                    return !0;
                            }
                            break;
                        case l:
                            return e === c || e === h;
                        case u:
                            return e === p;
                        case a:
                            return !1;
                    }
                    return !1;
                }
                var y = function(t1, e, r, n, i) {
                    this.left = e, this.point = t1, this.otherEvent = r, this.isSubject = n, this.type = i || o, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0;
                }, g = {
                    inResult: {
                        configurable: !0
                    }
                };
                function x(t1, e) {
                    return t1[0] === e[0] && t1[1] === e[1];
                }
                y.prototype.isBelow = function(t1) {
                    var e = this.point, r = this.otherEvent.point;
                    return this.left ? (e[0] - t1[0]) * (r[1] - t1[1]) - (r[0] - t1[0]) * (e[1] - t1[1]) > 0 : (r[0] - t1[0]) * (e[1] - t1[1]) - (e[0] - t1[0]) * (r[1] - t1[1]) > 0;
                }, y.prototype.isAbove = function(t1) {
                    return !this.isBelow(t1);
                }, y.prototype.isVertical = function() {
                    return this.point[0] === this.otherEvent.point[0];
                }, g.inResult.get = function() {
                    return 0 !== this.resultTransition;
                }, y.prototype.clone = function() {
                    var t1 = new y(this.point, this.left, this.otherEvent, this.isSubject, this.type);
                    return t1.contourId = this.contourId, t1.resultTransition = this.resultTransition, t1.prevInResult = this.prevInResult, t1.isExteriorRing = this.isExteriorRing, t1.inOut = this.inOut, t1.otherInOut = this.otherInOut, t1;
                }, Object.defineProperties(y.prototype, g);
                var v = 11102230246251565e-32, b = 134217729, w = (3 + 8 * v) * v;
                function _(t1, e, r, n, i) {
                    var s, o, a, l, u = e[0], c = n[0], h = 0, p = 0;
                    c > u == c > -u ? (s = u, u = e[++h]) : (s = c, c = n[++p]);
                    var d = 0;
                    if (h < t1 && p < r) for(c > u == c > -u ? (a = s - ((o = u + s) - u), u = e[++h]) : (a = s - ((o = c + s) - c), c = n[++p]), s = o, 0 !== a && (i[d++] = a); h < t1 && p < r;)c > u == c > -u ? (a = s - ((o = s + u) - (l = o - s)) + (u - l), u = e[++h]) : (a = s - ((o = s + c) - (l = o - s)) + (c - l), c = n[++p]), s = o, 0 !== a && (i[d++] = a);
                    for(; h < t1;)a = s - ((o = s + u) - (l = o - s)) + (u - l), u = e[++h], s = o, 0 !== a && (i[d++] = a);
                    for(; p < r;)a = s - ((o = s + c) - (l = o - s)) + (c - l), c = n[++p], s = o, 0 !== a && (i[d++] = a);
                    return 0 === s && 0 !== d || (i[d++] = s), d;
                }
                function A(t1) {
                    return new Float64Array(t1);
                }
                var M = 33306690738754716e-32, I = 22204460492503146e-32, S = 11093356479670487e-47, P = A(4), E = A(8), k = A(12), z = A(16), T = A(4);
                function B(t1, e, r) {
                    var n = function(t1, e, r, n, i, s) {
                        var o = (e - s) * (r - i), a = (t1 - i) * (n - s), l = o - a;
                        if (0 === o || 0 === a || o > 0 != a > 0) return l;
                        var u = Math.abs(o + a);
                        return Math.abs(l) >= M * u ? l : -function(t1, e, r, n, i, s, o) {
                            var a, l, u, c, h, p, d, f, m, y, g, x, v, A, M, B, V, C, F = t1 - i, D = r - i, L = e - s, R = n - s;
                            P[0] = (M = (f = F - (d = (p = b * F) - (p - F))) * (y = R - (m = (p = b * R) - (p - R))) - ((A = F * R) - d * m - f * m - d * y)) - ((g = M - (V = (f = L - (d = (p = b * L) - (p - L))) * (y = D - (m = (p = b * D) - (p - D))) - ((B = L * D) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), P[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), P[2] = x - ((C = x + g) - (h = C - x)) + (g - h), P[3] = C;
                            var O = function(t1, e) {
                                for(var r = e[0], n = 1; n < 4; n++)r += e[n];
                                return r;
                            }(0, P), U = I * o;
                            if (O >= U || -O >= U) return O;
                            if (a = t1 - (F + (h = t1 - F)) + (h - i), u = r - (D + (h = r - D)) + (h - i), l = e - (L + (h = e - L)) + (h - s), c = n - (R + (h = n - R)) + (h - s), 0 === a && 0 === l && 0 === u && 0 === c) return O;
                            if (U = S * o + w * Math.abs(O), (O += F * c + R * a - (L * u + D * l)) >= U || -O >= U) return O;
                            T[0] = (M = (f = a - (d = (p = b * a) - (p - a))) * (y = R - (m = (p = b * R) - (p - R))) - ((A = a * R) - d * m - f * m - d * y)) - ((g = M - (V = (f = l - (d = (p = b * l) - (p - l))) * (y = D - (m = (p = b * D) - (p - D))) - ((B = l * D) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((C = x + g) - (h = C - x)) + (g - h), T[3] = C;
                            var N = _(4, P, 4, T, E);
                            T[0] = (M = (f = F - (d = (p = b * F) - (p - F))) * (y = c - (m = (p = b * c) - (p - c))) - ((A = F * c) - d * m - f * m - d * y)) - ((g = M - (V = (f = L - (d = (p = b * L) - (p - L))) * (y = u - (m = (p = b * u) - (p - u))) - ((B = L * u) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((C = x + g) - (h = C - x)) + (g - h), T[3] = C;
                            var j = _(N, E, 4, T, k);
                            T[0] = (M = (f = a - (d = (p = b * a) - (p - a))) * (y = c - (m = (p = b * c) - (p - c))) - ((A = a * c) - d * m - f * m - d * y)) - ((g = M - (V = (f = l - (d = (p = b * l) - (p - l))) * (y = u - (m = (p = b * u) - (p - u))) - ((B = l * u) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((C = x + g) - (h = C - x)) + (g - h), T[3] = C;
                            var $ = _(j, k, 4, T, z);
                            return z[$ - 1];
                        }(t1, e, r, n, i, s, u);
                    }(t1[0], t1[1], e[0], e[1], r[0], r[1]);
                    return n > 0 ? -1 : n < 0 ? 1 : 0;
                }
                function V(t1, e) {
                    var r = t1.point, n = e.point;
                    return r[0] > n[0] ? 1 : r[0] < n[0] ? -1 : r[1] !== n[1] ? r[1] > n[1] ? 1 : -1 : function(t1, e, r, n) {
                        return t1.left !== e.left ? t1.left ? 1 : -1 : 0 !== B(r, t1.otherEvent.point, e.otherEvent.point) ? t1.isBelow(e.otherEvent.point) ? -1 : 1 : !t1.isSubject && e.isSubject ? 1 : -1;
                    }(t1, e, r);
                }
                function C(t1, e, r) {
                    var n = new y(e, !1, t1, t1.isSubject), i = new y(e, !0, t1.otherEvent, t1.isSubject);
                    return x(t1.point, t1.otherEvent.point) && console.warn("what is that, a collapsed segment?", t1), n.contourId = i.contourId = t1.contourId, V(i, t1.otherEvent) > 0 && (t1.otherEvent.left = !0, i.left = !1), t1.otherEvent.otherEvent = i, t1.otherEvent = n, r.push(i), r.push(n), r;
                }
                function F(t1, e) {
                    return t1[0] * e[1] - t1[1] * e[0];
                }
                function D(t1, e) {
                    return t1[0] * e[0] + t1[1] * e[1];
                }
                function L(t1, e, r) {
                    var n = function(t1, e, r, n, i) {
                        var s = [
                            e[0] - t1[0],
                            e[1] - t1[1]
                        ], o = [
                            n[0] - r[0],
                            n[1] - r[1]
                        ];
                        function a(t1, e, r) {
                            return [
                                t1[0] + e * r[0],
                                t1[1] + e * r[1]
                            ];
                        }
                        var l = [
                            r[0] - t1[0],
                            r[1] - t1[1]
                        ], u = F(s, o), c = u * u, h = D(s, s);
                        if (c > 0) {
                            var p = F(l, o) / u;
                            if (p < 0 || p > 1) return null;
                            var d = F(l, s) / u;
                            return d < 0 || d > 1 ? null : 0 === p || 1 === p ? [
                                a(t1, p, s)
                            ] : 0 === d || 1 === d ? [
                                a(r, d, o)
                            ] : [
                                a(t1, p, s)
                            ];
                        }
                        if ((c = (u = F(l, s)) * u) > 0) return null;
                        var f = D(s, l) / h, m = f + D(s, o) / h, y = Math.min(f, m), g = Math.max(f, m);
                        return y <= 1 && g >= 0 ? 1 === y ? [
                            a(t1, y > 0 ? y : 0, s)
                        ] : 0 === g ? [
                            a(t1, g < 1 ? g : 1, s)
                        ] : [
                            a(t1, y > 0 ? y : 0, s),
                            a(t1, g < 1 ? g : 1, s)
                        ] : null;
                    }(t1.point, t1.otherEvent.point, e.point, e.otherEvent.point), i = n ? n.length : 0;
                    if (0 === i) return 0;
                    if (1 === i && (x(t1.point, e.point) || x(t1.otherEvent.point, e.otherEvent.point))) return 0;
                    if (2 === i && t1.isSubject === e.isSubject) return 0;
                    if (1 === i) return x(t1.point, n[0]) || x(t1.otherEvent.point, n[0]) || C(t1, n[0], r), x(e.point, n[0]) || x(e.otherEvent.point, n[0]) || C(e, n[0], r), 1;
                    var s = [], o = !1, c = !1;
                    return x(t1.point, e.point) ? o = !0 : 1 === V(t1, e) ? s.push(e, t1) : s.push(t1, e), x(t1.otherEvent.point, e.otherEvent.point) ? c = !0 : 1 === V(t1.otherEvent, e.otherEvent) ? s.push(e.otherEvent, t1.otherEvent) : s.push(t1.otherEvent, e.otherEvent), o && c || o ? (e.type = a, t1.type = e.inOut === t1.inOut ? l : u, o && !c && C(s[1].otherEvent, s[0].point, r), 2) : c ? (C(s[0], s[1].point, r), 3) : s[0] !== s[3].otherEvent ? (C(s[0], s[1].point, r), C(s[1], s[2].point, r), 3) : (C(s[0], s[1].point, r), C(s[3].otherEvent, s[2].point, r), 3);
                }
                function R(t1, e) {
                    if (t1 === e) return 0;
                    if (0 !== B(t1.point, t1.otherEvent.point, e.point) || 0 !== B(t1.point, t1.otherEvent.point, e.otherEvent.point)) return x(t1.point, e.point) ? t1.isBelow(e.otherEvent.point) ? -1 : 1 : t1.point[0] === e.point[0] ? t1.point[1] < e.point[1] ? -1 : 1 : 1 === V(t1, e) ? e.isAbove(t1.point) ? -1 : 1 : t1.isBelow(e.point) ? -1 : 1;
                    if (t1.isSubject !== e.isSubject) return t1.isSubject ? -1 : 1;
                    var r = t1.point, n = e.point;
                    return r[0] === n[0] && r[1] === n[1] ? (r = t1.otherEvent.point)[0] === (n = e.otherEvent.point)[0] && r[1] === n[1] ? 0 : t1.contourId > e.contourId ? 1 : -1 : 1 === V(t1, e) ? 1 : -1;
                }
                var O = function() {
                    this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
                };
                function U(t1, e, r, n) {
                    var i, s = t1 + 1, o = e[t1].point, a = e.length;
                    for(s < a && (i = e[s].point); s < a && i[0] === o[0] && i[1] === o[1];){
                        if (!r[s]) return s;
                        ++s < a && (i = e[s].point);
                    }
                    for(s = t1 - 1; r[s] && s > n;)s--;
                    return s;
                }
                O.prototype.isExterior = function() {
                    return null == this.holeOf;
                };
                var N = $, j = $;
                function $(t1, e) {
                    if (!(this instanceof $)) return new $(t1, e);
                    if (this.data = t1 || [], this.length = this.data.length, this.compare = e || G, this.length > 0) for(var r = (this.length >> 1) - 1; r >= 0; r--)this._down(r);
                }
                function G(t1, e) {
                    return t1 < e ? -1 : t1 > e ? 1 : 0;
                }
                $.prototype = {
                    push: function(t1) {
                        this.data.push(t1), this.length++, this._up(this.length - 1);
                    },
                    pop: function() {
                        if (0 !== this.length) {
                            var t1 = this.data[0];
                            return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t1;
                        }
                    },
                    peek: function() {
                        return this.data[0];
                    },
                    _up: function(t1) {
                        for(var e = this.data, r = this.compare, n = e[t1]; t1 > 0;){
                            var i = t1 - 1 >> 1, s = e[i];
                            if (r(n, s) >= 0) break;
                            e[t1] = s, t1 = i;
                        }
                        e[t1] = n;
                    },
                    _down: function(t1) {
                        for(var e = this.data, r = this.compare, n = this.length >> 1, i = e[t1]; t1 < n;){
                            var s = 1 + (t1 << 1), o = s + 1, a = e[s];
                            if (o < this.length && r(e[o], a) < 0 && (s = o, a = e[o]), r(a, i) >= 0) break;
                            e[t1] = a, t1 = s;
                        }
                        e[t1] = i;
                    }
                }, N.default = j;
                var H = Math.max, q = Math.min, X = 0;
                function Z(t1, e, r, n, i, s) {
                    var o, a, l, u, c, h;
                    for(o = 0, a = t1.length - 1; o < a; o++)if (u = t1[o + 1], c = new y(l = t1[o], !1, void 0, e), h = new y(u, !1, c, e), c.otherEvent = h, l[0] !== u[0] || l[1] !== u[1]) {
                        c.contourId = h.contourId = r, s || (c.isExteriorRing = !1, h.isExteriorRing = !1), V(c, h) > 0 ? h.left = !0 : c.left = !0;
                        var p = l[0], d = l[1];
                        i[0] = q(i[0], p), i[1] = q(i[1], d), i[2] = H(i[2], p), i[3] = H(i[3], d), n.push(c), n.push(h);
                    }
                }
                var W = [];
                function Y(t1, e, n) {
                    "number" == typeof t1[0][0][0] && (t1 = [
                        t1
                    ]), "number" == typeof e[0][0][0] && (e = [
                        e
                    ]);
                    var i = function(t1, e, r) {
                        var n = null;
                        return t1.length * e.length == 0 && (r === c ? n = W : r === p ? n = t1 : r !== h && r !== d || (n = 0 === t1.length ? e : t1)), n;
                    }(t1, e, n);
                    if (i) return i === W ? null : i;
                    var s = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ], o = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ], a = function(t1, e, r, n, i) {
                        var s, o, a, l, u, c, h = new N(null, V);
                        for(a = 0, l = t1.length; a < l; a++)for(u = 0, c = (s = t1[a]).length; u < c; u++)(o = 0 === u) && X++, Z(s[u], !0, X, h, r, o);
                        for(a = 0, l = e.length; a < l; a++)for(u = 0, c = (s = e[a]).length; u < c; u++)o = 0 === u, i === p && (o = !1), o && X++, Z(s[u], !1, X, h, n, o);
                        return h;
                    }(t1, e, s, o, n);
                    if (i = function(t1, e, r, n, i) {
                        var s = null;
                        return (r[0] > n[2] || n[0] > r[2] || r[1] > n[3] || n[1] > r[3]) && (i === c ? s = W : i === p ? s = t1 : i !== h && i !== d || (s = t1.concat(e))), s;
                    }(t1, e, s, o, n)) return i === W ? null : i;
                    for(var l = function(t1) {
                        var e, r, n = function(t1) {
                            var e, r, n, i, s = [];
                            for(r = 0, n = t1.length; r < n; r++)((e = t1[r]).left && e.inResult || !e.left && e.otherEvent.inResult) && s.push(e);
                            for(var o = !1; !o;)for(o = !0, r = 0, n = s.length; r < n; r++)r + 1 < n && 1 === V(s[r], s[r + 1]) && (i = s[r], s[r] = s[r + 1], s[r + 1] = i, o = !1);
                            for(r = 0, n = s.length; r < n; r++)(e = s[r]).otherPos = r;
                            for(r = 0, n = s.length; r < n; r++)(e = s[r]).left || (i = e.otherPos, e.otherPos = e.otherEvent.otherPos, e.otherEvent.otherPos = i);
                            return s;
                        }(t1), i = {}, s = [], o = function() {
                            if (!i[e]) {
                                var t1 = s.length, r = function(t1, e, r) {
                                    var n = new O;
                                    if (null != t1.prevInResult) {
                                        var i = t1.prevInResult, s = i.outputContourId;
                                        if (i.resultTransition > 0) {
                                            var o = e[s];
                                            if (null != o.holeOf) {
                                                var a = o.holeOf;
                                                e[a].holeIds.push(r), n.holeOf = a, n.depth = e[s].depth;
                                            } else e[s].holeIds.push(r), n.holeOf = s, n.depth = e[s].depth + 1;
                                        } else n.holeOf = null, n.depth = e[s].depth;
                                    } else n.holeOf = null, n.depth = 0;
                                    return n;
                                }(n[e], s, t1), o = function(e) {
                                    i[e] = !0, e < n.length && n[e] && (n[e].outputContourId = t1);
                                }, a = e, l = e;
                                for(r.points.push(n[e].point); o(a), o(a = n[a].otherPos), r.points.push(n[a].point), !((a = U(a, n, i, l)) == l || a >= n.length) && n[a];);
                                s.push(r);
                            }
                        };
                        for(e = 0, r = n.length; e < r; e++)o();
                        return s;
                    }(function(t1, e, n, i, s, o) {
                        for(var a, l, u, h = new r(R), d = [], m = Math.min(i[2], s[2]); 0 !== t1.length;){
                            var y = t1.pop();
                            if (d.push(y), o === c && y.point[0] > m || o === p && y.point[0] > i[2]) break;
                            if (y.left) {
                                l = a = h.insert(y), a = a !== (u = h.minNode()) ? h.prev(a) : null, l = h.next(l);
                                var g = a ? a.key : null;
                                if (f(y, g, o), l && 2 === L(y, l.key, t1) && (f(y, g, o), f(l.key, y, o)), a && 2 === L(a.key, y, t1)) {
                                    var x = a;
                                    f(g, (x = x !== u ? h.prev(x) : null) ? x.key : null, o), f(y, g, o);
                                }
                            } else l = a = h.find(y = y.otherEvent), a && l && (a = a !== u ? h.prev(a) : null, l = h.next(l), h.remove(y), l && a && L(a.key, l.key, t1));
                        }
                        return d;
                    }(a, 0, 0, s, o, n)), u = [], m = 0; m < l.length; m++){
                        var y = l[m];
                        if (y.isExterior()) {
                            for(var g = [
                                y.points
                            ], x = 0; x < y.holeIds.length; x++)g.push(l[y.holeIds[x]].points);
                            u.push(g);
                        }
                    }
                    return u;
                }
                var K = {
                    UNION: h,
                    DIFFERENCE: p,
                    INTERSECTION: c,
                    XOR: d
                };
                t1.diff = function(t1, e) {
                    return Y(t1, e, p);
                }, t1.intersection = function(t1, e) {
                    return Y(t1, e, c);
                }, t1.operations = K, t1.union = function(t1, e) {
                    return Y(t1, e, h);
                }, t1.xor = function(t1, e) {
                    return Y(t1, e, d);
                }, Object.defineProperty(t1, "__esModule", {
                    value: !0
                });
            }(e);
        }(0, ep.exports)), ep.exports);
        /**
 * martinez v0.7.4
 * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
 *
 * @author Alex Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */ function np(t1, e, r, n) {
            const i = [], s = 0 === n ? (t1, e, r, n, i, s)=>{
                t1.push(new bt(s, r + (s - e) / (n - e) * (i - r)));
            } : (t1, e, r, n, i, s)=>{
                t1.push(new bt(e + (s - r) / (i - r) * (n - e), s));
            };
            for (const o of t1){
                const t1 = [];
                for (const i of o){
                    if (i.length <= 2) continue;
                    const o = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const a = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? a : l, p = 0 === n ? u : c;
                        h < e ? p > e && s(o, a, l, u, c, e) : h > r ? p < r && s(o, a, l, u, c, r) : o.push(i[t1]), p < e && h >= e && s(o, a, l, u, c, e), p > r && h <= r && s(o, a, l, u, c, r);
                    }
                    let a = i[i.length - 1];
                    const l = 0 === n ? a.x : a.y;
                    l >= e && l <= r && o.push(a), o.length && (a = o[o.length - 1], o[0].x === a.x && o[0].y === a.y || o.push(o[0]), t1.push(o));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        function ip(t1, e) {
            const r = op(t1), n = op([
                e
            ]), i = rp.intersection(r, n);
            return null == i ? [] : ap(i);
        }
        function sp(t1, e) {
            const r = 65536;
            let n = op(t1, r);
            for(; e.valid(); e.next()){
                const [t1, i] = e.get(), s = t1.x * r, o = t1.y * r, a = i.x * r, l = i.y * r, u = a - s, c = l - o, h = Math.hypot(u, c), p = Math.trunc(c / h * 3), d = -Math.trunc(u / h * 3);
                n = rp.diff(n, [
                    [
                        [
                            s,
                            o
                        ],
                        [
                            a,
                            l
                        ],
                        [
                            a + p,
                            l + d
                        ],
                        [
                            s + p,
                            o + d
                        ],
                        [
                            s,
                            o
                        ]
                    ]
                ]);
            }
            return ap(n, 1 / r);
        }
        function op(t1, e = 1) {
            return [
                t1.map((t1)=>t1.map((t1)=>[
                            t1.x * e,
                            t1.y * e
                        ]))
            ];
        }
        function ap(t1, e = 1) {
            return t1.map((t1)=>t1.map((t1, r)=>{
                    const n = t1.map((t1)=>new bt(t1[0] * e, t1[1] * e).round());
                    return r > 0 && n.reverse(), n;
                }));
        }
        class lp {
            constructor(t1, e){
                this.layoutVertexArray = new na, this.indexArray = new Ma, this.lineIndexArray = new va, this.triangleSegments = new el, this.lineSegments = new el, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.uploaded = !1, e && (this.elevatedLayoutVertexArray = new oa);
            }
            update(t1, e, r, n, i, s, o, a) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, a);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            needsUpload() {
                return this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, mh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t1.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t1.createVertexBuffer(this.elevatedLayoutVertexArray, yh.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
            }
            populatePaintArrays(t1, e, r, n, i, s, o) {
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, e, r, n, i, s, void 0, o);
            }
        }
        class up {
            constructor(t1){
                this.zoom = t1.zoom, this.pixelRatio = t1.pixelRatio, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.lut = t1.lut, this.bufferData = new lp(t1, !1), this.elevationBufferData = new lp(t1, !0), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"), this.sourceLayerIndex = t1.sourceLayerIndex, this.worldview = t1.worldview;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Zh("fill", this.layers, this.pixelRatio, e);
                const i = this.layers[0].layout.get("fill-sort-key"), s = [];
                for (const { feature: o, id: a, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = xu(o, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0, p = {
                        id: a,
                        properties: o.properties,
                        type: o.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : gu(o, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                i && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: o } = n;
                    if (this.hasPattern) {
                        const t1 = Wh("fill", this.layers, n, this.zoom, this.pixelRatio, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness, e.elevationFeatures);
                    e.featureIndex.insert(t1[s].feature, i, s, o, this.index);
                }
            }
            update(t1, e, r, n, i, s, o) {
                this.bufferData.update(t1, e, r, n, i, s, o, this.worldview), this.elevationBufferData.update(t1, e, r, n, i, s, o, this.worldview), this.elevatedStructures && this.elevatedStructures.update(t1, e, r, n, i, s, o, this.worldview);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const i of this.patternFeatures)this.addFeature(i, i.geometry, i.index, e, r, n, s, t1.elevationFeatures);
            }
            isEmpty() {
                return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
            }
            uploadPending() {
                return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
            }
            upload(t1) {
                this.bufferData.upload(t1), this.elevationBufferData.upload(t1), this.elevatedStructures && this.elevatedStructures.upload(t1);
            }
            destroy() {
                this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
            }
            addFeature(t1, e, r, n, i, s = [], o, a) {
                const l = Hh(e, 500);
                "none" !== this.elevationMode ? this.addElevatedRoadFeature(t1, l, n, r, a) : this.addGeometry(l, this.bufferData), this.bufferData.populatePaintArrays(t1, r, i, s, n, o, this.worldview), this.elevationBufferData.populatePaintArrays(t1, r, i, s, n, o, this.worldview);
            }
            getUnevaluatedPortalGraph() {
                return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
            }
            getElevationPolygons() {
                return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;
            }
            setEvaluatedPortalGraph(t1, e, r, n, i) {
                this.elevatedStructures && (this.elevatedStructures.construct(t1), this.elevatedStructures.populatePaintArrays(e, r, n, i, this.worldview));
            }
            addElevatedRoadFeature(t1, e, r, n, i) {
                const s = new Array, o = Gu.getElevationFeature(t1, i);
                if (!o) return void this.addGeometry(e, this.bufferData);
                {
                    const t1 = this.clipPolygonsToTile(e, 1);
                    t1.length > 0 && s.push({
                        polygons: t1,
                        elevationFeature: o,
                        elevationTileID: r
                    });
                }
                const a = {
                    guardRailEnabled: this.layers[0].layout.get("fill-construct-bridge-guard-rail").evaluate(t1, {}, r),
                    featureIndex: n
                };
                for (const e of s)if (e.elevationFeature) {
                    if ("hd-road-base" === this.elevationMode) {
                        this.elevatedStructures || (this.elevatedStructures = new Qh(e.elevationTileID, this.layers, this.zoom, this.lut));
                        const r = e.elevationFeature.isTunnel();
                        let n = 0;
                        t1.properties.hasOwnProperty(Pu) && (n = +t1.properties[Pu]);
                        for (const t1 of e.polygons)this.elevatedStructures.addPortalCandidates(e.elevationFeature.id, t1, r, e.elevationFeature, n);
                    }
                    null == e.elevationFeature.constantHeight && (e.polygons = this.prepareElevatedPolygons(e.polygons, e.elevationFeature, e.elevationTileID));
                    const i = new Hu(r, e.elevationTileID);
                    this.addElevatedGeometry(e.polygons, i, e.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : .05, n, a);
                }
            }
            addElevatedGeometry(t1, e, r, n, i, s) {
                const o = {
                    elevation: r,
                    elevationSampler: e,
                    bias: n,
                    index: i,
                    featureInfo: s
                }, [a, l] = this.addGeometry(t1, this.elevationBufferData, o);
                null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = {
                    min: a,
                    max: l
                } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, a), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, l));
            }
            addGeometry(t1, e, r) {
                let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, s = null;
                r && (s = r.elevationSampler.constantElevation(r.elevation, r.bias), null != s && (n = s, i = s));
                const o = (t1, o, a)=>{
                    if (null != r) if (o.push(t1), null != s) e.elevatedLayoutVertexArray.emplaceBack(s), a.push(s);
                    else {
                        const s = r.elevationSampler.pointElevation(t1, r.elevation, r.bias);
                        e.elevatedLayoutVertexArray.emplaceBack(s), a.push(s), n = Math.min(n, s), i = Math.max(i, s);
                    }
                };
                for (const n of t1){
                    let t1 = 0;
                    for (const e of n)t1 += e.length;
                    const i = e.triangleSegments.prepareSegment(t1, e.layoutVertexArray, e.indexArray), s = i.vertexLength, a = [], l = [], u = [], c = [], h = [], p = e.layoutVertexArray.length;
                    for (const t1 of n){
                        if (0 === t1.length) continue;
                        t1 !== n[0] && l.push(a.length / 2);
                        const i = e.lineSegments.prepareSegment(t1.length, e.layoutVertexArray, e.lineIndexArray), s = i.vertexLength;
                        r && h.push(e.layoutVertexArray.length - p), o(t1[0], u, c), e.layoutVertexArray.emplaceBack(t1[0].x, t1[0].y), e.lineIndexArray.emplaceBack(s + t1.length - 1, s), a.push(t1[0].x), a.push(t1[0].y);
                        for(let r = 1; r < t1.length; r++)o(t1[r], u, c), e.layoutVertexArray.emplaceBack(t1[r].x, t1[r].y), e.lineIndexArray.emplaceBack(s + r - 1, s + r), a.push(t1[r].x), a.push(t1[r].y);
                        i.vertexLength += t1.length, i.primitiveLength += t1.length;
                    }
                    const d = vh(a, l);
                    for(let t1 = 0; t1 < d.length; t1 += 3)e.indexArray.emplaceBack(s + d[t1], s + d[t1 + 1], s + d[t1 + 2]);
                    if (d.length > 0 && r && "hd-road-base" === this.elevationMode) {
                        const t1 = r.elevation.isTunnel(), e = r.elevation.safeArea, n = this.elevatedStructures.addVertices(u, c);
                        this.elevatedStructures.addTriangles(d, n, t1);
                        const i = h.length;
                        if (i > 0) {
                            for(let s = 0; s < i - 1; s++)this.elevatedStructures.addRenderableRing(r.index, h[s] + n, h[s + 1] - h[s], t1, e, r.featureInfo);
                            this.elevatedStructures.addRenderableRing(r.index, h[i - 1] + n, u.length - h[i - 1], t1, e, r.featureInfo);
                        }
                    }
                    i.vertexLength += t1, i.primitiveLength += d.length / 3;
                }
                return [
                    n,
                    i
                ];
            }
            prepareElevatedPolygons(t1, e, r) {
                const n = 1 / lu(r), i = [];
                for (const r of t1){
                    const t1 = sp(r, new ju(e, n));
                    i.push(...t1);
                }
                return i;
            }
            clipPolygonsToTile(t1, e) {
                const r = -e, n = -e, i = Cn + e, s = Cn + e;
                let o = 0;
                const a = [], l = [];
                for(; o < t1.length; o++){
                    const e = t1[o], u = pn(e);
                    (u.min.x >= r && u.max.x <= i && u.min.y >= n && u.max.y <= s ? a : l).push(e);
                }
                if (a.length === t1.length) return t1;
                const u = [
                    new bt(r, n),
                    new bt(i, n),
                    new bt(i, s),
                    new bt(r, s),
                    new bt(r, n)
                ], c = a;
                for (const t1 of l)c.push(...ip(t1, u));
                return c;
            }
        }
        let cp, hp, pp, dp;
        qs(up, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        }), qs(lp, "FillBufferData"), qs(Qh, "ElevatedStructures");
        class fp {
            constructor(t1, e, r, n){
                if (this.triangleCount = e.length / 3, this.min = new bt(0, 0), this.max = new bt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t1.length) return;
                const [i, s] = [
                    t1[0].clone(),
                    t1[0].clone()
                ];
                for(let e = 1; e < t1.length; ++e){
                    const r = t1[e];
                    i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), s.x = Math.max(s.x, r.x), s.y = Math.max(s.y, r.y);
                }
                if (n) {
                    const t1 = Math.ceil(Math.max(s.x - i.x, s.y - i.y) / n);
                    r = Math.max(r, t1);
                }
                if (0 === r) return;
                this.min = i, this.max = s;
                const o = this.max.sub(this.min);
                o.x = Math.max(o.x, 1), o.y = Math.max(o.y, 1);
                const a = Math.max(o.x, o.y) / r;
                this.cellsX = Math.max(1, Math.ceil(o.x / a)), this.cellsY = Math.max(1, Math.ceil(o.y / a)), this.xScale = 1 / a, this.yScale = 1 / a;
                const l = [];
                for(let r = 0; r < this.triangleCount; r++){
                    const n = t1[e[3 * r + 0]].sub(this.min), i = t1[e[3 * r + 1]].sub(this.min), s = t1[e[3 * r + 2]].sub(this.min), o = mp(Math.floor(Math.min(n.x, i.x, s.x)), this.xScale, this.cellsX), u = mp(Math.floor(Math.max(n.x, i.x, s.x)), this.xScale, this.cellsX), c = mp(Math.floor(Math.min(n.y, i.y, s.y)), this.yScale, this.cellsY), h = mp(Math.floor(Math.max(n.y, i.y, s.y)), this.yScale, this.cellsY), p = new bt(0, 0), d = new bt(0, 0), f = new bt(0, 0), m = new bt(0, 0);
                    for(let t1 = c; t1 <= h; ++t1){
                        p.y = d.y = t1 * a, f.y = m.y = (t1 + 1) * a;
                        for(let e = o; e <= u; ++e)p.x = f.x = e * a, d.x = m.x = (e + 1) * a, (lc(n, i, s, p, d, m) || lc(n, i, s, p, m, f)) && l.push({
                            cellIdx: t1 * this.cellsX + e,
                            triIdx: r
                        });
                    }
                }
                if (0 === l.length) return;
                l.sort((t1, e)=>t1.cellIdx - e.cellIdx || t1.triIdx - e.triIdx);
                let u = 0;
                for(; u < l.length;){
                    const t1 = l[u].cellIdx, e = {
                        start: this.payload.length,
                        len: 0
                    };
                    for(; u < l.length && l[u].cellIdx === t1;)++e.len, this.payload.push(l[u++].triIdx);
                    this.cells[t1] = e;
                }
            }
            _lazyInitLookup() {
                this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t1, e) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > t1.x || t1.y > this.max.y || this.min.y > t1.y) return;
                const r = mp(t1.x - this.min.x, this.xScale, this.cellsX), n = mp(t1.y - this.min.y, this.yScale, this.cellsY), i = this.cells[n * this.cellsX + r];
                if (i) {
                    this._lazyInitLookup();
                    for(let t1 = 0; t1 < i.len; t1++){
                        const r = this.payload[i.start + t1], n = Math.floor(r / 8), s = 1 << r % 8;
                        if (!(this.lookup[n] & s) && (this.lookup[n] |= s, e.push(r), e.length === this.triangleCount)) return;
                    }
                }
            }
            query(t1, e, r) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > e.x) return;
                if (t1.y > this.max.y || this.min.y > e.y) return;
                this._lazyInitLookup();
                const n = mp(t1.x - this.min.x, this.xScale, this.cellsX), i = mp(e.x - this.min.x, this.xScale, this.cellsX), s = mp(t1.y - this.min.y, this.yScale, this.cellsY), o = mp(e.y - this.min.y, this.yScale, this.cellsY);
                for(let t1 = s; t1 <= o; t1++)for(let e = n; e <= i; e++){
                    const n = this.cells[t1 * this.cellsX + e];
                    if (n) for(let t1 = 0; t1 < n.len; t1++){
                        const e = this.payload[n.start + t1], i = Math.floor(e / 8), s = 1 << e % 8;
                        if (!(this.lookup[i] & s) && (this.lookup[i] |= s, r.push(e), r.length === this.triangleCount)) return;
                    }
                }
            }
        }
        function mp(t1, e, r) {
            return Math.max(0, Math.min(r - 1, Math.floor(t1 * e)));
        }
        qs(fp, "TriangleGridIndex");
        class yp {
            constructor(t1){
                this.zoom = t1.zoom, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.footprints = [], this.worldview = t1.worldview;
            }
            updateFootprints(t1, e) {
                for (const r of this.footprints)e.push({
                    footprint: r,
                    id: t1
                });
            }
            populate(t1, e, r, n) {
                const i = [];
                for (const { feature: e, id: s, index: o, sourceLayerIndex: a } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = xu(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), l, r)) continue;
                    const u = {
                        id: s,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: a,
                        index: o,
                        geometry: t1 ? l.geometry : gu(e, r, n),
                        patterns: {}
                    };
                    i.push(u);
                }
                for (const n of i){
                    const { geometry: i, index: s, sourceLayerIndex: o } = n;
                    this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t1[s].feature, i, s, o, this.index);
                }
            }
            isEmpty() {
                return 0 === this.footprints.length;
            }
            uploadPending() {
                return !1;
            }
            upload(t1) {}
            update(t1, e, r, n, i, s, o) {}
            destroy() {}
            addFeature(t1, e, r, n, i, s = [], o) {
                for (const t1 of Hh(e, 2)){
                    const e = [], r = [], n = [], i = new bt(1 / 0, 1 / 0), s = new bt(-1 / 0, -1 / 0);
                    for (const o of t1)if (0 !== o.length) {
                        o !== t1[0] && n.push(r.length / 2);
                        for(let t1 = 0; t1 < o.length; t1++)r.push(o[t1].x), r.push(o[t1].y), e.push(o[t1]), i.x = Math.min(i.x, o[t1].x), i.y = Math.min(i.y, o[t1].y), s.x = Math.max(s.x, o[t1].x), s.y = Math.max(s.y, o[t1].y);
                    }
                    const o = vh(r, n), a = new fp(e, o, 8, 256);
                    this.footprints.push({
                        vertices: e,
                        indices: o,
                        grid: a,
                        min: i,
                        max: s
                    });
                }
            }
        }
        qs(yp, "ClipBucket", {
            omit: [
                "layers"
            ]
        });
        const gp = ea([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), xp = ea([
            {
                name: "a_pos_end",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_angular_offset_factor",
                components: 1,
                type: "Int16"
            }
        ]), vp = ea([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), bp = ea([
            {
                name: "a_join_normal_inside",
                components: 3,
                type: "Int16"
            }
        ]), wp = ea([
            {
                name: "a_hidden_by_landmark",
                components: 1,
                type: "Uint8"
            }
        ]), _p = ea([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: Ap } = gp, Mp = Number.MAX_SAFE_INTEGER, Ip = Mp - 1;
        function Sp(t1, e, r, n) {
            return t1.order < e || t1.order === Mp || !(t1.clipMask & r) || function(t1, e) {
                return 0 !== e.length && void 0 === e.find((e)=>e === t1);
            }(n, t1.clipScope);
        }
        function Pp(t1, e) {
            return t1.x - e.x || t1.y - e.y;
        }
        function Ep(t1, e) {
            return 0 === Pp(t1.min, e.min) && 0 === Pp(t1.max, e.max);
        }
        function kp(t1, e) {
            return !(t1.min.x > e.max.x || t1.max.x < e.min.x || t1.min.y > e.max.y || t1.max.y < e.min.y);
        }
        function zp(t1, e) {
            if (t1.length !== e.length) return !1;
            for(let r = 0; r < t1.length; r++)if (t1[r].sourceId !== e[r].sourceId || !Ep(t1[r], e[r]) || t1[r].order !== e[r].order || t1[r].clipMask !== e[r].clipMask || !wt(t1[r].clipScope, e[r].clipScope)) return !1;
            return !0;
        }
        function Tp(t1, e, r) {
            const n = 1 / Cn, i = 1 / (1 << r.canonical.z), s = (e.x * n + r.canonical.x) * i + r.wrap, o = (e.y * n + r.canonical.y) * i;
            return {
                min: new bt((t1.x * n + r.canonical.x) * i + r.wrap, (t1.y * n + r.canonical.y) * i),
                max: new bt(s, o)
            };
        }
        function Bp(t1, e, r) {
            const n = 1 << r.canonical.z, i = ((e.x - r.wrap) * n - r.canonical.x) * Cn, s = (e.y * n - r.canonical.y) * Cn;
            return {
                min: new bt(((t1.x - r.wrap) * n - r.canonical.x) * Cn, (t1.y * n - r.canonical.y) * Cn),
                max: new bt(i, s)
            };
        }
        function Vp(t1, e, r, n, i, s, o) {
            const a = t1.indices, l = t1.vertices, u = [];
            for(let c = n; c < n + i; c += 3){
                const n = e[r[c + 0] + s], i = e[r[c + 1] + s], h = e[r[c + 2] + s], p = Math.min(n.x, i.x, h.x), d = Math.max(n.x, i.x, h.x), f = Math.min(n.y, i.y, h.y), m = Math.max(n.y, i.y, h.y);
                u.length = 0, t1.grid.query(new bt(p, f), new bt(d, m), u);
                for(let t1 = 0; t1 < u.length; t1++){
                    const e = u[t1];
                    if (lc(l[a[3 * e + 0]], l[a[3 * e + 1]], l[a[3 * e + 2]], n, i, h, o)) return !0;
                }
            }
            return !1;
        }
        function Cp(t1, e, r, n) {
            if (!t1 || !r) return !1;
            let i = t1.vertices;
            if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {
                if (r.vertices.length < t1.vertices.length) return Cp(r, n, t1, e);
                const s = e.canonical, o = n.canonical, a = Math.pow(2, o.z - s.z);
                i = t1.vertices.map((t1)=>new bt((t1.x + s.x * Cn) * a - o.x * Cn, (t1.y + s.y * Cn) * a - o.y * Cn));
            }
            return Vp(r, i, t1.indices, 0, t1.indices.length, 0, 0);
        }
        function Fp(t1, e, r, n) {
            const i = Math.pow(2, n.z - r.z);
            return new bt((t1 + r.x * Cn) * i - n.x * Cn, (e + r.y * Cn) * i - n.y * Cn);
        }
        function Dp(t1, e) {
            const r = [];
            e.grid.queryPoint(t1, r);
            const n = e.indices, i = e.vertices;
            for(let e = 0; e < r.length; e++){
                const s = r[e];
                if (ic([
                    i[n[3 * s + 0]],
                    i[n[3 * s + 1]],
                    i[n[3 * s + 2]]
                ], t1)) return !0;
            }
            return !1;
        }
        const Lp = [
            new bt(0, 0),
            new bt(Cn, 0),
            new bt(Cn, Cn),
            new bt(0, Cn)
        ];
        function Rp(t1, e) {
            const r = [];
            let n = [];
            if (!e || t1.length < 2) return [
                t1
            ];
            if (2 === t1.length) return oc(t1[0], t1[1], Lp) ? [
                t1
            ] : [];
            for(let e = 0; e < t1.length + 2; e++){
                const i = t1[e % t1.length], s = t1[(e + 1) % t1.length], o = oc(0 === e ? t1[t1.length - 1] : t1[(e - 1) % t1.length], i, Lp), a = oc(i, s, Lp), l = o || a;
                l && n.push(i), l && a || n.length > 0 && (n.length > 1 && r.push(n), n = []);
            }
            return n.length > 1 && r.push(n), r;
        }
        const Op = vu.types, Up = [
            "fill-extrusion-base",
            "fill-extrusion-height",
            "fill-extrusion-color",
            "fill-extrusion-pattern",
            "fill-extrusion-flood-light-wall-radius",
            "fill-extrusion-line-width",
            "fill-extrusion-emissive-strength"
        ], Np = [
            "fill-extrusion-flood-light-ground-radius"
        ], jp = Math.pow(2, 13), $p = Math.pow(2, 15) - 1, Gp = new bt(0, 1), Hp = 2147483648;
        function qp(t1, e, r, n, i, s, o, a) {
            t1.emplaceBack((e << 1) + o, (r << 1) + s, (Math.floor(n * jp) << 1) + i, Math.round(a));
        }
        function Xp(t1, e, r) {
            t1.emplaceBack(e.x * Cn, e.y * Cn, r ? 1 : 0);
        }
        function Zp(t1, e, r, n, i, s) {
            t1.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, s);
        }
        function Wp(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Yp {
            constructor(){
                this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
        }
        class Kp {
            constructor(){
                this.centroidXY = new bt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new bt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new bt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0;
            }
            span() {
                return new bt(this.max.x - this.min.x, this.max.y - this.min.y);
            }
        }
        class Jp {
            constructor(){
                this.acc = new bt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t1, e) {
                t1.min.x === Number.MAX_VALUE && (t1.min.x = t1.max.x = e.x, t1.min.y = t1.max.y = e.y);
            }
            appendEdge(t1, e, r) {
                this.accCount++, this.acc._add(e);
                let n = !!this.borders;
                e.x < t1.min.x ? (t1.min.x = e.x, n = !0) : e.x > t1.max.x && (t1.max.x = e.x, n = !0), e.y < t1.min.y ? (t1.min.y = e.y, n = !0) : e.y > t1.max.y && (t1.max.y = e.y, n = !0), ((0 === e.x || e.x === Cn) && e.x === r.x) != ((0 === e.y || e.y === Cn) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);
            }
            checkBorderIntersection(t1, e) {
                e.x < 0 != t1.x < 0 && this.addBorderIntersection(0, ur(e.y, t1.y, (0 - e.x) / (t1.x - e.x))), e.x > Cn != t1.x > Cn && this.addBorderIntersection(1, ur(e.y, t1.y, (Cn - e.x) / (t1.x - e.x))), e.y < 0 != t1.y < 0 && this.addBorderIntersection(2, ur(e.x, t1.x, (0 - e.y) / (t1.y - e.y))), e.y > Cn != t1.y > Cn && this.addBorderIntersection(3, ur(e.x, t1.x, (Cn - e.y) / (t1.y - e.y)));
            }
            addBorderIntersection(t1, e) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
            }
            processBorderOverlap(t1, e) {
                if (t1.x === e.x) {
                    if (t1.y === e.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                return 0 === this.accCount ? new bt(0, 0) : new bt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
                return this.borders ? this.borders.reduce((t1, e)=>t1 + +(e[0] !== Number.MAX_VALUE), 0) : 0;
            }
        }
        function Qp(t1, e) {
            const r = t1.add(e)._unit(), n = zt(t1.x * r.x + t1.y * r.y, -1, 1);
            var i, s, o;
            return i = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(i))) / 4 * $p * ((s = t1).x * (o = e).y - s.y * o.x < 0 ? -1 : 1);
        }
        const td = [
            (t1)=>t1.x < 0,
            (t1)=>t1.x > Cn,
            (t1)=>t1.y < 0,
            (t1)=>t1.y > Cn
        ];
        function ed(t1, e, r, n) {
            const i = [
                4
            ];
            if (0 === n) return i;
            r._mult(n);
            const s = t1.sub(r), o = e.sub(r), a = [
                t1,
                e,
                s,
                o
            ];
            for(let t1 = 0; t1 < 4; t1++)for (const e of a)if (td[t1](e)) {
                i.push(t1);
                break;
            }
            return i;
        }
        class rd {
            constructor(t1){
                this.vertexArray = new ua, this.indexArray = new Ma, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Np.includes(t1)), this._segments = new el, this.hiddenByLandmarkVertexArray = new Ra, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [
                    0,
                    0,
                    0,
                    0,
                    0
                ], this.regionSegments = {}, this.regionSegments[4] = new el;
            }
            getDefaultSegment() {
                return this.regionSegments[4];
            }
            hasData() {
                return 0 !== this.vertexArray.length;
            }
            addData(t1, e, r, n = !1) {
                const i = t1.length;
                if (i > 2) {
                    let s = Math.max(0, this._segments.get().length - 1);
                    const o = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);
                    let a;
                    s !== this._segments.get().length - 1 && (s++, this._segmentToGroundQuads[s] = [], this._segmentToRegionTriCounts[s] = [
                        0,
                        0,
                        0,
                        0,
                        0
                    ]);
                    {
                        const e = t1[0], r = t1[1];
                        a = Qp(e.sub(t1[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());
                    }
                    for(let l = 0; l < i; l++){
                        const u = l === i - 1 ? 0 : l + 1, c = t1[l], h = t1[u], p = t1[u === i - 1 ? 0 : u + 1], d = h.sub(c)._perp()._unit(), f = Qp(d, p.sub(h)._perp()._unit()), m = a, y = f;
                        if (ad(c, h, e) || n && ld(c, e) && ld(h, e)) {
                            a = f;
                            continue;
                        }
                        const g = o.vertexLength;
                        Zp(this.vertexArray, c, h, 1, 1, m), Zp(this.vertexArray, c, h, 1, 0, m), Zp(this.vertexArray, c, h, 0, 1, y), Zp(this.vertexArray, c, h, 0, 0, y), o.vertexLength += 4;
                        const x = ed(c, h, d, r);
                        for (const t1 of x)this._segmentToGroundQuads[s].push({
                            id: g,
                            region: t1
                        }), this._segmentToRegionTriCounts[s][t1] += 2, o.primitiveLength += 2;
                        a = f;
                    }
                }
            }
            prepareBorderSegments() {
                if (!this.hasData()) return;
                const t1 = this._segments.get(), e = t1.length;
                for(let t1 = 0; t1 < e; t1++)this._segmentToGroundQuads[t1].sort((t1, e)=>t1.region - e.region);
                for(let r = 0; r < e; r++){
                    const e = this._segmentToGroundQuads[r], n = t1[r], i = this._segmentToRegionTriCounts[r];
                    i.reduce((t1, e)=>t1 + e, 0);
                    let s = 0;
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = i[t1];
                        if (0 !== e) {
                            let r = this.regionSegments[t1];
                            r || (r = this.regionSegments[t1] = new el);
                            const i = {
                                vertexOffset: n.vertexOffset,
                                primitiveOffset: n.primitiveOffset + s,
                                vertexLength: n.vertexLength,
                                primitiveLength: e
                            };
                            r.get().push(i);
                        }
                        s += e;
                    }
                    for(let t1 = 0; t1 < e.length; t1++){
                        const r = e[t1].id;
                        this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);
                    }
                }
                this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t1, e, r, n, i, s, o) {
                this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t1, e, r, n, i, s, void 0, o);
            }
            upload(t1) {
                this.hasData() && (this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, xp.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray));
            }
            uploadPaintProperties(t1) {
                this.hasData() && this.programConfigurations.upload(t1);
            }
            update(t1, e, r, n, i, s, o, a) {
                this.hasData() && this.programConfigurations.updatePaintArrays(t1, e, r, n, i, s, o, a);
            }
            updateHiddenByLandmark(t1) {
                this.updateHiddenByLandmarkRange(t1.groundVertexArrayOffset, t1.groundVertexCount, !!(t1.flags & Hp));
            }
            updateHiddenByLandmarkRange(t1, e, r) {
                if (!this.hasData()) return;
                const n = e + t1;
                if (0 !== e) {
                    for(let e = t1; e < n; ++e)this.hiddenByLandmarkVertexArray.emplace(e, r ? 1 : 0);
                    this._needsHiddenByLandmarkUpdate = !0;
                }
            }
            uploadHiddenByLandmark(t1) {
                this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t1.createVertexBuffer(this.hiddenByLandmarkVertexArray, wp.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
            }
            destroy() {
                if (this.vertexBuffer) {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = this.regionSegments[t1];
                        e && e.destroy();
                    }
                }
            }
        }
        class nd {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.pixelRatio = t1.pixelRatio, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Ma, this.footprintVertices = new na, this.footprintSegments = [], this.layoutVertexArray = new sa, this.centroidVertexArray = new Wa, this.wallVertexArray = new Ka, this.indexArray = new Ma, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Up.includes(t1)), this.segments = new el, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.groundEffect = new rd(t1), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = t1.worldview;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.features = [], this.hasPattern = Zh("fill-extrusion", this.layers, this.pixelRatio, e), this.featuresOnBorder = [], this.borderFeatureIndices = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE
                ], this.tileToMeter = lu(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
                for (const { feature: i, id: s, index: o, sourceLayerIndex: a } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = xu(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), l, r)) continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: a,
                        index: o,
                        geometry: t1 ? l.geometry : gu(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length, h = "Polygon" === Op[u.type];
                    if (this.hasPattern) this.features.push({
                        featureId: i.id,
                        feature: Wh("fill-extrusion", this.layers, u, this.zoom, this.pixelRatio, e)
                    });
                    else if (this.wallMode) for (const t1 of u.geometry)for (const s of Rp(t1, h))this.addFeature(i.id, u, [
                        s
                    ], o, r, {}, e.availableImages, n, e.brightness);
                    else this.addFeature(i.id, u, u.geometry, o, r, {}, e.availableImages, n, e.brightness);
                    e.featureIndex.insert(i, u.geometry, o, a, this.index, c);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const { featureId: t1, feature: o } of this.features){
                    const a = "Polygon" === Op[o.type], { geometry: l } = o;
                    if (this.wallMode) for (const u of l)for (const l of Rp(u, a))this.addFeature(t1, o, [
                        l
                    ], o.index, e, r, n, i, s);
                    else this.addFeature(t1, o, l, o.index, e, r, n, i, s);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t1, e, r, n, i, s, o) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, this.worldview), this.groundEffect.update(t1, e, i, r, n, s, o, this.worldview);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Ap), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t1.createVertexBuffer(this.wallVertexArray, bp.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, _p.members, !0)), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                this.groundEffect.uploadHiddenByLandmark(t1), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, vp.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e, r, n, i, s, o, a, l) {
                const u = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, c = [
                    new bt(0, 0),
                    new bt(Cn, Cn)
                ], h = a.projection, p = "globe" === h.name, d = this.wallMode || "Polygon" === Op[e.type], f = new Jp;
                f.centroidDataIndex = this.centroidData.length;
                const m = new Kp;
                m.buildingId = t1, e.properties && e.properties.hasOwnProperty("building_id") && (m.buildingId = e.properties.building_id);
                const y = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, i) <= 0, g = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, i);
                let x;
                if (m.height = g, m.vertexArrayOffset = this.layoutVertexArray.length, m.groundVertexArrayOffset = this.groundEffect.vertexArray.length, p && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new fa), this.wallMode) {
                    if (p) return void Gt("Non zero fill-extrusion-line-width is not yet supported on globe.");
                    if (1 !== r.length) return;
                    x = function(t1) {
                        const e = t1[0].x === t1[t1.length - 1].x && t1[0].y === t1[t1.length - 1].y, r = function(t1) {
                            let e = 0;
                            const r = t1.length;
                            for(let n = 0; n < r; n++)e += (t1[(n + 1) % r].x - t1[n].x) * (t1[(n + 1) % r].y + t1[n].y);
                            return e >= 0;
                        }(t1);
                        r || (t1 = t1.reverse());
                        const n = {
                            geometry: [],
                            joinNormals: [],
                            indices: []
                        }, i = [], s = [], o = [];
                        let a = t1.length;
                        for(; a >= 2 && t1[a - 1].equals(t1[a - 2]);)a--;
                        if (a < (e ? 3 : 2)) return n;
                        let l, u, c, h, p, d = 0;
                        for(; d < a - 1 && t1[d].equals(t1[d + 1]);)d++;
                        e && (l = t1[a - 2], p = t1[d].sub(l)._unit()._perp());
                        for(let r = d; r < a; r++){
                            if (c = r === a - 1 ? e ? t1[d + 1] : void 0 : t1[r + 1], c && t1[r].equals(c)) continue;
                            p && (h = p), l && (u = l), l = t1[r], p = c ? c.sub(l)._unit()._perp() : h, h = h || p;
                            let n = h.add(p);
                            0 === n.x && 0 === n.y || n._unit();
                            const f = n.x * p.x + n.y * p.y, m = 0 !== f ? 1 / f : 1 / 0, y = h.x * p.y - h.y * p.x > 0;
                            let g = "miter";
                            const x = 2;
                            "miter" === g && m > x && (g = "bevel"), "bevel" === g && (m > 100 && (g = "flipbevel"), m < x && (g = "miter"));
                            const v = (t1, e, r, n)=>{
                                const a = new bt(t1.x, t1.y), l = new bt(t1.x, t1.y);
                                a.x += e.x * n, a.y += e.y * n, l.x -= e.x * Math.max(r, 1), l.y -= e.y * Math.max(r, 1), o.push(e), i.push(a), s.push(l);
                            };
                            if ("miter" === g) n._mult(m), v(l, n, 0, 0);
                            else if ("flipbevel" === g) n = p.mult(-1), v(l, n, 0, 0), v(l, n.mult(-1), 0, 0);
                            else {
                                const t1 = -Math.sqrt(m * m - 1), e = y ? t1 : 0, r = y ? 0 : t1;
                                u && v(l, h, e, r), c && v(l, p, e, r);
                            }
                        }
                        n.geometry = [
                            ...i,
                            ...s.reverse(),
                            i[0]
                        ], n.joinNormals = [
                            ...o,
                            ...o.reverse(),
                            o[o.length - 1]
                        ];
                        const f = n.geometry.length - 1;
                        for(let t1 = 0; t1 < f / 2; t1++)if (t1 + 1 < f / 2) {
                            let e = t1, r = t1 + 1, i = f - 1 - t1, s = f - 2 - t1;
                            e = 0 === e ? f - 1 : e - 1, r = 0 === r ? f - 1 : r - 1, i = 0 === i ? f - 1 : i - 1, s = 0 === s ? f - 1 : s - 1, n.indices.push(i), n.indices.push(r), n.indices.push(e), n.indices.push(i), n.indices.push(s), n.indices.push(r);
                        }
                        return n;
                    }(r[0]), r = [
                        x.geometry
                    ];
                }
                const v = (t1, e)=>t1 < (e.length - 1) / 2 || t1 === e.length - 1, b = this.wallMode ? [
                    r
                ] : Hh(r, 500);
                for(let t1 = b.length - 1; t1 >= 0; t1--){
                    const e = b[t1];
                    (0 === e.length || (w = e[0]).every((t1)=>t1.x <= 0) || w.every((t1)=>t1.x >= Cn) || w.every((t1)=>t1.y <= 0) || w.every((t1)=>t1.y >= Cn)) && b.splice(t1, 1);
                }
                var w;
                let _;
                if (p) _ = pd(b, c, i);
                else {
                    _ = [];
                    for (const t1 of b)_.push({
                        polygon: t1,
                        bounds: c
                    });
                }
                const A = d ? this.edgeRadius : 0, M = A > 0 && this.zoom < 17, I = (t1, e)=>{
                    if (0 === t1.length) return !1;
                    const r = t1[t1.length - 1];
                    return e.x === r.x && e.y === r.y;
                };
                for (const { polygon: t1, bounds: e } of _){
                    let r = 0, n = 0;
                    for (const e of t1)d && !e[0].equals(e[e.length - 1]) && e.push(e[0]), n += d ? e.length - 1 : e.length;
                    const s = this.segments.prepareSegment((d ? 5 : 4) * n, this.layoutVertexArray, this.indexArray);
                    m.footprintSegIdx < 0 && (m.footprintSegIdx = this.footprintSegments.length), m.polygonSegIdx < 0 && (m.polygonSegIdx = this.polygonSegments.length);
                    const o = {
                        triangleArrayOffset: this.indexArray.length,
                        triangleCount: 0,
                        triangleSegIdx: this.segments.segments.length - 1
                    }, a = new Yp;
                    if (a.vertexOffset = this.footprintVertices.length, a.indexOffset = 3 * this.footprintIndices.length, a.ringIndices = [], d) {
                        const n = [], o = [];
                        r = s.vertexLength;
                        for(let r = 0; r < t1.length; r++){
                            const l = t1[r];
                            l.length && 0 !== r && o.push(n.length / 2);
                            const c = [];
                            let d, f;
                            d = l[1].sub(l[0])._perp()._unit(), a.ringIndices.push(l.length - 1);
                            for(let t1 = 1; t1 < l.length; t1++){
                                const e = l[t1], r = l[t1 === l.length - 1 ? 1 : t1 + 1], o = e.clone();
                                if (A) {
                                    f = r.sub(e)._perp()._unit();
                                    const t1 = d.add(f)._unit(), n = A * Math.min(4, 1 / (d.x * t1.x + d.y * t1.y));
                                    o.x += n * t1.x, o.y += n * t1.y, o.x = Math.round(o.x), o.y = Math.round(o.y), d = f;
                                }
                                if (!y || 0 !== A && !M || I(c, o) || c.push(o), qp(this.layoutVertexArray, o.x, o.y, 0, 0, 1, 1, 0), this.wallMode) {
                                    const e = v(t1, l);
                                    Xp(this.wallVertexArray, x.joinNormals[t1], !e);
                                }
                                s.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), n.push(e.x, e.y), p && Wp(this.layoutVertexExtArray, h.projectTilePoint(o.x, o.y, i), h.upVector(i, o.x, o.y));
                            }
                            y && (0 === A || M) && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u));
                        }
                        const l = this.wallMode ? x.indices : vh(n, o);
                        for(let t1 = 0; t1 < l.length; t1 += 3)this.footprintIndices.emplaceBack(a.vertexOffset + l[t1 + 0], a.vertexOffset + l[t1 + 1], a.vertexOffset + l[t1 + 2]), this.indexArray.emplaceBack(r + l[t1], r + l[t1 + 2], r + l[t1 + 1]), s.primitiveLength++;
                        a.indexCount += l.length, a.vertexCount += this.footprintVertices.length - a.vertexOffset;
                    }
                    for(let n = 0; n < t1.length; n++){
                        const o = t1[n];
                        f.startRing(m, o[0]);
                        let a = o.length > 4 && ud(o[o.length - 2], o[0], o[1]), l = A ? sd(o[o.length - 2], o[0], o[1], A) : 0;
                        const c = [];
                        let g, b, w;
                        b = o[1].sub(o[0])._perp()._unit();
                        let _ = !0;
                        for(let t1 = 1, n = 0; t1 < o.length; t1++){
                            let u = o[t1 - 1], d = o[t1];
                            const M = o[t1 === o.length - 1 ? 1 : t1 + 1];
                            if (f.appendEdge(m, d, u), ad(d, u, e)) {
                                A && (b = M.sub(d)._perp()._unit(), _ = !_);
                                continue;
                            }
                            const S = d.sub(u)._perp(), P = S.x / (Math.abs(S.x) + Math.abs(S.y)), E = S.y > 0 ? 1 : 0, k = u.dist(d);
                            if (n + k > 32768 && (n = 0), A) {
                                w = M.sub(d)._perp()._unit();
                                let t1 = od(u, d, M, id(b, w), A);
                                isNaN(t1) && (t1 = 0);
                                const e = d.sub(u)._unit();
                                u = u.add(e.mult(l))._round(), d = d.add(e.mult(-t1))._round(), l = t1, b = w, y && this.zoom >= 17 && (I(c, u) || c.push(u), I(c, d) || c.push(d));
                            }
                            const z = s.vertexLength, T = o.length > 4 && ud(u, d, M);
                            let B = cd(n, a, _);
                            if (qp(this.layoutVertexArray, u.x, u.y, P, E, 0, 0, B), qp(this.layoutVertexArray, u.x, u.y, P, E, 0, 1, B), this.wallMode) {
                                const e = v(t1 - 1, o), r = x.joinNormals[t1 - 1];
                                Xp(this.wallVertexArray, r, e), Xp(this.wallVertexArray, r, e);
                            }
                            if (n += k, B = cd(n, T, !_), a = T, qp(this.layoutVertexArray, d.x, d.y, P, E, 0, 0, B), qp(this.layoutVertexArray, d.x, d.y, P, E, 0, 1, B), this.wallMode) {
                                const e = v(t1, o), r = x.joinNormals[t1];
                                Xp(this.wallVertexArray, r, e), Xp(this.wallVertexArray, r, e);
                            }
                            if (s.vertexLength += 4, this.indexArray.emplaceBack(z + 0, z + 1, z + 2), this.indexArray.emplaceBack(z + 1, z + 3, z + 2), s.primitiveLength += 2, A) {
                                const n = r + (1 === t1 ? o.length - 2 : t1 - 2), i = 1 === t1 ? r : n + 1;
                                if (this.indexArray.emplaceBack(z + 1, n, z + 3), this.indexArray.emplaceBack(n, i, z + 3), s.primitiveLength += 2, void 0 === g && (g = z), !ad(M, o[t1], e)) {
                                    const e = t1 === o.length - 1 ? g : s.vertexLength;
                                    this.indexArray.emplaceBack(z + 2, z + 3, e), this.indexArray.emplaceBack(z + 3, e + 1, e), this.indexArray.emplaceBack(z + 3, i, e + 1), s.primitiveLength += 3;
                                }
                                _ = !_;
                            }
                            if (p) {
                                const t1 = this.layoutVertexExtArray, e = h.projectTilePoint(u.x, u.y, i), r = h.projectTilePoint(d.x, d.y, i), n = h.upVector(i, u.x, u.y), s = h.upVector(i, d.x, d.y);
                                Wp(t1, e, n), Wp(t1, e, n), Wp(t1, r, s), Wp(t1, r, s);
                            }
                        }
                        d && (r += o.length - 1), y && A && this.zoom >= 17 && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u, A > 0));
                    }
                    this.footprintSegments.push(a), o.triangleCount = this.indexArray.length - o.triangleArrayOffset, this.polygonSegments.push(o), ++m.footprintSegLen, ++m.polygonSegLen;
                }
                if (m.vertexCount = this.layoutVertexArray.length - m.vertexArrayOffset, m.groundVertexCount = this.groundEffect.vertexArray.length - m.groundVertexArrayOffset, 0 !== m.vertexCount) {
                    if (m.centroidXY = f.borders ? Gp : this.encodeCentroid(f, m), this.centroidData.push(m), f.borders) {
                        this.featuresOnBorder.push(f);
                        const t1 = this.featuresOnBorder.length - 1;
                        for(let e = 0; e < f.borders.length; e++)f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t1);
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, s, o, i, l, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(e, n, s, o, i, l, this.worldview), this.maxHeight = Math.max(this.maxHeight, g);
                }
            }
            sortBorders() {
                for(let t1 = 0; t1 < this.borderFeatureIndices.length; t1++)this.borderFeatureIndices[t1].sort((e, r)=>this.featuresOnBorder[e].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            splitToSubtiles() {
                const t1 = [];
                for(let e = 0; e < this.centroidData.length; e++){
                    const r = this.centroidData[e], n = +(r.min.y + r.max.y > Cn), i = 2 * n + (+(r.min.x + r.max.x > Cn) ^ n);
                    for(let n = 0; n < r.polygonSegLen; n++){
                        const s = r.polygonSegIdx + n;
                        t1.push({
                            centroidIdx: e,
                            subtile: i,
                            polygonSegmentIdx: s,
                            triangleSegmentIdx: this.polygonSegments[s].triangleSegIdx
                        });
                    }
                }
                const e = new Ma;
                t1.sort((t1, e)=>t1.triangleSegmentIdx === e.triangleSegmentIdx ? t1.subtile - e.subtile : t1.triangleSegmentIdx - e.triangleSegmentIdx);
                let r = 0, n = 0, i = 0;
                for (const e of t1){
                    if (e.triangleSegmentIdx !== r) break;
                    i++;
                }
                const s = t1.length;
                for(; n !== t1.length;){
                    r = t1[n].triangleSegmentIdx;
                    let o = 0, a = n, l = n;
                    for(let e = a; e < i && t1[e].subtile === o; e++)l++;
                    for(; a !== i;){
                        const n = t1[a];
                        o = n.subtile;
                        const s = this.centroidData[n.centroidIdx].min.clone(), u = this.centroidData[n.centroidIdx].max.clone(), c = {
                            vertexOffset: this.segments.segments[r].vertexOffset,
                            primitiveOffset: e.length,
                            vertexLength: this.segments.segments[r].vertexLength,
                            primitiveLength: 0,
                            sortKey: void 0,
                            vaos: {}
                        };
                        for(let r = a; r < l; r++){
                            const n = t1[r], i = this.polygonSegments[n.polygonSegmentIdx], o = this.centroidData[n.centroidIdx].min, a = this.centroidData[n.centroidIdx].max, l = this.indexArray.uint16;
                            for(let t1 = i.triangleArrayOffset; t1 < i.triangleArrayOffset + i.triangleCount; t1++)e.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
                            c.primitiveLength += i.triangleCount, s.x = Math.min(s.x, o.x), s.y = Math.min(s.y, o.y), u.x = Math.max(u.x, a.x), u.y = Math.max(u.y, a.y);
                        }
                        c.primitiveLength > 0 && this.triangleSubSegments.push({
                            segment: c,
                            min: s,
                            max: u
                        }), a = l;
                        for(let e = a; e < i && t1[e].subtile === t1[a].subtile; e++)l++;
                    }
                    n = i;
                    for(let e = n; e < s && t1[e].triangleSegmentIdx === t1[n].triangleSegmentIdx; e++)i++;
                }
                e._trim(), this.indexArray = e;
            }
            getVisibleSegments(t1, e, r) {
                const n = new el;
                if (this.wallMode) {
                    for (const t1 of this.triangleSubSegments)n.segments.push(t1.segment);
                    return n;
                }
                let i = 0, s = 0;
                const o = 1 << t1.canonical.z;
                if (e) {
                    const r = e.getMinMaxForTile(t1);
                    r && (i = r.min, s = r.max);
                }
                s += this.maxHeight;
                const a = t1.toUnwrapped();
                let l;
                const u = [
                    a.canonical.x / o + a.wrap,
                    a.canonical.y / o
                ], c = [
                    (a.canonical.x + 1) / o + a.wrap,
                    (a.canonical.y + 1) / o
                ], h = (t1, e, r)=>[
                        t1[0] * (1 - r[0]) + e[0] * r[0],
                        t1[1] * (1 - r[1]) + e[1] * r[1]
                    ], p = [], d = [];
                for (const t1 of this.triangleSubSegments){
                    p[0] = t1.min.x / Cn, p[1] = t1.min.y / Cn, d[0] = t1.max.x / Cn, d[1] = t1.max.y / Cn;
                    const e = h(u, c, p), o = h(u, c, d);
                    if (0 === new Nu([
                        e[0],
                        e[1],
                        i
                    ], [
                        o[0],
                        o[1],
                        s
                    ]).intersectsPrecise(r)) {
                        l && (n.segments.push(l), l = void 0);
                        continue;
                    }
                    const a = t1.segment;
                    l && l.vertexOffset !== a.vertexOffset && (n.segments.push(l), l = void 0), l ? (l.vertexLength += a.vertexLength, l.primitiveLength += a.primitiveLength) : l = {
                        vertexOffset: a.vertexOffset,
                        primitiveLength: a.primitiveLength,
                        vertexLength: a.vertexLength,
                        primitiveOffset: a.primitiveOffset,
                        sortKey: void 0,
                        vaos: {}
                    };
                }
                return l && n.segments.push(l), n;
            }
            encodeCentroid(t1, e) {
                const r = t1.centroid(), n = e.span(), i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)), s = Math.min(7, Math.round(n.y * this.tileToMeter / 10));
                return new bt(zt(r.x, 1, Cn - 1) << 3 | i, zt(r.y, 1, Cn - 1) << 3 | s);
            }
            encodeBorderCentroid(t1) {
                if (!t1.borders) return new bt(0, 0);
                const e = t1.borders, r = Number.MAX_VALUE;
                if (e[0][0] !== r || e[1][0] !== r) {
                    const t1 = e[0][0] !== r ? 0 : 1;
                    return new bt(6 | (e[0][0] !== r ? 0 : 65528), (e[t1][0] + e[t1][1]) / 2 << 3 | 6);
                }
                {
                    const t1 = e[2][0] !== r ? 2 : 3;
                    return new bt((e[t1][0] + e[t1][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));
                }
            }
            showCentroid(t1) {
                const e = this.centroidData[t1.centroidDataIndex];
                e.flags &= 2147483647, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);
            }
            writeCentroidToBuffer(t1) {
                this.groundEffect.updateHiddenByLandmark(t1);
                const e = t1.vertexArrayOffset, r = t1.vertexCount + t1.vertexArrayOffset, n = t1.flags & Hp ? Gp : t1.centroidXY, i = this.centroidVertexArray.geta_centroid_pos0(e);
                if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {
                    for(let t1 = e; t1 < r; ++t1)this.centroidVertexArray.emplace(t1, n.x, n.y);
                    this.needsCentroidUpdate = !0;
                }
            }
            createCentroidsBuffer() {
                this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (zp(this.activeReplacements, n)) return;
                if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
                else for (const t1 of this.centroidData)t1.flags &= 2147483647;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order < r) continue;
                    const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z));
                    if (e.footprint.buildingId) {
                        const t1 = e.footprint.buildingId;
                        for (const e of this.centroidData)e.buildingId === t1 && (e.flags |= Hp);
                    } else for (const r of this.centroidData)if (!(r.flags & Hp || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for(let s = 0; s < r.footprintSegLen; s++){
                        const o = this.footprintSegments[r.footprintSegIdx + s];
                        if (i.length = 0, dd(this.footprintVertices, o.vertexOffset, o.vertexCount, e.footprintTileId.canonical, t1.canonical, i), Vp(e.footprint, i, this.footprintIndices.uint16, o.indexOffset, o.indexCount, -o.vertexOffset, -n)) {
                            r.flags |= Hp;
                            break;
                        }
                    }
                }
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
                this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ];
            }
            footprintContainsPoint(t1, e, r) {
                let n = !1;
                for(let i = 0; i < r.footprintSegLen; i++){
                    const s = this.footprintSegments[r.footprintSegIdx + i];
                    let o = 0;
                    for (const r of s.ringIndices){
                        for(let i = o, a = r + o - 1; i < r + o; a = i++){
                            const r = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 0], o = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 1], l = this.footprintVertices.int16[2 * (a + s.vertexOffset) + 1];
                            o > e != l > e && t1 < (this.footprintVertices.int16[2 * (a + s.vertexOffset) + 0] - r) * (e - o) / (l - o) + r && (n = !n);
                        }
                        o = r;
                    }
                }
                return n;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + Cn) * Cn + (e + Cn);
                if (this.partLookup.hasOwnProperty(i)) {
                    const t1 = this.partLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: !!(t1.flags & Hp)
                    } : void 0;
                }
                for (const s of this.centroidData)t1 > s.max.x || s.min.x > t1 || e > s.max.y || s.min.y > e || s.height <= r || this.footprintContainsPoint(t1, e, s) && (r = s.height, this.partLookup[i] = s, n = !!(s.flags & Hp));
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.partLookup[i] = void 0;
            }
        }
        function id(t1, e) {
            const r = t1.add(e)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function sd(t1, e, r, n) {
            const i = e.sub(t1)._perp()._unit(), s = r.sub(e)._perp()._unit();
            return od(t1, e, r, id(i, s), n);
        }
        function od(t1, e, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e) / 3, e.dist(r) / 3, i * s / n);
        }
        function ad(t1, e, r) {
            return t1.x < r[0].x && e.x < r[0].x || t1.x > r[1].x && e.x > r[1].x || t1.y < r[0].y && e.y < r[0].y || t1.y > r[1].y && e.y > r[1].y;
        }
        function ld(t1, e) {
            return t1.x < e[0].x || t1.x > e[1].x || t1.y < e[0].y || t1.y > e[1].y;
        }
        function ud(t1, e, r) {
            if (t1.x < 0 || t1.x >= Cn || e.x < 0 || e.x >= Cn || r.x < 0 || r.x >= Cn) return !1;
            const n = r.sub(e), i = n.perp(), s = t1.sub(e);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;
        }
        function cd(t1, e, r) {
            const n = e ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function hd() {
            const t1 = Math.PI / 32, e = Math.tan(t1), r = Hl;
            return r * Math.sqrt(1 + 2 * e * e) - r;
        }
        function pd(t1, e, r) {
            const n = 1 << r.z, i = eu(r.x / n), s = eu((r.x + 1) / n), o = ru(r.y / n), a = ru((r.y + 1) / n);
            return function(t1, e, r, n, i = 0, s) {
                const o = [];
                if (!t1.length || !r || !n) return o;
                const a = (t1, e)=>{
                    for (const r of t1)o.push({
                        polygon: r,
                        bounds: e
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = np(p, e[0].y - i, e[1].y + i, 1), p = np(p, e[0].x - i, e[1].x + i, 0), !p.length) return o;
                const d = [];
                for(h.length ? d.push({
                    polygons: p,
                    bounds: e,
                    depth: 0
                }) : a(p, e); d.length;){
                    const t1 = d.pop(), e = t1.depth, r = h[e], n = t1.bounds[0], o = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? o.x : o.y, c = ("TURBOPACK compile-time truthy", 1) ? s(r, l, u) : "TURBOPACK unreachable", p = np(t1.polygons, l - i, c + i, r), f = np(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new bt(0 === r ? c : o.x, 1 === r ? c : o.y)
                        ];
                        h.length > e + 1 ? d.push({
                            polygons: p,
                            bounds: t1,
                            depth: e + 1
                        }) : a(p, t1);
                    }
                    if (f.length) {
                        const t1 = [
                            new bt(0 === r ? c : n.x, 1 === r ? c : n.y),
                            o
                        ];
                        h.length > e + 1 ? d.push({
                            polygons: f,
                            bounds: t1,
                            depth: e + 1
                        }) : a(f, t1);
                    }
                }
                return o;
            }(t1, e, Math.ceil((s - i) / 11.25), Math.ceil((o - a) / 11.25), 1, (t1, e, i)=>{
                if (0 === t1) return .5 * (e + i);
                {
                    const t1 = ru((r.y + e / Cn) / n);
                    return (Ql(.5 * (ru((r.y + i / Cn) / n) + t1)) * n - r.y) * Cn;
                }
            });
        }
        function dd(t1, e, r, n, i, s) {
            const o = Math.pow(2, n.z - i.z);
            for(let a = 0; a < r; a++){
                let r = t1.int16[2 * (a + e) + 0], l = t1.int16[2 * (a + e) + 1];
                r = (r + i.x * Cn) * o - n.x * Cn, l = (l + i.y * Cn) * o - n.y * Cn, s.push(new bt(r, l));
            }
        }
        let fd, md;
        qs(nd, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), qs(Kp, "PartData"), qs(Yp, "FootprintSegment"), qs(Jp, "BorderCentroidData"), qs(rd, "GroundEffect");
        class yd extends bt {
            constructor(t1, e, r){
                super(t1, e), this.z = r;
            }
        }
        class gd extends yd {
            constructor(t1, e, r, n){
                super(t1, e, r), this.w = n;
            }
        }
        function xd(t1, e, r, n) {
            const i = "x" === r ? "y" : "x", s = (n - t1[r]) / (e[r] - t1[r]);
            t1[i] = Math.round(t1[i] + (e[i] - t1[i]) * s), t1[r] = n, t1.hasOwnProperty("z") && (t1.z = ur(t1.z, e.z, s)), t1.hasOwnProperty("w") && (t1.w = ur(t1.w, e.w, s));
        }
        function vd(t1, e, r, n) {
            const i = r, s = n;
            for (const r of [
                "x",
                "y"
            ]){
                let n = t1, o = e;
                n[r] >= o[r] && (n = e, o = t1), n[r] < i && o[r] > i && xd(n, o, r, i), n[r] < s && o[r] > s && xd(o, n, r, s);
            }
        }
        function bd(t1, e, r, n, i, s) {
            const o = [];
            for(let a = 0; a < t1.length; a++){
                const l = t1[a];
                let u;
                const c = o.length;
                let h = 0;
                for(let t1 = 0; t1 < l.length - 1; t1++){
                    let c = l[t1], p = l[t1 + 1], d = 0;
                    const f = h;
                    let m, y;
                    s && (d = Math.hypot(p.x - c.x, p.y - c.y), h += d, m = c, y = p), c.x < e && p.x < e || (c.x < e ? c = new bt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x < e && (p = new bt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y < r && p.y < r || (c.y < r ? c = new bt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round() : p.y < r && (p = new bt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round()), c.x >= n && p.x >= n || (c.x >= n ? c = new bt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x >= n && (p = new bt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y >= i && p.y >= i || (c.y >= i ? c = new bt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round() : p.y >= i && (p = new bt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round()), u && c.equals(u[u.length - 1]) || (u = [
                        c
                    ], o.push(u), s && s.push({
                        progress: {
                            min: f + _d(m, y, c) * d,
                            max: 1
                        },
                        parentIndex: a,
                        prevPoint: m,
                        nextPoint: y
                    })), u.push(p), s && (s[s.length - 1].progress.max = f + _d(m, y, p) * d, s[s.length - 1].nextPoint = y)))));
                }
                if (s && h > 0) for(let t1 = c; t1 < o.length; t1++)s[t1].progress.min /= h, s[t1].progress.max /= h;
            }
            return o;
        }
        function wd(t1, e, r, n, i) {
            if (t1.length < 2) return void n.push(t1);
            const s = [];
            for(; e.valid();){
                const [r, n] = e.get();
                for(let e = 0; e < t1.length - 1; e++){
                    const i = t1[e], o = t1[e + 1], a = tc(i, o, r, n);
                    if (a) {
                        const [t1] = a, r = new bt(ur(i.x, o.x, t1), ur(i.y, o.y, t1));
                        s.push({
                            t: e + t1,
                            distance: 0,
                            point: r
                        });
                    }
                }
                e.next();
            }
            if (0 === s.length) return void n.push(t1);
            s.sort((t1, e)=>t1.t - e.t);
            let o = 0, a = 0, l = [];
            for(n.push(l); o !== t1.length;){
                if (a === s.length) {
                    for(; o !== t1.length;)0 !== l.length && l[l.length - 1].equals(t1[o]) || l.push(t1[o]), o++;
                    break;
                }
                s[a].t <= o ? (0 !== l.length && l[l.length - 1].equals(s[a].point) || l.push(s[a].point), Math.trunc(s[a].t), a++) : (0 !== l.length && l[l.length - 1].equals(t1[o]) || l.push(t1[o]), o++);
            }
        }
        function _d(t1, e, r) {
            return t1.x !== e.x ? (r.x - t1.x) / (e.x - t1.x) : t1.y !== e.y ? (r.y - t1.y) / (e.y - t1.y) : 0;
        }
        function Ad(t1, e) {
            return t1.x * e.x + t1.y * e.y;
        }
        function Md(t1, e) {
            if (1 === t1.length) {
                let r = 0;
                const n = e[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e[r++], !i) return 1 / 0;
                for(; r < e.length; r++){
                    const s = e[r], o = t1[0], a = i.sub(n), l = s.sub(n), u = o.sub(n), c = Ad(a, a), h = Ad(a, l), p = Ad(l, l), d = Ad(u, a), f = Ad(u, l), m = c * p - h * h, y = (p * d - h * f) / m, g = (c * f - h * d) / m, x = n.z * (1 - y - g) + i.z * y + s.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function Id(t1, e, r, n, i, s, o, a) {
            const l = o * i.getElevationAt(t1, e, !0, !0), u = 0 !== s[0], c = u ? 0 === s[1] ? o * (s[0] / 7 - 450) : o * function(t1, e, r) {
                const n = Math.floor(e[0] / 8), i = Math.floor(e[1] / 8), s = 10 * (e[0] - 8 * n), o = 10 * (e[1] - 8 * i), a = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (s * l - 1)), c = Math.floor(.5 * (o * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, d = 2 * c + 1, f = function(t1, e, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e, r, !0),
                        t1.getElevationAtPixel(e + i, r, !0),
                        t1.getElevationAtPixel(e, r + i, !0),
                        t1.getElevationAtPixel(e + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, d), m = Math.abs(f[0] - f[1]), y = Math.abs(f[2] - f[3]), g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]), x = Math.min(.25, .5 * l * (m + y) / p), v = Math.min(.25, .5 * l * g / d);
                return a + Math.max(x * s, v * o);
            }(i, s, a) : l;
            return {
                base: l + (0 === r ? -1 : r),
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        class Sd {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class Pd {
            constructor(){
                this.tasks = {}, this.taskQueue = [], Rt([
                    "process"
                ], this), this.invoker = new Sd(this.process), this.nextId = 0;
            }
            add(t1, e) {
                const r = this.nextId++, n = function({ type: t1, isSymbolTile: e, zoom: r }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e ? "parseTile" !== t1 || e ? "parseTile" === t1 && e ? 300 - r : "maybePrepare" === t1 && e ? 400 - r : 500 : 200 - r : 100 - r;
                }(e);
                if (0 === n) {
                    try {
                        t1();
                    } finally{}
                    return null;
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                try {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e) return;
                    e.fn();
                } finally{}
            }
            pick() {
                let t1 = null, e = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e && (e = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class Ed {
            constructor(t1, e, r){
                this.target = t1, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, Rt([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new Pd;
            }
            send(t1, e, r, n, i = !1, s) {
                const o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[o] = r);
                const a = new Set;
                return this.target.postMessage({
                    id: o,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Ws(e, a)
                }, a), {
                    cancel: ()=>{
                        r && delete this.callbacks[o], this.target.postMessage({
                            id: o,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e = t1.data;
                if (!e) return;
                const r = e.id;
                if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
                    const t1 = this.cancelCallbacks[r];
                    delete this.cancelCallbacks[r], t1 && t1.cancel();
                } else if (e.mustQueue || Zt(self)) {
                    const t1 = this.callbacks[r], n = this.scheduler.add(()=>this.processTask(r, e), t1 && t1.metadata || {
                        type: "message"
                    });
                    n && (this.cancelCallbacks[r] = n);
                } else this.processTask(r, e);
            }
            processTask(t1, e) {
                if (delete this.cancelCallbacks[t1], "<response>" === e.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e.error ? r(Ys(e.error)) : r(null, Ys(e.data)));
                } else {
                    const r = new Set, n = e.hasCallback ? (e, n)=>{
                        this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? Ws(e) : null,
                            data: Ws(n, r)
                        }, r);
                    } : ()=>{}, i = Ys(e.data);
                    if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e.type.split("."), { source: r, scope: s } = i;
                        this.parent.getWorkerSource(e.sourceMapId, t1[0], r, s)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }
        var kd = {
            workerUrl: "",
            workerClass: null,
            workerParams: void 0
        };
        const zd = "mapboxgl_preloaded_worker_pool";
        class Td {
            constructor(){
                this.active = {};
            }
            acquire(t1, e = Td.workerCount) {
                if (!this.workers) for(this.workers = []; this.workers.length < e;)this.workers.push(null != kd.workerClass ? new kd.workerClass : new self.Worker(kd.workerUrl, kd.workerParams));
                return this.active[t1] = !0, this.workers.slice();
            }
            release(t1) {
                delete this.active[t1], this.workers && 0 === this.numActive() && (this.workers.forEach((t1)=>{
                    t1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[zd];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        Td.workerCount = 2;
        class Bd {
            constructor(t1, e, r = "Worker", n = Td.workerCount){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = Dt();
                const i = this.workerPool.acquire(this.id, n);
                for(let t1 = 0; t1 < i.length; t1++){
                    const n = new Bd.Actor(i[t1], e, this.id);
                    n.name = `${r} ${t1}`, this.actors.push(n);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, e, r) {
                Vt(this.actors, (r, n)=>{
                    r.send(t1, e, n);
                }, r = r || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((t1)=>{
                    t1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        let Vd, Cd;
        function Fd() {
            return Vd || (Vd = new Td), Vd;
        }
        Bd.Actor = Ed;
        class Dd {
            constructor(t1){
                this.module = t1;
            }
            createIntArray(t1) {
                const e = new Int32Array(t1), r = this.module.malloc(e.length * e.BYTES_PER_ELEMENT);
                return this.module.heap32.set(e, r / e.BYTES_PER_ELEMENT), r;
            }
            createFloatArray(t1) {
                const e = new Float32Array(t1), r = this.module.malloc(e.length * e.BYTES_PER_ELEMENT);
                return this.module.heapF32.set(e, r / e.BYTES_PER_ELEMENT), r;
            }
            createStringBuffer(t1) {
                const e = this.module.malloc(t1.length + 1);
                for(let r = 0; r < t1.length; ++r)this.module.heapU8[e + r] = t1.charCodeAt(r);
                return this.module.heapU8[e + t1.length] = 0, e;
            }
            readStringBuffer(t1) {
                let e = "";
                for(; 0 !== this.module.heapU8[t1];)e += String.fromCharCode(this.module.heapU8[t1]), ++t1;
                return e;
            }
            setStyle(t1) {
                const e = t1.entranceColorRgb, r = t1.facadeGlazingColorRgb, n = t1.roofColorRgb, i = t1.wallColorRgb, s = t1.normalScale;
                this.module.setStyle(e[0], e[1], e[2], r[0], r[1], r[2], n[0], n[1], n[2], i[0], i[1], i[2], s[0], s[1], s[2], t1.tileToMeters);
            }
            setAOOptions(t1, e) {
                this.module.setAOOptions(t1 ? 1 : 0, e);
            }
            setMetricOptions(t1, e) {
                this.module.setMetricOptions(t1 ? 1 : 0, e);
            }
            setStructuralOptions(t1) {
                this.module.setStructuralOptions(t1 ? 1 : 0);
            }
            setFacadeOptions(t1, e) {
                this.module.setFacadeOptions(t1, e ? 1 : 0);
            }
            setFauxFacadeOptions(t1, e, r) {
                this.module.setFauxFacadeOptions(t1 ? 1 : 0, e ? 1 : 0, r);
            }
            setFacadeClassifierOptions(t1) {
                this.module.setFacadeClassifierOptions(t1);
            }
            generateMesh(t1, e) {
                for (const e of t1){
                    const t1 = this.createStringBuffer(e.roofType), r = [
                        0
                    ], n = [];
                    for (const t1 of e.coordinates)if (Array.isArray(t1)) {
                        for (const e of t1)n.push(e.x), n.push(e.y);
                        r.push(n.length);
                    }
                    const i = this.createIntArray(r), s = this.createFloatArray(n);
                    this.module.addFeature(e.id, e.sourceId, e.minHeight, e.height, t1, e.roofType.length, s, i, r.length - 1), this.module.free(t1), this.module.free(i), this.module.free(s);
                }
                for (const t1 of e){
                    let e;
                    e = t1.entrances ? JSON.parse(t1.entrances) : [];
                    const r = this.createFloatArray(e), n = [];
                    for (const e of t1.coordinates)n.push(e.x), n.push(e.y);
                    const i = this.createFloatArray(n);
                    this.module.addFacade(t1.sourceId, t1.crossPerc, t1.distanceToRoad, r, e.length, i, n.length), this.module.free(r), this.module.free(i);
                }
                if (!this.module.generateMesh()) {
                    const t1 = this.module.getLastError();
                    return this.readStringBuffer(t1);
                }
                const r = this.module.getMeshCount(), n = new Array(r);
                for(let t1 = 0; t1 < r; t1++){
                    const e = this.module.getPositionsPtr(t1), r = this.module.getPositionsLength(t1), i = new Float32Array(this.module.heapF32.buffer, e, r), s = this.module.getNormalsPtr(t1), o = this.module.getNormalsLength(t1), a = new Float32Array(this.module.heapF32.buffer, s, o), l = this.module.getColorsPtr(t1), u = this.module.getColorsLength(t1), c = new Uint8Array(this.module.heapU8.buffer, l, u), h = this.module.getAOPtr(t1), p = this.module.getAOLength(t1), d = new Float32Array(this.module.heapF32.buffer, h, p), f = this.module.getUVPtr(t1), m = this.module.getUVLength(t1), y = new Float32Array(this.module.heapF32.buffer, f, m), g = this.module.getFauxFacadePtr(t1), x = this.module.getFauxFacadeLength(t1), v = new Uint8Array(this.module.heapU8.buffer, g, x), b = this.module.getIndicesPtr(t1), w = this.module.getIndicesLength(t1), _ = new Int32Array(this.module.heap32.buffer, b, w), A = this.module.getBuildingPart(t1), M = this.readStringBuffer(A);
                    n[t1] = {
                        positions: i,
                        normals: a,
                        colors: c,
                        ao: d,
                        uv: y,
                        isFauxFacade: v,
                        indices: _,
                        buildingPart: M
                    };
                }
                const i = this.module.getRingCount(), s = [];
                for(let t1 = 0; t1 < i; t1++){
                    const e = this.module.getRingPtr(t1), r = this.module.getRingLength(t1), n = new Float32Array(this.module.heapF32.buffer, e, r);
                    s.push(n);
                }
                return {
                    meshes: n,
                    modifiedPolygonRings: s
                };
            }
        }
        let Ld, Rd, Od, Ud, Nd, jd = null, $d = null, Gd = null, Hd = null;
        function qd() {
            return Zt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : Rd || ne.DRACO_URL;
        }
        function Xd() {
            if (Zt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
            if (Ud) return Ud;
            const t1 = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                3,
                2,
                0,
                0,
                5,
                3,
                1,
                0,
                1,
                12,
                1,
                0,
                10,
                22,
                2,
                12,
                0,
                65,
                0,
                65,
                0,
                65,
                0,
                252,
                10,
                0,
                0,
                11,
                7,
                0,
                65,
                0,
                253,
                15,
                26,
                11
            ]);
            if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return Ud = WebAssembly.validate(t1) ? ne.MESHOPT_SIMD_URL : ne.MESHOPT_URL, Ud;
        }
        function Zd() {
            return Hd;
        }
        const Wd = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }, Yd = {
            5120: "DT_INT8",
            5121: "DT_UINT8",
            5122: "DT_INT16",
            5123: "DT_UINT16",
            5125: "DT_UINT32",
            5126: "DT_FLOAT32"
        }, Kd = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
        function Jd(t1, e, r) {
            const n = r.json.bufferViews.length, i = r.buffers.length;
            e.bufferView = n, r.json.bufferViews[n] = {
                buffer: i,
                byteLength: t1.byteLength
            }, r.buffers[i] = t1;
        }
        const Qd = "KHR_draco_mesh_compression";
        function tf(t1, e) {
            const r = t1.extensions && t1.extensions[Qd];
            if (!r) return;
            const n = new Od.Decoder, i = lf(e, r.bufferView), s = new Od.Mesh;
            if (!n.DecodeArrayToMesh(i, i.byteLength, s)) throw new Error("Failed to decode Draco mesh");
            const o = e.json.accessors[t1.indices], a = Wd[o.componentType], l = o.count * a.BYTES_PER_ELEMENT, u = Od._malloc(l);
            a === Uint16Array ? n.GetTrianglesUInt16Array(s, l, u) : n.GetTrianglesUInt32Array(s, l, u), Jd(Od.memory.buffer.slice(u, u + l), o, e), Od._free(u);
            for (const i of Object.keys(r.attributes)){
                const o = n.GetAttributeByUniqueId(s, r.attributes[i]), a = e.json.accessors[t1.attributes[i]], l = Yd[a.componentType], u = a.count * Kd[a.type] * Wd[a.componentType].BYTES_PER_ELEMENT, c = Od._malloc(u);
                n.GetAttributeDataArrayForAllPoints(s, o, Od[l], u, c), Jd(Od.memory.buffer.slice(c, c + u), a, e), Od._free(c);
            }
            n.destroy(), s.destroy(), delete t1.extensions[Qd];
        }
        const ef = "EXT_meshopt_compression";
        function rf(t1, e) {
            if (!t1.extensions || !t1.extensions[ef]) return;
            const r = t1.extensions[ef], n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0), i = new Uint8Array(r.count * r.byteStride);
            Nd.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t1.buffer = e.buffers.length, t1.byteOffset = 0, e.buffers[t1.buffer] = i.buffer, delete t1.extensions[ef];
        }
        const nf = 1179937895, sf = new TextDecoder("utf8");
        function of(t1, e) {
            return new URL(t1, e).href;
        }
        function af(t1, e, r, n) {
            return fetch(of(t1.uri, n)).then((t1)=>t1.arrayBuffer()).then((t1)=>{
                e.buffers[r] = t1;
            });
        }
        function lf(t1, e) {
            const r = t1.json.bufferViews[e];
            return new Uint8Array(t1.buffers[r.buffer], r.byteOffset || 0, r.byteLength);
        }
        function uf(t1, e, r, n) {
            if (t1.uri) {
                const i = of(t1.uri, n);
                return fetch(i).then((t1)=>t1.blob()).then((t1)=>createImageBitmap(t1)).then((t1)=>{
                    e.images[r] = t1;
                });
            }
            if (void 0 !== t1.bufferView) {
                const n = lf(e, t1.bufferView), i = new Blob([
                    n
                ], {
                    type: t1.mimeType
                });
                return createImageBitmap(i).then((t1)=>{
                    e.images[r] = t1;
                });
            }
        }
        function cf(t1, e = 0, r) {
            const n = {
                json: null,
                images: [],
                buffers: []
            };
            if (new Uint32Array(t1, e, 1)[0] === nf) {
                const r = new Uint32Array(t1, e);
                let i = 2;
                const s = (r[i++] >> 2) - 3, o = r[i++] >> 2;
                if (i++, n.json = JSON.parse(sf.decode(r.subarray(i, i + o))), i += o, i < s) {
                    const s = r[i++];
                    i++;
                    const o = e + (i << 2);
                    n.buffers[0] = t1.slice(o, o + s);
                }
            } else n.json = JSON.parse(sf.decode(new Uint8Array(t1, e)));
            const { buffers: i, images: s, meshes: o, extensionsUsed: a, bufferViews: l } = n.json;
            let u = Promise.resolve();
            if (i) {
                const t1 = [];
                for(let e = 0; e < i.length; e++){
                    const s = i[e];
                    s.uri ? t1.push(af(s, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);
                }
                u = Promise.all(t1);
            }
            return u.then(()=>{
                const t1 = [], e = a && a.includes(Qd), i = a && a.includes(ef);
                if (e && t1.push(function() {
                    if (!Od) return null != Ld ? Ld : (Ld = function(t1) {
                        let e, r = null;
                        function n() {
                            e = new Uint8Array(r.buffer);
                        }
                        function i() {
                            throw new Error("Unexpected Draco error.");
                        }
                        const s = {
                            a: {
                                a: i,
                                d: function(t1, r, n) {
                                    return e.copyWithin(t1, r, r + n);
                                },
                                c: function(t1) {
                                    const i = e.length, s = Math.max(t1 >>> 0, Math.ceil(1.2 * i)), o = Math.ceil((s - i) / 65536);
                                    try {
                                        return r.grow(o), n(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                b: i
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, s) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, s))).then((t1)=>{
                            const { Rb: i, Qb: s, P: o, T: a, X: l, Ja: u, La: c, Qa: h, Va: p, Wa: d, eb: f, jb: m, f: y, e: g, yb: x, zb: v, Ab: b, Bb: w, Db: _, Gb: A } = t1.instance.exports;
                            r = g;
                            const M = (()=>{
                                let t1 = 0, r = 0, n = 0, o = 0;
                                return (a)=>{
                                    n && (i(o), i(t1), r += n, n = t1 = 0), t1 || (r += 128, t1 = s(r));
                                    const l = a.length + 7 & -8;
                                    let u = t1;
                                    l >= r && (n = l, u = o = s(l));
                                    for(let t1 = 0; t1 < a.length; t1++)e[u + t1] = a[t1];
                                    return u;
                                };
                            })();
                            return n(), y(), {
                                memory: g,
                                _free: i,
                                _malloc: s,
                                Mesh: class {
                                    constructor(){
                                        this.ptr = o();
                                    }
                                    destroy() {
                                        a(this.ptr);
                                    }
                                },
                                Decoder: class {
                                    constructor(){
                                        this.ptr = u();
                                    }
                                    destroy() {
                                        m(this.ptr);
                                    }
                                    DecodeArrayToMesh(t1, e, r) {
                                        const n = M(t1), i = c(this.ptr, n, e, r.ptr);
                                        return !!l(i);
                                    }
                                    GetAttributeByUniqueId(t1, e) {
                                        return {
                                            ptr: h(this.ptr, t1.ptr, e)
                                        };
                                    }
                                    GetTrianglesUInt16Array(t1, e, r) {
                                        p(this.ptr, t1.ptr, e, r);
                                    }
                                    GetTrianglesUInt32Array(t1, e, r) {
                                        d(this.ptr, t1.ptr, e, r);
                                    }
                                    GetAttributeDataArrayForAllPoints(t1, e, r, n, i) {
                                        f(this.ptr, t1.ptr, e.ptr, r, n, i);
                                    }
                                },
                                DT_INT8: x(),
                                DT_UINT8: v(),
                                DT_INT16: b(),
                                DT_UINT16: w(),
                                DT_UINT32: _(),
                                DT_FLOAT32: A()
                            };
                        });
                    }(fetch(qd())), Ld.then((t1)=>{
                        Od = t1, Ld = void 0;
                    }));
                }()), i && t1.push(function() {
                    if (Nd) return;
                    const t1 = function(t1) {
                        let e;
                        const r = WebAssembly.instantiateStreaming(t1, {}).then((t1)=>{
                            e = t1.instance, e.exports.__wasm_call_ctors();
                        }), n = {
                            NONE: "",
                            OCTAHEDRAL: "meshopt_decodeFilterOct",
                            QUATERNION: "meshopt_decodeFilterQuat",
                            EXPONENTIAL: "meshopt_decodeFilterExp"
                        }, i = {
                            ATTRIBUTES: "meshopt_decodeVertexBuffer",
                            TRIANGLES: "meshopt_decodeIndexBuffer",
                            INDICES: "meshopt_decodeIndexSequence"
                        };
                        return {
                            ready: r,
                            supported: !0,
                            decodeGltfBuffer (t1, r, s, o, a, l) {
                                !function(t1, e, r, n, i, s, o) {
                                    const a = t1.exports.sbrk, l = n + 3 & -4, u = a(l * i), c = a(s.length), h = new Uint8Array(t1.exports.memory.buffer);
                                    h.set(s, c);
                                    const p = e(u, n, i, c, s.length);
                                    if (0 === p && o && o(u, l, i), r.set(h.subarray(u, u + n * i)), a(u - a(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);
                                }(e, e.exports[i[a]], t1, r, s, o, e.exports[n[l]]);
                            }
                        };
                    }(fetch(Xd()));
                    return t1.ready.then(()=>{
                        Nd = t1;
                    });
                }()), s) for(let e = 0; e < s.length; e++)t1.push(uf(s[e], n, e, r));
                return (t1.length ? Promise.all(t1) : Promise.resolve()).then(()=>{
                    if (e && o) for (const { primitives: t1 } of o)for (const e of t1)tf(e, n);
                    if (i && o && l) for (const t1 of l)rf(t1, n);
                    return n;
                });
            });
        }
        function hf(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.RGBA;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.DEPTH_COMPONENT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.DEPTH_STENCIL;
                case WebGL2RenderingContext.R8:
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.RED;
            }
        }
        function pf(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.UNSIGNED_SHORT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                case WebGL2RenderingContext.R8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.FLOAT;
            }
        }
        class df {
            constructor(t1, e, r, n){
                this.context = t1, this.format = r, this.useMipmap = n && n.useMipmap, this.texture = t1.gl.createTexture(), this.update(e, {
                    premultiply: n && n.premultiply
                });
            }
            update(t1, e) {
                const r = t1 && t1 instanceof HTMLVideoElement && 0 === t1.width ? t1.videoWidth : t1.width, n = t1 && t1 instanceof HTMLVideoElement && 0 === t1.height ? t1.videoHeight : t1.height, { context: i } = this, { gl: s } = i, { x: o, y: a } = e && e.position ? e.position : {
                    x: 0,
                    y: 0
                }, l = o + r, u = a + n;
                !this.size || this.size[0] === l && this.size[1] === u || (s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(this.texture), this.texture = s.createTexture(), this.size = null), s.bindTexture(s.TEXTURE_2D, this.texture), i.pixelStoreUnpackFlipY.set(!1), i.pixelStoreUnpack.set(1), i.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA8 && (!e || !1 !== e.premultiply));
                const c = t1 instanceof HTMLImageElement || t1 instanceof HTMLCanvasElement || t1 instanceof HTMLVideoElement || t1 instanceof ImageData || ImageBitmap && t1 instanceof ImageBitmap;
                if (!this.size && l > 0 && u > 0) {
                    const t1 = this.useMipmap ? Math.floor(Math.log2(Math.max(l, u))) + 1 : 1;
                    s.texStorage2D(s.TEXTURE_2D, t1, this.format, l, u), this.size = [
                        l,
                        u
                    ];
                }
                if (this.size) if (c) s.texSubImage2D(s.TEXTURE_2D, 0, o, a, hf(this.format), pf(this.format), t1);
                else {
                    const e = t1.data;
                    e && s.texSubImage2D(s.TEXTURE_2D, 0, o, a, r, n, hf(this.format), pf(this.format), e);
                }
                this.useMipmap && s.generateMipmap(s.TEXTURE_2D);
            }
            bind(t1, e, r = !1) {
                const { context: n } = this, { gl: i } = n;
                i.bindTexture(i.TEXTURE_2D, this.texture), t1 !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t1), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t1 === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            bindExtraParam(t1, e, r, n, i) {
                const { context: s } = this, { gl: o } = s;
                o.bindTexture(o.TEXTURE_2D, this.texture), e !== this.magFilter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), this.magFilter = e), t1 !== this.minFilter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === o.NEAREST ? o.NEAREST_MIPMAP_NEAREST : o.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), r !== this.wrapS && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, n), this.wrapT = n), i !== this.compareMode && (i ? (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_MODE, o.COMPARE_REF_TO_TEXTURE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_FUNC, i)) : o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_MODE, o.NONE), this.compareMode = i);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class ff {
            constructor(t1, e){
                this.context = t1, this.texture = e;
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
        }
        const mf = ea([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), yf = ea([
            {
                name: "a_color_3f",
                components: 3,
                type: "Float32"
            }
        ]), gf = ea([
            {
                name: "a_color_4f",
                components: 4,
                type: "Float32"
            }
        ]), xf = ea([
            {
                name: "a_uv_2f",
                components: 2,
                type: "Float32"
            }
        ]), vf = ea([
            {
                name: "a_normal_3f",
                components: 3,
                type: "Float32"
            }
        ]), bf = ea([
            {
                name: "a_normal_matrix0",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix1",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix2",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix3",
                components: 4,
                type: "Float32"
            }
        ]), wf = ea([
            {
                name: "a_pbr",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_heightBasedEmissiveStrength",
                components: 3,
                type: "Float32"
            }
        ]);
        function _f(t1, e) {
            const r = Mf(t1.projection, t1.zoom, t1.width, t1.height), n = function(t1, e, r, n, i) {
                const s = new Xl(r.lng - 180 * If, r.lat), o = new Xl(r.lng + 180 * If, r.lat), a = t1.project(s.lng, s.lat), u = t1.project(o.lng, o.lat), h = -Math.atan2(u.y - a.y, u.x - a.x), d = uu.fromLngLat(r);
                d.y = zt(d.y, -1 + If, 1 - If);
                const f = d.toLngLat(), y = t1.project(f.lng, f.lat), g = uu.fromLngLat(f);
                g.x += If;
                const x = g.toLngLat(), v = t1.project(x.lng, x.lat), b = Pf(v.x - y.x, v.y - y.y, h), w = uu.fromLngLat(f);
                w.y += If;
                const _ = w.toLngLat(), A = t1.project(_.lng, _.lat), M = Pf(A.x - y.x, A.y - y.y, h), I = Math.abs(b.x) / Math.abs(M.y), S = l([]);
                m(S, S, -h * (1 - (i ? 0 : n)));
                const P = l([]);
                return p(P, P, [
                    1,
                    1 - (1 - I) * n,
                    1
                ]), P[4] = -M.x / M.y * n, m(P, P, h), c(P, S, P), P;
            }(t1.projection, 0, t1.center, r, e), i = Af(t1);
            return p(n, n, [
                i,
                i,
                1
            ]), n;
        }
        function Af(t1) {
            const e = t1.projection, r = Mf(t1.projection, t1.zoom, t1.width, t1.height), n = Sf(e, t1.center), i = Sf(e, Xl.convert(e.center));
            return Math.pow(2, n * r + (1 - r) * i);
        }
        function Mf(t1, e, r, n, i = 1 / 0) {
            const s = t1.range;
            if (!s) return 0;
            const o = Math.min(i, Math.max(r, n)), a = Math.log(o / 1024) / Math.LN2;
            return Tt(s[0] + a, s[1] + a, e);
        }
        const If = 1 / 4e4;
        function Sf(t1, e) {
            const r = zt(e.lat, -iu, iu), n = new Xl(e.lng - 180 * If, r), i = new Xl(e.lng + 180 * If, r), s = t1.project(n.lng, r), o = t1.project(i.lng, r), a = uu.fromLngLat(n), l = uu.fromLngLat(i), u = o.x - s.x, c = o.y - s.y, h = l.x - a.x, p = l.y - a.y, d = Math.sqrt((h * h + p * p) / (u * u + c * c));
            return Math.log(d) / Math.LN2;
        }
        function Pf(t1, e, r) {
            const n = Math.cos(r), i = Math.sin(r);
            return {
                x: t1 * n - e * i,
                y: t1 * i + e * n
            };
        }
        function Ef(t1, e, r) {
            l(t1), m(t1, t1, Mt(e[2])), d(t1, t1, Mt(e[0])), f(t1, t1, Mt(e[1])), p(t1, t1, r), c(t1, t1, [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1
            ]);
        }
        function kf(t1, e, r, n, i, s, o, a) {
            const l = [
                r[0] - e[0],
                r[1] - e[1],
                0
            ], u = [
                n[0] - e[0],
                n[1] - e[1],
                0
            ];
            if (_(l) < 1e-12 || _(u) < 1e-12) return J(t1);
            const c = L([], l, u);
            F(c, c), S(u, n, e), l[2] = (s - i) * a, u[2] = (o - i) * a;
            const h = l;
            return L(h, l, u), F(h, h), st(t1, c, h);
        }
        function zf(t1, e, r = !1) {
            const n = Gc(e.zoom), i = function(t1, e, r) {
                const n = e.worldSize, i = [
                    t1[12],
                    t1[13],
                    t1[14]
                ], s = ru(i[1] / n), o = eu(i[0] / n), a = l([]), u = tu(1, s) * n, d = tu(1, 0) * n * ou(s, e.zoom), f = 1 / Nc(n);
                let m = d * f;
                if (r) {
                    const t1 = Mf(e.projection, e.zoom, e.width, e.height, 1024);
                    m = f * e.projection.pixelSpaceConversion(e.center.lat, n, t1);
                }
                const y = Gl(s, o);
                I(y, y, z([], F([], y), u * m * i[2]));
                const g = function(t1) {
                    const e = [
                        t1[0],
                        t1[1],
                        t1[2]
                    ];
                    let r = [
                        0,
                        1,
                        0
                    ];
                    const n = L([], r, e);
                    return L(r, e, n), 0 === V(r) && (r = [
                        0,
                        1,
                        0
                    ], L(n, e, r)), F(n, n), F(r, r), F(e, e), [
                        n[0],
                        n[1],
                        n[2],
                        0,
                        r[0],
                        r[1],
                        r[2],
                        0,
                        e[0],
                        e[1],
                        e[2],
                        0,
                        t1[0],
                        t1[1],
                        t1[2],
                        1
                    ];
                }(y);
                p(a, a, [
                    m,
                    m,
                    m * u
                ]), h(a, a, [
                    -i[0],
                    -i[1],
                    -i[2]
                ]);
                const x = c([], e.globeMatrix, g);
                return c(x, x, a), c(x, x, t1), x;
            }(t1, e, r);
            if (n > 0) {
                const r = function(t1, e) {
                    const r = e.worldSize, n = tu(1, 0) * r * ou(e.center.lat, e.zoom) / Nc(r), i = tu(1, e.center.lat) * r, s = l([]);
                    return f(s, s, Mt(e.center.lng)), d(s, s, Mt(e.center.lat)), h(s, s, [
                        0,
                        0,
                        Fl
                    ]), p(s, s, [
                        n,
                        n,
                        n * i
                    ]), h(s, s, [
                        e.point.x - .5 * r,
                        e.point.y - .5 * r,
                        0
                    ]), c(s, s, t1), c(s, e.globeMatrix, s);
                }(t1, e);
                return function(t1, e, r) {
                    const n = (t1, e, r)=>{
                        const n = _(t1), i = _(e), s = Tc(t1, e, r);
                        return z(s, s, 1 / _(s) * ur(n, i, r));
                    }, i = n([
                        t1[0],
                        t1[1],
                        t1[2]
                    ], [
                        e[0],
                        e[1],
                        e[2]
                    ], r), s = n([
                        t1[4],
                        t1[5],
                        t1[6]
                    ], [
                        e[4],
                        e[5],
                        e[6]
                    ], r), o = n([
                        t1[8],
                        t1[9],
                        t1[10]
                    ], [
                        e[8],
                        e[9],
                        e[10]
                    ], r), a = Tc([
                        t1[12],
                        t1[13],
                        t1[14]
                    ], [
                        e[12],
                        e[13],
                        e[14]
                    ], r);
                    return [
                        i[0],
                        i[1],
                        i[2],
                        0,
                        s[0],
                        s[1],
                        s[2],
                        0,
                        o[0],
                        o[1],
                        o[2],
                        0,
                        a[0],
                        a[1],
                        a[2],
                        1
                    ];
                }(i, r, n);
            }
            return i;
        }
        function Tf(t1, e, r, n) {
            const i = Nu.projectAabbCorners(n, r);
            let s = Number.MAX_VALUE, o = -1;
            for(let t1 = 0; t1 < i.length; ++t1){
                const r = i[t1];
                r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < s && (o = t1, s = r[2]);
            }
            const a = (t1)=>new bt(i[t1][0], i[t1][1]);
            let l;
            switch(o){
                case 0:
                case 6:
                    l = [
                        a(1),
                        a(5),
                        a(4),
                        a(7),
                        a(3),
                        a(2),
                        a(1)
                    ];
                    break;
                case 1:
                case 7:
                    l = [
                        a(0),
                        a(4),
                        a(5),
                        a(6),
                        a(2),
                        a(3),
                        a(0)
                    ];
                    break;
                case 3:
                case 5:
                    l = [
                        a(1),
                        a(0),
                        a(4),
                        a(7),
                        a(6),
                        a(2),
                        a(1)
                    ];
                    break;
                default:
                    l = [
                        a(1),
                        a(5),
                        a(6),
                        a(7),
                        a(3),
                        a(0),
                        a(1)
                    ];
            }
            if (Xu(t1, l)) return s;
        }
        const Bf = 64, Vf = {
            CoordinateSpaceTile: 1,
            HasMapboxMeshFeatures: 4,
            HasMeshoptCompression: 8
        };
        function Cf(t1, e, r, n, i, s, o, a, u, d = !1) {
            const f = r.zoom, m = r.project(n), y = ou(n.lat, f), g = 1 / y;
            l(t1), h(t1, t1, [
                m.x + o[0] * g,
                m.y + o[1] * g,
                o[2]
            ]);
            let v = 1, b = 1;
            const w = r.worldSize;
            if (d) {
                if ("mercator" === r.projection.name) {
                    let t1 = 0;
                    r.elevation && (t1 = r.elevation.getAtPointOrZero(new uu(m.x / w, m.y / w), 0));
                    const e = Y([], [
                        m.x,
                        m.y,
                        t1,
                        1
                    ], r.projMatrix)[3] / r.cameraToCenterDistance;
                    v = e, b = e * ou(r.center.lat, f);
                } else if ("globe" === r.projection.name) {
                    const e = zf(t1, r), i = [
                        0,
                        0,
                        0,
                        1
                    ];
                    Y(i, i, c([], r.projMatrix, e));
                    const s = i[3] / r.cameraToCenterDistance, o = Gc(f), a = r.projection.pixelsPerMeter(n.lat, w) * ou(n.lat, f), l = r.projection.pixelsPerMeter(r.center.lat, w) * ou(r.center.lat, f);
                    v = s / ur(a, su(r.center.lat), o), b = s * y / a, v *= l, b *= l;
                }
            } else v = g;
            p(t1, t1, [
                v,
                v,
                b
            ]);
            const _ = [
                ...t1
            ], A = e.orientation, M = [];
            if (Ef(M, [
                A[0] + i[0],
                A[1] + i[1],
                A[2] + i[2]
            ], s), c(t1, _, M), a && r.elevation) {
                let i = 0;
                const s = [];
                if (u && r.elevation) {
                    i = function(t1, e, r, n, i) {
                        const s = e.elevation;
                        if (!s) return 0;
                        const o = Nu.projectAabbCorners(r, n), a = tu(1, i.lat) * e.worldSize, l = function(t1, e) {
                            const r = [
                                0,
                                0,
                                1
                            ], n = [
                                {
                                    corners: [
                                        0,
                                        1,
                                        3,
                                        2
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        1,
                                        5,
                                        2,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        4,
                                        1,
                                        5
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        2,
                                        6,
                                        3,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        4,
                                        7,
                                        5,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        3,
                                        4,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                }
                            ];
                            for (const i of n){
                                const n = t1[i.corners[0]], s = t1[i.corners[1]], o = t1[i.corners[2]], a = [
                                    s[0] - n[0],
                                    s[1] - n[1],
                                    e * (s[2] - n[2])
                                ], l = L(a, a, [
                                    o[0] - n[0],
                                    o[1] - n[1],
                                    e * (o[2] - n[2])
                                ]);
                                F(l, l), i.dotProductWithUp = D(l, r);
                            }
                            return n.sort((t1, e)=>t1.dotProductWithUp - e.dotProductWithUp), n[0].corners;
                        }(o, a), u = o[l[0]], c = o[l[1]], h = o[l[2]], p = o[l[3]], d = s.getAtPointOrZero(new uu(u[0] / e.worldSize, u[1] / e.worldSize), 0), f = s.getAtPointOrZero(new uu(c[0] / e.worldSize, c[1] / e.worldSize), 0), m = s.getAtPointOrZero(new uu(h[0] / e.worldSize, h[1] / e.worldSize), 0), y = s.getAtPointOrZero(new uu(p[0] / e.worldSize, p[1] / e.worldSize), 0), g = (d + y) / 2, x = (f + m) / 2;
                        return g > x ? f < m ? kf(t1, c, p, u, f, y, d, a) : kf(t1, h, u, p, m, d, y, a) : d < y ? kf(t1, u, c, h, d, f, m, a) : kf(t1, p, h, c, y, m, f, a), Math.max(g, x);
                    }(s, r, e.aabb, t1, n);
                    const o = c([], x([], s), M);
                    c(t1, _, o);
                } else i = r.elevation.getAtPointOrZero(new uu(m.x / w, m.y / w), 0);
                0 !== i && (t1[14] += i);
            }
        }
        function Ff(t1, e, r = !1) {
            t1.uploaded || (t1.gfxTexture = new df(e, t1.image, r ? e.gl.R8 : e.gl.RGBA8, {
                useMipmap: t1.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST
            }), t1.uploaded = !0, t1.image = null);
        }
        function Df(t1, e, r) {
            t1.indexBuffer = e.createIndexBuffer(t1.indexArray, !1, !0), t1.vertexBuffer = e.createVertexBuffer(t1.vertexArray, mf.members, !1, !0), t1.normalArray && (t1.normalBuffer = e.createVertexBuffer(t1.normalArray, vf.members, !1, !0)), t1.texcoordArray && (t1.texcoordBuffer = e.createVertexBuffer(t1.texcoordArray, xf.members, !1, !0)), t1.colorArray && (t1.colorBuffer = e.createVertexBuffer(t1.colorArray, (12 === t1.colorArray.bytesPerElement ? yf : gf).members, !1, !0)), t1.featureArray && (t1.pbrBuffer = e.createVertexBuffer(t1.featureArray, wf.members, !0)), t1.segments = el.simpleSegment(0, 0, t1.vertexArray.length, t1.indexArray.length);
            const n = t1.material;
            n.pbrMetallicRoughness.baseColorTexture && Ff(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && Ff(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && Ff(n.normalTexture, e), n.occlusionTexture && Ff(n.occlusionTexture, e, r), n.emissionTexture && Ff(n.emissionTexture, e);
        }
        function Lf(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes)Df(n, e, r);
            if (t1.children) for (const n of t1.children)Lf(n, e, r);
        }
        function Rf(t1) {
            if (t1.meshes) for (const e of t1.meshes)e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
            if (t1.children) for (const e of t1.children)Rf(e);
        }
        function Of(t1) {
            if (t1.meshes) for (const r of t1.meshes)r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
            var e;
            if (t1.children) for (const e of t1.children)Of(e);
        }
        function Uf(t1, e) {
            const r = t1.json.bufferViews[e.bufferView], n = Wd[e.componentType];
            return new n(t1.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== Kd[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : Kd[e.type]));
        }
        function Nf(t1, e, r, n) {
            const i = Wd[e.componentType], s = function(t1) {
                switch(t1){
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        return 1;
                }
            }(i), o = t1.json.bufferViews[e.bufferView], a = o.byteStride ? o.byteStride / i.BYTES_PER_ELEMENT : Kd[e.type], l = r.float32, u = l.length / r.capacity;
            for(let t1 = 0, r = 0; t1 < e.count * a; t1 += a, r += u)for(let e = 0; e < u; e++)l[r + e] = n[t1 + e] * s;
            r._trim();
        }
        function jf(t1, e, r) {
            const n = t1.indices, i = t1.attributes, s = {};
            s.indexArray = new Ma;
            const o = e.json.accessors[n], a = o.count / 3;
            s.indexArray.reserve(a);
            const l = Uf(e, o);
            for(let t1 = 0; t1 < a; t1++)s.indexArray.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
            s.indexArray._trim(), s.vertexArray = new ha;
            const u = e.json.accessors[i.POSITION];
            s.vertexArray.reserve(u.count);
            const c = Uf(e, u);
            for(let t1 = 0; t1 < u.count; t1++)s.vertexArray.emplaceBack(c[3 * t1], c[3 * t1 + 1], c[3 * t1 + 2]);
            if (s.vertexArray._trim(), s.aabb = new Nu(u.min, u.max), s.centroid = function(t1, e) {
                const r = [
                    0,
                    0,
                    0
                ], n = t1.length;
                if (n > 0) {
                    for(let i = 0; i < n; i++){
                        const n = 3 * t1[i];
                        r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];
                    }
                    r[0] /= n, r[1] /= n, r[2] /= n;
                }
                return r;
            }(l, c), void 0 !== i.COLOR_0) {
                const t1 = e.json.accessors[i.COLOR_0], r = Kd[t1.type], n = Uf(e, t1);
                s.colorArray = 3 === r ? new ha : new ga, s.colorArray.resize(t1.count), Nf(e, t1, s.colorArray, n);
            }
            if (void 0 !== i.NORMAL) {
                s.normalArray = new ha;
                const t1 = e.json.accessors[i.NORMAL];
                s.normalArray.resize(t1.count);
                const r = Uf(e, t1);
                Nf(e, t1, s.normalArray, r);
            }
            if (void 0 !== i.TEXCOORD_0 && r.length > 0) {
                s.texcoordArray = new Ba;
                const t1 = e.json.accessors[i.TEXCOORD_0];
                s.texcoordArray.resize(t1.count);
                const r = Uf(e, t1);
                Nf(e, t1, s.texcoordArray, r);
            }
            if (void 0 !== i._FEATURE_ID_RGBA4444) {
                const t1 = e.json.accessors[i._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (s.featureData = Uf(e, t1));
            }
            void 0 !== i._FEATURE_RGBA4444 && (s.featureData = new Uint32Array(Uf(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));
            const h = t1.material;
            return s.material = function(t1, e) {
                const { emissiveFactor: r = [
                    0,
                    0,
                    0
                ], alphaMode: n = "OPAQUE", alphaCutoff: i = .5, normalTexture: s, occlusionTexture: o, emissiveTexture: a, doubleSided: l } = t1, { baseColorFactor: u = [
                    1,
                    1,
                    1,
                    1
                ], metallicFactor: c = 1, roughnessFactor: h = 1, baseColorTexture: p, metallicRoughnessTexture: d } = t1.pbrMetallicRoughness || {}, f = o ? e[o.index] : void 0;
                if (o && o.extensions && o.extensions.KHR_texture_transform && f) {
                    const t1 = o.extensions.KHR_texture_transform;
                    f.offsetScale = [
                        t1.offset[0],
                        t1.offset[1],
                        t1.scale[0],
                        t1.scale[1]
                    ];
                }
                return {
                    pbrMetallicRoughness: {
                        baseColorFactor: new sr(...u),
                        metallicFactor: c,
                        roughnessFactor: h,
                        baseColorTexture: p ? e[p.index] : void 0,
                        metallicRoughnessTexture: d ? e[d.index] : void 0
                    },
                    doubleSided: l,
                    emissiveFactor: new sr(...r),
                    alphaMode: n,
                    alphaCutoff: i,
                    normalTexture: s ? e[s.index] : void 0,
                    occlusionTexture: f,
                    emissionTexture: a ? e[a.index] : void 0,
                    defined: void 0 === t1.defined
                };
            }(void 0 !== h ? e.json.materials[h] : {
                defined: !1
            }, r), s;
        }
        function $f(t1, e, r) {
            const { matrix: n, rotation: i, translation: s, scale: o, mesh: a, extras: l, children: u } = t1, c = {};
            if (c.matrix = n || function(t1, e, r, n) {
                var i = e[0], s = e[1], o = e[2], a = e[3], l = i + i, u = s + s, c = o + o, h = i * l, p = i * u, d = i * c, f = s * u, m = s * c, y = o * c, g = a * l, x = a * u, v = a * c, b = n[0], w = n[1], _ = n[2];
                return t1[0] = (1 - (f + y)) * b, t1[1] = (p + v) * b, t1[2] = (d - x) * b, t1[3] = 0, t1[4] = (p - v) * w, t1[5] = (1 - (h + y)) * w, t1[6] = (m + g) * w, t1[7] = 0, t1[8] = (d + x) * _, t1[9] = (m - g) * _, t1[10] = (1 - (h + f)) * _, t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
            }([], i || [
                0,
                0,
                0,
                1
            ], s || [
                0,
                0,
                0
            ], o || [
                1,
                1,
                1
            ]), void 0 !== a) {
                c.meshes = r[a];
                const t1 = c.anchor = [
                    0,
                    0
                ];
                for (const e of c.meshes){
                    const { min: r, max: n } = e.aabb;
                    t1[0] += r[0] + n[0], t1[1] += r[1] + n[1];
                }
                t1[0] = Math.floor(t1[0] / c.meshes.length / 2), t1[1] = Math.floor(t1[1] / c.meshes.length / 2);
            }
            if (l && (l.id && (c.id = l.id), l.lights && (c.lights = function(t1) {
                if (!t1.length) return [];
                const e = function(t1) {
                    const e = atob(t1), r = new Uint8Array(e.length);
                    for(let t1 = 0; t1 < e.length; t1++)r[t1] = e.codePointAt(t1);
                    return r;
                }(t1), r = [], n = e.length / 24, i = new Uint16Array(e.buffer), s = new Float32Array(e.buffer);
                for(let t1 = 0; t1 < n; t1++){
                    const e = i[2 * t1 * 6] / 30, n = i[2 * t1 * 6 + 1] / 30, o = i[2 * t1 * 6 + 10] / 100, a = s[6 * t1 + 1], l = s[6 * t1 + 2], u = s[6 * t1 + 3], c = s[6 * t1 + 4], h = u - a, p = c - l, d = Math.hypot(h, p);
                    r.push({
                        pos: [
                            a + .5 * h,
                            l + .5 * p,
                            n
                        ],
                        normal: [
                            p / d,
                            -h / d,
                            0
                        ],
                        width: d,
                        height: e,
                        depth: o,
                        points: [
                            a,
                            l,
                            u,
                            c
                        ]
                    });
                }
                return r;
            }(l.lights))), u) {
                const t1 = [];
                for (const n of u)t1.push($f(e.json.nodes[n], e, r));
                c.children = t1;
            }
            return c;
        }
        function Gf(t1) {
            if (0 === t1.vertices.length || 0 === t1.indices.length) return null;
            const e = new fp(t1.vertices, t1.indices, 8, 256), [r, n] = [
                e.min.clone(),
                e.max.clone()
            ];
            return {
                vertices: t1.vertices,
                indices: t1.indices,
                grid: e,
                min: r,
                max: n
            };
        }
        function Hf(t1) {
            if (!t1.extras || !t1.extras.ground) return null;
            const e = t1.extras.ground;
            if (!e || !Array.isArray(e) || 0 === e.length) return null;
            const r = e[0];
            if (!r || !Array.isArray(r) || 0 === r.length) return null;
            const n = [];
            for (const t1 of r){
                if (!Array.isArray(t1) || 2 !== t1.length) continue;
                const e = t1[0], r = t1[1];
                "number" == typeof e && "number" == typeof r && n.push(new bt(e, r));
            }
            if (n.length < 3) return null;
            n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();
            let i = 0;
            for(let t1 = 0; t1 < n.length; t1++){
                const e = n[t1], r = n[(t1 + 1) % n.length], s = n[(t1 + 2) % n.length];
                i += (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y);
            }
            i > 0 && n.reverse();
            const s = vh(n.flatMap((t1)=>[
                    t1.x,
                    t1.y
                ]), []);
            return 0 === s.length ? null : {
                vertices: n,
                indices: s
            };
        }
        function qf(t1, e) {
            const r = [], n = [];
            let i = 0;
            const s = [];
            for (const o of t1){
                i = r.length;
                const t1 = o.vertexArray.float32, a = o.indexArray.uint16;
                for(let n = 0; n < o.vertexArray.length; n++)s[0] = t1[3 * n + 0], s[1] = t1[3 * n + 1], s[2] = t1[3 * n + 2], O(s, s, e), r.push(new bt(s[0], s[1]));
                for(let t1 = 0; t1 < 3 * o.indexArray.length; t1++)n.push(a[t1] + i);
            }
            if (n.length % 3 != 0) return null;
            for(let t1 = 0; t1 < n.length; t1 += 3){
                const e = r[n[t1 + 0]], i = r[n[t1 + 1]], s = r[n[t1 + 2]];
                (e.x - i.x) * (s.y - i.y) - (s.x - i.x) * (e.y - i.y) > 0 && ([n[t1 + 1], n[t1 + 2]] = [
                    n[t1 + 2],
                    n[t1 + 1]
                ]);
            }
            return {
                vertices: r,
                indices: n
            };
        }
        function Xf(t1) {
            const e = function(t1, e) {
                const r = [], n = WebGL2RenderingContext;
                if (t1.json.textures) for (const i of t1.json.textures){
                    const s = {
                        magFilter: n.LINEAR,
                        minFilter: n.NEAREST,
                        wrapS: n.REPEAT,
                        wrapT: n.REPEAT
                    };
                    void 0 !== i.sampler && Object.assign(s, t1.json.samplers[i.sampler]), r.push({
                        image: e[i.source],
                        sampler: s,
                        uploaded: !1
                    });
                }
                return r;
            }(t1, t1.images), r = function(t1, e) {
                const r = [];
                for (const n of t1.json.meshes){
                    const i = [];
                    for (const r of n.primitives)i.push(jf(r, t1, e));
                    r.push(i);
                }
                return r;
            }(t1, e), { scenes: n, scene: i, nodes: s } = t1.json, o = n ? n[i || 0].nodes : s, a = [];
            for (const e of o)a.push($f(s[e], t1, r));
            return function(t1, e, r) {
                const n = {}, i = new Set;
                for(let s = 0; s < t1.length; s++){
                    const t1 = r[e[s]];
                    if (!t1.extras) continue;
                    const o = t1.extras["mapbox:footprint:version"], a = t1.extras["mapbox:footprint:id"];
                    (o || a) && i.add(s), "1.0.0" === o && a && (n[a] = s);
                }
                for(let s = 0; s < t1.length; s++){
                    if (i.has(s)) continue;
                    const o = t1[s], a = r[e[s]];
                    if (!a.extras) continue;
                    let l = null;
                    o.id in n && (l = qf(t1[n[o.id]].meshes, o.matrix)), l || (l = Hf(a)), l && (o.footprint = Gf(l));
                }
                if (i.size > 0) {
                    const e = Array.from(i.values()).sort((t1, e)=>t1 - e);
                    for(let r = e.length - 1; r >= 0; r--)t1.splice(e[r], 1);
                }
            }(a, o, t1.json.nodes), a;
        }
        function Zf(t1) {
            t1.heightmap = new Float32Array(4096), t1.heightmap.fill(-1);
            const e = t1.vertexArray.float32, r = t1.aabb.min[0] - 1, n = t1.aabb.min[1] - 1, i = Bf / (t1.aabb.max[0] - r + 2), s = Bf / (t1.aabb.max[1] - n + 2);
            for(let o = 0; o < e.length; o += 3){
                const a = e[o + 2], l = (e[o + 0] - r) * i | 0, u = (e[o + 1] - n) * s | 0;
                a > t1.heightmap[u * Bf + l] && (t1.heightmap[u * Bf + l] = a);
            }
        }
        function Wf(t1, e, r, n, i) {
            r.reserve(r.length + 4 * t1.length), n.reserve(n.length + 10 * t1.length), i.reserve(i.length + 10 * t1.length);
            let s = n.length;
            for (const o of t1){
                const t1 = Math.min(10, Math.max(4, 1.3 * o.height)) * e, a = [
                    -o.normal[1],
                    o.normal[0],
                    0
                ], l = Math.min(.29, .1 * o.width / o.depth), u = o.width - 2 * o.depth * e * (l + .01), c = T([], o.pos, a, u / 2), h = T([], o.pos, a, -u / 2), p = [
                    c[0],
                    c[1],
                    c[2] + o.height
                ], d = [
                    h[0],
                    h[1],
                    h[2] + o.height
                ], f = T([], o.normal, a, l);
                z(f, f, t1);
                const m = T([], o.normal, a, -l);
                z(m, m, t1), I(f, c, f), I(m, h, m), c[2] += .1, h[2] += .1, n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(p[0], p[1], p[2]), n.emplaceBack(d[0], d[1], d[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]);
                const y = u / t1 / 2;
                i.emplaceBack(-y - l, -1, y, .8), i.emplaceBack(y + l, -1, y, .8), i.emplaceBack(-y, 0, y, 1.3), i.emplaceBack(y, 0, y, 1.3), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(y + l, -1.2, y, .8), i.emplaceBack(y + l, -1.2, y, .8), r.emplaceBack(6 + s, 4 + s, 8 + s), r.emplaceBack(7 + s, 9 + s, 5 + s), r.emplaceBack(0 + s, 1 + s, 2 + s), r.emplaceBack(1 + s, 3 + s, 2 + s), s += 10;
            }
        }
        function Yf(t1, e) {
            const r = {};
            r.indexArray = new Ma, r.vertexArray = new ha, r.colorArray = new ga, Wf(t1, e, r.indexArray, r.vertexArray, r.colorArray);
            const n = {
                defined: !0
            };
            n.emissiveFactor = sr.black;
            const i = {};
            return i.baseColorFactor = sr.white, n.pbrMetallicRoughness = i, r.material = n, r.aabb = new Nu([
                1 / 0,
                1 / 0,
                1 / 0
            ], [
                -1 / 0,
                -1 / 0,
                -1 / 0
            ]), r;
        }
        const Kf = ea([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), Jf = ea([
            {
                name: "a_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), Qf = ea([
            {
                name: "a_part_color_emissive",
                components: 2,
                type: "Uint16"
            }
        ]), tm = ea([
            {
                name: "a_bloom_attenuation",
                components: 4,
                type: "Float32"
            }
        ]), em = vu.types, rm = 32767;
        function nm(t1, e) {
            const r = Cn + e;
            for (const n of t1)for (const t1 of n)if (t1.x < -e || t1.x > r || t1.y < -e || t1.y > r) return !1;
            return !0;
        }
        class im {
            constructor(t1){
                this.layoutAOArray = [], this.indexArrayForConflationUploaded = !1, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.featuresOnBorder = [], this.buildingFeatures = [], this.footprintLookup = {}, this.zoom = t1.zoom, this.canonical = t1.canonical, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.worldview = t1.worldview, this.layoutVertexArray = new ha, this.layoutNormalArray = new ia, this.layoutColorArray = new va, this.indexArray = new Ma, this.indexArrayForConflation = new Ma, this.entranceBloom = {
                    layoutVertexArray: new ha,
                    layoutVertexBuffer: null,
                    layoutAttenuationArray: new ga,
                    layoutAttenuationBuffer: null,
                    layoutColorArray: new va,
                    layoutColorBuffer: null,
                    indexArray: new Ma,
                    indexArrayForConflation: new Ma,
                    indexBuffer: null,
                    segmentsBucket: new el
                }, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segmentsBucket = new el, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection, this.groundEffect = new rd(t1);
            }
            get segments() {
                return this.segmentsBucket;
            }
            get bloomGeometry() {
                return this.entranceBloom;
            }
            updateFootprints(t1, e) {
                for (const r of this.footprints)e.push({
                    footprint: r,
                    id: t1
                });
            }
            prepare() {
                return function() {
                    if (null != Hd || null != Gd) return null;
                    if (null != $d) return $d;
                    const t1 = fetch(ne.BUILDING_GEN_URL);
                    return $d = (function(t1) {
                        let e, r, n, i;
                        function s() {
                            e = new Uint8Array(i.buffer), r = new Int32Array(i.buffer), n = new Float32Array(i.buffer);
                        }
                        function o() {
                            throw new Error("Unexpected BuildingGen error.");
                        }
                        const a = ()=>{}, l = {
                            a: {
                                a: o,
                                f: function(t1) {
                                    const r = e.length, n = Math.max(t1 >>> 0, Math.ceil(1.2 * r)), o = Math.ceil((n - r) / 65536);
                                    try {
                                        return i.grow(o), s(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                g: o,
                                b: a,
                                c: a,
                                d: a,
                                e: a
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, l) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, l))).then((t1)=>{
                            const o = t1.instance.exports;
                            return (0, o.g)(), i = o.f, s(), new Dd({
                                setStyle: o.h,
                                setAOOptions: o.i,
                                setMetricOptions: o.j,
                                setStructuralOptions: o.k,
                                setFacadeOptions: o.l,
                                setFauxFacadeOptions: o.m,
                                setFacadeClassifierOptions: o.n,
                                addFeature: o.o,
                                addFacade: o.p,
                                generateMesh: o.q,
                                getLastError: o.r,
                                getMeshCount: o.s,
                                getPositionsPtr: o.t,
                                getPositionsLength: o.u,
                                getNormalsPtr: o.v,
                                getNormalsLength: o.w,
                                getColorsPtr: o.x,
                                getColorsLength: o.y,
                                getAOPtr: o.z,
                                getAOLength: o.A,
                                getUVPtr: o.B,
                                getUVLength: o.C,
                                getFauxFacadePtr: o.D,
                                getFauxFacadeLength: o.E,
                                getIndicesPtr: o.F,
                                getIndicesLength: o.G,
                                getBuildingPart: o.H,
                                getRingCount: o.I,
                                getRingPtr: o.J,
                                getRingLength: o.K,
                                free: o.L,
                                malloc: o.M,
                                heapU8: e,
                                heap32: r,
                                heapF32: n
                            });
                        });
                    })(t1).then((t1)=>($d = null, Hd = t1, Hd)).catch((t1)=>{
                        Gt("Could not load building-gen"), $d = null, Gd = t1;
                    }), $d;
                }();
            }
            populate(t1, e, r, n) {
                const i = Zd();
                if (!i) return;
                const s = lu(r);
                this.tileToMeter = s, this.brightness = e.brightness, i.setStyle({
                    convertToMeters: !1,
                    entranceColorRgb: [
                        1,
                        1,
                        1
                    ],
                    facadeGlazingColorRgb: [
                        .5607843137254902,
                        .6745098039215687,
                        .7215686274509804
                    ],
                    normalScale: [
                        1,
                        -1,
                        s
                    ],
                    ridgeHeight: 3,
                    roofColorRgb: [
                        .886274516,
                        .784313738,
                        .713725507
                    ],
                    tileToMeters: s,
                    tileZoom: 16,
                    wallColorRgb: [
                        .988235294,
                        .933333337,
                        .811764717
                    ]
                }), i.setAOOptions(!1, .3), i.setMetricOptions(!1, 16), i.setStructuralOptions(!0), i.setFacadeOptions(4, !0), i.setFauxFacadeOptions(!1, !1, 1), i.setFacadeClassifierOptions(3);
                const o = new Map;
                for (const { feature: e } of t1){
                    if ("LineString" !== em[e.type]) continue;
                    const t1 = this.layers[0]._featureFilter.needGeometry, i = xu(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), i, r)) continue;
                    const s = t1 ? i.geometry : gu(e, r, n), a = [];
                    for (const t1 of s)for (const e of t1)a.push({
                        x: e.x,
                        y: e.y
                    });
                    const l = {
                        coordinates: a,
                        crossPerc: e.properties.cross_perc,
                        distanceToRoad: e.properties.distance_to_road,
                        entrances: e.properties.entrances,
                        sourceId: 0
                    }, u = e.properties.source_id;
                    let c = o.get(u);
                    c || (c = [], o.set(u, c)), c.push(l);
                }
                this.maxHeight = 0;
                for (const { feature: s, index: a } of t1){
                    if ("LineString" === em[s.type]) continue;
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = xu(s, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), l, r)) continue;
                    const u = t1 ? l.geometry : gu(s, r, n), c = Hh(u, 500);
                    if (!nm(u, 163)) continue;
                    const h = this.layers[0], p = h.layout.get("building-base").evaluate(s, {}, r), d = h.layout.get("building-height").evaluate(s, {}, r), f = h.layout.get("building-roof-shape").evaluate(s, {}, r), m = h.paint.get("building-ambient-occlusion-intensity"), y = h.paint.get("building-ambient-occlusion-ground-radius") / this.tileToMeter;
                    if ("flat" === f) continue;
                    const g = s.properties.source_id;
                    let x;
                    x = o.has(g) ? o.get(g) : [];
                    const v = [], b = new bt(1 / 0, 1 / 0), w = new bt(-1 / 0, -1 / 0);
                    for (const t1 of c)if (t1.length > 0) {
                        const e = [];
                        for (const r of t1){
                            const t1 = [];
                            for(let e = r.length - 1; e >= 0; e--){
                                const n = r[e];
                                t1.push({
                                    x: n.x,
                                    y: n.y
                                }), b.x = Math.min(b.x, n.x), b.y = Math.min(b.y, n.y), w.x = Math.max(w.x, n.x), w.y = Math.max(w.y, n.y);
                            }
                            e.push(t1);
                        }
                        v.push({
                            id: s.id,
                            height: d,
                            minHeight: p,
                            sourceId: 0,
                            roofType: f,
                            coordinates: e
                        });
                    }
                    const _ = i.generateMesh(v, x);
                    if ("string" == typeof _) continue;
                    if (0 === _.meshes.length || 0 === _.modifiedPolygonRings.length) continue;
                    let A = 0;
                    for (const t1 of _.meshes)A += t1.positions.length / 3;
                    const M = this.segmentsBucket.prepareSegment(A, this.layoutVertexArray, this.indexArray), I = [];
                    let S = null, P = 0, E = -1;
                    const k = this.indexArray.length;
                    let z = 0;
                    for (const t1 of _.meshes){
                        const e = this.layoutVertexArray.length;
                        if ("entrance" === t1.buildingPart) {
                            const e = new Array;
                            for(let r = 0; r < t1.indices.length; r += 12){
                                const n = t1.positions[r + 0], i = t1.positions[r + 1], s = t1.positions[r + 3], o = t1.positions[r + 4], a = t1.positions[r + 2], l = t1.positions[r + 8] - a, u = 1, c = s - n, h = o - i, p = Math.hypot(c, h);
                                e.push({
                                    pos: [
                                        n + .5 * c,
                                        i + .5 * h,
                                        a
                                    ],
                                    normal: [
                                        h / p,
                                        -c / p,
                                        0
                                    ],
                                    width: p,
                                    height: l,
                                    depth: u,
                                    points: [
                                        n,
                                        i,
                                        s,
                                        o
                                    ]
                                });
                            }
                            const r = this.entranceBloom.segmentsBucket.prepareSegment(10 * e.length, this.entranceBloom.layoutVertexArray, this.entranceBloom.indexArray), n = this.entranceBloom.layoutVertexArray.length;
                            P = this.entranceBloom.indexArray.length, Wf(e, .5 / this.tileToMeter, this.entranceBloom.indexArray, this.entranceBloom.layoutVertexArray, this.entranceBloom.layoutAttenuationArray);
                            const i = this.entranceBloom.layoutVertexArray.length - n;
                            E = this.entranceBloom.indexArray.length - P;
                            for(let t1 = 0; t1 < i; t1++){
                                const t1 = 65535;
                                this.entranceBloom.layoutColorArray.emplaceBack(t1, t1);
                            }
                            r.vertexLength += i, r.primitiveLength += E, S = {
                                part: t1.buildingPart,
                                vertexOffset: n,
                                vertexLength: i
                            };
                        }
                        for(let e = 0; e < t1.positions.length; e += 3)z = Math.max(z, t1.positions[e + 2]), this.layoutVertexArray.emplaceBack(t1.positions[e], t1.positions[e + 1], t1.positions[e + 2]);
                        for(let e = 0; e < t1.normals.length; e += 3)this.layoutNormalArray.emplaceBack(t1.normals[e + 0] * rm, t1.normals[e + 1] * rm, t1.normals[e + 2] * rm);
                        for(let e = 0; e < t1.ao.length; e++)this.layoutAOArray.push(t1.ao[e]);
                        for(let e = 0; e < t1.colors.length; e += 3){
                            const r = 1 + (t1.ao[e / 3] - 1) * m;
                            this.layoutColorArray.emplaceBack(t1.colors[e] * r << 8 | t1.colors[e + 1] * r, t1.colors[e + 2] * r << 8);
                        }
                        const r = M.vertexLength;
                        for(let e = 0; e < t1.indices.length; e += 3)this.indexArray.emplaceBack(r + t1.indices[e], r + t1.indices[e + 1], r + t1.indices[e + 2]);
                        M.vertexLength += t1.positions.length / 3, M.primitiveLength += t1.indices.length / 3, ("roof" === t1.buildingPart || "wall" === t1.buildingPart || "facade_glazing" === t1.buildingPart || "entrance" === t1.buildingPart) && I.push({
                            part: t1.buildingPart,
                            vertexOffset: e,
                            vertexLength: t1.positions.length / 3
                        });
                    }
                    this.maxHeight = Math.max(this.maxHeight, z), this.buildingFeatures.push({
                        feature: l,
                        segment: M,
                        parts: I,
                        buildingBloom: S
                    });
                    const T = this.indexArray.length - k, B = [], V = [], C = new bt(1 / 0, 1 / 0), F = new bt(-1 / 0, -1 / 0), D = this.groundEffect.vertexArray.length;
                    for (const t1 of _.modifiedPolygonRings){
                        const e = [], r = new bt(1 / 0, 1 / 0), n = new bt(-1 / 0, -1 / 0);
                        for(let i = 0; i < t1.length; i += 2){
                            const s = t1.length - i - 2;
                            r.x = Math.min(r.x, t1[s]), r.y = Math.min(r.y, t1[s + 1]), n.x = Math.max(n.x, t1[s]), n.y = Math.max(n.y, t1[s + 1]);
                            const o = new bt(t1[s], t1[s + 1]);
                            e.push(o), B.push(o.x, o.y), V.push(o.clone());
                        }
                        C.x = Math.min(C.x, r.x), C.y = Math.min(C.y, r.y), F.x = Math.max(F.x, n.x), F.y = Math.max(F.y, n.y), this.groundEffect.addData(e, [
                            r,
                            n
                        ], y);
                    }
                    const L = this.groundEffect.vertexArray.length - D;
                    (b.x < 0 || w.x > Cn || b.y < 0 || w.y > Cn) && this.featuresOnBorder.push({
                        featureId: s.id,
                        footprintIndex: this.footprints.length
                    });
                    {
                        const t1 = vh(B, null, 2), e = new fp(V, t1, 8, 256);
                        let r = s.id;
                        s.properties && s.properties.hasOwnProperty("building_id") && (r = s.properties.building_id), this.footprints.push({
                            vertices: V,
                            indices: t1,
                            grid: e,
                            min: C,
                            max: F,
                            buildingId: r,
                            hiddenFlags: 0,
                            indicesOffset: k,
                            indicesLength: T,
                            bloomIndicesOffset: P,
                            bloomIndicesLength: E,
                            groundEffectVertexOffset: D,
                            groundEffectVertexLength: L,
                            segment: M,
                            height: z
                        });
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, s, a, {}, e.availableImages, r, e.brightness), this.groundEffect.addPaintPropertiesData(s, a, {}, e.availableImages, r, e.brightness);
                }
                this.groundEffect.prepareBorderSegments(), this.evaluate(this.layers[0]);
            }
            update(t1, e, r, n, i, s, o) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o), this.groundEffect.update(t1, e, i, r, n, s, o);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Kf.members), this.layoutNormalBuffer = t1.createVertexBuffer(this.layoutNormalArray, Jf.members), this.entranceBloom.layoutVertexBuffer = t1.createVertexBuffer(this.entranceBloom.layoutVertexArray, Kf.members), this.entranceBloom.layoutAttenuationBuffer = t1.createVertexBuffer(this.entranceBloom.layoutAttenuationArray, tm.members), this.uploadUpdatedColorBuffer(t1), this.uploadUpdatedIndexBuffer(t1), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.layoutNormalBuffer.destroy(), this.layoutColorBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segmentsBucket.destroy(), this.entranceBloom.layoutVertexBuffer.destroy(), this.entranceBloom.layoutColorBuffer.destroy(), this.entranceBloom.layoutAttenuationBuffer.destroy(), this.entranceBloom.indexBuffer.destroy(), this.entranceBloom.segmentsBucket.destroy());
            }
            updateFootprintHiddenFlags(t1, e, r = !0) {
                let n = !1;
                const i = r ? e : 0, s = 0 | (r ? -1 : ~e);
                0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const e of t1){
                    const t1 = this.footprints[e], r = t1.hiddenFlags & s | i;
                    t1.hiddenFlags !== r && (t1.hiddenFlags = r, n = !0, this.groundEffect.updateHiddenByLandmarkRange(t1.groundEffectVertexOffset, t1.groundEffectVertexLength, 0 !== t1.hiddenFlags));
                }
                return n && (this.indexArrayForConflationUploaded = !1), n;
            }
            uploadUpdatedIndexBuffer(t1) {
                if (this.groundEffect.uploadHiddenByLandmark(t1), !this.indexArrayForConflationUploaded && 0 !== this.indexArray.length) {
                    this.indexArrayForConflation.resize(this.indexArray.length), this.indexArrayForConflation.uint16.set(this.indexArray.uint16), this.entranceBloom.indexArrayForConflation.resize(this.entranceBloom.indexArray.length), this.entranceBloom.indexArrayForConflation.uint16.set(this.entranceBloom.indexArray.uint16);
                    for (const t1 of this.footprints){
                        const e = t1.indicesOffset + t1.indicesLength;
                        if (0 !== t1.hiddenFlags) {
                            for(let r = t1.indicesOffset; r < e; r++)this.indexArrayForConflation.uint16[3 * r + 0] = 0, this.indexArrayForConflation.uint16[3 * r + 1] = 0, this.indexArrayForConflation.uint16[3 * r + 2] = 0;
                            const r = t1.bloomIndicesOffset + t1.bloomIndicesLength;
                            for(let e = t1.bloomIndicesOffset; e < r; e++)this.entranceBloom.indexArrayForConflation.uint16[3 * e + 0] = 0, this.entranceBloom.indexArrayForConflation.uint16[3 * e + 1] = 0, this.entranceBloom.indexArrayForConflation.uint16[3 * e + 2] = 0;
                        }
                    }
                    this.indexBuffer ? this.indexBuffer.updateData(this.indexArrayForConflation) : this.indexBuffer = t1.createIndexBuffer(this.indexArrayForConflation, !0), this.entranceBloom.indexBuffer ? this.entranceBloom.indexBuffer.updateData(this.entranceBloom.indexArrayForConflation) : this.entranceBloom.indexBuffer = t1.createIndexBuffer(this.entranceBloom.indexArrayForConflation, !0), this.indexArrayForConflationUploaded = !0;
                }
            }
            uploadUpdatedColorBuffer(t1) {
                this.layoutColorBuffer ? this.layoutColorBuffer.updateData(this.layoutColorArray) : this.layoutColorBuffer = t1.createVertexBuffer(this.layoutColorArray, Qf.members, !0), this.entranceBloom.layoutColorBuffer ? this.entranceBloom.layoutColorBuffer.updateData(this.entranceBloom.layoutColorArray) : this.entranceBloom.layoutColorBuffer = t1.createVertexBuffer(this.entranceBloom.layoutColorArray, Qf.members, !0);
            }
            evaluate(t1) {
                const e = t1.paint.get("building-ambient-occlusion-intensity");
                for (const r of this.buildingFeatures){
                    const n = r.feature;
                    n.properties["building-part"] = "roof";
                    const i = t1.paint.get("building-color").evaluate(n, {}, this.canonical), s = t1.paint.get("building-emissive-strength").evaluate(n, {}, this.canonical);
                    n.properties["building-part"] = "wall";
                    const o = t1.paint.get("building-color").evaluate(n, {}, this.canonical), a = t1.paint.get("building-emissive-strength").evaluate(n, {}, this.canonical);
                    n.properties["building-part"] = "window";
                    const l = t1.paint.get("building-color").evaluate(n, {}, this.canonical), u = t1.paint.get("building-emissive-strength").evaluate(n, {}, this.canonical);
                    n.properties["building-part"] = "door";
                    const c = t1.paint.get("building-color").evaluate(n, {}, this.canonical), h = t1.paint.get("building-emissive-strength").evaluate(n, {}, this.canonical);
                    for (const t1 of r.parts){
                        let r, n = i;
                        "roof" === t1.part ? (n = i, r = s) : "wall" === t1.part ? (n = o, r = a) : "facade_glazing" === t1.part ? (n = l, r = u) : "entrance" === t1.part && (n = c, r = h), r = zt(r, 0, 1);
                        for(let i = 0; i < t1.vertexLength; i++){
                            const s = t1.vertexOffset + i, o = 1 + (this.layoutAOArray[s] - 1) * e;
                            this.layoutColorArray.emplace(s, n.r * o * 255 << 8 | n.g * o * 255, n.b * o * 255 << 8 | 255 * r);
                        }
                    }
                    const p = r.buildingBloom;
                    if (p) for(let t1 = 0; t1 < p.vertexLength; t1++)this.bloomGeometry.layoutColorArray.emplace(p.vertexOffset + t1, 255 * c.r << 8 | 255 * c.g, 255 * c.b << 8 | 51 * h);
                }
            }
            needsEvaluation(t1, e) {
                const r = t1.transform.projectionOptions, n = t1.style.getBrightness();
                return !(this.uploaded && r.name === this.projection.name && this.brightness === n || (this.projection = r, this.brightness = n, 0));
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (zp(this.activeReplacements, n)) return;
                this.activeReplacements = n;
                for (const t1 of this.footprints)t1.hiddenFlags &= -2;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order <= Ip) continue;
                    const r = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z));
                    for (const n of this.footprints)n.min.x > e.max.x || n.max.x < e.min.x || n.min.y > e.max.y || n.max.y < e.min.y || (i.length = 0, sm(n.vertices, 0, n.vertices.length, e.footprintTileId.canonical, t1.canonical, i), Vp(e.footprint, i, n.indices, 0, n.indices.length, 0, -r) && (n.hiddenFlags |= 1));
                }
                0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.footprints)this.groundEffect.updateHiddenByLandmarkRange(t1.groundEffectVertexOffset, t1.groundEffectVertexLength, 0 !== t1.hiddenFlags);
                this.indexArrayForConflationUploaded = !1;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + Cn) * Cn + (e + Cn);
                if (this.footprintLookup.hasOwnProperty(i)) {
                    const t1 = this.footprintLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: 0 !== t1.hiddenFlags
                    } : void 0;
                }
                const s = new bt(t1, e);
                for (const o of this.footprints)t1 > o.max.x || o.min.x > t1 || e > o.max.y || o.min.y > e || o.height <= r || Dp(s, o) && (r = o.height, this.footprintLookup[i] = o, n = 0 !== o.hiddenFlags);
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.footprintLookup[i] = void 0;
            }
        }
        function sm(t1, e, r, n, i, s) {
            const o = Math.pow(2, n.z - i.z);
            for(let a = 0; a < r; a++){
                let r = t1[a + e].x, l = t1[a + e].y;
                r = (r + i.x * Cn) * o - n.x * Cn, l = (l + i.y * Cn) * o - n.y * Cn, s.push(new bt(r, l));
            }
        }
        let om, am;
        qs(im, "BuildingBucket", {
            omit: [
                "layers"
            ]
        });
        const lm = ea([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), um = ea([
            {
                name: "a_z_offset_width",
                components: 3,
                type: "Float32"
            }
        ], 4), { members: cm } = lm, hm = ea([
            {
                name: "a_packed",
                components: 3,
                type: "Float32"
            }
        ]), { members: pm } = hm, dm = ea([
            {
                name: "a_pattern_data",
                components: 3,
                type: "Float32"
            }
        ]), { members: fm } = dm;
        class mm {
            constructor(t1, e){
                this.width = t1, this.height = e, this.nextRow = 0, this.image = new hh({
                    width: t1,
                    height: e
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e) {
                const r = this.getKey(t1, e);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e = this.height = Lt(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e
                });
            }
            getKey(t1, e) {
                return t1.join(",") + e;
            }
            getDashRanges(t1, e, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, s = t1[0] * r, o = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: o,
                    zeroLength: 0 === t1[0]
                });
                let a = t1[0];
                for(let e = 1; e < t1.length; e++){
                    o = !o;
                    const l = t1[e];
                    i = a * r, a += l, s = a * r, n.push({
                        left: i,
                        right: s,
                        isDash: o,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e, r) {
                const n = e / 2;
                for(let e = -r; e <= r; e++){
                    const i = this.width * (this.nextRow + r + e);
                    let s = 0, o = t1[s];
                    for(let a = 0; a < this.width; a++){
                        a / o.right > 1 && (o = t1[++s]);
                        const l = Math.abs(a - o.left), u = Math.abs(a - o.right), c = Math.min(l, u);
                        let h;
                        const p = e / r * (n + 1);
                        if (o.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + a] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e) {
                for(let e = t1.length - 1; e >= 0; --e){
                    const r = t1[e], n = t1[e + 1];
                    r.zeroLength ? t1.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0, o = t1[s];
                for(let r = 0; r < this.width; r++){
                    r / o.right > 1 && (o = t1[++s]);
                    const n = Math.abs(r - o.left), a = Math.abs(r - o.right), l = Math.min(n, a);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (o.isDash ? l : -l) + e + 128));
                }
            }
            addDash(t1, e) {
                const r = this.getKey(t1, e);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e, i = n ? 7 : 0, s = 2 * i + 1;
                if (this.nextRow + s > this.height) return Gt("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let o = 0;
                for(let e = 0; e < t1.length; e++)t1[e] < 0 && (Gt("Negative value is found in line dasharray, replacing values with 0"), t1[e] = 0), o += t1[e];
                if (0 !== o) {
                    const r = this.width / o, s = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
                }
                const a = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [
                        a,
                        i
                    ],
                    br: [
                        o,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        qs(mm, "LineAtlas");
        const ym = vu.types, gm = Math.cos(Math.PI / 180 * 37.5), xm = Math.cos(Math.PI / 180 * 5);
        class vm {
            constructor(t1){
                this.evaluationGlobals = {
                    zoom: 0,
                    lineProgress: void 0
                }, this.elevationType = "none", this.zoom = t1.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t1.overscaling, this.pixelRatio = t1.pixelRatio, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new ca, this.layoutVertexArray2 = new ha, this.patternVertexArray = new ha, this.indexArray = new Ma, this.programConfigurations = new kl(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new el, this.maxLineLength = 0, this.zOffsetVertexArray = new ha, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.tessellationStep = t1.tessellationStep ? t1.tessellationStep : Cn / 64, this.worldview = t1.worldview;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Zh("line", this.layers, this.pixelRatio, e);
                const i = this.layers[0].layout.get("line-sort-key");
                this.tileToMeter = lu(r);
                const s = this.layers[0].layout.get("line-elevation-reference");
                if ("hd-road-markup" === s) this.elevationType = "road";
                else {
                    const t1 = this.layers[0].layout.get("line-z-offset"), e = t1.isConstant() && !t1.constantOr(0);
                    this.elevationType = "sea" !== s && "ground" !== s && e ? "none" : "offset", "offset" === this.elevationType && "none" === s && Gt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
                }
                const o = this.layers[0].layout.get("line-cross-slope");
                this.hasCrossSlope = "offset" === this.elevationType && void 0 !== o;
                const a = [];
                for (const { feature: e, id: s, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = xu(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), u, r)) continue;
                    const c = i ? i.evaluate(u, {}, r) : void 0, h = {
                        id: s,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : gu(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    a.push(h);
                }
                i && a.sort((t1, e)=>t1.sortKey - e.sortKey);
                const { lineAtlas: l, featureIndex: u } = e, c = this.addConstantDashes(l);
                for (const n of a){
                    const { geometry: i, index: s, sourceLayerIndex: o } = n;
                    if (c && this.addFeatureDashes(n, l), this.hasPattern) {
                        const t1 = Wh("line", this.layers, n, this.zoom, this.pixelRatio, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, l.positions, e.availableImages, e.brightness, e.elevationFeatures);
                    u.insert(t1[s].feature, i, s, o, this.index);
                }
            }
            addConstantDashes(t1) {
                let e = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e = !0;
                    else {
                        const e = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e);
                    }
                }
                return e;
            }
            addFeatureDashes(t1, e) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, s = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === s.kind) continue;
                    let o, a;
                    if ("constant" === i.kind) {
                        if (o = i.value, !o) continue;
                    } else o = i.evaluate({
                        zoom: r
                    }, t1);
                    a = "constant" === s.kind ? s.value : s.evaluate({
                        zoom: r
                    }, t1), e.addDash(o, a), t1.patterns[n.id] = [
                        e.getKey(o, a)
                    ];
                }
            }
            update(t1, e, r, n, i, s, o, a) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, a);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e, r, n, s);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, pm)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t1.createVertexBuffer(this.patternVertexArray, fm)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, um.members, !0)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, cm), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && t1.properties.hasOwnProperty("mapbox_clip_start") && t1.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e, r, n, i, s, o, a) {
                const l = this.layers[0].layout, u = l.get("line-join").evaluate(t1, {}), c = l.get("line-cap").evaluate(t1, {}), h = l.get("line-miter-limit"), p = l.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1), this.lineFeature = t1, this.zOffsetValue = l.get("line-z-offset").value;
                const d = this.layers[0].paint.get("line-width").value;
                if ("constant" !== d.kind && !1 === d.isLineProgressConstant && (this.variableWidthValue = d), "road" === this.elevationType) {
                    const r = this.layoutVertexArray.length;
                    if (!this.addElevatedRoadFeature(t1, e, n, a, u, c, h, p)) {
                        const [i, s] = this.clipRuntimeLinesToTile(e, 1);
                        for(let e = 0; e < i.length; e++){
                            const r = i[e], o = s[e], a = {
                                progress: {
                                    min: o.progress.min,
                                    max: o.progress.max
                                },
                                nextDir: this.computeSegNextDir(o, r),
                                prevDir: this.computeSegPrevDir(o, r)
                            };
                            this.addLine(r, t1, n, u, c, h, p, a);
                        }
                        this.fillNonElevatedRoadSegment(r);
                    }
                } else for (const r of e)this.addLine(r, t1, n, u, c, h, p);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n, o, void 0, this.worldview);
            }
            computeSegNextDir(t1, e) {
                return t1.nextPoint.sub(e.at(-2)).unit();
            }
            computeSegPrevDir(t1, e) {
                return e[1].sub(t1.prevPoint).unit();
            }
            clipLinesToTile(t1, e) {
                return bd(t1, -e, -e, Cn + e, Cn + e);
            }
            clipRuntimeLinesToTile(t1, e) {
                const r = [];
                return [
                    bd(t1, -e, -e, Cn + e, Cn + e, r),
                    r
                ];
            }
            addElevatedRoadFeature(t1, e, r, n, i, s, o, a) {
                const l = [], u = Gu.getElevationFeature(t1, n);
                if (u) {
                    const t1 = this.clipLinesToTile(e, 1), n = this.prepareElevatedLines(t1, u, r);
                    for (const t1 of n)l.push({
                        geometry: t1,
                        elevation: u,
                        elevationTileID: r,
                        segment: {
                            progress: {
                                min: 0,
                                max: 1
                            },
                            nextDir: void 0,
                            prevDir: void 0
                        }
                    });
                }
                if (0 === l.length) return !1;
                for (const e of l){
                    const n = this.layoutVertexArray.length;
                    this.addLine(e.geometry, t1, r, i, s, o, a);
                    const l = new Hu(r, e.elevationTileID);
                    if (e.elevation) for(let t1 = n; t1 < this.layoutVertexArray.length; t1++){
                        const r = new bt(this.layoutVertexArray.int16[6 * t1] >> 1, this.layoutVertexArray.int16[6 * t1 + 1] >> 1), n = l.pointElevation(r, e.elevation, .05);
                        this.updateHeightRange(n), this.zOffsetVertexArray.emplaceBack(n, 0, 0);
                    }
                    else this.fillNonElevatedRoadSegment(n);
                }
                return !0;
            }
            prepareElevatedLines(t1, e, r) {
                if (null != e.constantHeight) return t1;
                const n = [], i = 1 / lu(r);
                for (const r of t1)wd(r, new ju(e, i), 0, n);
                return n;
            }
            fillNonElevatedRoadSegment(t1) {
                for(let e = t1; e < this.layoutVertexArray.length; e++)this.zOffsetVertexArray.emplaceBack(0, 0, 0);
            }
            updateHeightRange(t1) {
                this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t1), this.heightRange.max = Math.max(this.heightRange.max, t1)) : this.heightRange = {
                    min: t1,
                    max: t1
                };
            }
            addLine(t1, e, r, n, i, s, o, a) {
                this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
                const l = "none" === n;
                this.patternJoinNone = this.hasPattern && l, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
                const u = a && a.progress.min > 0, c = a && a.progress.max < 1;
                if (this.lineClips) {
                    let r = {
                        min: this.lineClips.start,
                        max: this.lineClips.end
                    }, n = 1;
                    if (a) {
                        const t1 = this.lineClips.end - this.lineClips.start;
                        r = function(t1, e, r) {
                            return {
                                min: re(t1.min, e, r),
                                max: re(t1.max, e, r)
                            };
                        }(a.progress, {
                            min: 0,
                            max: 1
                        }, r), t1 > 0 && (n = (r.max - r.min) / t1);
                    }
                    const i = +e.properties.mapbox_clip_feature_len, s = +e.properties.mapbox_clip_seg_len;
                    if (Number.isNaN(i) || Number.isNaN(s)) {
                        for(let e = 0; e < t1.length - 1; e++)this.totalDistance += t1[e].dist(t1[e + 1]);
                        const e = this.totalDistance / (r.max - r.min);
                        this.totalFeatureLength = Number.isFinite(e) ? e : 0, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                    } else this.totalFeatureLength = i, this.distance = s * n, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
                    this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
                }
                const h = "Polygon" === ym[e.type];
                let p = t1.length;
                for(; p >= 2 && t1[p - 1].equals(t1[p - 2]);)p--;
                let d = 0;
                for(; d < p - 1 && t1[d].equals(t1[d + 1]);)d++;
                if (p < (h ? 3 : 2)) return;
                "bevel" === n && (s = 1.05);
                const f = this.segments.prepareSegment(10 * p, this.layoutVertexArray, this.indexArray);
                let m, y, g, x, v, b, w, _;
                a && a.prevDir && (b = a.prevDir.perp()), a && a.nextDir && (w = a.nextDir.perp()), this.e1 = this.e2 = -1, h && (m = t1[p - 2], v = t1[d].sub(m)._unit()._perp());
                for(let e = d; e < p; e++){
                    if (g = e === p - 1 ? h ? t1[d + 1] : void 0 : t1[e + 1], g && t1[e].equals(g)) continue;
                    v && (x = v), m && (y = m), m = t1[e], _ = this.evaluateLineProgressFeatures(y ? y.dist(m) : 0), v = g ? g.sub(m)._unit()._perp() : x, x = x || v;
                    const r = y && g;
                    let a = r ? n : h || l ? "butt" : i;
                    const A = x.x * v.x + x.y * v.y;
                    if (l) {
                        const t1 = function(t1) {
                            if (t1.patternJoinNone) {
                                const e = t1.segmentPoints.length / 2, r = t1.lineSoFar - t1.segmentStart;
                                for(let n = 0; n < e; ++n){
                                    const e = t1.segmentPoints[2 * n + 1], i = Math.round(t1.segmentPoints[2 * n]) + .5 + .25 * e;
                                    t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart), t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart);
                                }
                                t1.segmentPoints.length = 0;
                            }
                            t1.e1 = t1.e2 = -1;
                        };
                        if (r && A < xm) {
                            this.updateDistance(y, m), this.addCurrentVertex(m, x, 1, 1, f, _), t1(this), this.addCurrentVertex(m, v, -1, -1, f, _);
                            continue;
                        }
                        if (y) {
                            if (!g) {
                                this.updateDistance(y, m), this.addCurrentVertex(m, x, 1, 1, f, _), t1(this);
                                continue;
                            }
                            a = "miter";
                        }
                    }
                    let M = x.add(v);
                    0 === M.x && 0 === M.y || M._unit();
                    const I = M.x * v.x + M.y * v.y, S = 0 !== I ? 1 / I : 1 / 0, P = 2 * Math.sqrt(2 - 2 * I), E = I < gm && y && g, k = x.x * v.y - x.y * v.x > 0, z = this.overscaling <= 16 ? 15 * Cn / (512 * this.overscaling) : 0;
                    if (r && "round" === a) {
                        if (S < o) a = "miter";
                        else if (S <= 2) {
                            const t1 = bm(m, -10, Cn + 10);
                            a = "offset" === this.elevationType && (t1 || this.hasCrossSlope) ? "miter" : "fakeround";
                        }
                    }
                    if ("miter" === a && S > s && (a = "bevel"), "bevel" === a && (S > 2 && (a = "flipbevel"), S < s && (a = "miter")), y && !("miter" === a && E) && this.updateDistance(y, m), "miter" === a) if (E) {
                        const t1 = m.dist(y);
                        if (t1 > 2 * z) {
                            const e = m.sub(m.sub(y)._mult(z / t1)._round());
                            this.updateDistance(y, e), this.addCurrentVertex(e, x, 0, 0, f, _), y = e;
                        }
                        this.updateDistance(y, m), M._mult(S), this.addCurrentVertex(m, M, 0, 0, f, _);
                        const e = m.dist(g);
                        if (e > 2 * z) {
                            const t1 = m.add(g.sub(m)._mult(z / e)._round());
                            this.updateDistance(m, t1), this.addCurrentVertex(t1, v, 0, 0, f, _), m = t1;
                        }
                    } else M._mult(S), this.addCurrentVertex(m, M, 0, 0, f, _);
                    else if ("flipbevel" === a) {
                        if (S > 100) M = v.mult(-1);
                        else {
                            const t1 = S * x.add(v).mag() / x.sub(v).mag();
                            M._perp()._mult(t1 * (k ? -1 : 1));
                        }
                        this.addCurrentVertex(m, M, 0, 0, f, _), this.addCurrentVertex(m, M.mult(-1), 0, 0, f, _);
                    } else if ("bevel" === a || "fakeround" === a) {
                        null != _ && y && this.addCurrentVertex(m, w || x, -1, -1, f, _);
                        const t1 = m.dist(y) <= 2 * z && "bevel" !== a, e = M.mult(k ? 1 : -1);
                        e._mult(S);
                        const r = v.mult(k ? -1 : 1), n = x.mult(k ? -1 : 1), i = this.evaluateLineProgressFeatures(this.distance);
                        if (null == _ && (this.addHalfVertex(m, e.x, e.y, !1, !k, 0, f, i), t1 || this.addHalfVertex(m, e.x + 2 * n.x, e.y + 2 * n.y, !1, k, 0, f, i)), "fakeround" === a) {
                            const t1 = Math.round(180 * P / Math.PI / 20);
                            this.addHalfVertex(m, n.x, n.y, !1, k, 0, f, i);
                            for(let e = 0; e < t1; e++){
                                let s = e / t1;
                                if (.5 !== s) {
                                    const t1 = s - .5;
                                    s += s * t1 * (s - 1) * ((1.0904 + A * (A * (3.55645 - 1.43519 * A) - 3.2452)) * t1 * t1 + (.848013 + A * (.215638 * A - 1.06021)));
                                }
                                const o = r.sub(n)._mult(s)._add(n)._unit();
                                this.addHalfVertex(m, o.x, o.y, !1, k, 0, f, i);
                            }
                            this.addHalfVertex(m, r.x, r.y, !1, k, 0, f, i);
                        }
                        t1 || null != _ || this.addHalfVertex(m, e.x + 2 * r.x, e.y + 2 * r.y, !1, k, 0, f, i), null != _ && g && this.addCurrentVertex(m, b || v, 1, 1, f, _);
                    } else if ("butt" === a) this.addCurrentVertex(m, M, 0, 0, f, _);
                    else if ("square" === a) {
                        if (!y) {
                            const t1 = u ? 0 : -1;
                            this.addCurrentVertex(m, M, t1, t1, f, _);
                        }
                        if (this.addCurrentVertex(m, M, 0, 0, f, _), y) {
                            const t1 = c ? 0 : 1;
                            this.addCurrentVertex(m, M, t1, t1, f, _);
                        }
                    } else if ("round" === a) {
                        if (y) {
                            const t1 = !r && w ? w : x;
                            this.addCurrentVertex(m, t1, 0, 0, f, _), !r && c || this.addCurrentVertex(m, t1, 1, 1, f, _, !0);
                        }
                        if (g) {
                            const t1 = !r && b ? b : v;
                            !r && u || this.addCurrentVertex(m, t1, -1, -1, f, _, !0), this.addCurrentVertex(m, t1, 0, 0, f, _);
                        }
                    }
                }
            }
            addVerticesTo(t1, e, r, n, i, s, o, a, l, u) {
                const c = (e.w - t1.w) / this.tessellationStep | 0;
                let h = 0;
                const p = this.scaledDistance;
                if (c > 1) {
                    this.lineSoFar = t1.w;
                    const p = (e.x - t1.x) / c, d = (e.y - t1.y) / c, f = (e.z - t1.z) / c, m = (e.w - t1.w) / c;
                    for(let e = 1; e < c; ++e){
                        t1.x += p, t1.y += d, t1.z += f, this.lineSoFar += m, h += m;
                        const e = this.evaluateLineProgressFeatures(this.prevDistance + h);
                        this.scaledDistance = (this.prevDistance + h) / this.totalDistance, this.addHalfVertex(t1, r, n, u, !1, o, l, e), this.addHalfVertex(t1, i, s, u, !0, -a, l, e);
                    }
                }
                this.lineSoFar = e.w, this.scaledDistance = p;
                const d = this.evaluateLineProgressFeatures(this.distance);
                this.addHalfVertex(e, r, n, u, !1, o, l, d), this.addHalfVertex(e, i, s, u, !0, -a, l, d);
            }
            evaluateLineProgressFeatures(t1) {
                if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
                this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t1) / this.totalFeatureLength) : Gt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
                let e = 0;
                return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? {
                    zOffset: 0,
                    variableWidth: e
                } : "constant" === this.zOffsetValue.kind ? {
                    zOffset: this.zOffsetValue.value,
                    variableWidth: e
                } : {
                    zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
                    variableWidth: e
                };
            }
            addCurrentVertex(t1, e, r, n, i, s, o = !1) {
                const a = e.x + e.y * r, l = e.y - e.x * r, u = e.y * n - e.x, c = -e.y - e.x * n;
                if (null != s) {
                    const e = "offset" === this.elevationType, h = -10, p = Cn + 10, d = s.zOffset, f = new gd(t1.x, t1.y, d, this.lineSoFar), m = !!e && bm(t1, h, p), y = this.lineSoFar, g = this.distance;
                    if (this.currentVertex) if (m) {
                        const e = this.currentVertexIsOutside, s = this.currentVertex, m = new gd(t1.x, t1.y, d, this.lineSoFar);
                        if (vd(s, m, h, p), !bm(m, h, p)) {
                            if (e) {
                                this.e1 = this.e2 = -1, this.distance -= s.dist(f), this.lineSoFar = s.w;
                                const t1 = this.evaluateLineProgressFeatures(s.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                this.addHalfVertex(s, a, l, o, !1, r, i, t1), this.addHalfVertex(s, u, c, o, !0, -n, i, t1), this.prevDistance = this.distance;
                            }
                            this.distance = this.prevDistance + s.dist(m), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s, m, a, l, u, c, r, n, i, o), this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                    } else {
                        const t1 = this.currentVertex;
                        if (this.currentVertexIsOutside) {
                            vd(t1, f, h, p), this.e1 = this.e2 = -1, this.distance -= t1.dist(f), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1.w;
                            const e = this.evaluateLineProgressFeatures(t1.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                            this.addHalfVertex(t1, a, l, o, !1, r, i, e), this.addHalfVertex(t1, u, c, o, !0, -n, i, e), this.prevDistance = this.distance, this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                        this.addVerticesTo(t1, f, a, l, u, c, r, n, i, o);
                    }
                    else m || (this.addHalfVertex(t1, a, l, o, !1, r, i, s), this.addHalfVertex(t1, u, c, o, !0, -n, i, s));
                    this.currentVertex = f, this.currentVertexIsOutside = m, this.lineSoFar = y;
                } else this.addHalfVertex(t1, a, l, o, !1, r, i, s), this.addHalfVertex(t1, u, c, o, !0, -n, i, s);
            }
            addHalfVertex({ x: t1, y: e }, r, n, i, s, o, a, l) {
                if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s || this.segmentPoints.push(this.lineSoFar - this.segmentStart, o)), this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
                    const t1 = ur(this.lineClips.start, this.lineClips.end, this.scaledDistance);
                    this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t1);
                }
                const u = a.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), a.primitiveLength++), s ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l.zOffset, l.variableWidth, l.variableWidth);
            }
            updateScaledDistance() {
                this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
            }
            updateDistance(t1, e) {
                this.prevDistance = this.distance, this.distance += t1.dist(e), this.updateScaledDistance();
            }
        }
        function bm(t1, e, r) {
            return t1.x < e || t1.x > r || t1.y < e || t1.y > r;
        }
        let wm, _m;
        function Am(t1, e, r) {
            return e * (Cn / (t1.tileSize * Math.pow(2, r - t1.tileID.overscaledZ)));
        }
        qs(vm, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures",
                "currentVertex",
                "currentVertexIsOutside"
            ]
        });
        const Mm = (t1, e, r)=>(1 - r) * t1 + r * e;
        function Im(t1, e) {
            return 1 / Am(t1, 1, e.tileZoom);
        }
        function Sm(t1, e, r, n) {
            return t1.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const Pm = (t1)=>{
            const e = [];
            Em(t1) && e.push("RENDER_LINE_DASH"), t1.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
            const r = t1.paint.get("line-trim-offset");
            0 === r[0] && 0 === r[1] || e.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t1.paint.get("line-border-width").constantOr(1) && e.push("RENDER_LINE_BORDER");
            const n = "none" === t1.layout.get("line-join").constantOr("miter"), i = !!t1.paint.get("line-pattern").constantOr(1);
            return n && i && e.push("LINE_JOIN_NONE"), e;
        };
        function Em(t1) {
            const e = t1.paint.get("line-dasharray").value;
            return e.value || "constant" !== e.kind;
        }
        let km;
        const zm = ()=>km || (km = {
                layout: wm || (wm = new zo({
                    "line-cap": new Eo(To.layout_line["line-cap"]),
                    "line-join": new Eo(To.layout_line["line-join"]),
                    "line-miter-limit": new Po(To.layout_line["line-miter-limit"]),
                    "line-round-limit": new Po(To.layout_line["line-round-limit"]),
                    "line-sort-key": new Eo(To.layout_line["line-sort-key"]),
                    "line-z-offset": new Eo(To.layout_line["line-z-offset"]),
                    "line-elevation-reference": new Po(To.layout_line["line-elevation-reference"]),
                    "line-cross-slope": new Po(To.layout_line["line-cross-slope"]),
                    visibility: new Po(To.layout_line.visibility),
                    "line-width-unit": new Po(To.layout_line["line-width-unit"])
                })),
                paint: _m || (_m = new zo({
                    "line-opacity": new Eo(To.paint_line["line-opacity"]),
                    "line-color": new Eo(To.paint_line["line-color"]),
                    "line-translate": new Po(To.paint_line["line-translate"]),
                    "line-translate-anchor": new Po(To.paint_line["line-translate-anchor"]),
                    "line-width": new Eo(To.paint_line["line-width"]),
                    "line-gap-width": new Eo(To.paint_line["line-gap-width"]),
                    "line-offset": new Eo(To.paint_line["line-offset"]),
                    "line-blur": new Eo(To.paint_line["line-blur"]),
                    "line-dasharray": new Eo(To.paint_line["line-dasharray"]),
                    "line-pattern": new Eo(To.paint_line["line-pattern"]),
                    "line-pattern-cross-fade": new Po(To.paint_line["line-pattern-cross-fade"]),
                    "line-gradient": new ko(To.paint_line["line-gradient"]),
                    "line-trim-offset": new Po(To.paint_line["line-trim-offset"]),
                    "line-trim-fade-range": new Po(To.paint_line["line-trim-fade-range"]),
                    "line-trim-color": new Po(To.paint_line["line-trim-color"]),
                    "line-emissive-strength": new Po(To.paint_line["line-emissive-strength"]),
                    "line-border-width": new Eo(To.paint_line["line-border-width"]),
                    "line-border-color": new Eo(To.paint_line["line-border-color"]),
                    "line-occlusion-opacity": new Po(To.paint_line["line-occlusion-opacity"]),
                    "line-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-gradient-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-trim-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-border-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, km);
        class Tm extends Eo {
            possiblyEvaluate(t1, e) {
                return e = new xo(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition,
                    worldview: e.worldview
                }), super.possiblyEvaluate(t1, e);
            }
            evaluate(t1, e, r, n) {
                return e = Ct({}, e, {
                    zoom: Math.floor(e.zoom)
                }), super.evaluate(t1, e, r, n);
            }
        }
        let Bm;
        function Vm(t1, e) {
            return e > 0 ? e + 2 * t1 : t1;
        }
        const Cm = ea([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), Fm = ea([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), Dm = ea([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        ea([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const Lm = ea([
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), Rm = ea([
            {
                name: "a_x_axis",
                components: 3,
                type: "Float32"
            },
            {
                name: "a_y_axis",
                components: 3,
                type: "Float32"
            }
        ]), Om = ea([
            {
                name: "a_texb",
                components: 2,
                type: "Uint16"
            }
        ]), Um = ea([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_elevation_from_sea",
                components: 2,
                type: "Float32"
            }
        ]), Nm = ea([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ]);
        ea([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const jm = ea([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), $m = ea([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        ea([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), ea([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), ea([
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            },
            {
                type: "Float32",
                name: "zOffset"
            },
            {
                type: "Uint8",
                name: "hasIconTextFit"
            },
            {
                type: "Uint16",
                name: "elevationFeatureIndex"
            }
        ]), ea([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), ea([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var Gm = 24;
        function Hm(t1, e, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), go.applyArabicShaping && (t1 = go.applyArabicShaping(t1)), t1;
                }(t1.text, e, r);
            }), t1;
        }
        const qm = {
            "!": "ï¸",
            "#": "ï¼",
            $: "ï¼",
            "%": "ï¼",
            "&": "ï¼",
            "(": "ï¸µ",
            ")": "ï¸¶",
            "*": "ï¼",
            "+": "ï¼",
            ",": "ï¸",
            "-": "ï¸²",
            ".": "ã»",
            "/": "ï¼",
            ":": "ï¸",
            ";": "ï¸",
            "<": "ï¸¿",
            "=": "ï¼",
            ">": "ï¹",
            "?": "ï¸",
            "@": "ï¼ ",
            "[": "ï¹",
            "\\": "ï¼¼",
            "]": "ï¹",
            "^": "ï¼¾",
            _: "ï¸³",
            "`": "ï½",
            "{": "ï¸·",
            "|": "â",
            "}": "ï¸¸",
            "~": "ï½",
            "Â¢": "ï¿ ",
            "Â£": "ï¿¡",
            "Â¥": "ï¿¥",
            "Â¦": "ï¿¤",
            "Â¬": "ï¿¢",
            "Â¯": "ï¿£",
            "â": "ï¸²",
            "â": "ï¸±",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â¦": "ï¸",
            "â§": "ã»",
            "â©": "ï¿¦",
            "ã": "ï¸",
            "ã": "ï¸",
            "ã": "ï¸¿",
            "ã": "ï¹",
            "ã": "ï¸½",
            "ã": "ï¸¾",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¸»",
            "ã": "ï¸¼",
            "ã": "ï¸¹",
            "ã": "ï¸º",
            "ã": "ï¸",
            "ã": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸µ",
            "ï¼": "ï¸¶",
            "ï¼": "ï¸",
            "ï¼": "ï¸²",
            "ï¼": "ã»",
            "ï¼": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸¿",
            "ï¼": "ï¹",
            "ï¼": "ï¸",
            "ï¼»": "ï¹",
            "ï¼½": "ï¹",
            "ï¼¿": "ï¸³",
            "ï½": "ï¸·",
            "ï½": "â",
            "ï½": "ï¸¸",
            "ï½": "ï¸µ",
            "ï½ ": "ï¸¶",
            "ï½¡": "ï¸",
            "ï½¢": "ï¹",
            "ï½£": "ï¹",
            "â": "â",
            "â": "â"
        };
        function Xm(t1) {
            return "ï¸¶" === t1 || "ï¹" === t1 || "ï¸¸" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸¾" === t1 || "ï¸¼" === t1 || "ï¸º" === t1 || "ï¸" === t1 || "ï¹" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï½" === t1 || "ï¿£" === t1 || "ï¸" === t1 || "ï¸" === t1;
        }
        function Zm(t1) {
            return "ï¸µ" === t1 || "ï¹" === t1 || "ï¸·" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸½" === t1 || "ï¸»" === t1 || "ï¸¹" === t1 || "ï¸" === t1 || "ï¸¿" === t1;
        }
        const Wm = 4294967296, Ym = 1 / Wm, Km = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        let Jm = class {
            constructor(t1 = new Uint8Array(16)){
                this.buf = ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            readFields(t1, e, r = this.length) {
                for(; this.pos < r;){
                    const r = this.readVarint(), n = r >> 3, i = this.pos;
                    this.type = 7 & r, t1(n, e, this), this.pos === i && this.skip(r);
                }
                return e;
            }
            readMessage(t1, e) {
                return this.readFields(t1, e, this.readVarint() + this.pos);
            }
            readFixed32() {
                const t1 = this.dataView.getUint32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readSFixed32() {
                const t1 = this.dataView.getInt32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readFixed64() {
                const t1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Wm;
                return this.pos += 8, t1;
            }
            readSFixed64() {
                const t1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Wm;
                return this.pos += 8, t1;
            }
            readFloat() {
                const t1 = this.dataView.getFloat32(this.pos, !0);
                return this.pos += 4, t1;
            }
            readDouble() {
                const t1 = this.dataView.getFloat64(this.pos, !0);
                return this.pos += 8, t1;
            }
            readVarint(t1) {
                const e = this.buf;
                let r, n;
                return n = e[this.pos++], r = 127 & n, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 7, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 14, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 21, n < 128 ? r : (n = e[this.pos], r |= (15 & n) << 28, function(t1, e, r) {
                    const n = r.buf;
                    let i, s;
                    if (s = n[r.pos++], i = (112 & s) >> 4, s < 128) return Qm(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 3, s < 128) return Qm(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 10, s < 128) return Qm(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 17, s < 128) return Qm(t1, i, e);
                    if (s = n[r.pos++], i |= (127 & s) << 24, s < 128) return Qm(t1, i, e);
                    if (s = n[r.pos++], i |= (1 & s) << 31, s < 128) return Qm(t1, i, e);
                    throw new Error("Expected varint not more than 10 bytes");
                }(r, t1, this)))));
            }
            readVarint64() {
                return this.readVarint(!0);
            }
            readSVarint() {
                const t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            }
            readBoolean() {
                return Boolean(this.readVarint());
            }
            readString() {
                const t1 = this.readVarint() + this.pos, e = this.pos;
                return this.pos = t1, t1 - e >= 12 && Km ? Km.decode(this.buf.subarray(e, t1)) : function(t1, e, r) {
                    let n = "", i = e;
                    for(; i < r;){
                        const e = t1[i];
                        let s, o, a, l = null, u = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                        if (i + u > r) break;
                        1 === u ? e < 128 && (l = e) : 2 === u ? (s = t1[i + 1], 128 == (192 & s) && (l = (31 & e) << 6 | 63 & s, l <= 127 && (l = null))) : 3 === u ? (s = t1[i + 1], o = t1[i + 2], 128 == (192 & s) && 128 == (192 & o) && (l = (15 & e) << 12 | (63 & s) << 6 | 63 & o, (l <= 2047 || l >= 55296 && l <= 57343) && (l = null))) : 4 === u && (s = t1[i + 1], o = t1[i + 2], a = t1[i + 3], 128 == (192 & s) && 128 == (192 & o) && 128 == (192 & a) && (l = (15 & e) << 18 | (63 & s) << 12 | (63 & o) << 6 | 63 & a, (l <= 65535 || l >= 1114112) && (l = null))), null === l ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += u;
                    }
                    return n;
                }(this.buf, e, t1);
            }
            readBytes() {
                const t1 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e;
            }
            readPackedVarint(t1 = [], e) {
                const r = this.readPackedEnd();
                for(; this.pos < r;)t1.push(this.readVarint(e));
                return t1;
            }
            readPackedSVarint(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSVarint());
                return t1;
            }
            readPackedBoolean(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readBoolean());
                return t1;
            }
            readPackedFloat(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFloat());
                return t1;
            }
            readPackedDouble(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readDouble());
                return t1;
            }
            readPackedFixed32(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFixed32());
                return t1;
            }
            readPackedSFixed32(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSFixed32());
                return t1;
            }
            readPackedFixed64(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readFixed64());
                return t1;
            }
            readPackedSFixed64(t1 = []) {
                const e = this.readPackedEnd();
                for(; this.pos < e;)t1.push(this.readSFixed64());
                return t1;
            }
            readPackedEnd() {
                return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
            }
            skip(t1) {
                const e = 7 & t1;
                if (0 === e) for(; this.buf[this.pos++] > 127;);
                else if (2 === e) this.pos = this.readVarint() + this.pos;
                else if (5 === e) this.pos += 4;
                else {
                    if (1 !== e) throw new Error(`Unimplemented type: ${e}`);
                    this.pos += 8;
                }
            }
            writeTag(t1, e) {
                this.writeVarint(t1 << 3 | e);
            }
            realloc(t1) {
                let e = this.length || 16;
                for(; e < this.pos + t1;)e *= 2;
                if (e !== this.length) {
                    const t1 = new Uint8Array(e);
                    t1.set(this.buf), this.buf = t1, this.dataView = new DataView(t1.buffer), this.length = e;
                }
            }
            finish() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }
            writeFixed32(t1) {
                this.realloc(4), this.dataView.setInt32(this.pos, t1, !0), this.pos += 4;
            }
            writeSFixed32(t1) {
                this.realloc(4), this.dataView.setInt32(this.pos, t1, !0), this.pos += 4;
            }
            writeFixed64(t1) {
                this.realloc(8), this.dataView.setInt32(this.pos, -1 & t1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t1 * Ym), !0), this.pos += 8;
            }
            writeSFixed64(t1) {
                this.realloc(8), this.dataView.setInt32(this.pos, -1 & t1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t1 * Ym), !0), this.pos += 8;
            }
            writeVarint(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e) {
                    let r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (r = ~(-t1 % 4294967296), n = ~(-t1 / 4294967296), 4294967295 ^ r ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e.realloc(10), function(t1, e, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e), function(t1, e) {
                        const r = (7 & t1) << 4;
                        e.buf[e.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1)))));
                    }(n, e);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            }
            writeSVarint(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            }
            writeBoolean(t1) {
                this.writeVarint(+t1);
            }
            writeString(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                const e = this.pos;
                this.pos = function(t1, e, r) {
                    for(let n, i, s = 0; s < e.length; s++){
                        if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                const r = this.pos - e;
                r >= 128 && ty(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
            }
            writeFloat(t1) {
                this.realloc(4), this.dataView.setFloat32(this.pos, t1, !0), this.pos += 4;
            }
            writeDouble(t1) {
                this.realloc(8), this.dataView.setFloat64(this.pos, t1, !0), this.pos += 8;
            }
            writeBytes(t1) {
                const e = t1.length;
                this.writeVarint(e), this.realloc(e);
                for(let r = 0; r < e; r++)this.buf[this.pos++] = t1[r];
            }
            writeRawMessage(t1, e) {
                this.pos++;
                const r = this.pos;
                t1(e, this);
                const n = this.pos - r;
                n >= 128 && ty(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            }
            writeMessage(t1, e, r) {
                this.writeTag(t1, 2), this.writeRawMessage(e, r);
            }
            writePackedVarint(t1, e) {
                e.length && this.writeMessage(t1, ey, e);
            }
            writePackedSVarint(t1, e) {
                e.length && this.writeMessage(t1, ry, e);
            }
            writePackedBoolean(t1, e) {
                e.length && this.writeMessage(t1, sy, e);
            }
            writePackedFloat(t1, e) {
                e.length && this.writeMessage(t1, ny, e);
            }
            writePackedDouble(t1, e) {
                e.length && this.writeMessage(t1, iy, e);
            }
            writePackedFixed32(t1, e) {
                e.length && this.writeMessage(t1, oy, e);
            }
            writePackedSFixed32(t1, e) {
                e.length && this.writeMessage(t1, ay, e);
            }
            writePackedFixed64(t1, e) {
                e.length && this.writeMessage(t1, ly, e);
            }
            writePackedSFixed64(t1, e) {
                e.length && this.writeMessage(t1, uy, e);
            }
            writeBytesField(t1, e) {
                this.writeTag(t1, 2), this.writeBytes(e);
            }
            writeFixed32Field(t1, e) {
                this.writeTag(t1, 5), this.writeFixed32(e);
            }
            writeSFixed32Field(t1, e) {
                this.writeTag(t1, 5), this.writeSFixed32(e);
            }
            writeFixed64Field(t1, e) {
                this.writeTag(t1, 1), this.writeFixed64(e);
            }
            writeSFixed64Field(t1, e) {
                this.writeTag(t1, 1), this.writeSFixed64(e);
            }
            writeVarintField(t1, e) {
                this.writeTag(t1, 0), this.writeVarint(e);
            }
            writeSVarintField(t1, e) {
                this.writeTag(t1, 0), this.writeSVarint(e);
            }
            writeStringField(t1, e) {
                this.writeTag(t1, 2), this.writeString(e);
            }
            writeFloatField(t1, e) {
                this.writeTag(t1, 5), this.writeFloat(e);
            }
            writeDoubleField(t1, e) {
                this.writeTag(t1, 1), this.writeDouble(e);
            }
            writeBooleanField(t1, e) {
                this.writeVarintField(t1, +e);
            }
        };
        function Qm(t1, e, r) {
            return r ? 4294967296 * e + (t1 >>> 0) : 4294967296 * (e >>> 0) + (t1 >>> 0);
        }
        function ty(t1, e, r) {
            const n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
            r.realloc(n);
            for(let e = r.pos - 1; e >= t1; e--)r.buf[e + n] = r.buf[e];
        }
        function ey(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeVarint(t1[r]);
        }
        function ry(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSVarint(t1[r]);
        }
        function ny(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFloat(t1[r]);
        }
        function iy(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeDouble(t1[r]);
        }
        function sy(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeBoolean(t1[r]);
        }
        function oy(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFixed32(t1[r]);
        }
        function ay(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSFixed32(t1[r]);
        }
        function ly(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeFixed64(t1[r]);
        }
        function uy(t1, e) {
            for(let r = 0; r < t1.length; r++)e.writeSFixed64(t1[r]);
        }
        const cy = 3;
        function hy(t1, e, r) {
            e.glyphs = [], 1 === t1 && r.readMessage(py, e);
        }
        function py(t1, e, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: s, left: o, top: a, advance: l } = r.readMessage(dy, {});
                e.glyphs.push({
                    id: t1,
                    bitmap: new hh({
                        width: i + 2 * cy,
                        height: s + 2 * cy
                    }, n),
                    metrics: {
                        width: i,
                        height: s,
                        left: o,
                        top: a,
                        advance: l
                    }
                });
            } else 4 === t1 ? e.ascender = r.readSVarint() : 5 === t1 && (e.descender = r.readSVarint());
        }
        function dy(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? e.bitmap = r.readBytes() : 3 === t1 ? e.width = r.readVarint() : 4 === t1 ? e.height = r.readVarint() : 5 === t1 ? e.left = r.readSVarint() : 6 === t1 ? e.top = r.readSVarint() : 7 === t1 && (e.advance = r.readVarint());
        }
        const fy = cy, my = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class yy {
            constructor(){
                this.scale = 1, this.fontStack = "", this.image = null;
            }
            static forText(t1, e) {
                const r = new yy;
                return r.scale = t1 || 1, r.fontStack = e, r;
            }
            static forImage(t1) {
                const e = new yy;
                return e.image = t1, e;
            }
        }
        class gy {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e, r) {
                const n = new gy;
                for(let i = 0; i < t1.sections.length; i++){
                    const s = t1.sections[i];
                    s.image ? n.addImageSection(s, r) : n.addTextSection(s, e);
                }
                return n;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCodePoint(t1) {
                return this.text.codePointAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, s = t1.charCodeAt(n - 1) || null;
                        r += !e && (i && ro(i) && !qm[t1[n + 1]] || s && ro(s) && !qm[t1[n - 1]]) || !qm[t1[n]] ? t1[n] : qm[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e = 0; e < this.text.length && vy[this.text.charCodeAt(e)]; e++)t1++;
                let e = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && vy[this.text.charCodeAt(r)]; r--)e--;
                this.text = this.text.substring(t1, e), this.sectionIndex = this.sectionIndex.slice(t1, e);
            }
            substring(t1, e) {
                const r = new gy;
                return r.text = this.text.substring(t1, e), r.sectionIndex = this.sectionIndex.slice(t1, e), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e)=>Math.max(t1, this.sections[e].scale), 0);
            }
            addTextSection(t1, e) {
                this.text += t1.text, this.sections.push(yy.forText(t1.scale, t1.fontStack || e));
                const r = this.sections.length - 1;
                for(let e = 0; e < t1.text.length; ++e)this.sectionIndex.push(r);
            }
            addImageSection(t1, e) {
                const r = t1.image ? t1.image.getPrimary() : null;
                if (!r) return void Gt("Can't add FormattedSection with an empty image.");
                r.scaleSelf(e);
                const n = this.getNextImageSectionCharCode();
                n ? (this.text += String.fromCodePoint(n), this.sections.push(yy.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : Gt("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function xy(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m = 1) {
            const y = gy.fromFeature(t1, i, m);
            h === my.vertical && y.verticalizePunctuation(p);
            let g = [];
            const x = function(t1, e, r, n, i, s) {
                if (!t1) return [];
                const o = [], a = function(t1, e, r, n, i, s) {
                    let o = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const a = t1.getSection(r);
                        o += wy(t1.getCodePoint(r), a, n, i, e, s);
                    }
                    return o / Math.max(1, Math.ceil(o / r));
                }(t1, e, r, n, i, s), l = t1.text.indexOf("â") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const h = t1.getSection(r), p = t1.getCodePoint(r);
                    if (vy[p] || (u += wy(p, h, n, i, e, s)), r < t1.length() - 1) {
                        const e = !((c = p) < 11904 || !(Ks["Bopomofo Extended"](c) || Ks.Bopomofo(c) || Ks["CJK Compatibility Forms"](c) || Ks["CJK Compatibility Ideographs"](c) || Ks["CJK Compatibility"](c) || Ks["CJK Radicals Supplement"](c) || Ks["CJK Strokes"](c) || Ks["CJK Symbols and Punctuation"](c) || Ks["CJK Unified Ideographs Extension A"](c) || Ks["CJK Unified Ideographs"](c) || Ks["Enclosed CJK Letters and Months"](c) || Ks["Halfwidth and Fullwidth Forms"](c) || Ks.Hiragana(c) || Ks["Ideographic Description Characters"](c) || Ks["Kangxi Radicals"](c) || Ks["Katakana Phonetic Extensions"](c) || Ks.Katakana(c) || Ks["Vertical Forms"](c) || Ks["Yi Radicals"](c) || Ks["Yi Syllables"](c)));
                        (by[p] || e || h.image) && o.push(My(r + 1, u, a, o, Ay(p, t1.getCodePoint(r + 1), e && l), !1));
                    }
                }
                var c;
                return Iy(My(t1.length(), u, a, o, 0, !0));
            }(y, u, s, e, n, d), { processBidirectionalText: v, processStyledBidirectionalText: b } = go;
            if (v && 1 === y.sections.length) {
                const t1 = v(y.toString(), x);
                for (const e of t1){
                    const t1 = new gy;
                    t1.text = e, t1.sections = y.sections;
                    for(let r = 0; r < e.length; r++)t1.sectionIndex.push(0);
                    g.push(t1);
                }
            } else if (b) {
                const t1 = b(y.text, y.sectionIndex, x);
                for (const e of t1){
                    const t1 = new gy;
                    t1.text = e[0], t1.sectionIndex = e[1], t1.sections = y.sections, g.push(t1);
                }
            } else g = function(t1, e) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(y, x);
            const w = [], _ = {
                positionedLines: w,
                text: y.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            if (function(t1, e, r, n, i, s, o, a, l, u, c, h) {
                let p = 0, d = 0, f = 0;
                const m = "right" === a ? 1 : "left" === a ? 0 : .5;
                let y = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.image) continue;
                        const r = e[t1.fontStack];
                        if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;
                    }
                    if (!y) break;
                }
                let g = 0;
                for (const o of i){
                    o.trim();
                    const i = o.getMaxScale(), a = (i - 1) * Gm, v = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = v;
                    const b = v.positionedGlyphs;
                    let w = 0;
                    if (!o.length()) {
                        d += s, ++g;
                        continue;
                    }
                    let _ = 0, A = 0;
                    for(let s = 0; s < o.length(); s++){
                        const a = o.getSection(s), f = o.getSectionIndex(s), m = o.getCodePoint(s);
                        let g = a.scale, v = null, M = null, I = null, S = Gm, P = 0, E = l;
                        E === my.vertical && (12312 === (x = m) || 12313 === x || 12316 === x || 12540 === x || 12448 === x) && (E = my.horizontal);
                        const k = !(E === my.horizontal || !c && !eo(m) || c && (vy[m] || no(m)));
                        if (a.image) {
                            const e = n.get(a.image.toString());
                            if (!e) continue;
                            I = a.image, t1.iconsInText = t1.iconsInText || !0, M = e.paddedRect;
                            const r = e.displaySize;
                            g = g * Gm / h, v = {
                                width: r[0],
                                height: r[1],
                                left: 0,
                                top: -fy,
                                advance: k ? r[1] : r[0],
                                localGlyph: !1
                            }, P = y ? -v.height * g : i * Gm - 17 - r[1] * g, S = v.advance;
                            const s = (k ? r[0] : r[1]) * g - Gm * i;
                            s > 0 && s > w && (w = s);
                        } else {
                            const t1 = r[a.fontStack];
                            if (!t1) continue;
                            t1[m] && (M = t1[m]);
                            const n = e[a.fontStack];
                            if (!n) continue;
                            const s = n.glyphs[m];
                            if (!s) continue;
                            if (v = s.metrics, S = 8203 !== m ? Gm : 0, y) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e) * g;
                                _ < r && (_ = r, A = (t1 - e) / 2 * g), P = -t1 * g;
                            } else P = (i - g) * Gm - 17;
                        }
                        k ? (t1.verticalizable = !0, b.push({
                            glyph: m,
                            image: I,
                            x: p,
                            y: d + P,
                            vertical: k,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: f,
                            metrics: v,
                            rect: M
                        }), p += S * g + u) : (b.push({
                            glyph: m,
                            image: I,
                            x: p,
                            y: d + P,
                            vertical: k,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: a.fontStack,
                            sectionIndex: f,
                            metrics: v,
                            rect: M
                        }), p += v.advance * g + u);
                    }
                    0 !== b.length && (f = Math.max(p - u, f), y ? Py(b, m, w, A, s * i / 2) : Py(b, m, w, 0, s / 2)), p = 0;
                    const M = s * i + w;
                    v.lineOffset = Math.max(w, a), d += M, ++g;
                }
                var x;
                const v = d, { horizontalAlign: b, verticalAlign: w } = Sy(o);
                (function(t1, e, r, n, i, s) {
                    const o = (e - r) * i, a = -s * n;
                    for (const e of t1)for (const t1 of e.positionedGlyphs)t1.x += o, t1.y += a;
                })(t1.positionedLines, m, b, w, f, v), t1.top += -w * v, t1.bottom = t1.top + v, t1.left += -b * f, t1.right = t1.left + f, t1.hasBaseline = y;
            }(_, e, r, n, g, o, a, l, h, u, p, f), !function(t1) {
                for (const e of t1)if (0 !== e.positionedGlyphs.length) return !1;
                return !0;
            }(w)) return _;
        }
        const vy = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, by = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function wy(t1, e, r, n, i, s) {
            if (e.image) {
                const t1 = n.get(e.image.toString());
                return t1 ? t1.displaySize[0] * e.scale * Gm / s + i : 0;
            }
            {
                const n = r[e.fontStack], s = n && n.glyphs[t1];
                return s ? s.metrics.advance * e.scale + i : 0;
            }
        }
        function _y(t1, e, r, n) {
            const i = Math.pow(t1 - e, 2);
            return n ? t1 < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function Ay(t1, e, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
        }
        function My(t1, e, r, n, i, s) {
            let o = null, a = _y(e, r, i, s);
            for (const t1 of n){
                const n = _y(e - t1.x, r, i, s) + t1.badness;
                n <= a && (o = t1, a = n);
            }
            return {
                index: t1,
                x: e,
                priorBreak: o,
                badness: a
            };
        }
        function Iy(t1) {
            return t1 ? Iy(t1.priorBreak).concat(t1.index) : [];
        }
        function Sy(t1) {
            let e = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e,
                verticalAlign: r
            };
        }
        function Py(t1, e, r, n, i) {
            if (!(e || r || n || i)) return;
            const s = t1.length - 1, o = t1[s], a = (o.x + o.metrics.advance * o.scale) * e;
            for(let e = 0; e <= s; e++)t1[e].x -= a, t1[e].y += r + n + i;
        }
        function Ey(t1) {
            return void 0 !== t1.imagePrimary && void 0 !== t1.top && void 0 !== t1.bottom && void 0 !== t1.left && void 0 !== t1.right;
        }
        function ky(t1, e, r, n) {
            const { horizontalAlign: i, verticalAlign: s } = Sy(n), o = r[0] - t1.displaySize[0] * i, a = r[1] - t1.displaySize[1] * s;
            return {
                imagePrimary: t1,
                imageSecondary: e,
                top: a,
                bottom: a + t1.displaySize[1],
                left: o,
                right: o + t1.displaySize[0]
            };
        }
        function zy(t1, e, r, n, i, s) {
            const o = t1.imagePrimary;
            let a;
            if (o.content) {
                const t1 = o.content, e = o.pixelRatio || 1;
                a = [
                    t1[0] / e,
                    t1[1] / e,
                    o.displaySize[0] - t1[2] / e,
                    o.displaySize[1] - t1[3] / e
                ];
            }
            const l = e.left * s, u = e.right * s;
            let c, h, p, d;
            "width" === r || "both" === r ? (d = i[0] + l - n[3], h = i[0] + u + n[1]) : (d = i[0] + (l + u - o.displaySize[0]) / 2, h = d + o.displaySize[0]);
            const f = e.top * s, m = e.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + f - n[0], p = i[1] + m + n[2]) : (c = i[1] + (f + m - o.displaySize[1]) / 2, p = c + o.displaySize[1]), {
                imagePrimary: o,
                imageSecondary: void 0,
                top: c,
                right: h,
                bottom: p,
                left: d,
                collisionPadding: a
            };
        }
        function Ty(t1) {
            return !t1.imagePrimary.stretchX;
        }
        function By(t1) {
            return !t1.imagePrimary.stretchY;
        }
        function Vy(t1) {
            return {
                width: t1.right - t1.left,
                height: t1.bottom - t1.top
            };
        }
        const Cy = 128;
        function Fy(t1, e, r) {
            const { expression: n } = e;
            if ("constant" === n.kind) return {
                kind: "constant",
                layoutSize: n.evaluate(new xo(t1 + 1, {
                    worldview: r
                }))
            };
            if ("source" === n.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e, interpolationType: i } = n;
                let s = 0;
                for(; s < e.length && e[s] <= t1;)s++;
                s = Math.max(0, s - 1);
                let o = s;
                for(; o < e.length && e[o] < t1 + 1;)o++;
                o = Math.min(e.length - 1, o);
                const a = e[s], l = e[o];
                return "composite" === n.kind ? {
                    kind: "composite",
                    minZoom: a,
                    maxZoom: l,
                    interpolationType: i
                } : {
                    kind: "camera",
                    minZoom: a,
                    maxZoom: l,
                    minSize: n.evaluate(new xo(a, {
                        worldview: r
                    })),
                    maxSize: n.evaluate(new xo(l, {
                        worldview: r
                    })),
                    interpolationType: i
                };
            }
        }
        function Dy(t1, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / Cy : "composite" === t1.kind ? ur(n / Cy, i / Cy, r) : e;
        }
        function Ly(t1, e, r = 1) {
            let n = 0, i = 0;
            if ("constant" === t1.kind) i = t1.layoutSize * r;
            else if ("source" !== t1.kind) {
                const { interpolationType: s, minZoom: o, maxZoom: a } = t1, l = s ? zt(ji.interpolationFactor(s, e, o, a), 0, 1) : 0;
                "camera" === t1.kind ? i = ur(t1.minSize, t1.maxSize, l) * r : n = l * r;
            }
            return {
                uSizeT: n,
                uSize: i
            };
        }
        class Ry extends bt {
            constructor(t1, e, r, n, i){
                super(t1, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new Ry(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function Oy(t1, e, r, n, i) {
            if (void 0 === e.segment) return !0;
            let s = e, o = e.segment + 1, a = 0;
            for(; a > -r / 2;){
                if (o--, o < 0) return !1;
                a -= t1[o].dist(s), s = t1[o];
            }
            a += t1[o].dist(t1[o + 1]), o++;
            const l = [];
            let u = 0;
            for(; a < r / 2;){
                const e = t1[o], r = t1[o + 1];
                if (!r) return !1;
                let s = t1[o - 1].angleTo(e) - e.angleTo(r);
                for(s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: a,
                    angleDelta: s
                }), u += s; a - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                o++, a += e.dist(r);
            }
            return !0;
        }
        function Uy(t1) {
            let e = 0;
            for(let r = 0; r < t1.length - 1; r++)e += t1[r].dist(t1[r + 1]);
            return e;
        }
        function Ny(t1, e, r) {
            return t1 ? .6 * e * r : 0;
        }
        function jy(t1, e) {
            return Math.max(t1 ? t1.right - t1.left : 0, e ? e.right - e.left : 0);
        }
        function $y(t1, e, r, n, i, s) {
            const o = Ny(r, i, s), a = jy(r, n) * s;
            let l = 0;
            const u = Uy(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s, h = ur(n.x, i.x, c), p = ur(n.y, i.y, c), d = new Ry(h, p, 0, i.angleTo(n), r);
                    return !o || Oy(t1, d, a, o, e) ? d : void 0;
                }
                l += s;
            }
        }
        function Gy(t1, e, r, n, i, s, o, a, l) {
            const u = Ny(n, s, o), c = jy(n, i), h = c * o, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e - h < e / 4 && (e = h + e / 4), Hy(t1, p ? e / 2 * a % e : (c / 2 + 2 * s) * o * a % e, e, u, r, h, p, !1, l);
        }
        function Hy(t1, e, r, n, i, s, o, a, l) {
            const u = s / 2, c = Uy(t1);
            let h = 0, p = e - r, d = [];
            for(let e = 0; e < t1.length - 1; e++){
                const o = t1[e], a = t1[e + 1], f = o.dist(a), m = a.angleTo(o);
                for(; p + r < h + f;){
                    p += r;
                    const y = (p - h) / f, g = ur(o.x, a.x, y), x = ur(o.y, a.y, y);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Ry(g, x, 0, m, e);
                        n && !Oy(t1, r, s, n, i) || d.push(r);
                    }
                }
                h += f;
            }
            return a || d.length || o || (d = Hy(t1, h / 2, r, n, i, s, o, !0, l)), d;
        }
        function qy(t1) {
            let e = 0, r = 0;
            for (const n of t1)e += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e)=>e.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, s = 0;
            for (const e of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e.w > r.w || e.h > r.h)) {
                    if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
                        const e = n.pop();
                        e && t1 < n.length && (n[t1] = e);
                    } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
                        x: r.x + e.w,
                        y: r.y,
                        w: r.w - e.w,
                        h: e.h
                    }), r.y += e.h, r.h -= e.h);
                    break;
                }
            }
            return {
                w: i,
                h: s,
                fill: e / (i * s) || 0
            };
        }
        qs(Ry, "Anchor");
        const Xy = 1;
        class Zy {
            static getImagePositionScale(t1, e, r) {
                if (e && t1 && t1.options && t1.options.transform) {
                    const e = t1.options.transform;
                    return {
                        x: e.a,
                        y: e.d
                    };
                }
                return {
                    x: r,
                    y: r
                };
            }
            constructor(t1, e, r, n){
                this.paddedRect = t1;
                const { pixelRatio: i, version: s, stretchX: o, stretchY: a, content: l, sdf: u, usvg: c } = e;
                this.pixelRatio = i, this.stretchX = o, this.stretchY = a, this.content = l, this.version = s, this.padding = r, this.sdf = u, this.usvg = c, this.scale = Zy.getImagePositionScale(n, c, i);
            }
            get tl() {
                return [
                    this.paddedRect.x + this.padding,
                    this.paddedRect.y + this.padding
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - this.padding,
                    this.paddedRect.y + this.paddedRect.h - this.padding
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2 * this.padding) / this.scale.x,
                    (this.paddedRect.h - 2 * this.padding) / this.scale.y
                ];
            }
        }
        function Wy(t1, e, r) {
            const n = Fr.parse(t1), i = function(t1, e, r = [
                1,
                1
            ]) {
                return {
                    x: 0,
                    y: 0,
                    w: (t1.data ? t1.data.width : t1.width * r[0]) + 2 * e,
                    h: (t1.data ? t1.data.height : t1.height * r[1]) + 2 * e
                };
            }(e, r, [
                n.options.transform.a,
                n.options.transform.d
            ]);
            return {
                bin: i,
                imagePosition: new Zy(i, e, r, n),
                imageVariant: n
            };
        }
        class Yy {
            constructor(t1, e, r){
                const n = new Map, i = new Map;
                this.haveRenderCallbacks = [];
                const s = [];
                this.addImages(t1, n, Xy, s), this.addImages(e, i, 2, s);
                const { w: o, h: a } = qy(s), l = new ph({
                    width: o || 1,
                    height: a || 1
                });
                for (const [e, i] of t1.entries()){
                    const t1 = n.get(e).paddedRect;
                    ph.copy(i.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: t1.x + Xy,
                        y: t1.y + Xy
                    }, i.data, r, i.sdf);
                }
                for (const [t1, n] of e.entries()){
                    const e = i.get(t1), s = e.paddedRect;
                    let o = e.padding;
                    const a = s.x + o, u = s.y + o, c = n.data.width, h = n.data.height;
                    o = o > 1 ? o - 1 : o, ph.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: u
                    }, n.data, r), ph.copy(n.data, l, {
                        x: 0,
                        y: h - o
                    }, {
                        x: a,
                        y: u - o
                    }, {
                        width: c,
                        height: o
                    }, r), ph.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: u + h
                    }, {
                        width: c,
                        height: o
                    }, r), ph.copy(n.data, l, {
                        x: c - o,
                        y: 0
                    }, {
                        x: a - o,
                        y: u
                    }, {
                        width: o,
                        height: h
                    }, r), ph.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a + c,
                        y: u
                    }, {
                        width: o,
                        height: h
                    }, r), ph.copy(n.data, l, {
                        x: c - o,
                        y: h - o
                    }, {
                        x: a - o,
                        y: u - o
                    }, {
                        width: o,
                        height: o
                    }, r), ph.copy(n.data, l, {
                        x: 0,
                        y: h - o
                    }, {
                        x: a + c,
                        y: u - o
                    }, {
                        width: o,
                        height: o
                    }, r), ph.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a + c,
                        y: u + h
                    }, {
                        width: o,
                        height: o
                    }, r), ph.copy(n.data, l, {
                        x: c - o,
                        y: 0
                    }, {
                        x: a - o,
                        y: u + h
                    }, {
                        width: o,
                        height: o
                    }, r);
                }
                this.lut = r, this.image = l, this.iconPositions = n, this.patternPositions = i;
            }
            addImages(t1, e, r, n) {
                for (const [i, s] of t1.entries()){
                    const { bin: t1, imagePosition: o, imageVariant: a } = Wy(i, s, r);
                    e.set(i, o), n.push(t1), s.hasRenderCallback && this.haveRenderCallbacks.push(a.id);
                }
            }
            patchUpdatedImages(t1, e, r) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e)=>t1.hasImage(e, r)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks, r);
                for (const n of t1.getUpdatedImages(r)){
                    for (const i of this.iconPositions.keys()){
                        const s = Fr.parse(i);
                        if (er.isEqual(s.id, n)) {
                            const s = t1.getImage(n, r);
                            this.patchUpdatedImage(this.iconPositions.get(i), s, e);
                        }
                    }
                    for (const i of this.patternPositions.keys()){
                        const s = Fr.parse(i);
                        if (er.isEqual(s.id, n)) {
                            const s = t1.getImage(n, r);
                            this.patchUpdatedImage(this.patternPositions.get(i), s, e);
                        }
                    }
                }
            }
            patchUpdatedImage(t1, e, r) {
                if (!t1 || !e) return;
                if (t1.version === e.version) return;
                t1.version = e.version;
                const [n, i] = t1.tl, s = t1.sdf;
                if (this.lut || s) {
                    const t1 = {
                        width: e.data.width,
                        height: e.data.height
                    }, o = new ph(t1);
                    ph.copy(e.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, t1, this.lut, s), r.update(o, {
                        position: {
                            x: n,
                            y: i
                        }
                    });
                } else r.update(e.data, {
                    position: {
                        x: n,
                        y: i
                    }
                });
            }
        }
        qs(Zy, "ImagePosition"), qs(Yy, "ImageAtlas");
        const Ky = 1e20;
        function Jy(t1, e, r, n, i, s, o, a, l) {
            for(let u = e; u < e + n; u++)Qy(t1, r * s + u, s, i, o, a, l);
            for(let u = r; u < r + i; u++)Qy(t1, u * s + e, 1, n, o, a, l);
        }
        function Qy(t1, e, r, n, i, s, o) {
            s[0] = 0, o[0] = -Ky, o[1] = Ky, i[0] = t1[e];
            for(let a = 1, l = 0, u = 0; a < n; a++){
                i[a] = t1[e + a * r];
                const n = a * a;
                do {
                    const t1 = s[l];
                    u = (i[a] - i[t1] + n - t1 * t1) / (a - t1) / 2;
                }while (u <= o[l] && --l > -1)
                l++, s[l] = a, o[l] = u, o[l + 1] = Ky;
            }
            for(let a = 0, l = 0; a < n; a++){
                for(; o[l + 1] < a;)l++;
                const n = s[l], u = a - n;
                t1[e + a * r] = i[n] + u * u;
            }
        }
        const tg = 2, eg = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class rg {
            constructor(t1, e, r){
                this.requestManager = t1, this.localGlyphMode = e, this.localFontFamily = r, this.url = "", this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1) {
                this.url = t1;
            }
            getGlyphs(t1, e) {
                const r = [], n = this.url || ne.GLYPHS_URL;
                for(const e in t1)for (const n of t1[e])r.push({
                    stack: e,
                    id: n
                });
                Vt(r, ({ stack: t1, id: e }, r)=>{
                    let i = this.entries[t1];
                    i || (i = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let s = i.glyphs[e];
                    if (void 0 !== s) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    if (s = this._tinySDF(i, t1, e), s) return i.glyphs[e] = s, void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    const o = Math.floor(e / 256);
                    if (256 * o > 65535) return Gt("glyphs > 65535 not supported"), void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    if (i.ranges[o]) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: s
                    });
                    let a = i.requests[o];
                    a || (a = i.requests[o] = [], rg.loadGlyphRange(t1, o, n, this.requestManager, (t1, e)=>{
                        if (e) {
                            i.ascender = e.ascender, i.descender = e.descender;
                            for(const t1 in e.glyphs)this._doesCharSupportLocalGlyph(+t1) || (i.glyphs[+t1] = e.glyphs[+t1]);
                            i.ranges[o] = !0;
                        }
                        for (const r of a)r(t1, e);
                        delete i.requests[o];
                    })), a.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e,
                            glyph: i.glyphs[e] || null
                        });
                    });
                }, (t1, r)=>{
                    if (t1) e(t1);
                    else if (r) {
                        const t1 = {};
                        for (const { stack: e, id: n, glyph: i } of r)void 0 === t1[e] && (t1[e] = {}), void 0 === t1[e].glyphs && (t1[e].glyphs = {}), t1[e].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[e].ascender = this.entries[e].ascender, t1[e].descender = this.entries[e].descender;
                        e(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== eg.none && (this.localGlyphMode === eg.all ? !!this.localFontFamily : !!this.localFontFamily && (Ks["CJK Unified Ideographs"](t1) || Ks["Hangul Syllables"](t1) || Ks.Hiragana(t1) || Ks.Katakana(t1) || Ks["CJK Symbols and Punctuation"](t1) || Ks["CJK Unified Ideographs Extension A"](t1) || Ks["CJK Unified Ideographs Extension B"](t1) || Ks.Osage(t1)));
            }
            _tinySDF(t1, e, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t1.tinySDF = new rg.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 24 * tg,
                        buffer: 3 * tg,
                        radius: 8 * tg
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCodePoint(r), { data: o, width: a, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: d } = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new hh({
                        width: a,
                        height: l
                    }, o),
                    metrics: {
                        width: u / tg,
                        height: c / tg,
                        left: h / tg,
                        top: p / tg - 27,
                        advance: d / tg,
                        localGlyph: !0
                    }
                };
            }
        }
        rg.loadGlyphRange = function(t1, e, r, n, i) {
            const s = 256 * e, o = s + 255, a = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${s}-${o}`), Be.Glyphs);
            De(a, (t1, e)=>{
                if (t1) i(t1);
                else if (e) {
                    const t1 = {}, r = function(t1) {
                        return new Jm(t1).readFields(hy, {});
                    }(e);
                    for (const e of r.glyphs)t1[e.id] = e;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, rg.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: s = "normal", fontStyle: o = "normal" } = {}){
                this.buffer = e, this.cutoff = n, this.radius = r;
                const a = this.size = t1 + 4 * e, l = this._createCanvas(a), u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${o} ${s} ${t1}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a);
            }
            _createCanvas(t1) {
                const e = document.createElement("canvas");
                return e.width = e.height = t1, e;
            }
            draw(t1) {
                const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s } = this.ctx.measureText(t1), o = Math.ceil(r), a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))), l = Math.min(this.size - this.buffer, o + Math.ceil(n)), u = a + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), d = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: a,
                    glyphHeight: l,
                    glyphTop: o,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === a || 0 === l) return d;
                const { ctx: f, buffer: m, gridInner: y, gridOuter: g } = this;
                f.clearRect(m, m, a, l), f.fillText(t1, m, m + o);
                const x = f.getImageData(m, m, a, l);
                g.fill(Ky, 0, h), y.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e = 0; e < a; e++){
                    const r = x.data[4 * (t1 * a + e) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + m) * u + e + m;
                    if (1 === r) g[n] = 0, y[n] = Ky;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, y[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                Jy(g, 0, 0, u, c, u, this.f, this.v, this.z), Jy(y, m, m, a, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e = Math.sqrt(g[t1]) - Math.sqrt(y[t1]);
                    p[t1] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }
                return d;
            }
        };
        const ng = Xy;
        function ig(t1, e) {
            return t1 + e[1] - e[0];
        }
        function sg(t1, e, r, n, i = 1) {
            const s = [], o = t1.imagePrimary, a = o.pixelRatio, l = o.paddedRect.w - 2 * ng, u = o.paddedRect.h - 2 * ng, c = (t1.right - t1.left) * i, h = (t1.bottom - t1.top) * i, p = o.stretchX || [
                [
                    0,
                    l
                ]
            ], d = o.stretchY || [
                [
                    0,
                    u
                ]
            ], f = p.reduce(ig, 0), m = d.reduce(ig, 0), y = l - f, g = u - m;
            let x = 0, v = f, b = 0, w = m, _ = 0, A = y, M = 0, I = g;
            if (o.content && n) {
                const t1 = o.content;
                x = og(p, 0, t1[0]), b = og(d, 0, t1[1]), v = og(p, t1[0], t1[2]), w = og(d, t1[1], t1[3]), _ = t1[0] - x, M = t1[1] - b, A = t1[2] - t1[0] - v, I = t1[3] - t1[1] - w;
            }
            const S = (n, s, l, u)=>{
                const p = lg(n.stretch - x, v, c, t1.left * i), d = ug(n.fixed - _, A, n.stretch, f), y = lg(s.stretch - b, w, h, t1.top * i), g = ug(s.fixed - M, I, s.stretch, m), S = lg(l.stretch - x, v, c, t1.left * i), P = ug(l.fixed - _, A, l.stretch, f), E = lg(u.stretch - b, w, h, t1.top * i), k = ug(u.fixed - M, I, u.stretch, m), z = new bt(p, y), T = new bt(S, y), B = new bt(S, E), V = new bt(p, E), C = new bt(d / a, g / a), F = new bt(P / a, k / a), D = e * Math.PI / 180;
                if (D) {
                    const t1 = Math.sin(D), e = Math.cos(D), r = [
                        e,
                        -t1,
                        t1,
                        e
                    ];
                    z._matMult(r), T._matMult(r), V._matMult(r), B._matMult(r);
                }
                const L = n.stretch + n.fixed, R = l.stretch + l.fixed, O = s.stretch + s.fixed, U = u.stretch + u.fixed, N = t1.imageSecondary;
                return {
                    tl: z,
                    tr: T,
                    bl: V,
                    br: B,
                    texPrimary: {
                        x: o.paddedRect.x + ng + L,
                        y: o.paddedRect.y + ng + O,
                        w: R - L,
                        h: U - O
                    },
                    texSecondary: N ? {
                        x: N.paddedRect.x + ng + L,
                        y: N.paddedRect.y + ng + O,
                        w: R - L,
                        h: U - O
                    } : void 0,
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: C,
                    pixelOffsetBR: F,
                    minFontScaleX: A / a / c,
                    minFontScaleY: I / a / h,
                    isSDF: r
                };
            };
            if (n && (o.stretchX || o.stretchY)) {
                const t1 = ag(p, y, f), e = ag(d, g, m);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], i = t1[r + 1];
                    for(let t1 = 0; t1 < e.length - 1; t1++)s.push(S(n, e[t1], i, e[t1 + 1]));
                }
            } else s.push(S({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: l + 1
            }, {
                fixed: 0,
                stretch: u + 1
            }));
            return s;
        }
        function og(t1, e, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
            return n;
        }
        function ag(t1, e, r) {
            const n = [
                {
                    fixed: -ng,
                    stretch: 0
                }
            ];
            for (const [e, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch + (r - e)
                });
            }
            return n.push({
                fixed: e + ng,
                stretch: r
            }), n;
        }
        function lg(t1, e, r, n) {
            return t1 / e * r + n;
        }
        function ug(t1, e, r, n) {
            return t1 - e * r / n;
        }
        function cg(t1, e, r, n) {
            const i = e + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        function hg(t1, e = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0;
            const a = t1[0];
            for(let t1 = 0; t1 < a.length; t1++){
                const e = a[t1];
                (!t1 || e.x < n) && (n = e.x), (!t1 || e.y < i) && (i = e.y), (!t1 || e.x > s) && (s = e.x), (!t1 || e.y > o) && (o = e.y);
            }
            const l = Math.min(s - n, o - i);
            let u = l / 2;
            const c = new Vn([], pg);
            if (0 === l) return new bt(n, i);
            for(let e = n; e < s; e += l)for(let r = i; r < o; r += l)c.push(new dg(e + u, r + u, u, t1));
            let h = function(t1) {
                let e = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, s = i.length, o = s - 1; t1 < s; o = t1++){
                    const s = i[t1], a = i[o], l = s.x * a.y - a.x * s.y;
                    r += (s.x + a.x) * l, n += (s.y + a.y) * l, e += 3 * l;
                }
                return new dg(r / e, n / e, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new dg(n.p.x - u, n.p.y - u, u, t1)), c.push(new dg(n.p.x + u, n.p.y - u, u, t1)), c.push(new dg(n.p.x - u, n.p.y + u, u, t1)), c.push(new dg(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function pg(t1, e) {
            return e.max - t1.max;
        }
        class dg {
            constructor(t1, e, r, n){
                this.p = new bt(t1, e), this.h = r, this.d = function(t1, e) {
                    let r = !1, n = 1 / 0;
                    for(let i = 0; i < e.length; i++){
                        const s = e[i];
                        for(let e = 0, i = s.length, o = i - 1; e < i; o = e++){
                            const i = s[e], a = s[o];
                            i.y > t1.y != a.y > t1.y && t1.x < (a.x - i.x) * (t1.y - i.y) / (a.y - i.y) + i.x && (r = !r), n = Math.min(n, rc(t1, i, a));
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(n);
                }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
            }
        }
        const fg = Object.keys, mg = Number.POSITIVE_INFINITY, yg = Math.sqrt(2);
        function gg(t1, [e, r]) {
            let n = 0, i = 0;
            if (r === mg) {
                e < 0 && (e = 0);
                const r = e / yg;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = 7 - r;
                        break;
                    case "bottom":
                        i = 7 - e;
                        break;
                    case "top":
                        i = e - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e;
                        break;
                    case "right":
                        n = -e;
                }
            } else {
                switch(e = Math.abs(e), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e;
                }
            }
            return [
                n,
                i
            ];
        }
        function xg(t1, e, r, n, i, s, o, a, l) {
            if (!e || !e.usvg) return;
            const u = Vy(n), c = Vy(i), h = "both" !== s && "width" !== s || !Ty(n) ? 1 : c.width / u.width, p = "both" !== s && "height" !== s || !By(n) ? 1 : c.height / u.height;
            r.scaleSelf(h, p);
            const d = r.toString();
            o.set(d, r), a.set(d, e);
            const { imagePosition: f } = Wy(d, e, Xy);
            l.set(d, f);
        }
        function vg(t1, e, r, n, i, s, o, a, l) {
            if (!t1) return;
            const u = function(t1, e, r, n, i, s) {
                if ("camera" === t1.kind) return t1.maxSize;
                if ("composite" === t1.kind) {
                    const n = e.possiblyEvaluate(new xo(t1.maxZoom, {
                        worldview: s
                    }), r).evaluate(i, {}, r), o = e.possiblyEvaluate(new xo(t1.minZoom, {
                        worldview: s
                    }), r).evaluate(i, {}, r);
                    return Math.max(n, o);
                }
                return e.possiblyEvaluate(new xo(n, {
                    worldview: s
                })).evaluate(i, {}, r);
            }(e, r, n, i, s, l);
            return t1.scaleSelf(u * a * o);
        }
        function bg(t1, e, r, n, i, s, o, a, l) {
            return {
                iconPrimary: vg(t1.getPrimary(), e, r, n, i, s, o, a, l),
                iconSecondary: vg(t1.getSecondary(), e, r, n, i, s, o, a, l)
            };
        }
        function wg(t1, e, r) {
            if (!e) return;
            const n = r.get(t1.toString()), i = r.get(e.toString());
            i && (n.paddedRect.w === i.paddedRect.w && n.paddedRect.h === i.paddedRect.h || Gt(`Mismatch in icon variant sizes: ${t1.toString()} and ${e.toString()}`), n.usvg !== i.usvg && Gt(`Mismatch in icon variant image types: ${t1.id} and ${e.id}`));
        }
        function _g(t1, e, r, n) {
            if (!t1) return;
            const i = e.get(r.toString());
            if (t1.imagePrimary = i, n) {
                const r = e.get(n.toString());
                t1.imageSecondary = r;
            }
        }
        function Ag(t1, e) {
            for(const r in t1.horizontal)Mg(t1.horizontal[r], e);
            Mg(t1.vertical, e);
        }
        function Mg(t1, e) {
            if (t1) {
                for (const r of t1.positionedLines)for (const t1 of r.positionedGlyphs)if (null !== t1.image) {
                    const r = t1.image.toString();
                    t1.rect = e.get(r).paddedRect;
                }
            }
        }
        function Ig(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function Sg(t1, e, r, n, i, s, o, a, l) {
            const u = Tg(s.horizontal) || s.vertical, c = r.get("icon-text-fit-padding").evaluate(n, {}, i);
            let h, p = e;
            return e && "none" !== l && (t1.allowVerticalPlacement && s.vertical && (h = zy(e, s.vertical, l, c, a, o)), u && (p = zy(e, u, l, c, a, o))), {
                defaultShapedIcon: p,
                verticallyShapedIcon: h
            };
        }
        function Pg(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v) {
            let b = o.textMaxSize.evaluate(e, {}, p);
            void 0 === b ? b = a * o.textScaleFactor : b *= o.textScaleFactor;
            const w = t1.layers[0].layout, _ = Tg(r.horizontal) || r.vertical, A = "globe" === d.name, M = Gm, I = t1.tilePixelRatio * b / M, S = (B = t1.overscaling, t1.zoom > 18 && B > 2 && (B >>= 1), Math.max(Cn / (512 * B), 1) * w.get("symbol-spacing")), P = w.get("text-padding") * t1.tilePixelRatio, E = w.get("icon-padding") * t1.tilePixelRatio, k = Mt(w.get("text-max-angle")), z = "map" === w.get("icon-rotation-alignment") && "point" !== v, T = S / 2;
            var B;
            !1 === t1.hasAnyIconTextFit && "none" !== y && (t1.hasAnyIconTextFit = !0);
            const V = e.properties ? +e.properties[Su] : null, C = V && t1.elevationFeatureIdToIndex ? t1.elevationFeatureIdToIndex.get(V) : 65535, F = (a, l, v)=>{
                if (l.x < 0 || l.x >= Cn || l.y < 0 || l.y >= Cn) return;
                let b = null;
                if (A) {
                    const { x: t1, y: e, z: r } = d.projectTilePoint(l.x, l.y, v);
                    b = {
                        anchor: new Ry(t1, e, r, 0, void 0),
                        up: d.upVector(v, l.x, l.y)
                    };
                }
                !function(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, E) {
                    const k = t1.addToLineVertexArray(e, n);
                    let z, T, B, V, C, F, D, L = 0, R = 0, O = 0, U = 0, N = -1, j = -1;
                    const $ = {};
                    let G = We("");
                    const H = r ? r.anchor : e, q = "none" !== P;
                    let X = 0, Z = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset")) {
                        const t1 = l.layout.get("text-offset").evaluate(b, {}, M);
                        X = t1[0] * Gm, Z = t1[1] * Gm;
                    } else X = l.layout.get("text-radial-offset").evaluate(b, {}, M) * Gm, Z = mg;
                    if (t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (f) F = Vg(t1), a && (D = Vg(a));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, M) + 90;
                            B = Bg(u, H, e, c, h, p, t1, d, r, m), a && (V = Bg(u, H, e, c, h, p, a, g, r));
                        }
                    }
                    if (s) {
                        const n = t1.iconSizeData, i = l.layout.get("icon-rotate").evaluate(b, {}, M), o = sg(s, i, _, q, w.iconScaleFactor), d = a ? sg(a, i, _, q, w.iconScaleFactor) : void 0;
                        T = Bg(u, H, e, c, h, p, s, g, i, null), L = 4 * o.length;
                        let f = null;
                        "source" === n.kind ? (f = [
                            Cy * l.layout.get("icon-size").evaluate(b, {}, M) * w.iconScaleFactor
                        ], f[0] > kg && Gt(`${t1.layerIds[0]}: Value for "icon-size" is >= ${Eg}. Reduce your "icon-size".`)) : "composite" === n.kind && (f = [
                            Cy * w.compositeIconSizes[0].evaluate(b, {}, M) * w.iconScaleFactor,
                            Cy * w.compositeIconSizes[1].evaluate(b, {}, M) * w.iconScaleFactor
                        ], (f[0] > kg || f[1] > kg) && Gt(`${t1.layerIds[0]}: Value for "icon-size" is >= ${Eg}. Reduce your "icon-size".`)), t1.addSymbols(t1.icon, o, f, v, x, b, void 0, r, e, k.lineStartIndex, k.lineLength, -1, A, M, I, S), N = t1.icon.placedSymbolArray.length - 1, d && (R = 4 * d.length, t1.addSymbols(t1.icon, d, f, v, x, b, my.vertical, r, e, k.lineStartIndex, k.lineLength, -1, A, M, I, S), j = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const s = n, a = i.horizontal[s];
                        z || (G = We(a.text), f ? C = Vg(a) : z = Bg(u, H, e, c, h, p, a, d, l.layout.get("text-rotate").evaluate(b, {}, M), m));
                        const y = 1 === a.positionedLines.length;
                        if (O += zg(t1, r, e, a, o, l, f, b, m, k, i.vertical ? my.horizontal : my.horizontalOnly, y ? fg(i.horizontal) : [
                            s
                        ], $, N, w, A, M, I), y) break;
                    }
                    i.vertical && (U += zg(t1, r, e, i.vertical, o, l, f, b, m, k, my.vertical, [
                        "vertical"
                    ], $, j, w, A, M, I));
                    let W = -1;
                    const Y = (t1, e)=>t1 ? Math.max(t1, e) : e;
                    W = Y(C, W), W = Y(F, W), W = Y(D, W);
                    const K = W > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= 65535 && Gt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, b.sortKey), t1.symbolInstances.emplaceBack(e.x, e.y, H.x, H.y, H.z, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical >= 0 ? $.vertical : -1, N, j, G, void 0 !== z ? z : t1.collisionBoxArray.length, void 0 !== z ? z + 1 : t1.collisionBoxArray.length, void 0 !== B ? B : t1.collisionBoxArray.length, void 0 !== B ? B + 1 : t1.collisionBoxArray.length, void 0 !== T ? T : t1.collisionBoxArray.length, void 0 !== T ? T + 1 : t1.collisionBoxArray.length, V || t1.collisionBoxArray.length, V ? V + 1 : t1.collisionBoxArray.length, c, O, U, L, R, K, 0, X, Z, W, 0, q ? 1 : 0, E);
                }(t1, l, b, a, r, n, s, i, t1.layers[0], t1.collisionBoxArray, e.index, e.sourceLayerIndex, t1.index, P, x, u, 0, E, z, g, e, o, c, h, p, f, m, y, C);
            };
            if ("line" === v) for (const i of bd(e.geometry, 0, 0, Cn, Cn)){
                const e = Gy(i, S, k, r.vertical || _, n, M, I, t1.overscaling, Cn);
                for (const r of e)_ && Cg(t1, _.text, T, r) || F(i, r, p);
            }
            else if ("line-center" === v) {
                for (const t1 of e.geometry)if (t1.length > 1) {
                    const e = $y(t1, k, r.vertical || _, n, M, I);
                    e && F(t1, e, p);
                }
            } else if ("Polygon" === e.type) for (const t1 of Hh(e.geometry, 0)){
                const e = hg(t1, 16);
                F(t1[0], new Ry(e.x, e.y, 0, 0, void 0), p);
            }
            else if ("LineString" === e.type) for (const t1 of e.geometry)F(t1, new Ry(t1[0].x, t1[0].y, 0, 0, void 0), p);
            else if ("Point" === e.type) for (const t1 of e.geometry)for (const e of t1)F([
                e
            ], new Ry(e.x, e.y, 0, 0, void 0), p);
        }
        const Eg = 255, kg = Eg * Cy;
        function zg(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g) {
            const x = function(t1, e, r, n, i, s, o, a) {
                const l = [];
                if (0 === e.positionedLines.length) return l;
                const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, c = function(t1) {
                    const e = t1[0], r = t1[1], n = e * r;
                    return n > 0 ? [
                        e,
                        -r
                    ] : n < 0 ? [
                        -e,
                        r
                    ] : 0 === e ? [
                        r,
                        e
                    ] : [
                        r,
                        -e
                    ];
                }(r);
                let h = Math.abs(e.top - e.bottom);
                for (const t1 of e.positionedLines)h -= t1.lineOffset;
                const p = e.positionedLines.length, d = h / p;
                let f = e.top - r[1];
                for(let t1 = 0; t1 < p; ++t1){
                    const n = e.positionedLines[t1];
                    f = cg(e, d, f, t1);
                    for (const t1 of n.positionedGlyphs){
                        if (!t1.rect) continue;
                        const n = t1.rect || {};
                        let s = fy + 1, h = !0, p = 1, d = 0;
                        if (t1.image) {
                            const e = o.get(t1.image.toString());
                            if (!e) continue;
                            if (e.sdf) {
                                Gt("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h = !1, p = e.pixelRatio, s = Xy / p;
                        }
                        const m = (i || a) && t1.vertical, y = t1.metrics.advance * t1.scale / 2, g = t1.metrics, x = t1.rect;
                        if (null === x) continue;
                        a && e.verticalizable && (d = t1.image ? y - t1.metrics.width * t1.scale / 2 : 0);
                        const v = i ? [
                            t1.x + y,
                            t1.y
                        ] : [
                            0,
                            0
                        ];
                        let b = [
                            0,
                            0
                        ], w = [
                            0,
                            0
                        ], _ = !1;
                        i || (m ? (w = [
                            t1.x + y + c[0],
                            t1.y + c[1] - d
                        ], _ = !0) : b = [
                            t1.x + y + r[0],
                            t1.y + r[1] - d
                        ]);
                        const A = x.w * t1.scale / (p * (t1.localGlyph ? tg : 1)), M = x.h * t1.scale / (p * (t1.localGlyph ? tg : 1));
                        let I, S, P, E;
                        if (m) {
                            const e = t1.y - f, r = new bt(-y, y - e), n = -Math.PI / 2, i = new bt(...w);
                            I = new bt(-y + b[0], b[1]), I._rotateAround(n, r)._add(i), I.x += -e + y, I.y -= (g.left - s) * t1.scale;
                            const o = t1.image ? g.advance * t1.scale : Gm * t1.scale, a = String.fromCodePoint(t1.glyph);
                            Xm(a) ? I.x += (1 - s) * t1.scale : Zm(a) ? I.x += o - g.height * t1.scale + (-s - 1) * t1.scale : I.x += t1.image || g.width + 2 * s === x.w && g.height + 2 * s === x.h ? (o - M) / 2 : (o - (g.height + 2 * s) * t1.scale) / 2, S = new bt(I.x, I.y - A), P = new bt(I.x + M, I.y), E = new bt(I.x + M, I.y - A);
                        } else {
                            const e = (g.left - s) * t1.scale - y + b[0], r = (-g.top - s) * t1.scale + b[1], n = e + A, i = r + M;
                            I = new bt(e, r), S = new bt(n, r), P = new bt(e, i), E = new bt(n, i);
                        }
                        if (u) {
                            let t1;
                            t1 = i ? new bt(0, 0) : _ ? new bt(c[0], c[1]) : new bt(r[0], r[1]), I._rotateAround(u, t1), S._rotateAround(u, t1), P._rotateAround(u, t1), E._rotateAround(u, t1);
                        }
                        const k = new bt(0, 0), z = new bt(0, 0);
                        l.push({
                            tl: I,
                            tr: S,
                            bl: P,
                            br: E,
                            texPrimary: n,
                            texSecondary: void 0,
                            writingMode: e.writingMode,
                            glyphOffset: v,
                            sectionIndex: t1.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: k,
                            pixelOffsetBR: z,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l;
            }(0, n, l, s, o, a, i, t1.allowVerticalPlacement), v = t1.textSizeData;
            let b = null;
            "source" === v.kind ? (b = [
                Cy * s.layout.get("text-size").evaluate(a, {}, y) * f.textScaleFactor
            ], b[0] > kg && Gt(`${t1.layerIds[0]}: Value for "text-size" is >= ${Eg}. Reduce your "text-size".`)) : "composite" === v.kind && (b = [
                Cy * f.compositeTextSizes[0].evaluate(a, {}, y) * f.textScaleFactor,
                Cy * f.compositeTextSizes[1].evaluate(a, {}, y) * f.textScaleFactor
            ], (b[0] > kg || b[1] > kg) && Gt(`${t1.layerIds[0]}: Value for "text-size" is >= ${Eg}. Reduce your "text-size".`)), t1.addSymbols(t1.text, x, b, l, o, a, c, e, r, u.lineStartIndex, u.lineLength, d, m, y, g, !1);
            for (const e of h)p[e] = t1.text.placedSymbolArray.length - 1;
            return 4 * x.length;
        }
        function Tg(t1) {
            for(const e in t1)return t1[e];
            return null;
        }
        function Bg(t1, e, r, n, i, s, o, a, l, u) {
            let c = o.top, h = o.bottom, p = o.left, d = o.right;
            if (Ey(o) && o.collisionPadding) {
                const t1 = o.collisionPadding;
                p -= t1[0], c -= t1[1], d += t1[2], h += t1[3];
            }
            if (l) {
                const t1 = new bt(p, c), e = new bt(d, c), r = new bt(p, h), n = new bt(d, h), i = Mt(l);
                let s = new bt(0, 0);
                u && (s = new bt(u[0], u[1])), t1._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t1.x, e.x, r.x, n.x), d = Math.max(t1.x, e.x, r.x, n.x), c = Math.min(t1.y, e.y, r.y, n.y), h = Math.max(t1.y, e.y, r.y, n.y);
            }
            return t1.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, d, h, a, n, i, s), t1.length - 1;
        }
        function Vg(t1) {
            Ey(t1) && t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e = t1.bottom - t1.top;
            return e > 0 ? Math.max(10, e) : null;
        }
        function Cg(t1, e, r, n) {
            const i = t1.compareText;
            if (e in i) {
                const t1 = i[e];
                for(let e = t1.length - 1; e >= 0; e--)if (n.dist(t1[e]) < r) return !0;
            } else i[e] = [];
            return i[e].push(n), !1;
        }
        function Fg(t1, e) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01));
            let o = Math.sin(t1._pitch) * s + i;
            const a = i * (1 / t1._horizonShift);
            if (!t1.elevation || 0 === t1.elevation.exaggeration()) {
                let e = Math.max(t1.zoom - 17, 0);
                t1.isOrthographic && (e /= 10), o *= 1 + e;
            }
            return Math.min(1.01 * o, a);
        }
        function Dg(t1, e) {
            if (!e.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, s = t1.y * r, o = (t1.y + 1) * r, a = eu(n), l = eu(i), u = ru(s), c = ru(o), h = e.project(a, u), p = e.project(l, u), d = e.project(l, c), f = e.project(a, c);
            let m = Math.min(h.x, p.x, d.x, f.x), y = Math.min(h.y, p.y, d.y, f.y), g = Math.max(h.x, p.x, d.x, f.x), x = Math.max(h.y, p.y, d.y, f.y);
            const v = r / 16;
            function b(t1, r, n, i, s, o) {
                const a = (n + s) / 2, l = (i + o) / 2, u = e.project(eu(a), ru(l)), c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);
                m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t1, u, n, i, a, l), b(u, r, a, l, s, o));
            }
            b(h, p, n, s, i, s), b(p, d, i, s, i, o), b(d, f, i, o, n, o), b(f, h, n, o, n, s), m -= v, y -= v, g += v, x += v;
            const w = 1 / Math.max(g - m, x - y);
            return {
                scale: w,
                x: m * w,
                y: y * w,
                x2: g * w,
                y2: x * w,
                projection: e
            };
        }
        function Lg(t1, { x: e, y: r }, n = 0) {
            return new bt(((e - n) * t1.scale - t1.x) * Cn, (r * t1.scale - t1.y) * Cn);
        }
        const Rg = l(new Float32Array(16));
        class Og {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e) {
                return new Xl(0, 0);
            }
            projectTilePoint(t1, e, r) {
                return {
                    x: t1,
                    y: e,
                    z: 0
                };
            }
            locationPoint(t1, e, r, n = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e, r), n);
            }
            pixelsPerMeter(t1, e) {
                return tu(1, t1) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return Fg(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e, r, n) {
                const i = t1.horizonLineFromTop(!1), s = new bt(e, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(s, n));
            }
            pointCoordinate3D(t1, e, r) {
                const n = new bt(e, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e.x,
                        e.y,
                        e.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e) {
                if (t1.elevation && t1.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t1, e.x, e.y);
                const r = t1.horizonLineFromTop();
                return e.y < r;
            }
            createInversionMatrix(t1, e) {
                return Rg;
            }
            createTileMatrix(t1, e, r) {
                let n, i, s;
                const o = r.canonical, a = l(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = Dg(o, this);
                    n = 1, i = l.x + r.wrap * l.scale, s = l.y, p(a, a, [
                        n / l.scale,
                        n / l.scale,
                        t1.pixelsPerMeter / e
                    ]);
                } else n = e / t1.zoomScale(o.z), i = (o.x + Math.pow(2, o.z) * r.wrap) * n, s = o.y * n;
                return h(a, a, [
                    i,
                    s,
                    0
                ]), p(a, a, [
                    n / Cn,
                    n / Cn,
                    1
                ]), a;
            }
            upVector(t1, e, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Ug extends Og {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin(Mt(e));
                this.n = (n + Math.sin(Mt(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e) {
                const { n: r, c: n, r0: i } = this, s = Mt(t1 - this.center[0]), o = Mt(e), a = Math.sqrt(n - 2 * r * Math.sin(o)) / r;
                return {
                    x: a * Math.sin(s * r),
                    y: a * Math.cos(s * r) - i,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { n: r, c: n, r0: i } = this, s = i + e;
                let o = Math.atan2(t1, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (o -= Math.PI * Math.sign(t1) * Math.sign(s));
                const a = Mt(this.center[0]) * r;
                o = Bt(o, -Math.PI - a, Math.PI - a);
                const l = zt(It(o / r) + this.center[0], -180, 180), u = Math.asin(zt((n - (t1 * t1 + s * s) * r * r) / (2 * r), -1, 1)), c = zt(It(u), -iu, iu);
                return new Xl(l, c);
            }
        }
        const Ng = 1.340264, jg = -.081106, $g = 893e-6, Gg = .003796, Hg = Math.sqrt(3) / 2;
        class qg extends Og {
            project(t1, e) {
                e = e / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(Hg * Math.sin(e)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (Hg * (Ng + 3 * jg * n + i * (7 * $g + 9 * Gg * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (Ng + jg * n + i * ($g + Gg * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, s, o, a = 0; a < 12 && (s = r * (Ng + jg * n + i * ($g + Gg * n)) - e, o = Ng + 3 * jg * n + i * (7 * $g + 9 * Gg * n), t1 = s / o, r = zt(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++a);
                const s = Hg * t1 * (Ng + 3 * jg * n + i * (7 * $g + 9 * Gg * n)) / Math.cos(r), o = Math.asin(Math.sin(r) / Hg), a = zt(180 * s / Math.PI, -180, 180), l = zt(180 * o / Math.PI, -iu, iu);
                return new Xl(a, l);
            }
        }
        class Xg extends Og {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e / 360,
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = 360 * (t1 - .5), n = zt(360 * (.5 - e), -iu, iu);
                return new Xl(r, n);
            }
        }
        const Zg = Math.PI / 2;
        function Wg(t1) {
            return Math.tan((Zg + t1) / 2);
        }
        class Yg extends Og {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = Mt(e), i = Mt(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const s = Math.cos(n), o = Wg(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Wg(i) / o), this.f = s * Math.pow(Wg(n), this.n) / this.n;
            }
            project(t1, e) {
                e = Mt(e), this.southernCenter && (e = -e), t1 = Mt(t1 - this.center[0]);
                const r = 1e-6, { n, f: i } = this;
                i > 0 ? e < -Zg + r && (e = -Zg + r) : e > Zg - r && (e = Zg - r);
                const s = i / Math.pow(Wg(e), n);
                let o = s * Math.sin(n * t1), a = i - s * Math.cos(n * t1);
                return o = .5 * (o / Math.PI + .5), a = .5 * (a / Math.PI + .5), {
                    x: o,
                    y: this.southernCenter ? a : 1 - a,
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;
                const { n: r, f: n } = this, i = n - e, s = Math.sign(i), o = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let a = Math.atan2(t1, Math.abs(i)) * s;
                i * r < 0 && (a -= Math.PI * Math.sign(t1) * s);
                const l = zt(It(a / r) + this.center[0], -180, 180), u = zt(It(2 * Math.atan(Math.pow(n / o, 1 / r)) - Zg), -iu, iu);
                return new Xl(l, this.southernCenter ? -u : u);
            }
        }
        class Kg extends Og {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e) {
                return {
                    x: Jl(t1),
                    y: Ql(e),
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = eu(t1), n = ru(e);
                return new Xl(r, n);
            }
        }
        const Jg = Mt(iu);
        class Qg extends Og {
            project(t1, e) {
                const r = (e = Mt(e)) * e, n = r * r;
                return {
                    x: .5 * ((t1 = Mt(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = 25, i = 0, s = r * r;
                do {
                    s = r * r;
                    const t1 = s * s;
                    i = (r * (1.007226 + s * (.015085 + t1 * (.028874 * s - .044475 - .005916 * t1))) - e) / (1.007226 + s * (.045255 + t1 * (.259866 * s - .311325 - .005916 * 11 * t1))), r = zt(r - i, -Jg, Jg);
                }while (Math.abs(i) > 1e-6 && --n > 0)
                s = r * r;
                const o = zt(It(t1 / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180), a = It(r);
                return new Xl(o, a);
            }
        }
        const tx = Mt(iu);
        class ex extends Og {
            project(t1, e) {
                e = Mt(e), t1 = Mt(t1);
                const r = Math.cos(e), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), s = Math.sin(i) / i, o = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / s) || 0, a = .5 * (e + Math.sin(e) / s) || 0;
                return {
                    x: .5 * (o / Math.PI + .5),
                    y: 1 - .5 * (a / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e = (2 * (1 - e) - 1) * Math.PI, i = 25;
                const s = 1e-6;
                let o = 0, a = 0;
                do {
                    const i = Math.cos(n), s = Math.sin(n), l = 2 * s * i, u = s * s, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), d = 2 * h * p, f = p * p, m = 1 - c * h * h, y = m ? 1 / m : 0, g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, v = .5 * (g * s + n) - e, b = .5 * y * (c * f + g * i * h * u) + 1 / Math.PI, w = y * (d * l / 4 - g * s * p), _ = .125 * y * (l * p - g * s * c * d), A = .5 * y * (u * h + g * f * i) + .5, M = w * _ - A * b;
                    o = (v * w - x * A) / M, a = (x * _ - v * b) / M, r = zt(r - o, -Math.PI, Math.PI), n = zt(n - a, -tx, tx);
                }while ((Math.abs(o) > s || Math.abs(a) > s) && --i > 0)
                return new Xl(It(r), It(n));
            }
        }
        class rx extends Og {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos(Mt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                const { scale: r, cosPhi: n } = this;
                return {
                    x: Mt(t1) * n * r + .5,
                    y: -Math.sin(Mt(e)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { scale: r, cosPhi: n } = this, i = -(e - .5) / r, s = zt(It((t1 - .5) / r) / n, -180, 180), o = Math.asin(zt(i * n, -1, 1)), a = zt(It(o), -iu, iu);
                return new Xl(s, a);
            }
        }
        class nx extends Kg {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t1, e, r) {
                const n = Dc(t1, e, r);
                return O(n, n, Oc(zc(r))), {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                };
            }
            locationPoint(t1, e, r) {
                const n = Gl(e.lat, e.lng), i = F([], n), s = r ? t1._centerAltitude + r : t1.elevation ? t1.elevation.getAtPointOrZero(t1.locationCoordinate(e), t1._centerAltitude) : t1._centerAltitude;
                T(n, n, i, tu(1, 0) * Cn * s);
                const o = l(new Float64Array(16));
                return c(o, t1.pixelMatrix, t1.globeMatrix), O(n, n, o), new bt(n[0], n[1]);
            }
            pixelsPerMeter(t1, e) {
                return tu(1, 0) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                const n = tu(1, t1) * e, i = ur(tu(1, 45) * e, n, r);
                return this.pixelsPerMeter(t1, e) / i;
            }
            createTileMatrix(t1, e, r) {
                const n = Uc(zc(r.canonical));
                return c(new Float64Array(16), t1.globeMatrix, n);
            }
            createInversionMatrix(t1, e) {
                const { center: r } = t1, n = Oc(zc(e));
                return f(n, n, Mt(r.lng)), d(n, n, Mt(r.lat)), p(n, n, [
                    t1._pixelsPerMercatorPixel,
                    t1._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n);
            }
            pointCoordinate(t1, e, r, n) {
                return Pc(t1, e, r, !0) || new uu(0, 0);
            }
            pointCoordinate3D(t1, e, r) {
                const n = this.pointCoordinate(t1, e, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e) {
                return !Pc(t1, e.x, e.y, !1);
            }
            farthestPixelDistance(t1) {
                const e = function(t1, e) {
                    const r = t1.cameraToCenterDistance, n = t1._centerAltitude * e, i = t1._camera, s = t1._camera.forward(), o = I([], z([], s, -r), [
                        0,
                        0,
                        n
                    ]), a = t1.worldSize / (2 * Math.PI), l = [
                        0,
                        0,
                        -a
                    ], u = t1.width / t1.height, c = Math.tan(t1.fovAboveCenter), h = z([], i.up(), c), p = z([], i.right(), c * u), d = F([], I([], I([], s, h), p)), f = [];
                    let m;
                    if (new Cu(o, d).closestPointOnSphere(l, a, f)) {
                        const e = I([], f, l), r = G([], e, o);
                        m = Math.cos(t1.fovAboveCenter) * _(r);
                    } else {
                        const t1 = G([], o, l), e = G([], l, o);
                        F(e, e);
                        const r = _(t1) - a;
                        m = Math.sqrt(r * (r + 2 * a));
                        const n = Math.acos(m / (a + r)) - Math.acos(D(s, e));
                        m *= Math.cos(n);
                    }
                    return 1.01 * m;
                }(t1, this.pixelsPerMeter(t1.center.lat, t1.worldSize)), r = Gc(t1.zoom);
                if (r > 0) {
                    const n = Fg(t1, tu(1, t1.center.lat) * t1.worldSize), i = t1.worldSize / (2 * Math.PI), s = Math.max(t1.width, t1.height) / t1.worldSize * Math.PI;
                    return ur(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
                }
                return e;
            }
            upVector(t1, e, r) {
                return Dc(e, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: Ic(Lc(zc(t1)))
                };
            }
        }
        function ix(t1) {
            const e = t1.parallels, r = !!e && Math.abs(e[0] + e[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new Kg(t1);
                case "equirectangular":
                    return new Xg(t1);
                case "naturalEarth":
                    return new Qg(t1);
                case "equalEarth":
                    return new qg(t1);
                case "winkelTripel":
                    return new ex(t1);
                case "albers":
                    return r ? new rx(t1) : new Ug(t1);
                case "lambertConformalConic":
                    return r ? new rx(t1) : new Yg(t1);
                case "globe":
                    return new nx(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        const sx = vu.types, ox = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function ax(t1, e, r, n, i, s, o, a, l, u, c, h, p) {
            const d = a ? Math.min(kg, Math.round(a[0])) : 0, f = a ? Math.min(kg, Math.round(a[1])) : 0;
            t1.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, o, (d << 1) + (l ? 1 : 0), f, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function lx(t1, e, r) {
            t1.emplaceBack(e, r);
        }
        function ux(t1, e, r, n, i, s, o) {
            t1.emplaceBack(e, r, n, i, s, o);
        }
        const cx = (t1, e, r, n)=>{
            for(let i = 0; i < e; i++)t1.emplaceBack(r[0], r[1], r[2], n[0], n[1], n[2]);
        };
        function hx(t1, e, r, n, i) {
            t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i);
        }
        function px(t1) {
            for (const e of t1.sections)if (oo(e.text)) return !0;
            return !1;
        }
        class dx {
            constructor(t1){
                this.layoutVertexArray = new ma, this.indexArray = new Ma, this.programConfigurations = t1, this.segments = new el, this.dynamicLayoutVertexArray = new ga, this.opacityVertexArray = new xa, this.placedSymbolArray = new ja, this.iconTransitioningVertexArray = new va, this.globeExtVertexArray = new ya, this.zOffsetVertexArray = new oa, this.orientationVertexArray = new Pa;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            upload(t1, e, r, n, i) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Cm.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, Dm.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, ox, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t1.createVertexBuffer(this.iconTransitioningVertexArray, Om.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Fm.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, Lm.members, !0)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = t1.createVertexBuffer(this.orientationVertexArray, Rm.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy());
            }
        }
        qs(dx, "SymbolBuffers");
        class fx {
            constructor(t1, e, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e, this.indexArray = new r, this.segments = new el, this.collisionVertexArray = new Aa, this.collisionVertexArrayExt = new ga;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, Um.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, Nm.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        qs(fx, "CollisionBuffers");
        class mx {
            constructor(t1){
                this.collisionBoxArray = t1.collisionBoxArray, this.zoom = t1.zoom, this.lut = t1.lut, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.pixelRatio = t1.pixelRatio, this.sourceLayerIndex = t1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = l([]), this.placementViewportMatrix = l([]);
                const e = this.layers[0]._unevaluatedLayout._values;
                this.worldview = t1.worldview, this.textSizeData = Fy(this.zoom, e["text-size"], this.worldview), this.iconSizeData = Fy(this.zoom, e["icon-size"], this.worldview);
                const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order");
                this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((t1)=>my[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = t1.sourceID, this.projection = t1.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = "none", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = !1;
            }
            createArrays() {
                this.text = new dx(new kl(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("text") || t1.startsWith("symbol"))), this.icon = new dx(new kl(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("icon") || t1.startsWith("symbol"))), this.glyphOffsetArray = new Ha, this.lineVertexArray = new qa, this.symbolInstances = new Ga;
            }
            calculateGlyphDependencies(t1, e, r, n, i) {
                for (const r of t1){
                    const t1 = r.codePointAt(0);
                    if (void 0 === t1) break;
                    if (e[t1] = !0, n && i && t1 <= 65535) {
                        const t1 = qm[r];
                        t1 && (e[t1.charCodeAt(0)] = !0);
                    }
                }
            }
            updateFootprints(t1, e) {}
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                return !zp(this.activeReplacements, r) && (this.activeReplacements = r, !0);
            }
            populate(t1, e, r, n) {
                const i = this.layers[0], s = i.layout, o = "globe" === this.projection.name, a = s.get("text-font"), l = s.get("text-field"), u = s.get("icon-image"), [c, h] = s.get("icon-size-scale-range"), p = zt(e.scaleFactor || 1, c, h), d = ("constant" !== l.value.kind || l.value.value instanceof Cr && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), f = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0, m = s.get("symbol-sort-key");
                if (this.features = [], !d && !f) return;
                const y = e.iconDependencies, g = e.glyphDependencies, x = e.availableImages, v = new xo(this.zoom, {
                    worldview: this.worldview
                });
                for (const { feature: e, id: l, index: u, sourceLayerIndex: c } of t1){
                    const t1 = i._featureFilter.needGeometry, h = xu(e, t1);
                    if (!i._featureFilter.filter(v, h, r)) continue;
                    if (t1 || (h.geometry = gu(e, r, n)), o && 1 !== e.type && r.z <= 5) {
                        const t1 = h.geometry, e = .98078528056, n = (t1, n)=>D(Dc(t1.x, t1.y, r, 1), Dc(n.x, n.y, r, 1)) < e;
                        for(let e = 0; e < t1.length; e++)t1[e] = du(t1[e], n);
                    }
                    let b, w;
                    if (d) {
                        const t1 = i.getValueAndResolveTokens("text-field", h, r, x), e = Cr.factory(t1);
                        px(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === mo() || this.hasRTLText && go.isParsed()) && (b = Hm(e, i, h));
                    }
                    if (f) {
                        const t1 = i.getValueAndResolveTokens("icon-image", h, r, x);
                        w = "string" == typeof t1 ? Dr.build(t1) : t1;
                    }
                    if (!b && !w) continue;
                    const _ = this.sortFeaturesByKey ? m.evaluate(h, {}, r) : void 0, A = {
                        id: l,
                        text: b,
                        icon: w,
                        index: u,
                        sourceLayerIndex: c,
                        geometry: h.geometry,
                        properties: e.properties,
                        type: sx[e.type],
                        sortKey: _
                    };
                    if (this.features.push(A), w) {
                        const t1 = this.layers[0]._unevaluatedLayout._values, { iconPrimary: e, iconSecondary: n } = bg(w, this.iconSizeData, t1["icon-size"], r, this.zoom, A, this.pixelRatio, p, this.worldview), i = e.id.toString();
                        if (y.has(i) ? y.get(i).push(e) : y.set(i, [
                            e
                        ]), n) {
                            this.hasAnySecondaryIcon = !0;
                            const t1 = n.id.toString();
                            y.has(t1) ? y.get(t1).push(n) : y.set(t1, [
                                n
                            ]);
                        }
                    }
                    if (b) {
                        const t1 = a.evaluate(h, {}, r).join(","), e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(my.vertical) >= 0;
                        for (const r of b.sections)if (r.image) {
                            const t1 = r.image.getPrimary().scaleSelf(this.pixelRatio), e = t1.id.toString(), n = y.get(e) || [];
                            n.push(t1), y.set(e, n);
                        } else {
                            const n = Js(b.toString()), i = r.fontStack || t1, s = g[i] = g[i] || {};
                            this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
                        }
                    }
                }
                if ("line" === s.get("symbol-placement") && (this.features = function(t1) {
                    const e = {}, r = {}, n = [];
                    let i = 0;
                    function s(e) {
                        n.push(t1[e]), i++;
                    }
                    function o(t1, e, i) {
                        const s = r[t1];
                        return delete r[t1], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }
                    function a(t1, r, i) {
                        const s = e[r];
                        return delete e[r], e[t1] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }
                    function l(t1, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue;
                        }
                        const d = l(p, h), f = l(p, h, !0);
                        if (d in r && f in e && r[d] !== e[f]) {
                            const t1 = a(d, f, h), i = o(d, f, n[t1].geometry);
                            delete e[d], delete r[f], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else d in r ? o(d, f, h) : f in e ? a(d, f, h) : (s(u), e[d] = i - 1, r[f] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), "hd-road-markup" === s.get("symbol-elevation-reference")) {
                    if (this.elevationType = "road", e.elevationFeatures) {
                        !this.elevationFeatures && e.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map);
                        for (const t1 of e.elevationFeatures)this.elevationFeatureIdToIndex.set(t1.id, this.elevationFeatures.length), this.elevationFeatures.push(t1);
                    }
                } else s.get("symbol-z-elevate") && (this.elevationType = "offset");
                "none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((t1, e)=>t1.sortKey - e.sortKey);
            }
            update(t1, e, r, n, i, s, o) {
                this.text.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, this.worldview), this.icon.programConfigurations.updatePaintArrays(t1, e, i, r, n, s, o, this.worldview);
            }
            updateRoadElevation(t1) {
                if ("road" !== this.elevationType || !this.elevationFeatures) return;
                if (this.elevationStateComplete) return;
                this.elevationStateComplete = !0, this.hasAnyZOffset = !1;
                let e = !1;
                const r = lu(t1), n = 1 / r;
                let i = !1, s = !1;
                for(let t1 = 0; t1 < this.symbolInstances.length; t1++){
                    const o = this.symbolInstances.get(t1), a = A(1, 0, 0), l = A(0, 1, 0), { numHorizontalGlyphVertices: u, numVerticalGlyphVertices: c, numIconVertices: h, numVerticalIconVertices: p } = o, d = u > 0 || c > 0, f = h > 0, m = this.elevationFeatures[o.elevationFeatureIndex];
                    if (m) {
                        const t1 = new bt(o.tileAnchorX, o.tileAnchorY), u = .075 + m.pointElevation(t1);
                        o.zOffset !== u && (e = !0, o.zOffset = u);
                        const c = m.computeSlopeNormal(t1, n), h = st(K(), A(0, 0, 1), c);
                        N(a, a, h), N(l, l, h), a[2] *= r, l[2] *= r, 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === l[0] && 1 === l[1] && 0 === l[2] || (i = i || d, s = s || f);
                    }
                    if (d && (cx(this.text.orientationVertexArray, u, a, l), cx(this.text.orientationVertexArray, c, a, l)), f) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: e } = o;
                        t1 >= 0 && cx(this.icon.orientationVertexArray, h, a, l), e >= 0 && cx(this.icon.orientationVertexArray, p, a, l);
                    }
                }
                i || (this.text.orientationVertexArray = void 0), s || (this.icon.orientationVertexArray = void 0), e && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0);
            }
            updateZOffset() {
                const t1 = (t1, e, n)=>{
                    r += e, r > t1.length && t1.resize(r);
                    for(let i = -e; i < 0; i++)t1.emplace(i + r, n);
                }, e = (t1, e, r)=>{
                    n += e, n > t1.length && t1.resize(n);
                    for(let i = -e; i < 0; i++)t1.emplace(i + n, r);
                };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let r = 0, n = 0;
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const n = this.symbolInstances.get(r), { numHorizontalGlyphVertices: i, numVerticalGlyphVertices: s, numIconVertices: o } = n, a = n.zOffset, l = o > 0;
                    if ((i > 0 || s > 0) && (t1(this.text.zOffsetVertexArray, i, a), t1(this.text.zOffsetVertexArray, s, a)), l) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: r } = n;
                        t1 >= 0 && e(this.icon.zOffsetVertexArray, o, a), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, a);
                    }
                }
                this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = ix(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1, y: r } of e)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m) {
                const y = t1.indexArray, g = t1.layoutVertexArray, x = t1.globeExtVertexArray, v = t1.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? s.sortKey : void 0), b = this.glyphOffsetArray.length, w = v.vertexLength, _ = this.allowVerticalPlacement && o === my.vertical ? Math.PI / 2 : 0, A = s.text && s.text.sections;
                for(let n = 0; n < e.length; n++){
                    const { tl: i, tr: o, bl: u, br: c, texPrimary: h, texSecondary: b, pixelOffsetTL: w, pixelOffsetBR: M, minFontScaleX: I, minFontScaleY: S, glyphOffset: P, isSDF: E, sectionIndex: k } = e[n], z = v.vertexLength, T = P[1];
                    if (ax(g, l.x, l.y, i.x, T + i.y, h.x, h.y, r, E, w.x, w.y, I, S), ax(g, l.x, l.y, o.x, T + o.y, h.x + h.w, h.y, r, E, M.x, w.y, I, S), ax(g, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, E, w.x, M.y, I, S), ax(g, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, E, M.x, M.y, I, S), a) {
                        const { x: e, y: r, z: n } = a.anchor, [i, s, o] = a.up;
                        ux(x, e, r, n, i, s, o), ux(x, e, r, n, i, s, o), ux(x, e, r, n, i, s, o), ux(x, e, r, n, i, s, o), hx(t1.dynamicLayoutVertexArray, e, r, n, _);
                    } else hx(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, _);
                    if (m) {
                        const e = b || h;
                        lx(t1.iconTransitioningVertexArray, e.x, e.y), lx(t1.iconTransitioningVertexArray, e.x + e.w, e.y), lx(t1.iconTransitioningVertexArray, e.x, e.y + e.h), lx(t1.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);
                    }
                    y.emplaceBack(z, z + 1, z + 2), y.emplaceBack(z + 1, z + 2, z + 3), v.vertexLength += 4, v.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), n !== e.length - 1 && k === e[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(g.length, s, s.index, {}, p, d, f, A && A[k], this.worldview);
                }
                const M = a ? a.anchor : l;
                t1.placedSymbolArray.emplaceBack(M.x, M.y, M.z, l.x, l.y, b, this.glyphOffsetArray.length - b, w, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, 0, 0, h, 0);
            }
            _commitLayoutVertex(t1, e, r, n, i, s, o) {
                t1.emplaceBack(e, r, n, i, s, Math.round(o.x), Math.round(o.y));
            }
            _addCollisionDebugVertices(t1, e, r, n, i, s, o) {
                const a = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = a.vertexLength, u = o.tileAnchorX, c = o.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t1.padding, o.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new bt(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new bt(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new bt(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new bt(t1.x1, t1.y2)), a.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), a.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let o = n; o < i; o++){
                    const n = r.get(o), i = this.getSymbolInstanceTextSize(t1, s, e, o);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let o = n; o < i; o++){
                    const n = r.get(o), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t1, e, r) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fx(wa, jm.members, va), this.iconCollisionBox = new fx(wa, jm.members, va);
                const n = Ly(this.iconSizeData, t1), i = Ly(this.textSizeData, t1, r);
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const s = this.symbolInstances.get(r);
                    this._addTextDebugCollisionBoxes(i, t1, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(i, t1, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t1, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t1, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t1, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n), s = Dy(this.textSizeData, t1, i) / Gm;
                return this.tilePixelRatio * s;
            }
            getSymbolInstanceIconSize(t1, e, r) {
                const n = this.icon.placedSymbolArray.get(r), i = Dy(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e, r, n) {
                t1.emplaceBack(e, -r, -r, n), t1.emplaceBack(e, r, -r, n), t1.emplaceBack(e, r, r, n), t1.emplaceBack(e, -r, r, n);
            }
            _updateTextDebugCollisionBoxes(t1, e, r, n, i, s, o) {
                for(let o = n; o < i; o++){
                    const n = r.get(o), i = this.getSymbolInstanceTextSize(t1, s, e, o);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e, r, n, i, s, o) {
                for(let o = n; o < i; o++){
                    const n = r.get(o), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            updateCollisionDebugBuffers(t1, e, r, n) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const i = Ly(this.iconSizeData, t1, n), s = Ly(this.textSizeData, t1, r);
                for(let o = 0; o < this.symbolInstances.length; o++){
                    const a = this.symbolInstances.get(o);
                    this._updateTextDebugCollisionBoxes(s, t1, e, a.textBoxStartIndex, a.textBoxEndIndex, a, r), this._updateTextDebugCollisionBoxes(s, t1, e, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a, r), this._updateIconDebugCollisionBoxes(i, t1, e, a.iconBoxStartIndex, a.iconBoxEndIndex, a, n), this._updateIconDebugCollisionBoxes(i, t1, e, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a, n);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e, r, n, i, s, o, a, l) {
                const u = {};
                if (e < r) {
                    const { x1: r, y1: n, x2: i, y2: s, padding: o, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(e);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: s,
                        padding: o,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = d;
                }
                if (n < i) {
                    const { x1: e, y1: r, x2: i, y2: s, padding: o, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e,
                        y1: r,
                        x2: i,
                        y2: s,
                        padding: o,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = d;
                }
                if (s < o) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: o, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(s);
                    u.iconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: o,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = d;
                }
                if (a < l) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: d } = t1.get(a);
                    u.verticalIconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = d;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e = 0; e < this.symbolInstances.length; e++){
                    const r = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
                return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t1, e) {
                const r = t1.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e = r.vertexStartIndex; e < n; e += 4)t1.indexArray.emplaceBack(e, e + 1, e + 2), t1.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e = Math.sin(t1), r = Math.cos(t1), n = [], i = [], s = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    s.push(t1);
                    const o = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e * o.tileAnchorX + r * o.tileAnchorY)), i.push(o.featureIndex);
                }
                return s.sort((t1, e)=>n[t1] - n[e] || i[e] - i[t1]), s;
            }
            getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                    this.symbolInstanceIndexesSortedZOffset = [];
                    for(let t1 = 0; t1 < this.symbolInstances.length; ++t1)this.symbolInstanceIndexesSortedZOffset.push(t1);
                }
                return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t1, e)=>this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t1).zOffset);
            }
            addToSortKeyRanges(t1, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: s, placedIconSymbolIndex: o, verticalPlacedIconSymbolIndex: a } = e;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        let yx, gx, xx;
        qs(mx, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), mx.addDynamicAttributes = hx;
        class vx {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : mr, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t1.formattedSection)) return e.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        qs(vx, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        const bx = ()=>xx || (xx = {
                layout: yx || (yx = new zo({
                    "symbol-placement": new Po(To.layout_symbol["symbol-placement"]),
                    "symbol-spacing": new Po(To.layout_symbol["symbol-spacing"]),
                    "symbol-avoid-edges": new Po(To.layout_symbol["symbol-avoid-edges"]),
                    "symbol-sort-key": new Eo(To.layout_symbol["symbol-sort-key"]),
                    "symbol-z-order": new Po(To.layout_symbol["symbol-z-order"]),
                    "symbol-z-elevate": new Po(To.layout_symbol["symbol-z-elevate"]),
                    "symbol-elevation-reference": new Po(To.layout_symbol["symbol-elevation-reference"]),
                    "icon-allow-overlap": new Po(To.layout_symbol["icon-allow-overlap"]),
                    "icon-ignore-placement": new Po(To.layout_symbol["icon-ignore-placement"]),
                    "icon-optional": new Po(To.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new Po(To.layout_symbol["icon-rotation-alignment"]),
                    "icon-size": new Eo(To.layout_symbol["icon-size"]),
                    "icon-size-scale-range": new Po(To.layout_symbol["icon-size-scale-range"]),
                    "icon-text-fit": new Eo(To.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new Eo(To.layout_symbol["icon-text-fit-padding"]),
                    "icon-image": new Eo(To.layout_symbol["icon-image"]),
                    "icon-rotate": new Eo(To.layout_symbol["icon-rotate"]),
                    "icon-padding": new Po(To.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new Po(To.layout_symbol["icon-keep-upright"]),
                    "icon-offset": new Eo(To.layout_symbol["icon-offset"]),
                    "icon-anchor": new Eo(To.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new Po(To.layout_symbol["icon-pitch-alignment"]),
                    "text-pitch-alignment": new Po(To.layout_symbol["text-pitch-alignment"]),
                    "text-rotation-alignment": new Po(To.layout_symbol["text-rotation-alignment"]),
                    "text-field": new Eo(To.layout_symbol["text-field"]),
                    "text-font": new Eo(To.layout_symbol["text-font"]),
                    "text-size": new Eo(To.layout_symbol["text-size"]),
                    "text-size-scale-range": new Po(To.layout_symbol["text-size-scale-range"]),
                    "text-max-width": new Eo(To.layout_symbol["text-max-width"]),
                    "text-line-height": new Eo(To.layout_symbol["text-line-height"]),
                    "text-letter-spacing": new Eo(To.layout_symbol["text-letter-spacing"]),
                    "text-justify": new Eo(To.layout_symbol["text-justify"]),
                    "text-radial-offset": new Eo(To.layout_symbol["text-radial-offset"]),
                    "text-variable-anchor": new Po(To.layout_symbol["text-variable-anchor"]),
                    "text-anchor": new Eo(To.layout_symbol["text-anchor"]),
                    "text-max-angle": new Po(To.layout_symbol["text-max-angle"]),
                    "text-writing-mode": new Po(To.layout_symbol["text-writing-mode"]),
                    "text-rotate": new Eo(To.layout_symbol["text-rotate"]),
                    "text-padding": new Po(To.layout_symbol["text-padding"]),
                    "text-keep-upright": new Po(To.layout_symbol["text-keep-upright"]),
                    "text-transform": new Eo(To.layout_symbol["text-transform"]),
                    "text-offset": new Eo(To.layout_symbol["text-offset"]),
                    "text-allow-overlap": new Po(To.layout_symbol["text-allow-overlap"]),
                    "text-ignore-placement": new Po(To.layout_symbol["text-ignore-placement"]),
                    "text-optional": new Po(To.layout_symbol["text-optional"]),
                    visibility: new Po(To.layout_symbol.visibility)
                })),
                paint: gx || (gx = new zo({
                    "icon-opacity": new Eo(To.paint_symbol["icon-opacity"]),
                    "icon-occlusion-opacity": new Eo(To.paint_symbol["icon-occlusion-opacity"]),
                    "icon-emissive-strength": new Eo(To.paint_symbol["icon-emissive-strength"]),
                    "text-emissive-strength": new Eo(To.paint_symbol["text-emissive-strength"]),
                    "icon-color": new Eo(To.paint_symbol["icon-color"]),
                    "icon-halo-color": new Eo(To.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new Eo(To.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new Eo(To.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new Po(To.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new Po(To.paint_symbol["icon-translate-anchor"]),
                    "icon-image-cross-fade": new Po(To.paint_symbol["icon-image-cross-fade"]),
                    "text-opacity": new Eo(To.paint_symbol["text-opacity"]),
                    "text-occlusion-opacity": new Eo(To.paint_symbol["text-occlusion-opacity"]),
                    "text-color": new Eo(To.paint_symbol["text-color"], {
                        runtimeType: vr,
                        getOverride: (t1)=>t1.textColor,
                        hasOverride: (t1)=>!!t1.textColor
                    }),
                    "text-halo-color": new Eo(To.paint_symbol["text-halo-color"]),
                    "text-halo-width": new Eo(To.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new Eo(To.paint_symbol["text-halo-blur"]),
                    "text-translate": new Po(To.paint_symbol["text-translate"]),
                    "text-translate-anchor": new Po(To.paint_symbol["text-translate-anchor"]),
                    "icon-color-saturation": new Po(To.paint_symbol["icon-color-saturation"]),
                    "icon-color-contrast": new Po(To.paint_symbol["icon-color-contrast"]),
                    "icon-color-brightness-min": new Po(To.paint_symbol["icon-color-brightness-min"]),
                    "icon-color-brightness-max": new Po(To.paint_symbol["icon-color-brightness-max"]),
                    "symbol-z-offset": new Eo(To.paint_symbol["symbol-z-offset"]),
                    "icon-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "icon-halo-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-halo-color-use-theme": new Eo({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, xx);
        class wx extends Ko {
            constructor(t1, e, r, n){
                super(t1, bx(), e, r, n), this._colorAdjustmentMatrix = l([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t1.paint && ("icon-occlusion-opacity" in t1.paint || "text-occlusion-opacity" in t1.paint);
            }
            recalculate(t1, e) {
                super.recalculate(t1, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e of r)t1.indexOf(e) < 0 && t1.push(e);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(t1, e, r, n) {
                return this._saturation === t1 && this._contrast === e && this._brightnessMin === r && this._brightnessMax === n || (this._colorAdjustmentMatrix = function(t1, e, r, n) {
                    t1 = ee(t1), e = te(e);
                    const i = a(), s = t1 / 3, o = 1 - 2 * s, l = [
                        o,
                        s,
                        s,
                        0,
                        s,
                        o,
                        s,
                        0,
                        s,
                        s,
                        o,
                        0,
                        0,
                        0,
                        0,
                        1
                    ], u = .5 - .5 * e, h = n - r;
                    return c(i, [
                        h,
                        0,
                        0,
                        0,
                        0,
                        h,
                        0,
                        0,
                        0,
                        0,
                        h,
                        0,
                        r,
                        r,
                        r,
                        1
                    ], [
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        u,
                        u,
                        u,
                        1
                    ]), c(i, i, l), i;
                }(t1, e, r, n), this._saturation = t1, this._contrast = e, this._brightnessMin = r, this._brightnessMax = n), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t1, e, r, n) {
                const i = this.layout.get(t1).evaluate(e, {}, r, n), s = this._unevaluatedLayout._values[t1];
                return s.isDataDriven() || Cs(s.value) || !i ? i : function(t1, e) {
                    return e.replace(/{([^{}]+)}/g, (e, r)=>r in t1 ? String(t1[r]) : "");
                }(e.properties, i);
            }
            createBucket(t1) {
                return new mx(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of bx().paint.overridableProperties){
                    if (!wx.hasPaintOverride(this.layout, t1)) continue;
                    const e = this.paint.get(t1), r = new vx(e), n = new Vs(r, e.property.specification, this.scope, this.options);
                    let i = null;
                    i = "constant" === e.value.kind || "source" === e.value.kind ? new Ds("source", n) : new Ls("composite", n, e.value.zoomStops, e.value.interpolationType), this.paint._values[t1] = new Io(e.property, i, e.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && wx.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e) {
                const r = t1.get("text-field"), n = bx().paint.properties[e];
                let i = !1;
                const s = (t1)=>{
                    for (const e of t1)if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof Cr) s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e)=>{
                        i || (e instanceof Nr && Or(e.value) === Ar ? s(e.value.sections) : e instanceof Hr ? s(e.sections) : e.eachChild(t1));
                    }, e = r.value;
                    e._styleExpression && t1(e._styleExpression.expression);
                }
                return i;
            }
            getProgramIds() {
                return [
                    "symbol"
                ];
            }
            getDefaultProgramParams(t1, e, r) {
                return {
                    config: new El(this, {
                        zoom: e,
                        lut: r
                    }),
                    overrideFog: !1
                };
            }
            hasElevation() {
                return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
            }
        }
        let _x, Ax, Mx, Ix;
        var Sx = ea([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function Px(t1, e, r, n, i, a, l, u) {
            const c = [
                t1,
                e,
                1,
                r,
                n,
                1,
                i,
                a,
                1
            ], h = [
                l,
                u,
                1
            ], p = s([], c), [d, f, m] = U(h, h, p);
            return o(c, c, [
                d,
                0,
                0,
                0,
                f,
                0,
                0,
                0,
                m
            ]);
        }
        function Ex(t1, e, r, n, i, a, l, u) {
            const c = function(t1, e, r, n, i, a, l, u) {
                const c = Px(0, 0, 1, 0, 1, 1, 0, 1), h = Px(t1, e, r, n, i, a, l, u);
                return o(h, h, s([], c));
            }(t1, e, r, n, i, a, l, u);
            return [
                c[2] / c[8] / Cn,
                c[5] / c[8] / Cn
            ];
        }
        function kx(t1) {
            return [
                t1[0],
                Math.min(Math.max(t1[1], -iu), iu)
            ];
        }
        class zx extends tr {
            constructor(t1, e, r, n){
                super(), this.id = t1, this.dispatcher = r, this.coordinates = e.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;
            }
            load(t1, e) {
                if (this._loaded = e || !1, this.fire(new Ye("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, !this.url) return t1 && (this.coordinates = t1), this._loaded = !0, void this._finishLoading();
                this._imageRequest = Ne(this.map._requestManager.transformRequest(this.url, Be.Image), (e, r)=>{
                    this._imageRequest = null, this._loaded = !0, e ? this.fire(new Ke(e)) : r && (this.image = r instanceof HTMLImageElement ? de.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading());
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(t1) {
                return t1.url ? (this._imageRequest && t1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t1.url, this.load(t1.coordinates, this._loaded), this) : this;
            }
            setTexture(t1) {
                if (!(t1.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
                return this.texture = new ff(this.map.painter.context, t1.handle), this.width = t1.dimensions[0], this.height = t1.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new Ye("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            onRemove(t1) {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof ff || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t1) {
                if (this.coordinates = t1, this._boundsArray = void 0, this._unsupportedCoords = !1, !t1.length) return this;
                this.onNorthPole = !1, this.onSouthPole = !1;
                let e = t1[0][1], r = t1[0][1];
                for (const n of t1)n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);
                const n = (r + e) / 2;
                if (n > iu ? this.onNorthPole = !0 : n < -iu && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                    const e = t1.map(uu.fromLngLat);
                    this.tileID = function(t1) {
                        let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
                        for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
                        const s = Math.max(n - e, i - r), o = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), a = Math.pow(2, o);
                        let l = Math.floor((e + n) / 2 * a);
                        return l > 1 && (l -= 1), new yc(o, l, Math.floor((r + i) / 2 * a));
                    }(e), this.minzoom = this.maxzoom = this.tileID.z;
                }
                return this.fire(new Ye("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                !this.texture || this.texture instanceof ff || (this.texture.destroy(), this._dirty = !0), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = !1;
            }
            _prepareData(t1) {
                for(const t1 in this.tiles){
                    const e = this.tiles[t1];
                    "loaded" !== e.state && (e.state = "loaded", e.texture = this.texture);
                }
                if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
                const e = Dg(new yc(0, 0, 0), this.map.transform.projection), r = [
                    e.projection.project(this.coordinates[0][0], this.coordinates[0][1]),
                    e.projection.project(this.coordinates[1][0], this.coordinates[1][1]),
                    e.projection.project(this.coordinates[2][0], this.coordinates[2][1]),
                    e.projection.project(this.coordinates[3][0], this.coordinates[3][1])
                ];
                if (!function(t1) {
                    const e = t1[1].x - t1[0].x, r = t1[1].y - t1[0].y, n = t1[2].x - t1[1].x, i = t1[2].y - t1[1].y, s = t1[3].x - t1[2].x, o = t1[3].y - t1[2].y, a = t1[0].x - t1[3].x, l = t1[0].y - t1[3].y, u = e * i - n * r, c = n * o - s * i, h = s * l - a * o, p = a * r - e * l;
                    return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;
                }(r)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
                const n = Dg(this.tileID, this.map.transform.projection), [i, a, l, u] = this.coordinates.map((t1)=>{
                    const e = n.projection.project(t1[0], t1[1]);
                    return Lg(n, e)._round();
                });
                this.perspectiveTransform = Ex(i.x, i.y, a.x, a.y, l.x, l.y, u.x, u.y);
                const c = this._boundsArray = new sa;
                c.emplaceBack(i.x, i.y, 0, 0), c.emplaceBack(a.x, a.y, Cn, 0), c.emplaceBack(u.x, u.y, 0, Cn), c.emplaceBack(l.x, l.y, Cn, Cn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t1.createVertexBuffer(c, Sx.members), this.boundsSegments = el.simpleSegment(0, 0, 4, 2);
                const h = [], p = [
                    kx((d = this.coordinates)[0]),
                    kx(d[1]),
                    kx(d[2]),
                    kx(d[3])
                ];
                var d;
                const [f, m, y, g] = function(t1) {
                    let e = t1[0][0], r = e, n = t1[0][1], i = n;
                    for(let s = 1; s < t1.length; s++)t1[s][0] < e ? e = t1[s][0] : t1[s][0] > r && (r = t1[s][0]), t1[s][1] < n ? n = t1[s][1] : t1[s][1] > i && (i = t1[s][1]);
                    return [
                        e,
                        n,
                        r - e,
                        i - n
                    ];
                }(p);
                {
                    const n = new sa, [i, a, l, u] = function(t1) {
                        let e = t1[0].x, r = e, n = t1[0].y, i = n;
                        for(let s = 1; s < t1.length; s++)t1[s].x < e ? e = t1[s].x : t1[s].x > r && (r = t1[s].x), t1[s].y < n ? n = t1[s].y : t1[s].y > i && (i = t1[s].y);
                        return [
                            e,
                            n,
                            r - e,
                            i - n
                        ];
                    }(r), c = (t1)=>[
                            (t1.x - i) / l,
                            (t1.y - a) / u
                        ], [p, d, x, v] = r.map(c), b = function(t1, e, r, n, i, a, l, u) {
                        const c = Px(0, 0, 1, 0, 1, 1, 0, 1);
                        return o(c, c, s([], Px(t1, e, r, n, i, a, l, u)));
                    }(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);
                    this.elevatedGlobePerspectiveTransform = Ex(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);
                    const w = (t1, e)=>{
                        h.push(t1.lng);
                        const r = Math.round((t1.lng - f) / y * Cn), i = Math.round((t1.lat - m) / g * Cn), s = c(e), o = U([], [
                            s[0],
                            s[1],
                            1
                        ], b), a = Math.round(o[0] / o[2] * Cn), l = Math.round(o[1] / o[2] * Cn);
                        n.emplaceBack(r, i, a, l);
                    }, _ = r[3].x - r[0].x, A = r[3].y - r[0].y, M = r[2].x - r[1].x, I = r[2].y - r[1].y;
                    for(let t1 = 0; t1 < 65; t1++){
                        const n = t1 / 64, i = [
                            r[0].x + n * _,
                            r[0].y + n * A
                        ], s = [
                            r[1].x + n * M,
                            r[1].y + n * I
                        ], o = s[0] - i[0], a = s[1] - i[1];
                        for(let t1 = 0; t1 < 65; t1++){
                            const r = t1 / 64, n = {
                                x: i[0] + o * r,
                                y: i[1] + a * r
                            };
                            w(e.projection.unproject(n.x, n.y), n);
                        }
                    }
                    this.elevatedGlobeVertexBuffer = t1.createVertexBuffer(n, Sx.members);
                }
                {
                    this.maxLongitudeTriangleSize = 0;
                    let e = [], r = new Ma;
                    const n = (t1, n, i)=>{
                        r.emplaceBack(t1, n, i);
                        const s = h[t1], o = h[n], a = h[i], l = Math.min(Math.min(s, o), a), u = Math.max(Math.max(s, o), a) - l;
                        u > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u), e.push(l + u / 2);
                    };
                    for(let t1 = 0; t1 < 64; t1++)for(let e = 0; e < 64; e++){
                        const r = 65 * t1 + e, i = r + 1, s = r + 65, o = s + 1;
                        n(r, s, i), n(i, s, o);
                    }
                    [e, r] = function(t1, e) {
                        const r = Array.from({
                            length: t1.length
                        }, (t1, e)=>e);
                        r.sort((e, r)=>t1[e] - t1[r]);
                        const n = [], i = new Ma;
                        for(let s = 0; s < r.length; s++){
                            const o = r[s];
                            n.push(t1[o]);
                            const a = 3 * o, l = a + 1;
                            i.emplaceBack(e.uint16[a], e.uint16[l], e.uint16[l + 1]);
                        }
                        return [
                            n,
                            i
                        ];
                    }(e, r), this.elevatedGlobeTrianglesCenterLongitudes = e, this.elevatedGlobeIndexBuffer = t1.createIndexBuffer(r);
                }
                this.elevatedGlobeSegments = el.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([
                    0,
                    y / Cn,
                    0,
                    g / Cn,
                    0,
                    0,
                    m,
                    f,
                    0
                ]);
            }
            prepare() {
                const t1 = 0 !== Object.keys(this.tiles).length;
                if (this.tileID && !t1) return;
                const e = this.map.painter.context, r = e.gl;
                !this._dirty || this.texture instanceof ff || (this.texture ? this.texture.update(this.image) : (this.texture = new df(e, this.image, r.RGBA8), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t1 && this._prepareData(e);
            }
            loadTile(t1, e) {
                this.tileID && this.tileID.equals(t1.tileID.canonical) ? (this.tiles[String(t1.tileID.wrap)] = t1, t1.buckets = {}, e(null)) : (t1.state = "errored", e(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
            getSegmentsForLongitude(t1) {
                const e = this.elevatedGlobeSegments;
                if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;
                const r = this.elevatedGlobeTrianglesCenterLongitudes;
                let n = (i = t1 + 180) + 360 * Math.round((r[0] - i) / 360);
                var i;
                const s = new el, o = (t1, r)=>{
                    s.segments.push({
                        vertexOffset: 0,
                        primitiveOffset: t1,
                        vertexLength: e.segments[0].vertexLength,
                        primitiveLength: r,
                        sortKey: void 0,
                        vaos: {}
                    });
                }, a = .51 * this.maxLongitudeTriangleSize;
                if (Math.abs(r[0] - n) <= a) {
                    const t1 = Qt(r, 0, r.length, n + a);
                    return t1 === r.length || o(t1, Jt(r, t1 + 1, r.length, n + 360 - a) - t1), s;
                }
                n < r[0] && (n += 360);
                const l = Jt(r, 0, r.length, n - a);
                if (l === r.length) return o(0, r.length), s;
                o(0, l - 0);
                const u = Qt(r, l + 1, r.length, n + a);
                return u !== r.length && o(u, r.length - u), s;
            }
        }
        const Tx = (Math.pow(256, 2) - 1) / 16907520;
        class Bx extends Ko {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: Mx || (Mx = new zo({
                        visibility: new Po(To.layout_raster.visibility)
                    })),
                    paint: Ix || (Ix = new zo({
                        "raster-opacity": new Po(To.paint_raster["raster-opacity"]),
                        "raster-color": new ko(To.paint_raster["raster-color"]),
                        "raster-color-mix": new Po(To.paint_raster["raster-color-mix"]),
                        "raster-color-range": new Po(To.paint_raster["raster-color-range"]),
                        "raster-hue-rotate": new Po(To.paint_raster["raster-hue-rotate"]),
                        "raster-brightness-min": new Po(To.paint_raster["raster-brightness-min"]),
                        "raster-brightness-max": new Po(To.paint_raster["raster-brightness-max"]),
                        "raster-saturation": new Po(To.paint_raster["raster-saturation"]),
                        "raster-contrast": new Po(To.paint_raster["raster-contrast"]),
                        "raster-resampling": new Po(To.paint_raster["raster-resampling"]),
                        "raster-fade-duration": new Po(To.paint_raster["raster-fade-duration"]),
                        "raster-emissive-strength": new Po(To.paint_raster["raster-emissive-strength"]),
                        "raster-array-band": new Po(To.paint_raster["raster-array-band"]),
                        "raster-elevation": new Po(To.paint_raster["raster-elevation"]),
                        "raster-color-use-theme": new Eo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this.updateColorRamp(), this._curRampRange = [
                    NaN,
                    NaN
                ];
            }
            getProgramIds() {
                return [
                    "raster"
                ];
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
                return this.paint.get("raster-elevation");
            }
            isDraped(t1) {
                return !(t1 && t1._source instanceof zx && (t1._source.onNorthPole || t1._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-color" !== t1 && "raster-color-range" !== t1 || (this._curRampRange = [
                    NaN,
                    NaN
                ], this.updateColorRamp());
            }
            _clear() {
                this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            updateColorRamp(t1) {
                if (!this.hasColorMap()) return;
                if (!this._curRampRange) return;
                const e = this._transitionablePaint._values["raster-color"].value.expression, [r, n] = t1 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({
                    zoom: 0
                }) || [
                    NaN,
                    NaN
                ];
                isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = fh({
                    expression: e,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: r,
                            end: n
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null, this._curRampRange = [
                    r,
                    n
                ]);
            }
        }
        let Vx, Cx, Fx, Dx, Lx;
        class Rx extends Ko {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: Vx || (Vx = new zo({
                        visibility: new Po(To["layout_raster-particle"].visibility)
                    })),
                    paint: Cx || (Cx = new zo({
                        "raster-particle-array-band": new Po(To["paint_raster-particle"]["raster-particle-array-band"]),
                        "raster-particle-count": new Po(To["paint_raster-particle"]["raster-particle-count"]),
                        "raster-particle-color": new ko(To["paint_raster-particle"]["raster-particle-color"]),
                        "raster-particle-max-speed": new Po(To["paint_raster-particle"]["raster-particle-max-speed"]),
                        "raster-particle-speed-factor": new Po(To["paint_raster-particle"]["raster-particle-speed-factor"]),
                        "raster-particle-fade-opacity-factor": new Po(To["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                        "raster-particle-reset-rate-factor": new Po(To["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
                        "raster-particle-elevation": new Po(To["paint_raster-particle"]["raster-particle-elevation"]),
                        "raster-particle-color-use-theme": new Eo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = de.now();
            }
            _clear() {
                this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null);
            }
            onRemove(t1) {
                this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
                return [
                    "rasterParticle"
                ];
            }
            hasOffscreenPass() {
                return "none" !== this.visibility;
            }
            isDraped(t1) {
                return !1;
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-particle-color" !== t1 && "raster-particle-max-speed" !== t1 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t1 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
                if (!this.hasColorMap()) return;
                const t1 = this._transitionablePaint._values["raster-particle-color"].value.expression, e = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({
                    zoom: 0
                });
                this.colorRamp = fh({
                    expression: t1,
                    evaluationKey: "rasterParticleSpeed",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: 0,
                            end: e
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
                this.lastInvalidatedAt = de.now();
            }
            tileCoverLift() {
                return this.paint.get("raster-particle-elevation");
            }
        }
        class Ox extends Ko {
            constructor(t1, e){
                super(t1, {}, e, null), this.implementation = t1, t1.slot && (this.slot = t1.slot);
            }
            is3D(t1) {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isDraped(t1) {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        function Ux(t1, e, r) {
            const n = [
                0,
                0,
                1
            ], i = J([]);
            return tt(i, i, r ? -Mt(t1) + Math.PI : Mt(t1)), Q(i, i, -Mt(e)), N(n, n, i), F(n, n);
        }
        const Nx = {
            None: 0,
            Model: 1,
            Symbol: 2,
            FillExtrusion: 4
        };
        class jx {
            constructor(t1, e, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
            }
        }
        function $x(t1, e) {
            const r = -1 === t1.indexOf("://");
            try {
                return new URL(t1, r && e ? "http://example.com" : void 0), !0;
            } catch (t1) {
                return !1;
            }
        }
        class Gx {
            constructor(t1, e){
                this.feature = t1, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [
                    0,
                    0,
                    0
                ], this.scale = [
                    1,
                    1,
                    1
                ], this.translation = [
                    0,
                    0,
                    0
                ];
            }
        }
        class Hx {
            constructor(){
                this.instancedDataArray = new Fa, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
        }
        class qx {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.projection = t1.projection, this.index = t1.index, this.worldview = t1.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
                    id: null,
                    timestamp: 0
                }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t1.styleDefinedModelURLs;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.tileToMeter = lu(r);
                const i = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const { feature: s, id: o, index: a, sourceLayerIndex: l } of t1){
                    const t1 = null != o ? o : s.properties && s.properties.hasOwnProperty("id") ? s.properties.id : void 0, u = xu(s, i);
                    if (!this.layers[0]._featureFilter.filter(new xo(this.zoom, {
                        worldview: this.worldview
                    }), u, r)) continue;
                    const c = {
                        id: t1,
                        sourceLayerIndex: l,
                        index: a,
                        geometry: i ? u.geometry : gu(s, r, n),
                        properties: s.properties,
                        type: s.type,
                        patterns: {}
                    }, h = this.addFeature(c, c.geometry, u);
                    h && e.featureIndex.insert(s, c.geometry, a, l, this.index, this.instancesPerModel[h].instancedDataArray.length, Cn / 32);
                }
                this.lookup = null;
            }
            update(t1, e, r, n) {
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for(const e in t1)r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t1[e], r, !0), this.uploaded = !1);
                }
                this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let t1 = !1;
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for (const e of r.features){
                        const n = this.layers[0], i = e.feature, s = this.canonical, o = n.paint.get("model-rotation").evaluate(i, {}, s), a = n.paint.get("model-scale").evaluate(i, {}, s), l = n.paint.get("model-translation").evaluate(i, {}, s);
                        $(e.rotation, o) && $(e.scale, a) && $(e.translation, l) || (this.evaluate(e, e.featureStates, r, !0), t1 = !0);
                    }
                }
                return t1;
            }
            updateReplacement(t1, e, r, n) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const i = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                if (zp(this.activeReplacements, i)) return !1;
                this.activeReplacements = i;
                let s = !1;
                for(const e in this.instancesPerModel){
                    const i = this.instancesPerModel[e], o = i.instancedDataArray;
                    for (const e of i.features){
                        const i = e.instancedDataOffset, a = e.instancedDataCount;
                        for(let e = 0; e < a; e++){
                            const a = 16 * (e + i);
                            let l = o.float32[a + 0];
                            const u = l > Cn;
                            l = u ? l - Cn : l;
                            const c = Math.floor(l), h = o.float32[a + 1];
                            let p = !1;
                            for (const e of this.activeReplacements)if (!Sp(e, r, Nx.Model, n) && !(e.min.x > c || c > e.max.x || e.min.y > h || h > e.max.y) && (p = Dp(Fp(c, h, t1.canonical, e.footprintTileId.canonical), e.footprint), p)) break;
                            o.float32[a] = p ? l + Cn : l, s = s || p !== u;
                        }
                    }
                }
                return s;
            }
            isEmpty() {
                for(const t1 in this.instancesPerModel)if (0 !== this.instancesPerModel[t1].instancedDataArray.length) return !1;
                return !0;
            }
            uploadPending() {
                return !this.uploaded;
            }
            upload(t1) {
                if (!this.uploaded) for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t1.createVertexBuffer(r.instancedDataArray, bf.members, !0, void 0, this.instanceCount));
                }
                this.uploaded = !0;
            }
            destroy() {
                for(const t1 in this.instancesPerModel){
                    const e = this.instancesPerModel[t1];
                    0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();
                }
                const t1 = this.layers[0].modelManager;
                if (t1 && this.modelUris && this.modelsRequested) for (const e of this.modelUris)t1.removeModel(e, "", !0);
            }
            addFeature(t1, e, r) {
                const n = this.layers[0], i = n.layout.get("model-id").evaluate(r, {}, this.canonical);
                if (!i) return Gt(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), i;
                ($x(i, !1) || void 0 !== this.styleDefinedModelURLs[i]) && (this.modelUris.includes(i) || this.modelUris.push(i)), this.instancesPerModel[i] || (this.instancesPerModel[i] = new Hx);
                const s = this.instancesPerModel[i], o = s.instancedDataArray, a = new Gx(r, o.length);
                for (const t1 of e)for (const e of t1){
                    if (e.x < 0 || e.x >= Cn || e.y < 0 || e.y >= Cn) continue;
                    const t1 = (this.lookupDim - 1) / Cn, r = this.lookupDim * (e.y * t1 | 0) + e.x * t1 | 0;
                    if (this.lookup) {
                        if (0 !== this.lookup[r]) continue;
                        this.lookup[r] = 1;
                    }
                    this.instanceCount++;
                    const n = o.length;
                    o.resize(n + 1), s.instancesEvaluatedElevation.push(0), o.float32[16 * n] = e.x, o.float32[16 * n + 1] = e.y;
                }
                return a.instancedDataCount = s.instancedDataArray.length - a.instancedDataOffset, a.instancedDataCount > 0 && (t1.id && (s.idToFeaturesIndex[t1.id] = s.features.length), s.features.push(a), this.evaluate(a, {}, s, !1)), i;
            }
            getModelUris() {
                return this.modelUris;
            }
            evaluate(t1, e, r, n) {
                const i = this.layers[0], s = t1.feature, o = this.canonical, a = t1.rotation = i.paint.get("model-rotation").evaluate(s, e, o), l = t1.scale = i.paint.get("model-scale").evaluate(s, e, o), u = t1.translation = i.paint.get("model-translation").evaluate(s, e, o), c = i.paint.get("model-color").evaluate(s, e, o);
                c.a = i.paint.get("model-color-mix-intensity").evaluate(s, e, o);
                const h = [];
                this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), Ef(h, a, l);
                const p = Math.round(100 * c.a) + c.b / 1.05;
                for(let e = 0; e < t1.instancedDataCount; ++e){
                    const i = t1.instancedDataOffset + e, s = 16 * i, a = r.instancedDataArray.float32;
                    let l = 0;
                    n && (l = a[s + 6] - r.instancesEvaluatedElevation[i]);
                    const d = 0 | a[s + 1];
                    a[s] = (0 | a[s]) + c.r / 1.05, a[s + 1] = d + c.g / 1.05, a[s + 2] = p, a[s + 3] = 1 / (o.z > 10 ? this.tileToMeter : lu(o, d)), a[s + 4] = u[0], a[s + 5] = u[1], a[s + 6] = u[2] + l, a[s + 7] = h[0], a[s + 8] = h[1], a[s + 9] = h[2], a[s + 10] = h[4], a[s + 11] = h[5], a[s + 12] = h[6], a[s + 13] = h[8], a[s + 14] = h[9], a[s + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];
                }
            }
        }
        let Xx, Zx;
        qs(qx, "ModelBucket", {
            omit: [
                "layers"
            ]
        }), qs(Hx, "PerModelAttributes"), qs(Gx, "ModelFeature");
        class Wx {
            constructor(t1, e, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
            }
            static create(t1, e, r) {
                const n = r || t1.findDEMTileFor(e);
                if (!n || !n.dem) return;
                const i = n.dem, s = n.tileID, o = 1 << e.canonical.z - s.canonical.z;
                return new Wx(n, i.dim / Cn / o, [
                    (e.canonical.x / o - s.canonical.x) * i.dim,
                    (e.canonical.y / o - s.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e) {
                const r = e * this._scale + this._offset[1];
                return new bt(Math.floor(t1 * this._scale + this._offset[0]), Math.floor(r));
            }
            getElevationAt(t1, e, r, n) {
                const i = t1 * this._scale + this._offset[0], s = e * this._scale + this._offset[1], o = Math.floor(i), a = Math.floor(s), l = this._dem;
                return n = !!n, r ? ur(ur(l.get(o, a, n), l.get(o, a + 1, n), s - a), ur(l.get(o + 1, a, n), l.get(o + 1, a + 1, n), s - a), i - o) : l.get(o, a, n);
            }
            getElevationAtPixel(t1, e, r) {
                return this._dem.get(t1, e, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * tu(1, t1) * this._dem.stride;
            }
        }
        const Yx = new Float32Array(262144), Kx = new Uint8Array(262144);
        function Jx(t1) {
            let e = 0;
            if (t1.meshes) for (const r of t1.meshes)e = Math.max(e, r.aabb.max[2]);
            if (t1.children) for (const r of t1.children)e = Math.max(e, Jx(r));
            return e;
        }
        function Qx(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes){
                if (n.aabb.min[0] === 1 / 0) continue;
                const i = Nu.applyTransform(n.aabb, t1.matrix);
                r.insert(e, i.min[0], i.min[1], i.max[0], i.max[1]);
            }
            if (t1.children) for (const n of t1.children)Qx(n, e, r);
        }
        const tv = [
            "",
            "wall",
            "door",
            "roof",
            "window",
            "lamp",
            "logo"
        ];
        class ev {
            constructor(t1){
                this.node = t1, this.evaluatedRMEA = [
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        .4,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ]
                ], this.hiddenByReplacement = !1, this.evaluatedTranslation = [
                    0,
                    0,
                    0
                ], this.evaluatedScale = [
                    1,
                    1,
                    1
                ], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {
                    type: "Point",
                    id: t1.id,
                    geometry: [],
                    properties: {
                        height: Jx(t1)
                    }
                }, this.aabb = this._getLocalBounds(), this.state = null;
            }
            _getLocalBounds() {
                if (!this.node.meshes) return new Nu([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]);
                if (!this.aabb) {
                    let t1 = 0;
                    const e = new Nu([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]);
                    for (const r of this.node.meshes)this.node.lightMeshIndex !== t1 && (r.transformedAabb = Nu.applyTransformFast(r.aabb, this.node.matrix), e.encapsulate(r.transformedAabb)), t1++;
                    this.aabb = e;
                }
                return this.aabb;
            }
        }
        class rv {
            constructor(t1, e, r, n, i, s, o, a){
                this.id = r, this.layers = t1, this.layerIds = this.layers.map((t1)=>t1.fqid), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.modelTraits |= Vf.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n && (this.modelTraits |= Vf.HasMapboxMeshFeatures), i && (this.modelTraits |= Vf.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {
                    name: "mercator"
                }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s, this.worldview = a, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];
                for (const t1 of e)this.nodesInfo.push(new ev(t1)), Qx(t1, o.featureIndexArray.length, o.grid), o.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, o.bucketLayerIDs.length - 1, 0);
                this.states = {};
            }
            updateFootprints(t1, e) {
                for (const r of this.getNodesInfo()){
                    const n = r.node;
                    n.footprint && e.push({
                        footprint: n.footprint,
                        id: t1
                    });
                }
            }
            update(t1) {
                const e = 0 !== Object.keys(t1).length;
                if (e && !this.stateDependentLayers.length) return;
                const r = e ? this.stateDependentLayers : this.layers;
                if (!wt(t1, this.states)) for (const e of r)this.evaluate(e, t1);
                this.states = structuredClone(t1);
            }
            populate() {
                console.log("populate 3D model bucket");
            }
            uploadPending() {
                return !this.uploaded || this.needsUpload;
            }
            upload(t1) {
                if (!this.needsUpload) return;
                const e = this.getNodesInfo();
                for (const r of e){
                    const e = r.node;
                    this.uploaded ? this.updatePbrBuffer(e) : Lf(e, t1, !0);
                }
                for (const t1 of e)Rf(t1.node);
                this.uploaded = !0, this.needsUpload = !1;
            }
            updatePbrBuffer(t1) {
                let e = !1;
                if (!t1.meshes) return e;
                for (const r of t1.meshes)r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);
                return e;
            }
            needsReEvaluation(t1, e, r) {
                const n = t1.transform.projectionOptions, i = t1.style.getBrightness(), s = this.brightness !== i;
                if (!this.uploaded || this.dirty || n.name !== this.projection.name || nv(r.paint.get("model-color").value, s) || nv(r.paint.get("model-color-mix-intensity").value, s) || nv(r.paint.get("model-roughness").value, s) || nv(r.paint.get("model-emissive-strength").value, s) || nv(r.paint.get("model-height-based-emissive-strength-multiplier").value, s)) {
                    this.projection = n, this.brightness = i;
                    const t1 = this.getNodesInfo();
                    for (const e of t1)e.state = null;
                    return !0;
                }
                return !1;
            }
            evaluateTransform(t1, e) {
                if (t1.transform.zoom === this.zoom) return;
                this.zoom = t1.transform.zoom;
                const r = this.getNodesInfo(), n = this.id.canonical;
                for (const t1 of r){
                    const r = t1.feature;
                    t1.evaluatedTranslation = e.paint.get("model-translation").evaluate(r, {}, n), t1.evaluatedScale = e.paint.get("model-scale").evaluate(r, {}, n);
                }
            }
            evaluate(t1, e) {
                const r = this.getNodesInfo();
                for (const n of r){
                    if (!n.node.meshes) continue;
                    const r = n.feature, i = e && e[r.id];
                    if (wt(i, n.state)) continue;
                    n.state = structuredClone(i);
                    const s = n.node.meshes && n.node.meshes[0].featureData, o = n.evaluatedColor[2], a = n.evaluatedRMEA[2], l = this.id.canonical;
                    if (n.hasTranslucentParts = !1, s) {
                        for(let e = 0; e < tv.length; e++){
                            const s = tv[e];
                            s.length && (r.properties.part = s);
                            const o = t1.paint.get("model-color").evaluate(r, i, l).toPremultipliedRenderColor(null), a = t1.paint.get("model-color-mix-intensity").evaluate(r, i, l);
                            n.evaluatedColor[e] = [
                                o.r,
                                o.g,
                                o.b,
                                a
                            ], n.evaluatedRMEA[e][0] = t1.paint.get("model-roughness").evaluate(r, i, l), n.evaluatedRMEA[e][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l), n.evaluatedRMEA[e][3] = o.a, n.emissionHeightBasedParams[e] = t1.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r, i, l), !n.hasTranslucentParts && o.a < 1 && (n.hasTranslucentParts = !0);
                        }
                        delete r.properties.part, sv(n, o !== n.evaluatedColor[2] || a !== n.evaluatedRMEA[2], this.modelTraits);
                    } else n.evaluatedRMEA[0][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l);
                    n.evaluatedTranslation = t1.paint.get("model-translation").evaluate(r, i, l), n.evaluatedScale = t1.paint.get("model-scale").evaluate(r, i, l), this.updatePbrBuffer(n.node) || (this.needsUpload = !0);
                }
                this.dirty = !1;
            }
            elevationUpdate(t1, e, r, n) {
                const i = t1.findDEMTileFor(r);
                if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {
                    if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {
                        this.elevationReadFromZ = i.tileID.overscaledZ;
                        const e = Wx.create(t1, r, i);
                        if (!e) return;
                        this.modelTraits & Vf.HasMapboxMeshFeatures && this.updateDEM(t1, e, r, n);
                        for (const t1 of this.getNodesInfo()){
                            const r = t1.node;
                            if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;
                            const n = r.footprint.vertices;
                            let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);
                            for(let t1 = 1; t1 < n.length; t1++)i = Math.min(i, e.getElevationAt(n[t1].x, n[t1].y, !0, !0));
                            r.elevation = i;
                        }
                    }
                    this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;
                }
            }
            updateDEM(t1, e, r, n) {
                let i = e._dem._modifiedForSources[n];
                if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;
                const s = e._dem.dim;
                i.push(r.canonical);
                let o = !1;
                for (const t1 of this.getNodesInfo()){
                    const r = t1.node;
                    if (!r.footprint || !r.footprint.grid) continue;
                    const n = r.footprint.grid, i = e.tileCoordToPixel(n.min.x, n.min.y), a = e.tileCoordToPixel(n.max.x, n.max.y), l = Math.min(Math.min(s - a.y, i.x), Math.min(i.y, s - a.x));
                    if (l < 0) continue;
                    const u = zt(l, 2, 5);
                    let c = Math.max(0, i.x - u), h = Math.max(0, i.y - u), p = Math.min(a.x + u, s - 1), d = Math.min(a.y + u, s - 1);
                    for(let t1 = h; t1 <= d; ++t1)for(let e = c; e <= p; ++e)Kx[t1 * s + e] = 255;
                    let f = 0, m = 0;
                    for(let t1 = 0; t1 < n.cellsY; ++t1)for(let r = 0; r < n.cellsX; ++r){
                        if (!n.cells[t1 * n.cellsX + r]) continue;
                        const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t1 / n.yScale), o = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t1 + 1) / n.yScale);
                        for(let t1 = i.y; t1 <= Math.min(o.y + 1, s - 1); ++t1)for(let r = i.x; r <= Math.min(o.x + 1, s - 1); ++r)255 === Kx[t1 * s + r] && (Kx[t1 * s + r] = 0, f += e.getElevationAtPixel(r, t1), m++);
                    }
                    const y = f / m;
                    c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(a.x + u, s - 2), d = Math.min(a.y + u, s - 2), o = !0;
                    for(let t1 = h; t1 <= d; ++t1)for(let r = c; r <= p; ++r)0 === Kx[t1 * s + r] && (Yx[t1 * s + r] = e._dem.set(r, t1, y));
                    for(let t1 = 1; t1 < u; ++t1){
                        c = Math.max(1, i.x - t1), h = Math.max(1, i.y - t1), p = Math.min(a.x + t1, s - 2), d = Math.min(a.y + t1, s - 2);
                        for(let r = h; r <= d; ++r)for(let n = c; n <= p; ++n){
                            const i = r * s + n;
                            if (255 === Kx[i]) {
                                let o = 0, a = 0, l = -1, c = -1;
                                for(let e = -1; e <= 1; ++e)for(let i = -1; i <= 1; ++i){
                                    const u = (r + e) * s + n + i;
                                    if (Kx[u] >= t1) continue;
                                    const h = Yx[u], p = Math.abs(h);
                                    p > a && (o = h, a = p, l = i, c = e);
                                }
                                if (a > .1) {
                                    const s = 1 - (t1 + .5 * Math.abs(l * c)) / u;
                                    let a = e._dem.get(n, r) + o * s;
                                    const h = e._dem.get(n + l, r + c), p = e._dem.get(n - l, r - c, !0);
                                    (a - h) * (a - p) > 0 && (a = (h + p) / 2), Yx[i] = e._dem.set(n, r, a), Kx[i] = t1;
                                }
                            }
                        }
                    }
                }
                o && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = de.now());
            }
            setFilter(t1) {
                this.filter = t1 ? Fo(t1) : null;
            }
            getNodesInfo() {
                return this.filter ? this.nodesInfo.filter((t1)=>this.filter.filter(new xo(this.id.overscaledZ, {
                        worldview: this.worldview
                    }), t1.feature, this.id.canonical)) : this.nodesInfo;
            }
            destroy() {
                const t1 = this.getNodesInfo();
                for (const e of t1)Rf(e.node), Of(e.node);
            }
            isEmpty() {
                return !this.nodesInfo.length;
            }
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped());
                for (const t1 of this.getNodesInfo()){
                    const e = t1.node.footprint;
                    t1.hiddenByReplacement = !!e && !r.find((t1)=>t1.footprint === e);
                }
            }
            getHeightAtTileCoord(t1, e) {
                const r = [], n = [
                    0,
                    0,
                    0
                ], i = l([]);
                for (const s of this.getNodesInfo()){
                    const o = s.node.meshes[0], a = o.transformedAabb;
                    if (t1 < a.min[0] || e < a.min[1] || t1 > a.max[0] || e > a.max[1]) continue;
                    if (!0 === s.node.hidden) return {
                        height: 1 / 0,
                        maxHeight: s.feature.properties.height,
                        hidden: !1,
                        verticalScale: s.evaluatedScale[2]
                    };
                    u(i, s.node.matrix), n[0] = t1, n[1] = e, O(n, n, i);
                    const l = (n[0] - o.aabb.min[0]) / (o.aabb.max[0] - o.aabb.min[0]) * Bf | 0, c = Math.min(63, (n[1] - o.aabb.min[1]) / (o.aabb.max[1] - o.aabb.min[1]) * Bf | 0) * Bf + Math.min(63, l), h = o.heightmap[c];
                    if (!(h < 0 && s.node.footprint)) {
                        if (s.hiddenByReplacement) return;
                        return {
                            height: h,
                            maxHeight: s.feature.properties.height,
                            hidden: !1,
                            verticalScale: s.evaluatedScale[2]
                        };
                    }
                    if (s.node.footprint.grid.query(new bt(t1, e), new bt(t1, e), r), r.length > 0) return {
                        height: void 0,
                        maxHeight: s.feature.properties.height,
                        hidden: s.hiddenByReplacement,
                        verticalScale: s.evaluatedScale[2]
                    };
                }
            }
        }
        function nv(t1, e) {
            return t1 instanceof Ds && !t1.isLightConstant && e;
        }
        function iv(t1, e, r, n, i, s, o, a) {
            let l = (61440 & e | (61440 & e) >> 4) >> 8, u = (3840 & e | (3840 & e) >> 4) >> 4, c = 240 & e | (240 & e) >> 4;
            r[3] > 0 && (l = ur(l, 255 * r[0], r[3]), u = ur(u, 255 * r[1], r[3]), c = ur(c, 255 * r[2], r[3]));
            const h = l << 8 | u, p = c << 8 | Math.floor(255 * n[3]), d = function(t1) {
                const e = zt(t1, 0, 2);
                return Math.min(Math.round(.5 * e * 255), 255);
            }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1], f = zt(i[0], 0, 1), m = zt(i[1], 0, 1), y = zt(i[2], 0, 1), g = zt(i[3], 0, 1);
            let x, v, b, w;
            if (f !== m && o !== s && m !== f) {
                const t1 = o - s;
                v = 1 / (t1 * (m - f)), b = -(s + t1 * f) / (t1 * (m - f));
                const e = zt(i[4], -1, 1);
                w = Math.pow(10, e), x = 255 * y << 8 | 255 * g;
            } else x = 65535, v = 0, b = 1, w = 1;
            if (t1.emplaceBack(h, p, d, x, v, b, w), a) {
                const t1 = a.length;
                a.clear();
                for(let e = 0; e < t1; e++)a.emplaceBack(h, p, d, x, v, b, w);
            }
        }
        function sv(t1, e, r) {
            const n = t1.node;
            let i = 0;
            const s = r & Vf.HasMeshoptCompression;
            for (const r of n.meshes){
                if (n.lights && n.lightMeshIndex === i) continue;
                if (!r.featureData) continue;
                r.featureArray = new Da, r.featureArray.reserve(r.featureData.length);
                let o = e;
                for (const e of r.featureData){
                    const i = s ? 65535 & e : e >> 16 & 65535, a = s ? e >> 16 & 65535 : 65535 & e, l = (15 & a) < 8 ? 15 & a : 0, u = t1.evaluatedRMEA[l], c = t1.evaluatedColor[l], h = t1.emissionHeightBasedParams[l];
                    let p;
                    if (o && 2 === l && n.lights && (p = new Da, p.resize(10 * n.lights.length)), iv(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && o) {
                        o = !1;
                        const t1 = n.meshes[n.lightMeshIndex];
                        t1.featureArray = p, t1.featureArray._trim();
                    }
                }
                r.featureArray._trim(), i++;
            }
        }
        function ov(t1, e, r, n) {
            const i = 1 << t1.z;
            e.lat = ru((n / Cn + t1.y) / i), e.lng = eu((r / Cn + t1.x) / i);
        }
        function av(t1, e, r, n) {
            const i = t1.getNodesInfo()[e];
            if (!i || i.hiddenByReplacement || !i.node.meshes) return;
            let s = Number.MAX_VALUE;
            const o = i.node, a = r.tile, l = n.calculatePosMatrix(a.tileID.toUnwrapped(), n.worldSize), u = i.evaluatedScale;
            let d = 0;
            n.elevation && o.elevation && (d = o.elevation * n.elevation.exaggeration()), h(l, l, [
                (o.anchor ? o.anchor[0] : 0) * (u[0] - 1),
                (o.anchor ? o.anchor[1] : 0) * (u[1] - 1),
                d
            ]), p(l, l, u);
            const f = r.queryGeometry, m = f.isPointQuery() ? f.screenBounds : f.screenGeometry, y = function(t1) {
                const e = c([], l, t1.matrix);
                c(e, n.expandedFarZProjMatrix, e);
                for(let r = 0; r < t1.meshes.length; ++r){
                    const i = t1.meshes[r];
                    if (r === t1.lightMeshIndex) continue;
                    const o = Tf(m, n, e, i.aabb);
                    null != o && (s = Math.min(o, s));
                }
                if (t1.children) for (const e of t1.children)y(e);
            };
            if (y(o), s === Number.MAX_VALUE) return;
            const g = new Xl(0, 0);
            return ov(a.tileID.canonical, g, i.node.anchor[0], i.node.anchor[1]), {
                intersectionZ: s,
                position: g,
                feature: i.feature
            };
        }
        qs(rv, "Tiled3dModelBucket", {
            omit: [
                "layers"
            ]
        }), qs(ev, "Tiled3dModelFeature");
        const lv = {
            circle: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: dc || (dc = new zo({
                            "circle-sort-key": new Eo(To.layout_circle["circle-sort-key"]),
                            "circle-elevation-reference": new Po(To.layout_circle["circle-elevation-reference"]),
                            visibility: new Po(To.layout_circle.visibility)
                        })),
                        paint: fc || (fc = new zo({
                            "circle-radius": new Eo(To.paint_circle["circle-radius"]),
                            "circle-color": new Eo(To.paint_circle["circle-color"]),
                            "circle-blur": new Eo(To.paint_circle["circle-blur"]),
                            "circle-opacity": new Eo(To.paint_circle["circle-opacity"]),
                            "circle-translate": new Po(To.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new Po(To.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new Po(To.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new Po(To.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new Eo(To.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new Eo(To.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new Eo(To.paint_circle["circle-stroke-opacity"]),
                            "circle-emissive-strength": new Po(To.paint_circle["circle-emissive-strength"]),
                            "circle-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "circle-stroke-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                createBucket(t1) {
                    return new qu(t1);
                }
                queryRadius(t1) {
                    const e = t1;
                    return uc("circle-radius", this, e) + uc("circle-stroke-width", this, e) + cc(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s, o, a) {
                    const l = pc(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return Jc(t1, n, s, o, a, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = Kc(this);
                    return {
                        config: new El(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                is3D(t1) {
                    return !t1 && !!this.layout && "none" !== this.layout.get("circle-elevation-reference");
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("circle-elevation-reference");
                }
            },
            heatmap: class extends Ko {
                createBucket(t1) {
                    return new nh(t1);
                }
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: ih || (ih = new zo({
                            visibility: new Po(To.layout_heatmap.visibility)
                        })),
                        paint: sh || (sh = new zo({
                            "heatmap-radius": new Eo(To.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new Eo(To.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new Po(To.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new ko(To.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new Po(To.paint_heatmap["heatmap-opacity"]),
                            "heatmap-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = fh({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                _clear() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                queryRadius(t1) {
                    return uc("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e, r, n, i, s, o, a) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, r);
                    return Jc(t1, n, s, o, a, !0, !0, new bt(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return "heatmap" === t1 ? {
                        config: new El(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    } : {};
                }
            },
            hillshade: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: oh || (oh = new zo({
                            visibility: new Po(To.layout_hillshade.visibility)
                        })),
                        paint: ah || (ah = new zo({
                            "hillshade-illumination-direction": new Po(To.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-anchor": new Po(To.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new Po(To.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new Po(To.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new Po(To.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new Po(To.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-emissive-strength": new Po(To.paint_hillshade["hillshade-emissive-strength"]),
                            "hillshade-shadow-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-highlight-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-accent-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                shouldRedrape() {
                    return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
            },
            fill: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: cp || (cp = new zo({
                            "fill-sort-key": new Eo(To.layout_fill["fill-sort-key"]),
                            visibility: new Po(To.layout_fill.visibility),
                            "fill-elevation-reference": new Po(To.layout_fill["fill-elevation-reference"]),
                            "fill-construct-bridge-guard-rail": new Eo(To.layout_fill["fill-construct-bridge-guard-rail"])
                        })),
                        paint: hp || (hp = new zo({
                            "fill-antialias": new Po(To.paint_fill["fill-antialias"]),
                            "fill-opacity": new Eo(To.paint_fill["fill-opacity"]),
                            "fill-color": new Eo(To.paint_fill["fill-color"]),
                            "fill-outline-color": new Eo(To.paint_fill["fill-outline-color"]),
                            "fill-translate": new Po(To.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new Po(To.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new Eo(To.paint_fill["fill-pattern"]),
                            "fill-pattern-cross-fade": new Po(To.paint_fill["fill-pattern-cross-fade"]),
                            "fill-emissive-strength": new Po(To.paint_fill["fill-emissive-strength"]),
                            "fill-z-offset": new Eo(To.paint_fill["fill-z-offset"]),
                            "fill-bridge-guard-rail-color": new Eo(To.paint_fill["fill-bridge-guard-rail-color"]),
                            "fill-tunnel-structure-color": new Eo(To.paint_fill["fill-tunnel-structure-color"]),
                            "fill-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-outline-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-bridge-guard-rail-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-tunnel-structure-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e = t1 && t1.constantOr(1), r = [
                        e ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        config: new El(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    };
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new up(t1);
                }
                queryRadius() {
                    return cc(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    return !t1.queryGeometry.isAboveHorizon && Wu(hc(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return 0 === this.paint.get("fill-z-offset").constantOr(1);
                }
                is3D(t1) {
                    if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return !0;
                    const e = this.layout && "none" !== this.layout.get("fill-elevation-reference");
                    return null != t1 ? e && !t1 : e;
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("fill-elevation-reference");
                }
                hasShadowPass() {
                    return this.layout && "none" !== this.layout.get("fill-elevation-reference");
                }
            },
            "fill-extrusion": class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: fd || (fd = new zo({
                            visibility: new Po(To["layout_fill-extrusion"].visibility),
                            "fill-extrusion-edge-radius": new Po(To["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                        })),
                        paint: md || (md = new zo({
                            "fill-extrusion-opacity": new Po(To["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new Eo(To["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new Po(To["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new Po(To["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new Eo(To["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-pattern-cross-fade": new Po(To["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]),
                            "fill-extrusion-height": new Eo(To["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new Eo(To["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-height-alignment": new Po(To["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
                            "fill-extrusion-base-alignment": new Po(To["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
                            "fill-extrusion-vertical-gradient": new Po(To["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                            "fill-extrusion-ambient-occlusion-intensity": new Po(To["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                            "fill-extrusion-ambient-occlusion-radius": new Po(To["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                            "fill-extrusion-ambient-occlusion-wall-radius": new Po(To["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-radius": new Po(To["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-attenuation": new Po(To["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                            "fill-extrusion-flood-light-color": new Po(To["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                            "fill-extrusion-flood-light-intensity": new Po(To["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                            "fill-extrusion-flood-light-wall-radius": new Eo(To["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                            "fill-extrusion-flood-light-ground-radius": new Eo(To["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                            "fill-extrusion-flood-light-ground-attenuation": new Po(To["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                            "fill-extrusion-vertical-scale": new Po(To["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                            "fill-extrusion-rounded-roof": new Po(To["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                            "fill-extrusion-cutoff-fade-range": new Po(To["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                            "fill-extrusion-emissive-strength": new Eo(To["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
                            "fill-extrusion-line-width": new Eo(To["paint_fill-extrusion"]["fill-extrusion-line-width"]),
                            "fill-extrusion-cast-shadows": new Po(To["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
                            "fill-extrusion-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-extrusion-flood-light-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new nd(t1);
                }
                queryRadius() {
                    return cc(this.paint.get("fill-extrusion-translate"));
                }
                is3D(t1) {
                    return !0;
                }
                hasShadowPass() {
                    return this.paint.get("fill-extrusion-cast-shadows");
                }
                cutoffRange() {
                    return this.paint.get("fill-extrusion-cutoff-fade-range");
                }
                canCastShadows() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                queryIntersectsFeature(t1, e, r, n, i, s, o, a, l) {
                    const u = pc(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), c = this.paint.get("fill-extrusion-height").evaluate(e, r), h = this.paint.get("fill-extrusion-base").evaluate(e, r), p = [
                        0,
                        0
                    ], d = a && s.elevation, f = s.elevation ? s.elevation.exaggeration() : 1, m = t1.tile.getBucket(this);
                    if (d && m instanceof nd) {
                        const t1 = m.centroidVertexArray, e = l + 1;
                        e < t1.length && (p[0] = t1.geta_centroid_pos0(e), p[1] = t1.geta_centroid_pos1(e));
                    }
                    if (0 === p[0] && 1 === p[1]) return !1;
                    "globe" === s.projection.name && (n = pd([
                        n
                    ], [
                        new bt(0, 0),
                        new bt(Cn, Cn)
                    ], t1.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const y = d ? a : null, [g, x] = function(t1, e, r, n, i, s, o, a, l, u, c) {
                        return "globe" === t1.projection.name ? function(t1, e, r, n, i, s, o, a, l, u, c) {
                            const h = [], p = [], d = t1.projection.upVectorScale(c, t1.center.lat, t1.worldSize).metersToTile, f = [
                                0,
                                0,
                                0,
                                1
                            ], m = [
                                0,
                                0,
                                0,
                                1
                            ], y = (t1, e, r, n)=>{
                                t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = 1;
                            }, g = hd();
                            r > 0 && (r += g), n += g;
                            for (const g of e){
                                const e = [], x = [];
                                for (const h of g){
                                    const p = h.x + i.x, g = h.y + i.y, v = t1.projection.projectTilePoint(p, g, c), b = t1.projection.upVector(c, h.x, h.y);
                                    let w = r, _ = n;
                                    if (o) {
                                        const t1 = Id(p, g, r, n, o, a, l, u);
                                        w += t1.base, _ += t1.top;
                                    }
                                    0 !== r ? y(f, v.x + b[0] * d * w, v.y + b[1] * d * w, v.z + b[2] * d * w) : y(f, v.x, v.y, v.z), y(m, v.x + b[0] * d * _, v.y + b[1] * d * _, v.z + b[2] * d * _), O(f, f, s), O(m, m, s), e.push(new yd(f[0], f[1], f[2])), x.push(new yd(m[0], m[1], m[2]));
                                }
                                h.push(e), p.push(x);
                            }
                            return [
                                h,
                                p
                            ];
                        }(t1, e, r, n, i, s, o, a, l, u, c) : o ? function(t1, e, r, n, i, s, o, a, l) {
                            const u = [], c = [], h = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const p of t1){
                                const t1 = [], d = [];
                                for (const u of p){
                                    const c = u.x + n.x, p = u.y + n.y, f = Id(c, p, e, r, s, o, a, l);
                                    h[0] = c, h[1] = p, h[2] = f.base, h[3] = 1, Y(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const m = new yd(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    h[0] = c, h[1] = p, h[2] = f.top, h[3] = 1, Y(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const y = new yd(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    t1.push(m), d.push(y);
                                }
                                u.push(t1), c.push(d);
                            }
                            return [
                                u,
                                c
                            ];
                        }(e, r, n, i, s, o, a, l, u) : function(t1, e, r, n, i) {
                            const s = [], o = [], a = i[8] * e, l = i[9] * e, u = i[10] * e, c = i[11] * e, h = i[8] * r, p = i[9] * r, d = i[10] * r, f = i[11] * r;
                            for (const e of t1){
                                const t1 = [], r = [];
                                for (const s of e){
                                    const e = s.x + n.x, o = s.y + n.y, m = i[0] * e + i[4] * o + i[12], y = i[1] * e + i[5] * o + i[13], g = i[2] * e + i[6] * o + i[14], x = i[3] * e + i[7] * o + i[15], v = m + a, b = y + l, w = g + u, _ = Math.max(x + c, 1e-5), A = m + h, M = y + p, I = g + d, S = Math.max(x + f, 1e-5);
                                    t1.push(new yd(v / _, b / _, w / _)), r.push(new yd(A / S, M / S, I / S));
                                }
                                s.push(t1), o.push(r);
                            }
                            return [
                                s,
                                o
                            ];
                        }(e, r, n, i, s);
                    }(s, n, h, c, u, o, y, p, f, s.center.lat, t1.tileID.canonical), v = t1.queryGeometry;
                    return function(t1, e, r) {
                        let n = 1 / 0;
                        Wu(r, e) && (n = Md(r, e[0]));
                        for(let i = 0; i < e.length; i++){
                            const s = e[i], o = t1[i];
                            for(let t1 = 0; t1 < s.length - 1; t1++){
                                const e = s[t1], i = [
                                    e,
                                    s[t1 + 1],
                                    o[t1 + 1],
                                    o[t1],
                                    e
                                ];
                                Xu(r, i) && (n = Math.min(n, Md(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(g, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry);
                }
            },
            building: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: om || (om = new zo({
                            visibility: new Po(To.layout_building.visibility),
                            "building-facade": new Eo(To.layout_building["building-facade"]),
                            "building-facade-floors": new Eo(To.layout_building["building-facade-floors"]),
                            "building-facade-window": new Eo(To.layout_building["building-facade-window"]),
                            "building-roof-shape": new Eo(To.layout_building["building-roof-shape"]),
                            "building-height": new Eo(To.layout_building["building-height"]),
                            "building-base": new Eo(To.layout_building["building-base"])
                        })),
                        paint: am || (am = new zo({
                            "building-opacity": new Po(To.paint_building["building-opacity"]),
                            "building-ambient-occlusion-intensity": new Po(To.paint_building["building-ambient-occlusion-intensity"]),
                            "building-ambient-occlusion-ground-intensity": new Po(To.paint_building["building-ambient-occlusion-ground-intensity"]),
                            "building-ambient-occlusion-ground-radius": new Po(To.paint_building["building-ambient-occlusion-ground-radius"]),
                            "building-ambient-occlusion-ground-attenuation": new Po(To.paint_building["building-ambient-occlusion-ground-attenuation"]),
                            "building-vertical-scale": new Po(To.paint_building["building-vertical-scale"]),
                            "building-cast-shadows": new Po(To.paint_building["building-cast-shadows"]),
                            "building-color": new Eo(To.paint_building["building-color"]),
                            "building-emissive-strength": new Eo(To.paint_building["building-emissive-strength"]),
                            "building-facade-emissive-chance": new Po(To.paint_building["building-facade-emissive-chance"]),
                            "building-cutoff-fade-range": new Po(To.paint_building["building-cutoff-fade-range"]),
                            "building-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new im(t1);
                }
                hasShadowPass() {
                    return this.paint.get("building-cast-shadows");
                }
                hasLightBeamPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                is3D(t1) {
                    return !0;
                }
            },
            line: class extends Ko {
                constructor(t1, e, r, n){
                    const i = zm();
                    super(t1, i, e, r, n), i.layout && (this.layout = new So(i.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof Ai, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e), this.paint._values["line-floorwidth"] = (()=>{
                        if (Bm) return Bm;
                        const t1 = zm();
                        return Bm = new Tm(t1.paint.properties["line-width"].specification), Bm.useIntegerZoom = !0, Bm;
                    })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new vm(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = Pm(this);
                    return {
                        config: new El(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                queryRadius(t1) {
                    const e = t1, r = Vm(uc("line-width", this, e), uc("line-gap-width", this, e)), n = uc("line-offset", this, e);
                    return r / 2 + Math.abs(n) + cc(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const o = hc(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), a = t1.pixelToTileUnitsFactor / 2 * Vm(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), l = this.paint.get("line-offset").evaluate(e, r);
                    return l && (n = function(t1, e) {
                        const r = [], n = new bt(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const s = t1[i], o = [];
                            for(let t1 = 0; t1 < s.length; t1++){
                                const r = s[t1], i = s[t1 + 1], a = 0 === t1 ? n : r.sub(s[t1 - 1])._unit()._perp(), l = t1 === s.length - 1 ? n : i.sub(r)._unit()._perp(), u = a._add(l)._unit();
                                u._mult(1 / (u.x * l.x + u.y * l.y)), o.push(u._mult(e)._add(r));
                            }
                            r.push(o);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e, r) {
                        for(let n = 0; n < e.length; n++){
                            const i = e[n];
                            if (t1.length >= 3) {
                                for(let e = 0; e < i.length; e++)if (ic(t1, i[e])) return !0;
                            }
                            if (Yu(t1, i, r)) return !0;
                        }
                        return !1;
                    }(o, n, a);
                }
                isTileClipped() {
                    return this.hasNonElevatedBuckets;
                }
                isDraped(t1) {
                    return !this.hasElevatedBuckets || this.layout && "hd-road-markup" === this.layout.get("line-elevation-reference");
                }
                hasElevation() {
                    return this.layout && "none" !== this.layout.get("line-elevation-reference");
                }
            },
            symbol: wx,
            background: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: _x || (_x = new zo({
                            visibility: new Po(To.layout_background.visibility)
                        })),
                        paint: Ax || (Ax = new zo({
                            "background-pitch-alignment": new Po(To.paint_background["background-pitch-alignment"]),
                            "background-color": new Po(To.paint_background["background-color"]),
                            "background-pattern": new Po(To.paint_background["background-pattern"]),
                            "background-opacity": new Po(To.paint_background["background-opacity"]),
                            "background-emissive-strength": new Po(To.paint_background["background-emissive-strength"]),
                            "background-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
                is3D(t1) {
                    return "viewport" === this.paint.get("background-pitch-alignment");
                }
            },
            raster: Bx,
            "raster-particle": Rx,
            sky: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Fx || (Fx = new zo({
                            visibility: new Po(To.layout_sky.visibility)
                        })),
                        paint: Dx || (Dx = new zo({
                            "sky-type": new Po(To.paint_sky["sky-type"]),
                            "sky-atmosphere-sun": new Po(To.paint_sky["sky-atmosphere-sun"]),
                            "sky-atmosphere-sun-intensity": new Po(To.paint_sky["sky-atmosphere-sun-intensity"]),
                            "sky-gradient-center": new Po(To.paint_sky["sky-gradient-center"]),
                            "sky-gradient-radius": new Po(To.paint_sky["sky-gradient-radius"]),
                            "sky-gradient": new ko(To.paint_sky["sky-gradient"]),
                            "sky-atmosphere-halo-color": new Po(To.paint_sky["sky-atmosphere-halo-color"]),
                            "sky-atmosphere-color": new Po(To.paint_sky["sky-atmosphere-color"]),
                            "sky-opacity": new Po(To.paint_sky["sky-opacity"]),
                            "sky-gradient-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-halo-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _clear() {
                    this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = !0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = fh({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    }
                    return !1;
                }
                getCenter(t1, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && Gt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? Ux(s.azimuthal, 90 - s.polar, e) : Ux(r[0], 90 - r[1], e);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return Ux(r[0], 90 - r[1], e);
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            },
            slot: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        paint: Lx || (Lx = new zo({}))
                    }, e, null);
                }
            },
            model: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Xx || (Xx = new zo({
                            visibility: new Po(To.layout_model.visibility),
                            "model-id": new Eo(To.layout_model["model-id"])
                        })),
                        paint: Zx || (Zx = new zo({
                            "model-opacity": new Eo(To.paint_model["model-opacity"]),
                            "model-rotation": new Eo(To.paint_model["model-rotation"]),
                            "model-scale": new Eo(To.paint_model["model-scale"]),
                            "model-translation": new Eo(To.paint_model["model-translation"]),
                            "model-color": new Eo(To.paint_model["model-color"]),
                            "model-color-mix-intensity": new Eo(To.paint_model["model-color-mix-intensity"]),
                            "model-type": new Po(To.paint_model["model-type"]),
                            "model-cast-shadows": new Po(To.paint_model["model-cast-shadows"]),
                            "model-receive-shadows": new Po(To.paint_model["model-receive-shadows"]),
                            "model-ambient-occlusion-intensity": new Po(To.paint_model["model-ambient-occlusion-intensity"]),
                            "model-emissive-strength": new Eo(To.paint_model["model-emissive-strength"]),
                            "model-roughness": new Eo(To.paint_model["model-roughness"]),
                            "model-height-based-emissive-strength-multiplier": new Eo(To.paint_model["model-height-based-emissive-strength-multiplier"]),
                            "model-cutoff-fade-range": new Po(To.paint_model["model-cutoff-fade-range"]),
                            "model-front-cutoff": new Po(To.paint_model["model-front-cutoff"]),
                            "model-color-use-theme": new Eo({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new qx(t1);
                }
                getProgramIds() {
                    return [
                        "model"
                    ];
                }
                is3D(t1) {
                    return !0;
                }
                hasShadowPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                hasLightBeamPass() {
                    return !0;
                }
                cutoffRange() {
                    return this.paint.get("model-cutoff-fade-range");
                }
                queryRadius(t1) {
                    return t1 instanceof rv ? Cn - 1 : 0;
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    if (!this.modelManager) return !1;
                    const o = this.modelManager, l = t1.tile.getBucket(this);
                    if (!(l && l instanceof qx)) return !1;
                    for(const r in l.instancesPerModel){
                        const n = l.instancesPerModel[r], i = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                        if (n.idToFeaturesIndex.hasOwnProperty(i)) {
                            const e = n.features[n.idToFeaturesIndex[i]], u = o.getModel(r, this.scope);
                            if (!u) return !1;
                            let h = a();
                            const p = new Xl(0, 0), d = l.canonical;
                            let f = Number.MAX_VALUE;
                            for(let r = 0; r < e.instancedDataCount; ++r){
                                const i = 16 * (e.instancedDataOffset + r), o = n.instancedDataArray.float32, a = [
                                    o[i + 4],
                                    o[i + 5],
                                    o[i + 6]
                                ];
                                ov(d, p, o[i], 0 | o[i + 1]), Cf(h, u, s, p, e.rotation, e.scale, a, !1, !1, !1), "globe" === s.projection.name && (h = zf(h, s));
                                const l = c([], s.projMatrix, h), m = t1.queryGeometry, y = Tf(m.isPointQuery() ? m.screenBounds : m.screenGeometry, s, l, u.aabb);
                                null != y && (f = Math.min(y, f));
                            }
                            return f !== Number.MAX_VALUE && f;
                        }
                    }
                    return !1;
                }
                _handleOverridablePaintPropertyUpdate(t1, e, r) {
                    return !(!this.layout || e.isDataDriven() || r.isDataDriven() || "model-color" !== t1 && "model-color-mix-intensity" !== t1 && "model-rotation" !== t1 && "model-scale" !== t1 && "model-translation" !== t1 && "model-emissive-strength" !== t1);
                }
                _isPropertyZoomDependent(t1) {
                    const e = this._transitionablePaint._values[t1];
                    return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof Ls;
                }
                isZoomDependent() {
                    return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
                }
            },
            clip: class extends Ko {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: pp || (pp = new zo({
                            "clip-layer-types": new Po(To.layout_clip["clip-layer-types"]),
                            "clip-layer-scope": new Po(To.layout_clip["clip-layer-scope"])
                        })),
                        paint: dp || (dp = new zo({}))
                    }, e, r, n);
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                }
                createBucket(t1) {
                    return new yp(t1);
                }
                is3D(t1) {
                    return !0;
                }
            }
        }, uv = new sr(0, 0, 0), cv = {
            PATH_RULE_NON_ZERO: 1,
            PATH_RULE_EVEN_ODD: 2
        }, hv = {
            LINE_CAP_BUTT: 1,
            LINE_CAP_ROUND: 2,
            LINE_CAP_SQUARE: 3
        }, pv = {
            LINE_JOIN_MITER: 1,
            LINE_JOIN_MITER_CLIP: 2,
            LINE_JOIN_ROUND: 3,
            LINE_JOIN_BEVEL: 4
        }, dv = {
            PAINT_ORDER_FILL_AND_STROKE: 1
        }, fv = {
            PATH_COMMAND_MOVE: 1,
            PATH_COMMAND_LINE: 2,
            PATH_COMMAND_QUAD: 3,
            PATH_COMMAND_CUBIC: 4,
            PATH_COMMAND_CLOSE: 5
        }, mv = {
            MASK_TYPE_LUMINANCE: 1
        };
        function yv(t1, e, r) {
            1 === t1 && e.icons.push(function(t1, e) {
                return function(t1) {
                    if (t1.usvg_tree.height || (t1.usvg_tree.height = t1.usvg_tree.width), !t1.metadata) return t1;
                    const { metadata: e } = t1;
                    if (e.content_area) {
                        const { content_area: r } = e;
                        null == r.top && (r.top = r.left), null == r.width && (r.width = t1.usvg_tree.width), null == r.height && (r.height = r.width);
                    }
                    return e.stretch_x && e.stretch_x.length && gv(e, "x"), e.stretch_y && e.stretch_y.length && gv(e, "y"), t1;
                }(t1.readFields(xv, {
                    name: void 0
                }, e));
            }(r, r.readVarint() + r.pos));
        }
        function gv(t1, e) {
            const r = [], n = t1[`stretch_${e}`];
            let i = null;
            for(let t1 = 0; t1 < n.length; t1++)null === i ? i = 0 === r.length ? n[0] : r[r.length - 1][1] + n[t1] : (r.push([
                i,
                i + n[t1]
            ]), i = null);
            t1[`stretch_${e}_areas`] = r;
        }
        function xv(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 ? e.metadata = function(t1, e) {
                return t1.readFields(vv, {
                    stretch_x: null,
                    stretch_y: null,
                    stretch_x_areas: null,
                    stretch_y_areas: null,
                    variables: []
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 && (e.usvg_tree = function(t1, e) {
                return t1.readFields(_v, {
                    width: 20,
                    children: [],
                    linear_gradients: [],
                    radial_gradients: [],
                    clip_paths: [],
                    masks: []
                }, e);
            }(r, r.readVarint() + r.pos), e.data = "usvg_tree");
        }
        function vv(t1, e, r) {
            1 === t1 ? e.stretch_x = r.readPackedVarint() : 2 === t1 ? e.stretch_y = r.readPackedVarint() : 3 === t1 ? e.content_area = function(t1, e) {
                return t1.readFields(bv, {
                    left: 0
                }, e);
            }(r, r.readVarint() + r.pos) : 4 === t1 && e.variables.push(function(t1, e) {
                return t1.readFields(wv, {
                    name: void 0
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function bv(t1, e, r) {
            1 === t1 ? e.left = r.readVarint() : 2 === t1 ? e.width = r.readVarint() : 3 === t1 ? e.top = r.readVarint() : 4 === t1 && (e.height = r.readVarint());
        }
        function wv(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 && (e.rgb_color = zv(r.readVarint()), e.value = "rgb_color");
        }
        function _v(t1, e, r) {
            1 === t1 ? e.width = e.height = r.readVarint() : 2 === t1 ? e.height = r.readVarint() : 3 === t1 ? e.children.push(Av(r, r.readVarint() + r.pos)) : 4 === t1 ? e.linear_gradients.push(function(t1, e) {
                return t1.readFields(Bv, {
                    spread_method: 1,
                    stops: [],
                    x1: 0,
                    y1: 0,
                    x2: 1,
                    y2: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 5 === t1 ? e.radial_gradients.push(function(t1, e) {
                return t1.readFields(Fv, {
                    spread_method: 1,
                    stops: [],
                    cx: .5,
                    cy: .5,
                    r: .5,
                    fx: .5,
                    fy: .5,
                    fr: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 7 === t1 ? e.clip_paths.push(function(t1, e) {
                return t1.readFields(Dv, {
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos)) : 8 === t1 && e.masks.push(function(t1, e) {
                const r = t1.readFields(Lv, {
                    left: 0,
                    width: 20,
                    mask_type: mv.MASK_TYPE_LUMINANCE,
                    children: []
                }, e);
                return null == r.height && (r.height = r.width), null == r.top && (r.top = r.left), r;
            }(r, r.readVarint() + r.pos));
        }
        function Av(t1, e) {
            return t1.readFields(Mv, {}, e);
        }
        function Mv(t1, e, r) {
            1 === t1 ? (e.group = function(t1, e) {
                return t1.readFields(Iv, {
                    opacity: 255,
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "group") : 2 === t1 && (e.path = function(t1, e) {
                return t1.readFields(Ev, {
                    paint_order: 1,
                    commands: [],
                    step: 1,
                    diffs: [],
                    rule: cv.PATH_RULE_NON_ZERO
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "path");
        }
        function Iv(t1, e, r) {
            1 === t1 ? e.transform = Sv(r, r.readVarint() + r.pos) : 2 === t1 ? e.opacity = r.readVarint() : 5 === t1 ? e.clip_path_idx = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(Av(r, r.readVarint() + r.pos));
        }
        function Sv(t1, e) {
            return t1.readFields(Pv, {
                sx: 1,
                ky: 0,
                kx: 0,
                sy: 1,
                tx: 0,
                ty: 0
            }, e);
        }
        function Pv(t1, e, r) {
            1 === t1 ? e.sx = r.readFloat() : 2 === t1 ? e.ky = r.readFloat() : 3 === t1 ? e.kx = r.readFloat() : 4 === t1 ? e.sy = r.readFloat() : 5 === t1 ? e.tx = r.readFloat() : 6 === t1 && (e.ty = r.readFloat());
        }
        function Ev(t1, e, r) {
            1 === t1 ? e.fill = function(t1, e) {
                return t1.readFields(kv, {
                    rgb_color: uv,
                    paint: "rgb_color",
                    opacity: 255
                }, e);
            }(r, r.readVarint() + r.pos) : 2 === t1 ? e.stroke = function(t1, e) {
                return t1.readFields(Tv, {
                    rgb_color: uv,
                    paint: "rgb_color",
                    dasharray: [],
                    dashoffset: 0,
                    miterlimit: 4,
                    opacity: 255,
                    width: 1,
                    linecap: 1,
                    linejoin: 1
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 ? e.paint_order = r.readVarint() : 5 === t1 ? r.readPackedVarint(e.commands) : 6 === t1 ? e.step = r.readFloat() : 7 === t1 ? r.readPackedSVarint(e.diffs) : 8 === t1 && (e.rule = r.readVarint());
        }
        function kv(t1, e, r) {
            1 === t1 ? (e.rgb_color = zv(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 && (e.opacity = r.readVarint());
        }
        function zv(t1) {
            return new sr((t1 >> 16 & 255) / 255, (t1 >> 8 & 255) / 255, (255 & t1) / 255, 1);
        }
        function Tv(t1, e, r) {
            1 === t1 ? (e.rgb_color = zv(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 ? r.readPackedFloat(e.dasharray) : 6 === t1 ? e.dashoffset = r.readFloat() : 7 === t1 ? e.miterlimit = r.readFloat() : 8 === t1 ? e.opacity = r.readVarint() : 9 === t1 ? e.width = r.readFloat() : 10 === t1 ? e.linecap = r.readVarint() : 11 === t1 && (e.linejoin = r.readVarint());
        }
        function Bv(t1, e, r) {
            1 === t1 ? e.transform = Sv(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(Vv(r, r.readVarint() + r.pos)) : 4 === t1 ? e.x1 = r.readFloat() : 5 === t1 ? e.y1 = r.readFloat() : 6 === t1 ? e.x2 = r.readFloat() : 7 === t1 && (e.y2 = r.readFloat());
        }
        function Vv(t1, e) {
            return t1.readFields(Cv, {
                offset: 0,
                opacity: 255,
                rgb_color: uv
            }, e);
        }
        function Cv(t1, e, r) {
            1 === t1 ? e.offset = r.readFloat() : 2 === t1 ? e.opacity = r.readVarint() : 3 === t1 && (e.rgb_color = zv(r.readVarint()));
        }
        function Fv(t1, e, r) {
            1 === t1 ? e.transform = Sv(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(Vv(r, r.readVarint() + r.pos)) : 4 === t1 ? e.cx = r.readFloat() : 5 === t1 ? e.cy = r.readFloat() : 6 === t1 ? e.r = r.readFloat() : 7 === t1 ? e.fx = r.readFloat() : 8 === t1 ? e.fy = r.readFloat() : 9 === t1 && (e.fr = r.readFloat());
        }
        function Dv(t1, e, r) {
            1 === t1 ? e.transform = Sv(r, r.readVarint() + r.pos) : 2 === t1 ? e.clip_path_idx = r.readVarint() : 3 === t1 && e.children.push(Av(r, r.readVarint() + r.pos));
        }
        function Lv(t1, e, r) {
            1 === t1 ? e.left = e.top = r.readFloat() : 2 === t1 ? e.width = e.height = r.readFloat() : 3 === t1 ? e.top = r.readFloat() : 4 === t1 ? e.height = r.readFloat() : 5 === t1 ? e.mask_type = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(Av(r, r.readVarint() + r.pos));
        }
        class Rv {
            static calculate(t1 = {}, e = []) {
                const r = new Map, n = new Map;
                if (0 === Object.keys(t1).length) return r;
                e.forEach((t1)=>{
                    n.set(t1.name, t1.rgb_color || new sr(0, 0, 0));
                });
                for (const [e, i] of Object.entries(t1))n.has(e) ? r.set(n.get(e).toString(), i) : console.warn(`Ignoring unknown image variable "${e}"`);
                return r;
            }
        }
        function Ov(t1, e = 255, r) {
            const n = e / 255, i = t1.toString(), s = r.has(i) ? r.get(i).clone() : t1.clone();
            return s.a *= n, s.toString();
        }
        function Uv(t1, e) {
            if (!pe()) {
                const r = document.createElement("canvas");
                return r.width = t1, r.height = e, r;
            }
            return new OffscreenCanvas(t1, e);
        }
        function Nv(t1, e) {
            const r = Rv.calculate(e.params, t1.metadata ? t1.metadata.variables : []), n = t1.usvg_tree, i = n.width, s = n.height, o = e.transform ? e.transform : new DOMMatrix, a = Math.max(1, Math.round(i * o.a)), l = Math.max(1, Math.round(s * o.d)), u = new DOMMatrix([
                a / i,
                0,
                0,
                l / s,
                0,
                0
            ]), c = Uv(a, l).getContext("2d");
            return jv(c, u, n, n, r), c.getImageData(0, 0, a, l);
        }
        function jv(t1, e, r, n, i) {
            for (const s of n.children)$v(t1, e, r, s, i);
        }
        function $v(t1, e, r, n, i) {
            n.group ? (t1.save(), function(t1, e, r, n, i) {
                const s = null != n.mask_idx ? r.masks[n.mask_idx] : null, o = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
                if (n.transform && (e = Jv(n.transform).preMultiplySelf(e)), !function(t1, e, r) {
                    return 255 !== t1.opacity || e || r;
                }(n, null != o, null != s)) return void jv(t1, e, r, n, i);
                const a = Uv(t1.canvas.width, t1.canvas.height), l = a.getContext("2d");
                jv(l, e, r, n, i), o && Yv(l, e, r, o), s && Kv(l, e, r, s, i), t1.globalAlpha = n.opacity / 255, t1.drawImage(a, 0, 0);
            }(t1, e, r, n.group, i), t1.restore()) : n.path && (t1.save(), function(t1, e, r, n, i) {
                t1.setTransform(e), n.paint_order === dv.PAINT_ORDER_FILL_AND_STROKE ? (Gv(t1, r, n, i), qv(t1, r, n, i)) : (qv(t1, r, n, i), Gv(t1, r, n, i));
            }(t1, e, r, n.path, i), t1.restore());
        }
        function Gv(t1, e, r, n) {
            const i = r.fill;
            if (!i) return;
            const s = i.opacity / 255;
            switch(t1.save(), t1.beginPath(), Qv(r, t1), i.paint){
                case "rgb_color":
                    t1.fillStyle = Ov(i.rgb_color, i.opacity, n);
                    break;
                case "linear_gradient_idx":
                    {
                        const r = e.linear_gradients[i.linear_gradient_idx];
                        r.transform && t1.setTransform(Jv(r.transform).preMultiplySelf(t1.getTransform())), t1.fillStyle = Xv(t1, r, s, n);
                        break;
                    }
                case "radial_gradient_idx":
                    {
                        const r = e.radial_gradients[i.radial_gradient_idx];
                        r.transform && t1.setTransform(Jv(r.transform).preMultiplySelf(t1.getTransform())), t1.fillStyle = Zv(t1, r, s, n);
                    }
            }
            t1.fill(Hv(r)), t1.restore();
        }
        function Hv(t1) {
            return t1.rule === cv.PATH_RULE_NON_ZERO ? "nonzero" : t1.rule === cv.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
        }
        function qv(t1, e, r, n) {
            const i = r.stroke;
            if (!i) return;
            const s = tb(r);
            t1.lineWidth = i.width, t1.miterLimit = i.miterlimit, t1.setLineDash(i.dasharray), t1.lineDashOffset = i.dashoffset;
            const o = i.opacity / 255;
            switch(i.paint){
                case "rgb_color":
                    t1.strokeStyle = Ov(i.rgb_color, i.opacity, n);
                    break;
                case "linear_gradient_idx":
                    t1.strokeStyle = Xv(t1, e.linear_gradients[i.linear_gradient_idx], o, n, !0);
                    break;
                case "radial_gradient_idx":
                    t1.strokeStyle = Zv(t1, e.radial_gradients[i.radial_gradient_idx], o, n, !0);
            }
            switch(i.linejoin){
                case pv.LINE_JOIN_MITER_CLIP:
                case pv.LINE_JOIN_MITER:
                    t1.lineJoin = "miter";
                    break;
                case pv.LINE_JOIN_ROUND:
                    t1.lineJoin = "round";
                    break;
                case pv.LINE_JOIN_BEVEL:
                    t1.lineJoin = "bevel";
            }
            switch(i.linecap){
                case hv.LINE_CAP_BUTT:
                    t1.lineCap = "butt";
                    break;
                case hv.LINE_CAP_ROUND:
                    t1.lineCap = "round";
                    break;
                case hv.LINE_CAP_SQUARE:
                    t1.lineCap = "square";
            }
            t1.stroke(s);
        }
        function Xv(t1, e, r, n, i = !1) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return Ov(t1.rgb_color, t1.opacity * r, n);
            }
            const { x1: s, y1: o, x2: a, y2: l } = e;
            let u = new DOMPoint(s, o), c = new DOMPoint(a, l);
            if (i) {
                const t1 = Jv(e.transform);
                u = t1.transformPoint(u), c = t1.transformPoint(c);
            }
            const h = t1.createLinearGradient(u.x, u.y, c.x, c.y);
            for (const t1 of e.stops)h.addColorStop(t1.offset, Ov(t1.rgb_color, t1.opacity * r, n));
            return h;
        }
        function Zv(t1, e, r, n, i = !1) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return Ov(t1.rgb_color, t1.opacity * r, n);
            }
            const s = Jv(e.transform), { fx: o, fy: a, fr: l, cx: u, cy: c, r: h } = e;
            let p = new DOMPoint(o, a), d = new DOMPoint(u, c), f = l, m = h;
            if (i) {
                p = s.transformPoint(p), d = s.transformPoint(d);
                const t1 = (s.a + s.d) / 2;
                f = l * t1, m = e.r * t1;
            }
            const y = t1.createRadialGradient(p.x, p.y, f, d.x, d.y, m);
            for (const t1 of e.stops)y.addColorStop(t1.offset, Ov(t1.rgb_color, t1.opacity * r, n));
            return y;
        }
        function Wv(t1, e, r, n) {
            const i = n.transform ? Jv(n.transform).preMultiplySelf(e) : e, s = Uv(t1.canvas.width, t1.canvas.height), o = s.getContext("2d");
            for (const t1 of n.children)if (t1.group) Wv(o, i, r, t1.group);
            else if (t1.path) {
                const e = t1.path, r = new Path2D;
                r.addPath(tb(e), i), o.fill(r, Hv(e));
            }
            const a = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
            a && Yv(o, i, r, a), t1.globalCompositeOperation = "source-over", t1.drawImage(s, 0, 0);
        }
        function Yv(t1, e, r, n) {
            const i = Uv(t1.canvas.width, t1.canvas.height);
            Wv(i.getContext("2d"), e, r, n), t1.globalCompositeOperation = "destination-in", t1.drawImage(i, 0, 0);
        }
        function Kv(t1, e, r, n, i) {
            if (0 === n.children.length) return;
            const s = null != n.mask_idx ? r.masks[n.mask_idx] : null;
            s && Kv(t1, e, r, s, i);
            const o = t1.canvas.width, a = t1.canvas.height, l = Uv(o, a), u = l.getContext("2d"), c = n.width, h = n.height, p = n.left, d = n.top, f = new Path2D, m = new Path2D;
            m.rect(p, d, c, h), f.addPath(m, e), u.clip(f);
            for (const t1 of n.children)$v(u, e, r, t1, i);
            const y = u.getImageData(0, 0, o, a), g = y.data;
            if (n.mask_type === mv.MASK_TYPE_LUMINANCE) for(let t1 = 0; t1 < g.length; t1 += 4)g[t1 + 3] = g[t1 + 3] / 255 * (.2126 * g[t1] + .7152 * g[t1 + 1] + .0722 * g[t1 + 2]);
            u.putImageData(y, 0, 0), t1.globalCompositeOperation = "destination-in", t1.drawImage(l, 0, 0);
        }
        function Jv(t1) {
            return t1 ? new DOMMatrix([
                t1.sx,
                t1.ky,
                t1.kx,
                t1.sy,
                t1.tx,
                t1.ty
            ]) : new DOMMatrix;
        }
        function Qv(t1, e) {
            const r = t1.step;
            let n = t1.diffs[0] * r, i = t1.diffs[1] * r;
            e.moveTo(n, i);
            for(let s = 0, o = 2; s < t1.commands.length; s++)switch(t1.commands[s]){
                case fv.PATH_COMMAND_MOVE:
                    n += t1.diffs[o++] * r, i += t1.diffs[o++] * r, e.moveTo(n, i);
                    break;
                case fv.PATH_COMMAND_LINE:
                    n += t1.diffs[o++] * r, i += t1.diffs[o++] * r, e.lineTo(n, i);
                    break;
                case fv.PATH_COMMAND_QUAD:
                    {
                        const s = n + t1.diffs[o++] * r, a = i + t1.diffs[o++] * r;
                        n = s + t1.diffs[o++] * r, i = a + t1.diffs[o++] * r, e.quadraticCurveTo(s, a, n, i);
                        break;
                    }
                case fv.PATH_COMMAND_CUBIC:
                    {
                        const s = n + t1.diffs[o++] * r, a = i + t1.diffs[o++] * r, l = s + t1.diffs[o++] * r, u = a + t1.diffs[o++] * r;
                        n = l + t1.diffs[o++] * r, i = u + t1.diffs[o++] * r, e.bezierCurveTo(s, a, l, u, n, i);
                        break;
                    }
                case fv.PATH_COMMAND_CLOSE:
                    e.closePath();
            }
            return e;
        }
        function tb(t1) {
            return Qv(t1, new Path2D);
        }
        class eb {
            constructor(t1){
                this.capacity = t1, this.cache = new Map;
            }
            get(t1) {
                if (!this.cache.has(t1)) return;
                const e = this.cache.get(t1);
                return this.cache.delete(t1), this.cache.set(t1, e), e;
            }
            put(t1, e) {
                this.cache.has(t1) ? this.cache.delete(t1) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t1, e);
            }
            delete(t1) {
                this.cache.delete(t1);
            }
        }
        qs(eb, "LRUCache");
        class rb {
            constructor(){
                this.cacheMap = new Map, this.cacheDependenciesMap = new Map;
            }
            static _getImage(t1) {
                return new ph(t1, t1.data);
            }
            getFromCache(t1, e, r) {
                return this.cacheMap.has(r) || this.cacheMap.set(r, new eb(150)), this.cacheMap.get(r).get(Zo(t1.toString(), e));
            }
            setInCache(t1, e, r, n) {
                this.cacheDependenciesMap.has(n) || this.cacheDependenciesMap.set(n, new Map), this.cacheMap.has(n) || this.cacheMap.set(n, new eb(150));
                const i = this.cacheDependenciesMap.get(n), s = Zo(t1.id.toString(), r);
                i.get(s) || i.set(s, new Set);
                const o = this.cacheMap.get(n), a = t1.toString();
                i.get(s).add(a), o.put(Zo(t1.toString(), r), e);
            }
            removeImagesFromCacheByIds(t1, e, r = 0) {
                if (!this.cacheMap.has(r) || !this.cacheDependenciesMap.has(r)) return;
                const n = this.cacheMap.get(r), i = this.cacheDependenciesMap.get(r);
                for (const r of t1){
                    const t1 = Zo(r.toString(), e);
                    if (i.has(t1)) {
                        for (const e of i.get(t1))n.delete(e);
                        i.delete(t1);
                    }
                }
            }
            rasterize(t1, e, r, n, i = Nv) {
                const s = this.getFromCache(t1, r, n);
                if (s) return s.clone();
                const o = i(e.icon, t1.options), a = rb._getImage(o);
                return this.setInCache(t1, a, r, n), a.clone();
            }
        }
        class nb {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e) {
                const r = this.toIdx(t1, e);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e) {
                return this.leaves[this.toIdx(t1, e)];
            }
            toIdx(t1, e) {
                return e * this.size + t1;
            }
        }
        function ib(t1, e, r, n) {
            let i = 0, s = Number.MAX_VALUE;
            for(let o = 0; o < 3; o++)if (Math.abs(n[o]) < 1e-15) {
                if (r[o] < t1[o] || r[o] > e[o]) return null;
            } else {
                const a = 1 / n[o];
                let l = (t1[o] - r[o]) * a, u = (e[o] - r[o]) * a;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }
            return i;
        }
        function sb(t1, e, r, n, i, s, o, a, l, u, c) {
            const h = n - t1, p = i - e, d = s - r, f = o - t1, m = a - e, y = l - r, g = c[1] * y - c[2] * m, x = c[2] * f - c[0] * y, v = c[0] * m - c[1] * f, b = h * g + p * x + d * v;
            if (Math.abs(b) < 1e-15) return null;
            const w = 1 / b, _ = u[0] - t1, A = u[1] - e, M = u[2] - r, I = (_ * g + A * x + M * v) * w;
            if (I < 0 || I > 1) return null;
            const S = A * d - M * p, P = M * h - _ * d, E = _ * p - A * h, k = (c[0] * S + c[1] * P + c[2] * E) * w;
            return k < 0 || I + k > 1 ? null : (f * S + m * P + y * E) * w;
        }
        function ob(t1, e, r) {
            return (t1 - e) / (r - e);
        }
        function ab(t1, e, r, n, i, s, o, a, l) {
            const u = 1 << r, c = s - n, h = o - i, p = (t1 + 1) / u * c + n, d = (e + 0) / u * h + i, f = (e + 1) / u * h + i;
            a[0] = (t1 + 0) / u * c + n, a[1] = d, l[0] = p, l[1] = f;
        }
        class lb {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e = function(t1) {
                    const e = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e));
                    const i = 1 / n, s = (t1, e, r, n, i)=>{
                        const s = n ? 1 : 0, o = (t1 + 1) * r - s, a = e * r, l = (e + 1) * r - s;
                        i[0] = t1 * r, i[1] = a, i[2] = o, i[3] = l;
                    };
                    let o = new nb(n);
                    const a = [];
                    for(let e = 0; e < n * n; e++){
                        s(e % n, Math.floor(e / n), i, !1, a);
                        const r = cb(a[0], a[1], t1), l = cb(a[2], a[1], t1), u = cb(a[2], a[3], t1), c = cb(a[0], a[3], t1);
                        o.minimums.push(Math.min(r, l, u, c)), o.maximums.push(Math.max(r, l, u, c)), o.leaves.push(1);
                    }
                    for(r.push(o), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        o = new nb(n);
                        for(let e = 0; e < n * n; e++){
                            s(e % n, Math.floor(e / n), 2, !0, a);
                            const r = t1.getElevation(a[0], a[1]), i = t1.getElevation(a[2], a[1]), l = t1.getElevation(a[2], a[3]), u = t1.getElevation(a[0], a[3]), c = t1.isLeaf(a[0], a[1]), h = t1.isLeaf(a[2], a[1]), p = t1.isLeaf(a[2], a[3]), d = t1.isLeaf(a[0], a[3]), f = Math.min(r.min, i.min, l.min, u.min), m = Math.max(r.max, i.max, l.max, u.max), y = c && h && p && d;
                            o.maximums.push(m), o.minimums.push(f), o.leaves.push(m - f <= 5 && y ? 1 : 0);
                        }
                        r.push(o);
                    }
                    return r;
                }(this.dem), r = e.length - 1, n = e[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
            }
            raycastRoot(t1, e, r, n, i, s, o = 1) {
                return ib([
                    t1,
                    e,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * o
                ], i, s);
            }
            raycast(t1, e, r, n, i, s, o = 1) {
                if (!this.nodeCount) return null;
                const a = this.raycastRoot(t1, e, r, n, i, s, o);
                if (null == a) return null;
                const l = [], u = [], c = [], h = [], p = [
                    {
                        idx: 0,
                        t: a,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p.length > 0;){
                    const { idx: a, t: d, nodex: f, nodey: m, depth: y } = p.pop();
                    if (this.leaves[a]) {
                        ab(f, m, y, t1, e, r, n, c, h);
                        const a = 1 << y, l = (f + 0) / a, u = (f + 1) / a, p = (m + 0) / a, g = (m + 1) / a, x = cb(l, p, this.dem) * o, v = cb(u, p, this.dem) * o, b = cb(u, g, this.dem) * o, w = cb(l, g, this.dem) * o, _ = sb(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s), A = sb(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s), M = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (M !== Number.MAX_VALUE) return M;
                        {
                            const t1 = T([], i, s, d);
                            if (ub(x, v, w, b, ob(t1[0], c[0], h[0]), ob(t1[1], c[1], h[1])) >= t1[2]) return d;
                        }
                        continue;
                    }
                    let g = 0;
                    for(let p = 0; p < this._siblingOffset.length; p++){
                        ab((f << 1) + this._siblingOffset[p][0], (m << 1) + this._siblingOffset[p][1], y + 1, t1, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[a] + p] * o;
                        const d = ib(c, h, i, s);
                        if (null != d) {
                            const t1 = d;
                            l[p] = t1;
                            let e = !1;
                            for(let r = 0; r < g && !e; r++)t1 >= l[u[r]] && (u.splice(r, 0, p), e = !0);
                            e || (u[g] = p), g++;
                        }
                    }
                    for(let t1 = 0; t1 < g; t1++){
                        const e = u[t1];
                        p.push({
                            idx: this.childOffsets[a] + e,
                            t: l[e],
                            nodex: (f << 1) + this._siblingOffset[e][0],
                            nodey: (m << 1) + this._siblingOffset[e][1],
                            depth: y + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e, r) {
                return this.minimums.push(t1), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e, r, n, i) {
                if (1 === t1[n].isLeaf(e, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1, o = t1[s];
                let a = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], s = o.getElevation(n, i), u = o.isLeaf(n, i), c = this._addNode(s.min, s.max, u);
                    u && (a |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)a & 1 << n || this._construct(t1, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function ub(t1, e, r, n, i, s) {
            return ur(ur(t1, r, s), ur(e, n, s), i);
        }
        function cb(t1, e, r) {
            const n = r.dim, i = zt(t1 * n - .5, 0, n - 1), s = zt(e * n - .5, 0, n - 1), o = Math.floor(i), a = Math.floor(s), l = Math.min(o + 1, n - 1), u = Math.min(a + 1, n - 1);
            return ub(r.get(o, a), r.get(l, a), r.get(o, u), r.get(l, u), i - o, s - a);
        }
        const hb = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        function pb(t1, e, r) {
            return (256 * t1 * 256 + 256 * e + r) / 10 - 1e4;
        }
        function db(t1, e, r) {
            return 256 * t1 + e + r / 256 - 32768;
        }
        class fb {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e, r, n = !1){
                if (this.uid = t1, e.height !== e.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return void Gt(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e.height;
                const i = this.dim = e.height - 2, s = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {
                    for(let t1 = 0; t1 < i; t1++)s[this._idx(-1, t1)] = s[this._idx(0, t1)], s[this._idx(i, t1)] = s[this._idx(i - 1, t1)], s[this._idx(t1, -1)] = s[this._idx(t1, 0)], s[this._idx(t1, i)] = s[this._idx(t1, i - 1)];
                    s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(i, -1)] = s[this._idx(i - 1, 0)], s[this._idx(-1, i)] = s[this._idx(0, i - 1)], s[this._idx(i, i)] = s[this._idx(i - 1, i - 1)];
                }
                const o = "terrarium" === r ? db : pb;
                for(let t1 = 0; t1 < s.length; ++t1){
                    const e = 4 * t1;
                    this.floatView[t1] = o(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);
                }
                this._timestamp = de.now();
            }
            _buildQuadTree() {
                this._tree = new lb(this);
            }
            get(t1, e, r = !1) {
                r && (t1 = zt(t1, -1, this.dim), e = zt(e, -1, this.dim));
                const n = this._idx(t1, e);
                return this.floatView[n];
            }
            set(t1, e, r) {
                const n = this._idx(t1, e), i = this.floatView[n];
                return this.floatView[n] = r, r - i;
            }
            static getUnpackVector(t1) {
                return hb[t1];
            }
            _idx(t1, e) {
                if (t1 < -1 || t1 >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t1 + 1);
            }
            static pack(t1, e) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = fb.getUnpackVector(e);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new dh({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e * this.dim, i = e * this.dim + this.dim, s = r * this.dim, o = r * this.dim + this.dim;
                switch(e){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        s = o - 1;
                        break;
                    case 1:
                        o = s + 1;
                }
                const a = -e * this.dim, l = -r * this.dim;
                for(let e = s; e < o; e++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e), i = 4 * this._idx(r + a, e + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        function mb(t1, e, r) {
            1 === t1 ? e.headerLength = r.readFixed32() : 2 === t1 ? e.x = r.readVarint() : 3 === t1 ? e.y = r.readVarint() : 4 === t1 ? e.z = r.readVarint() : 5 === t1 && e.layers.push(function(t1, e) {
                return t1.readFields(bb, {
                    version: 0,
                    name: "",
                    units: "",
                    tileSize: 0,
                    buffer: 0,
                    pixelFormat: 0,
                    dataIndex: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function yb(t1, e, r) {
            1 === t1 ? (e.delta_filter = function(t1, e) {
                return t1.readFields(gb, {
                    blockSize: 0
                }, e);
            }(r, r.readVarint() + r.pos), e.filter = "delta_filter") : 2 === t1 ? (r.readVarint(), e.filter = "zigzag_filter") : 3 === t1 ? (r.readVarint(), e.filter = "bitshuffle_filter") : 4 === t1 && (r.readVarint(), e.filter = "byteshuffle_filter");
        }
        function gb(t1, e, r) {
            1 === t1 && (e.blockSize = r.readVarint());
        }
        function xb(t1, e, r) {
            1 === t1 ? (r.readVarint(), e.codec = "gzip_data") : 2 === t1 ? (r.readVarint(), e.codec = "jpeg_image") : 3 === t1 ? (r.readVarint(), e.codec = "webp_image") : 4 === t1 && (r.readVarint(), e.codec = "png_image");
        }
        function vb(t1, e, r) {
            let n = 0, i = 0;
            1 === t1 ? e.firstByte = r.readFixed64() : 2 === t1 ? e.lastByte = r.readFixed64() : 3 === t1 ? e.filters.push(function(t1, e) {
                return t1.readFields(yb, {}, e);
            }(r, r.readVarint() + r.pos)) : 4 === t1 ? e.codec = function(t1, e) {
                return t1.readFields(xb, {}, e);
            }(r, r.readVarint() + r.pos) : 5 === t1 ? i = r.readFloat() : 6 === t1 ? n = r.readFloat() : 7 === t1 ? e.bands.push(r.readString()) : 8 === t1 ? e.offset = r.readDouble() : 9 === t1 && (e.scale = r.readDouble()), 0 === e.offset && (e.offset = i), 0 === e.scale && (e.scale = n);
        }
        function bb(t1, e, r) {
            1 === t1 ? e.version = r.readVarint() : 2 === t1 ? e.name = r.readString() : 3 === t1 ? e.units = r.readString() : 4 === t1 ? e.tileSize = r.readVarint() : 5 === t1 ? e.buffer = r.readVarint() : 6 === t1 ? e.pixelFormat = r.readVarint() : 7 === t1 && e.dataIndex.push(function(t1, e) {
                return t1.readFields(vb, {
                    firstByte: 0,
                    lastByte: 0,
                    filters: [],
                    codec: null,
                    offset: 0,
                    scale: 0,
                    bands: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function wb(t1, e, r) {
            if (2 === t1) !function(t1, e, r) {
                t1.readFields(_b, r, e);
            }(r, r.readVarint() + r.pos, e);
            else if (3 === t1) throw new Error("Not implemented");
        }
        function _b(t1, e, r) {
            if (1 === t1) {
                let t1 = 0;
                const n = r.readVarint() + r.pos;
                for(; r.pos < n;)e[t1++] = r.readVarint();
            }
        }
        function Ab(t1, e) {
            if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
            let r = e[3];
            for(let n = 2; n >= 1; n--){
                const i = 1 === n ? 1 : 0, s = 2 === n ? 1 : 0;
                for(let n = 0; n < e[0]; n++){
                    const o = e[1] * n;
                    for(let n = i; n < e[1]; n++){
                        const i = e[2] * (n + o);
                        for(let n = s; n < e[2]; n++){
                            const s = e[3] * (n + i);
                            for(let n = 0; n < e[3]; n++){
                                const e = s + n;
                                t1[e] += t1[e - r];
                            }
                        }
                    }
                }
                r *= e[n];
            }
            return t1;
        }
        function Mb(t1) {
            for(let e = 0, r = t1.length; e < r; e++)t1[e] = t1[e] >>> 1 ^ -(1 & t1[e]);
            return t1;
        }
        function Ib(t1, e) {
            switch(e){
                case "uint32":
                    return t1;
                case "uint16":
                    for(let e = 0; e < t1.length; e += 2){
                        const r = t1[e], n = t1[e + 1];
                        t1[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t1[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;
                    }
                    return t1;
                case "uint8":
                    for(let e = 0; e < t1.length; e += 4){
                        const r = t1[e], n = t1[e + 1], i = t1[e + 2], s = t1[e + 3];
                        t1[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & s, t1[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & s) << 2, t1[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & s) << 4, t1[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & s) << 6;
                    }
                    return t1;
                default:
                    throw new Error(`Invalid pixel format, "${e}"`);
            }
        }
        qs(fb, "DEMData"), qs(lb, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        var Sb = Uint8Array, Pb = Uint16Array, Eb = Int32Array, kb = new Sb([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            0,
            0,
            0,
            0
        ]), zb = new Sb([
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13,
            0,
            0
        ]), Tb = new Sb([
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ]), Bb = function(t1, e) {
            for(var r = new Pb(31), n = 0; n < 31; ++n)r[n] = e += 1 << t1[n - 1];
            var i = new Eb(r[30]);
            for(n = 1; n < 30; ++n)for(var s = r[n]; s < r[n + 1]; ++s)i[s] = s - r[n] << 5 | n;
            return {
                b: r,
                r: i
            };
        }, Vb = Bb(kb, 2), Cb = Vb.b, Fb = Vb.r;
        Cb[28] = 258, Fb[258] = 28;
        for(var Db = Bb(zb, 0).b, Lb = new Pb(32768), Rb = 0; Rb < 32768; ++Rb){
            var Ob = (43690 & Rb) >> 1 | (21845 & Rb) << 1;
            Lb[Rb] = ((65280 & (Ob = (61680 & (Ob = (52428 & Ob) >> 2 | (13107 & Ob) << 2)) >> 4 | (3855 & Ob) << 4)) >> 8 | (255 & Ob) << 8) >> 1;
        }
        var Ub = function(t1, e, r) {
            for(var n = t1.length, i = 0, s = new Pb(e); i < n; ++i)t1[i] && ++s[t1[i] - 1];
            var o, a = new Pb(e);
            for(i = 1; i < e; ++i)a[i] = a[i - 1] + s[i - 1] << 1;
            o = new Pb(1 << e);
            var l = 15 - e;
            for(i = 0; i < n; ++i)if (t1[i]) for(var u = i << 4 | t1[i], c = e - t1[i], h = a[t1[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h)o[Lb[h] >> l] = u;
            return o;
        }, Nb = new Sb(288);
        for(Rb = 0; Rb < 144; ++Rb)Nb[Rb] = 8;
        for(Rb = 144; Rb < 256; ++Rb)Nb[Rb] = 9;
        for(Rb = 256; Rb < 280; ++Rb)Nb[Rb] = 7;
        for(Rb = 280; Rb < 288; ++Rb)Nb[Rb] = 8;
        var jb = new Sb(32);
        for(Rb = 0; Rb < 32; ++Rb)jb[Rb] = 5;
        var $b = Ub(Nb, 9), Gb = Ub(jb, 5), Hb = function(t1) {
            for(var e = t1[0], r = 1; r < t1.length; ++r)t1[r] > e && (e = t1[r]);
            return e;
        }, qb = function(t1, e, r) {
            var n = e / 8 | 0;
            return (t1[n] | t1[n + 1] << 8) >> (7 & e) & r;
        }, Xb = function(t1, e) {
            var r = e / 8 | 0;
            return (t1[r] | t1[r + 1] << 8 | t1[r + 2] << 16) >> (7 & e);
        }, Zb = [
            "unexpected EOF",
            "invalid block type",
            "invalid length/literal",
            "invalid distance",
            "stream finished",
            "no stream handler",
            ,
            "no callback",
            "invalid UTF-8 data",
            "extra field too long",
            "date not in range 1980-2099",
            "filename too long",
            "stream finishing",
            "invalid zip data"
        ], Wb = function(t1, e, r) {
            var n = new Error(e || Zb[t1]);
            if (n.code = t1, Error.captureStackTrace && Error.captureStackTrace(n, Wb), !r) throw n;
            return n;
        }, Yb = new Sb(0), Kb = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            Kb.decode(Yb, {
                stream: !0
            });
        } catch (t1) {}
        const Jb = {
            gzip_data: "gzip"
        };
        class Qb extends Error {
            constructor(t1){
                super(t1), this.name = "MRTError";
            }
        }
        const tw = {
            0: "uint32",
            1: "uint32",
            2: "uint16",
            3: "uint8"
        }, ew = {
            uint32: 1,
            uint16: 2,
            uint8: 4
        }, rw = {
            uint32: Uint32Array,
            uint16: Uint16Array,
            uint8: Uint8Array
        };
        let nw;
        class iw {
            constructor(t1 = 5){
                this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t1;
            }
            getLayer(t1) {
                const e = this.layers[t1];
                if (!e) throw new Qb(`Layer '${t1}' not found`);
                return e;
            }
            getHeaderLength(t1) {
                const e = new Uint8Array(t1), r = new DataView(t1);
                if (13 !== e[0]) throw new Qb("File is not a valid MRT.");
                return r.getUint32(1, !0);
            }
            parseHeader(t1) {
                const e = new Uint8Array(t1), r = this.getHeaderLength(t1);
                if (e.length < r) throw new Qb(`Expected header with length >= ${r} but got buffer of length ${e.length}`);
                const n = new nw(e.subarray(0, r)).readFields(mb, {
                    headerLength: 0,
                    x: 0,
                    y: 0,
                    z: 0,
                    layers: []
                }, void 0);
                if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new Qb(`Invalid attempt to parse header ${n.z}/${n.x}/${n.y} for tile ${this.z}/${this.x}/${this.y}`);
                this.x = n.x, this.y = n.y, this.z = n.z;
                for (const t1 of n.layers)this.layers[t1.name] = new sw(t1, {
                    cacheSize: this._cacheSize
                });
                return this;
            }
            createDecodingTask(t1) {
                const e = [], r = this.getLayer(t1.layerName);
                for (let n of t1.blockIndices){
                    const i = r.dataIndex[n], s = i.firstByte - t1.firstByte, o = i.lastByte - t1.firstByte;
                    if (r._blocksInProgress.has(n)) continue;
                    const a = {
                        layerName: r.name,
                        firstByte: s,
                        lastByte: o,
                        pixelFormat: r.pixelFormat,
                        blockIndex: n,
                        blockShape: [
                            i.bands.length
                        ].concat(r.bandShape),
                        buffer: r.buffer,
                        codec: i.codec.codec,
                        filters: i.filters.map((t1)=>t1.filter)
                    };
                    r._blocksInProgress.add(n), e.push(a);
                }
                return new ow(e, ()=>{
                    e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex));
                }, (t1, n)=>{
                    if (e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex)), t1) throw t1;
                    n.forEach((t1)=>{
                        this.getLayer(t1.layerName).processDecodedData(t1);
                    });
                });
            }
        }
        class sw {
            constructor({ version: t1, name: e, units: r, tileSize: n, pixelFormat: i, buffer: s, dataIndex: o }, a){
                if (this.version = t1, 1 !== this.version) throw new Qb(`Cannot parse raster layer encoded with MRT version ${t1}`);
                this.name = e, this.units = r, this.tileSize = n, this.buffer = s, this.pixelFormat = tw[i], this.dataIndex = o, this.bandShape = [
                    n + 2 * s,
                    n + 2 * s,
                    ew[this.pixelFormat]
                ], this._decodedBlocks = new eb(a ? a.cacheSize : 5), this._blocksInProgress = new Set;
            }
            get dimension() {
                return ew[this.pixelFormat];
            }
            get cacheSize() {
                return this._decodedBlocks.capacity;
            }
            getBandList() {
                return this.dataIndex.map(({ bands: t1 })=>t1).flat();
            }
            processDecodedData(t1) {
                const e = t1.blockIndex.toString();
                this._decodedBlocks.get(e) || this._decodedBlocks.put(e, t1.data);
            }
            getBlockForBand(t1) {
                let e = 0;
                switch(typeof t1){
                    case "string":
                        for (const [r, n] of this.dataIndex.entries()){
                            for (const [i, s] of n.bands.entries())if (s === t1) return {
                                bandIndex: e + i,
                                blockIndex: r,
                                blockBandIndex: i
                            };
                            e += n.bands.length;
                        }
                        break;
                    case "number":
                        for (const [r, n] of this.dataIndex.entries()){
                            if (t1 >= e && t1 < e + n.bands.length) return {
                                bandIndex: t1,
                                blockIndex: r,
                                blockBandIndex: t1 - e
                            };
                            e += n.bands.length;
                        }
                        break;
                    default:
                        throw new Qb(`Invalid band \`${JSON.stringify(t1)}\`. Expected string or integer.`);
                }
                return {
                    blockIndex: -1,
                    blockBandIndex: -1
                };
            }
            getDataRange(t1) {
                let e = 1 / 0, r = -1 / 0;
                const n = [], i = new Set;
                for (const s of t1){
                    const { blockIndex: t1 } = this.getBlockForBand(s);
                    if (t1 < 0) throw new Qb(`Invalid band: ${JSON.stringify(s)}`);
                    const o = this.dataIndex[t1];
                    n.includes(t1) || n.push(t1), i.add(t1), e = Math.min(e, o.firstByte), r = Math.max(r, o.lastByte);
                }
                if (i.size > this.cacheSize) throw new Qb(`Number of blocks to decode (${i.size}) exceeds cache size (${this.cacheSize}).`);
                return {
                    layerName: this.name,
                    firstByte: e,
                    lastByte: r,
                    blockIndices: n
                };
            }
            hasBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0;
            }
            hasDataForBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0 && !!this._decodedBlocks.get(e.toString());
            }
            getBandView(t1) {
                const { blockIndex: e, blockBandIndex: r } = this.getBlockForBand(t1);
                if (e < 0) throw new Qb(`Band not found: ${JSON.stringify(t1)}`);
                const n = this._decodedBlocks.get(e.toString());
                if (!n) throw new Qb(`Data for band ${JSON.stringify(t1)} of layer "${this.name}" not decoded.`);
                const i = this.dataIndex[e], s = this.bandShape.reduce((t1, e)=>t1 * e, 1), o = r * s, a = n.subarray(o, o + s);
                return {
                    data: a,
                    bytes: new Uint8Array(a.buffer).subarray(a.byteOffset, a.byteOffset + a.byteLength),
                    tileSize: this.tileSize,
                    buffer: this.buffer,
                    pixelFormat: this.pixelFormat,
                    dimension: this.dimension,
                    offset: i.offset,
                    scale: i.scale
                };
            }
        }
        iw.setPbf = function(t1) {
            nw = t1;
        };
        class ow {
            constructor(t1, e, r){
                this.tasks = t1, this._onCancel = e, this._onComplete = r, this._finalized = !1;
            }
            cancel() {
                this._finalized || (this._onCancel(), this._finalized = !0);
            }
            complete(t1, e) {
                this._finalized || (this._onComplete(t1, e), this._finalized = !0);
            }
        }
        iw.performDecoding = function(t1, e) {
            const r = new Uint8Array(t1);
            return Promise.all(e.tasks.map((t1)=>{
                const { layerName: e, firstByte: n, lastByte: i, pixelFormat: s, blockShape: o, blockIndex: a, filters: l, codec: u } = t1, c = r.subarray(n, i + 1), h = new Uint32Array(o[0] * o[1] * o[2]);
                let p;
                if ("gzip_data" !== u) throw new Qb(`Unhandled codec: ${u}`);
                return p = (function(t1, e) {
                    if (!globalThis.DecompressionStream && "gzip_data" === e) return Promise.resolve(((s = function(t1) {
                        31 == t1[0] && 139 == t1[1] && 8 == t1[2] || Wb(6, "invalid gzip data");
                        var e = t1[3], r = 10;
                        4 & e && (r += 2 + (t1[10] | t1[11] << 8));
                        for(var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t1[r++]);
                        return r + (2 & e);
                    }(i = t1)) + 8 > i.length && Wb(6, "invalid gzip data"), function(t1, e, r, n) {
                        var i = t1.length;
                        if (!i || e.f && !e.l) return r || new Sb(0);
                        var s = !r, o = s || 2 != e.i, a = e.i;
                        s && (r = new Sb(3 * i));
                        var l, u, c = function(t1) {
                            var e = r.length;
                            if (t1 > e) {
                                var n = new Sb(Math.max(2 * e, t1));
                                n.set(r), r = n;
                            }
                        }, h = e.f || 0, p = e.p || 0, d = e.b || 0, f = e.l, m = e.d, y = e.m, g = e.n, x = 8 * i;
                        do {
                            if (!f) {
                                h = qb(t1, p, 1);
                                var v = qb(t1, p + 1, 3);
                                if (p += 3, !v) {
                                    var b = t1[(T = 4 + ((p + 7) / 8 | 0)) - 4] | t1[T - 3] << 8, w = T + b;
                                    if (w > i) {
                                        a && Wb(0);
                                        break;
                                    }
                                    o && c(d + b), r.set(t1.subarray(T, w), d), e.b = d += b, e.p = p = 8 * w, e.f = h;
                                    continue;
                                }
                                if (1 == v) f = $b, m = Gb, y = 9, g = 5;
                                else if (2 == v) {
                                    var _ = qb(t1, p, 31) + 257, A = qb(t1, p + 10, 15) + 4, M = _ + qb(t1, p + 5, 31) + 1;
                                    p += 14;
                                    for(var I = new Sb(M), S = new Sb(19), P = 0; P < A; ++P)S[Tb[P]] = qb(t1, p + 3 * P, 7);
                                    p += 3 * A;
                                    var E = Hb(S), k = (1 << E) - 1, z = Ub(S, E);
                                    for(P = 0; P < M;){
                                        var T, B = z[qb(t1, p, k)];
                                        if (p += 15 & B, (T = B >> 4) < 16) I[P++] = T;
                                        else {
                                            var V = 0, C = 0;
                                            for(16 == T ? (C = 3 + qb(t1, p, 3), p += 2, V = I[P - 1]) : 17 == T ? (C = 3 + qb(t1, p, 7), p += 3) : 18 == T && (C = 11 + qb(t1, p, 127), p += 7); C--;)I[P++] = V;
                                        }
                                    }
                                    var F = I.subarray(0, _), D = I.subarray(_);
                                    y = Hb(F), g = Hb(D), f = Ub(F, y), m = Ub(D, g);
                                } else Wb(1);
                                if (p > x) {
                                    a && Wb(0);
                                    break;
                                }
                            }
                            o && c(d + 131072);
                            for(var L = (1 << y) - 1, R = (1 << g) - 1, O = p;; O = p){
                                var U = (V = f[Xb(t1, p) & L]) >> 4;
                                if ((p += 15 & V) > x) {
                                    a && Wb(0);
                                    break;
                                }
                                if (V || Wb(2), U < 256) r[d++] = U;
                                else {
                                    if (256 == U) {
                                        O = p, f = null;
                                        break;
                                    }
                                    var N = U - 254;
                                    U > 264 && (N = qb(t1, p, (1 << (G = kb[P = U - 257])) - 1) + Cb[P], p += G);
                                    var j = m[Xb(t1, p) & R], $ = j >> 4;
                                    if (j || Wb(3), p += 15 & j, D = Db[$], $ > 3) {
                                        var G = zb[$];
                                        D += Xb(t1, p) & (1 << G) - 1, p += G;
                                    }
                                    if (p > x) {
                                        a && Wb(0);
                                        break;
                                    }
                                    o && c(d + 131072);
                                    var H = d + N;
                                    if (d < D) {
                                        var q = 0 - D, X = Math.min(D, H);
                                        for(q + d < 0 && Wb(3); d < X; ++d)r[d] = (void 0)[q + d];
                                    }
                                    for(; d < H; ++d)r[d] = r[d - D];
                                }
                            }
                            e.l = f, e.p = O, e.b = d, e.f = h, f && (h = 1, e.m = y, e.d = m, e.n = g);
                        }while (!h)
                        return d != r.length && s ? (l = r, (null == (u = d) || u > l.length) && (u = l.length), new Sb(l.subarray(0, u))) : r.subarray(0, d);
                    }(i.subarray(s, -8), {
                        i: 2
                    }, new Sb(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0))));
                    var r, n, i, s;
                    const o = Jb[e];
                    if (!o) throw new Error(`Unhandled codec: ${e}`);
                    const a = new globalThis.DecompressionStream(o);
                    return new Response(new Blob([
                        t1
                    ]).stream().pipeThrough(a)).arrayBuffer().then((t1)=>new Uint8Array(t1));
                })(c, u).then((t1)=>((function(t1, e) {
                        t1.readFields(wb, e);
                    })(new nw(t1), h), new (0, rw[s])(h.buffer))), p.then((t1)=>{
                    for(let e = l.length - 1; e >= 0; e--)switch(l[e]){
                        case "delta_filter":
                            Ab(t1, o);
                            break;
                        case "zigzag_filter":
                            Mb(t1);
                            break;
                        case "bitshuffle_filter":
                            Ib(t1, s);
                            break;
                        default:
                            throw new Qb(`Unhandled filter "${l[e]}"`);
                    }
                    return {
                        layerName: e,
                        blockIndex: a,
                        data: t1
                    };
                }).catch((t1)=>{
                    throw t1;
                });
            }));
        }, qs(ow, "MRTDecodingBatch", {
            omit: [
                "_onCancel",
                "_onComplete"
            ]
        }), qs(iw, "MapboxRasterTile"), qs(sw, "MapboxRasterLayer", {
            omit: [
                "_blocksInProgress"
            ]
        });
        class aw {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    this._stringToNumber[r] = e, this._numberToString[e] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        const lw = [
            "id",
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class uw {
            constructor(t1, e, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e, this._x = r, this._y = n, this.properties = t1.properties, this.id = i;
            }
            clone() {
                const t1 = new uw(this._vectorTileFeature, this._z, this._x, this._y, this.id);
                return this.state && (t1.state = Object.assign({}, this.state)), this.layer && (t1.layer = Object.assign({}, this.layer)), this.source && (t1.source = this.source), this.sourceLayer && (t1.sourceLayer = this.sourceLayer), t1;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    state: void 0,
                    geometry: this.geometry,
                    properties: this.properties
                };
                for (const e of lw)void 0 !== this[e] && (t1[e] = this[e]);
                return t1;
            }
        }
        class cw {
            constructor(t1, e){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new Gs(Cn, 16, 0), this.featureIndexArray = new Za, this.promoteId = e, this.is3DTile = !1, this.serializedLayersCache = new Map;
            }
            insert(t1, e, r, n, i, s = 0, o = 0) {
                const a = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const l = this.grid;
                for(let t1 = 0; t1 < e.length; t1++){
                    const r = e[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e = r[t1];
                        n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
                    }
                    0 !== o && (n[0] -= o, n[1] -= o, n[2] += o, n[3] += o), n[0] < Cn && n[1] < Cn && n[2] >= 0 && n[3] >= 0 && l.insert(a, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new Mu(new Jm(this.rawTileData)).layers, this.sourceLayerCoder = new aw(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e) {
                const { tilespaceGeometry: r, transform: n, tileTransform: i, pixelPosMatrix: s, availableImages: o, worldview: a } = e;
                this.loadVTLayers(), this.serializedLayersCache.clear();
                const l = r.bufferedTilespaceBounds, u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t1, e, n, i)=>sc(r.bufferedTilespaceGeometry, t1, e, n, i));
                u.sort(pw);
                let c = null;
                n.elevation && u.length > 0 && (c = Wx.create(n.elevation, this.tileID));
                const h = {};
                let p;
                for(let e = 0; e < u.length; e++){
                    const l = u[e];
                    if (l === p) continue;
                    p = l;
                    const d = this.featureIndexArray.get(l);
                    let f = null;
                    this.is3DTile ? this.loadMatchingModelFeature(h, d, t1, r, n, a) : this.loadMatchingFeature(h, d, t1, o, a, (t1, e, o, a = 0)=>(f || (f = gu(t1, this.tileID.canonical, i)), e.queryIntersectsFeature(r, t1, o, f, this.z, n, s, c, a)));
                }
                return h;
            }
            loadMatchingFeature(t1, e, r, n, i, s) {
                const { featureIndex: o, bucketIndex: a, sourceLayerIndex: l, layoutVertexArrayOffset: u } = e, c = this.bucketLayerIDs[a], h = r.layers, p = Object.keys(h);
                if (p.length && !jt(p, c)) return;
                const d = r.sourceCache, f = this.sourceLayerCoder.decode(l), m = this.vtLayers[f].feature(o), y = this.getId(m, f);
                for(let e = 0; e < c.length; e++){
                    const r = c[e];
                    if (!h[r]) continue;
                    const { styleLayer: a, targets: l } = h[r];
                    let p = {};
                    void 0 !== y && (p = d.getFeatureState(a.sourceLayer, y));
                    const f = !s || s(m, a, p, u);
                    if (!f) continue;
                    const g = new uw(m, this.z, this.x, this.y, y);
                    g.tile = this.tileID.canonical, g.state = p;
                    let x = this.serializedLayersCache.get(r);
                    x || (x = a.serialize(), x.id = r, this.serializedLayersCache.set(r, x)), g.source = x.source, g.sourceLayer = x["source-layer"], g.layer = Ct({}, x), g.layer.paint = hw(x.paint, a.paint, m, p, n), g.layer.layout = hw(x.layout, a.layout, m, p, n);
                    let v = !1;
                    for (const t1 of l){
                        this.updateFeatureProperties(g, t1);
                        const { filter: e } = t1;
                        if (e) {
                            if (m.properties = g.properties, e.needGeometry) {
                                const t1 = xu(m, !0);
                                if (!e.filter(new xo(this.tileID.overscaledZ, {
                                    worldview: i
                                }), t1, this.tileID.canonical)) continue;
                            } else if (!e.filter(new xo(this.tileID.overscaledZ, {
                                worldview: i
                            }), m)) continue;
                        }
                        v = !0, t1.targetId && this.addFeatureVariant(g, t1);
                    }
                    v && this.appendToResult(t1, r, o, g, f);
                }
            }
            loadMatchingModelFeature(t1, e, r, n, i, s) {
                const { featureIndex: o, bucketIndex: a } = e, l = this.bucketLayerIDs[a], u = r.layers, c = Object.keys(u);
                if (!c.length || jt(c, l)) for(let e = 0; e < l.length; e++){
                    const a = l[e], { styleLayer: c, targets: h } = u[a];
                    if ("model" !== c.type) continue;
                    const p = n.tile, d = p.getBucket(c);
                    if (!(d && d instanceof rv)) continue;
                    const f = av(d, o, n, i);
                    if (!f) continue;
                    const { z: m, x: y, y: g } = p.tileID.canonical, { feature: x, intersectionZ: v, position: b } = f;
                    let w = {};
                    void 0 !== x.id && (w = r.sourceCache.getFeatureState(c.sourceLayer, x.id));
                    const _ = new uw({}, m, y, g, x.id);
                    _.tile = this.tileID.canonical, _.state = w, _.properties = x.properties, _.geometry = {
                        type: "Point",
                        coordinates: [
                            b.lng,
                            b.lat
                        ]
                    };
                    let A = this.serializedLayersCache.get(a);
                    A || (A = c.serialize(), A.id = a, this.serializedLayersCache.set(a, A)), _.source = A.source, _.sourceLayer = A["source-layer"], _.layer = Ct({}, A);
                    let M = !1;
                    for (const t1 of h){
                        this.updateFeatureProperties(_, t1);
                        const { filter: e } = t1;
                        if (e) {
                            if (x.properties = _.properties, e.needGeometry) {
                                if (!e.filter(new xo(this.tileID.overscaledZ, {
                                    worldview: s
                                }), x, this.tileID.canonical)) continue;
                            } else if (!e.filter(new xo(this.tileID.overscaledZ, {
                                worldview: s
                            }), x)) continue;
                        }
                        M = !0, t1.targetId && this.addFeatureVariant(_, t1);
                    }
                    M && this.appendToResult(t1, a, o, _, v);
                }
            }
            updateFeatureProperties(t1, e, r) {
                if (e.properties) {
                    const n = {};
                    for(const i in e.properties){
                        const s = e.properties[i].evaluate({
                            zoom: this.z
                        }, t1._vectorTileFeature, t1.state, t1.tile, r);
                        null != s && (n[i] = s);
                    }
                    t1.properties = n;
                }
            }
            addFeatureVariant(t1, e, r) {
                const n = {
                    target: e.target,
                    namespace: e.namespace,
                    uniqueFeatureID: e.uniqueFeatureID
                };
                e.properties && (n.properties = t1.properties), t1.variants = t1.variants || {}, t1.variants[e.targetId] = t1.variants[e.targetId] || [], t1.variants[e.targetId].push(n);
            }
            appendToResult(t1, e, r, n, i) {
                let s = t1[e];
                void 0 === s && (s = t1[e] = []), s.push({
                    featureIndex: r,
                    feature: n,
                    intersectionZ: i
                });
            }
            lookupSymbolFeatures(t1, e, r, n, i, s) {
                const o = {};
                this.loadVTLayers();
                for (const a of t1)this.loadMatchingFeature(o, {
                    bucketIndex: e,
                    sourceLayerIndex: r,
                    featureIndex: a,
                    layoutVertexArrayOffset: 0
                }, n, i, s);
                return o;
            }
            loadFeature(t1) {
                const { featureIndex: e, sourceLayerIndex: r } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e]) return i[e];
                const s = this.vtLayers[n].feature(e);
                return i[e] = s, s;
            }
            hasLayer(t1) {
                for (const e of this.bucketLayerIDs)for (const r of e)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    if (null != n) if (Array.isArray(n)) {
                        if (!this.promoteIdExpression) {
                            const t1 = Fs(n);
                            if ("success" !== t1.result) {
                                const e = t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", ");
                                return void Gt(`Failed to create expression for promoteId: ${e}`);
                            }
                            this.promoteIdExpression = t1.value;
                        }
                        this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new Kr), r = this.promoteIdExpression.evaluate({
                            zoom: 0
                        }, t1);
                    } else r = t1.properties[n];
                    "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function hw(t1, e, r, n, i) {
            return Ot(t1, (t1, s)=>{
                const o = e instanceof So ? e.get(s) : null;
                return o && o.evaluate ? o.evaluate(r, n, void 0, i) : o;
            });
        }
        function pw(t1, e) {
            return e - t1;
        }
        qs(cw, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        const dw = [
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        ];
        class fw {
            static from(t1) {
                if (!(t1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                const [e, r] = new Uint8Array(t1, 0, 2);
                if (219 !== e) throw new Error("Data does not appear to be in a KDBush format.");
                const n = r >> 4;
                if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);
                const i = dw[15 & r];
                if (!i) throw new Error("Unrecognized array type.");
                const [s] = new Uint16Array(t1, 2, 1), [o] = new Uint32Array(t1, 4, 1);
                return new fw(o, s, i, t1);
            }
            constructor(t1, e = 64, r = Float64Array, n){
                if (isNaN(t1) || t1 < 0) throw new Error(`Unpexpected numItems value: ${t1}.`);
                this.numItems = +t1, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t1 < 65536 ? Uint16Array : Uint32Array;
                const i = dw.indexOf(this.ArrayType), s = 2 * t1 * this.ArrayType.BYTES_PER_ELEMENT, o = t1 * this.IndexArrayType.BYTES_PER_ELEMENT, a = (8 - o % 8) % 8;
                if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
                n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + o + a, 2 * t1), this._pos = 2 * t1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + o + a), this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + o + a, 2 * t1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([
                    219,
                    16 + i
                ]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t1);
            }
            add(t1, e) {
                const r = this._pos >> 1;
                return this.ids[r] = r, this.coords[this._pos++] = t1, this.coords[this._pos++] = e, r;
            }
            finish() {
                const t1 = this._pos >> 1;
                if (t1 !== this.numItems) throw new Error(`Added ${t1} items when expected ${this.numItems}.`);
                return mw(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
            }
            range(t1, e, r, n) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: i, coords: s, nodeSize: o } = this, a = [
                    0,
                    i.length - 1,
                    0
                ], l = [];
                for(; a.length;){
                    const u = a.pop() || 0, c = a.pop() || 0, h = a.pop() || 0;
                    if (c - h <= o) {
                        for(let o = h; o <= c; o++){
                            const a = s[2 * o], u = s[2 * o + 1];
                            a >= t1 && a <= r && u >= e && u <= n && l.push(i[o]);
                        }
                        continue;
                    }
                    const p = h + c >> 1, d = s[2 * p], f = s[2 * p + 1];
                    d >= t1 && d <= r && f >= e && f <= n && l.push(i[p]), (0 === u ? t1 <= d : e <= f) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? r >= d : n >= f) && (a.push(p + 1), a.push(c), a.push(1 - u));
                }
                return l;
            }
            within(t1, e, r) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: n, coords: i, nodeSize: s } = this, o = [
                    0,
                    n.length - 1,
                    0
                ], a = [], l = r * r;
                for(; o.length;){
                    const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0;
                    if (c - h <= s) {
                        for(let r = h; r <= c; r++)vw(i[2 * r], i[2 * r + 1], t1, e) <= l && a.push(n[r]);
                        continue;
                    }
                    const p = h + c >> 1, d = i[2 * p], f = i[2 * p + 1];
                    vw(d, f, t1, e) <= l && a.push(n[p]), (0 === u ? t1 - r <= d : e - r <= f) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? t1 + r >= d : e + r >= f) && (o.push(p + 1), o.push(c), o.push(1 - u));
                }
                return a;
            }
        }
        function mw(t1, e, r, n, i, s) {
            if (i - n <= r) return;
            const o = n + i >> 1;
            yw(t1, e, o, n, i, s), mw(t1, e, r, n, o - 1, 1 - s), mw(t1, e, r, o + 1, i, 1 - s);
        }
        function yw(t1, e, r, n, i, s) {
            for(; i > n;){
                if (i - n > 600) {
                    const o = i - n + 1, a = r - n + 1, l = Math.log(o), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (o - u) / o) * (a - o / 2 < 0 ? -1 : 1);
                    yw(t1, e, r, Math.max(n, Math.floor(r - a * u / o + c)), Math.min(i, Math.floor(r + (o - a) * u / o + c)), s);
                }
                const o = e[2 * r + s];
                let a = n, l = i;
                for(gw(t1, e, n, r), e[2 * i + s] > o && gw(t1, e, n, i); a < l;){
                    for(gw(t1, e, a, l), a++, l--; e[2 * a + s] < o;)a++;
                    for(; e[2 * l + s] > o;)l--;
                }
                e[2 * n + s] === o ? gw(t1, e, n, l) : (l++, gw(t1, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);
            }
        }
        function gw(t1, e, r, n) {
            xw(t1, r, n), xw(e, 2 * r, 2 * n), xw(e, 2 * r + 1, 2 * n + 1);
        }
        function xw(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function vw(t1, e, r, n) {
            const i = t1 - r, s = e - n;
            return i * i + s * s;
        }
        t1.$ = Jr, t1.A = Ye, t1.B = Fr, t1.C = Zo, t1.D = Bd, t1.E = tr, t1.F = 2, t1.G = Zy, t1.H = qy, t1.I = er, t1.J = Xr, t1.K = class extends jx {
        }, t1.L = pr, t1.M = Bo, t1.N = Ms, t1.O = ws, t1.P = bt, t1.Q = As, t1.R = Be, t1.S = Cs, t1.T = df, t1.U = Vo, t1.V = jx, t1.W = Rs, t1.X = Fs, t1.Y = pi, t1.Z = fi, t1._ = hi, t1.a = function(t1) {
            return ne.API_CDN_URL_REGEX.test(t1);
        }, t1.a$ = Dt, t1.a0 = ir, t1.a1 = Co, t1.a2 = Is, t1.a3 = _s, t1.a4 = function(t1) {
            const e = t1.value;
            let r = [];
            if (!e) return r;
            const n = Xr(e);
            return "string" !== n ? (r = r.concat([
                new jx(t1.key, e, `string expected, "${n}" found`)
            ]), r) : ($x(e, !0) || (r = r.concat([
                new jx(t1.key, e, `invalid url "${e}"`)
            ])), r);
        }, t1.a5 = To, t1.a6 = wo, t1.a7 = zo, t1.a8 = Po, t1.a9 = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return Xt(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: ur(t1.x, e.x, r),
                    y: ur(t1.y, e.y, r),
                    z: ur(t1.z, e.z, r),
                    azimuthal: ur(t1.azimuthal, e.azimuthal, r),
                    polar: ur(t1.polar, e.polar, r)
                };
            }
        }, t1.aA = Y, t1.aB = Fl, t1.aC = ic, t1.aD = Jl, t1.aE = hu, t1.aF = function(t1, e) {
            const r = {};
            for(let n = 0; n < e.length; n++){
                const i = e[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.aG = Zl, t1.aH = Ql, t1.aI = class {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }, t1.aJ = function(t1, e, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e)=>{
                const n = De(t1.request, (t1, n, i, s)=>{
                    t1 ? e(t1) : n && e(null, {
                        vectorTile: r ? void 0 : new Mu(new Jm(n)),
                        rawData: n,
                        cacheControl: i,
                        expires: s
                    });
                });
                return ()=>{
                    n.cancel(), e();
                };
            }, e);
        }, t1.aK = function(t1) {
            Me++, Me > xe && (t1.getActor().send("enforceCacheSizeLimit", ge), Me = 0);
        }, t1.aL = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t1) / Math.LN2));
        }, t1.aM = xc, t1.aN = Bx, t1.aO = Rx, t1.aP = zx, t1.aQ = function(t1, e) {
            const r = document.createElement("video");
            r.muted = !0, r.onloadstart = function() {
                e(null, r);
            };
            for(let e = 0; e < t1.length; e++){
                const n = document.createElement("source");
                Le(t1[e]) || (r.crossOrigin = "Anonymous"), n.src = t1[e], r.appendChild(n);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.aR = ff, t1.aS = function(t1) {
            return fetch(t1).then((t1)=>t1.arrayBuffer()).then((e)=>cf(e, 0, t1));
        }, t1.aT = Xf, t1.aU = class {
            constructor(t1, e, r, n){
                this.id = t1, this.position = null != e ? new Xl(e[0], e[1]) : new Xl(0, 0), this.orientation = null != r ? r : [
                    0,
                    0,
                    0
                ], this.nodes = n, this.uploaded = !1, this.aabb = new Nu([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]), this.matrix = [];
            }
            _applyTransformations(t1, e) {
                if (c(t1.matrix, e, t1.matrix), t1.meshes) for (const e of t1.meshes){
                    const r = Nu.applyTransformFast(e.aabb, t1.matrix);
                    this.aabb.encapsulate(r);
                }
                if (t1.children) for (const e of t1.children)this._applyTransformations(e, t1.matrix);
            }
            computeBoundsAndApplyParent() {
                const t1 = l([]);
                for (const e of this.nodes)this._applyTransformations(e, t1);
            }
            computeModelMatrix(t1, e, r, n, i, s, o = !1) {
                Cf(this.matrix, this, t1.transform, this.position, e, r, n, i, s, o);
            }
            upload(t1) {
                if (!this.uploaded) {
                    for (const e of this.nodes)Lf(e, t1);
                    for (const t1 of this.nodes)Rf(t1);
                    this.uploaded = !0;
                }
            }
            destroy() {
                for (const t1 of this.nodes)Of(t1);
            }
        }, t1.aV = Rt, t1.aW = Dg, t1.aX = eu, t1.aY = ru, t1.aZ = sa, t1.a_ = Ma, t1.aa = xo, t1.ab = Ls, t1.ac = uu, t1.ad = O, t1.ae = _, t1.af = Tt, t1.ag = So, t1.ah = Gc, t1.ai = ur, t1.aj = Cn, t1.ak = cr, t1.al = Mt, t1.am = sr, t1.an = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return function([t1, e]) {
                    const r = Xt([
                        1,
                        t1,
                        e
                    ]);
                    return {
                        x: r.x,
                        y: r.y,
                        z: r.z
                    };
                }(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: ur(t1.x, e.x, r),
                    y: ur(t1.y, e.y, r),
                    z: ur(t1.z, e.z, r)
                };
            }
        }, t1.ao = function(t1, e, r = 0, n = !0) {
            const i = new bt(r, r), s = t1.sub(i), o = e.add(i), a = [
                s,
                new bt(o.x, s.y),
                o,
                new bt(s.x, o.y)
            ];
            return n && a.push(s.clone()), a;
        }, t1.ap = function(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = Bt(n - 1, -1, t1.length - 1), s = Bt(n + 1, -1, t1.length - 1), o = t1[n], a = t1[s], l = t1[i].sub(o).unit(), u = a.sub(o).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
                r.push(o.add(h));
            }
            return r;
        }, t1.aq = Lg, t1.ar = sc, t1.as = function(t1, e, r = 0) {
            return A(((e.x - r) * t1.scale - t1.x) * Cn, (e.y * t1.scale - t1.y) * Cn, nu(e.z, e.y));
        }, t1.at = G, t1.au = F, t1.av = Cu, t1.aw = Am, t1.ax = function(t1) {
            let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
            return {
                min: new bt(e, r),
                max: new bt(n, i)
            };
        }, t1.ay = zt, t1.az = c, t1.b = function(t1) {
            return ne.API_FONTS_REGEX.test(t1);
        }, t1.b$ = Ig, t1.b0 = Ua, t1.b1 = mx, t1.b2 = function() {
            go.isLoading() || go.isLoaded() || "deferred" !== mo() || yo();
        }, t1.b3 = Fo, t1.b4 = xu, t1.b5 = uw, t1.b6 = Wt, t1.b7 = vm, t1.b8 = up, t1.b9 = gu, t1.bA = function(t1, e) {
            const { x: r, y: n } = t1.point, i = $c(r, n, t1.worldSize / t1._pixelsPerMercatorPixel, 0, 0);
            return c(i, i, Uc(zc(e)));
        }, t1.bB = n, t1.bC = j, t1.bD = function(t1, e) {
            return Math.hypot(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }, t1.bE = T, t1.bF = L, t1.bG = D, t1.bH = Ly, t1.bI = my, t1.bJ = Dy, t1.bK = function(t1, e, r, n, i) {
            const s = 5 * e + 2;
            t1.float32[s + 0] = r, t1.float32[s + 1] = n, t1.float32[s + 2] = i;
        }, t1.bL = hx, t1.bM = at, t1.bN = ct, t1.bO = lt, t1.bP = yt, t1.bQ = Bt, t1.bR = function(t1, e, n, i) {
            var s = new r(4);
            return s[0] = t1, s[1] = e, s[2] = n, s[3] = i, s;
        }, t1.bS = bd, t1.bT = Xu, t1.bU = Gm, t1.bV = Sp, t1.bW = Nx, t1.bX = Fp, t1.bY = Dp, t1.bZ = Sy, t1.b_ = gg, t1.ba = na, t1.bb = Ca, t1.bc = Mc, t1.bd = el, t1.be = vh, t1.bf = Sx, t1.bg = function(t1, e) {
            const r = Gc(e.zoom);
            if (0 === r) return zc(t1);
            const n = Cc(t1), i = Fc(n), s = Jl(n.getWest()) * e.worldSize, o = Jl(n.getEast()) * e.worldSize, a = Ql(n.getNorth()) * e.worldSize, l = Ql(n.getSouth()) * e.worldSize, c = [
                s,
                a,
                0
            ], h = [
                o,
                a,
                0
            ], p = [
                s,
                l,
                0
            ], d = [
                o,
                l,
                0
            ], f = u([], e.globeMatrix);
            return O(c, c, f), O(h, h, f), O(p, p, f), O(d, d, f), i[0] = Tc(i[0], p, r), i[1] = Tc(i[1], d, r), i[2] = Tc(i[2], h, r), i[3] = Tc(i[3], c, r), Nu.fromPoints(i);
        }, t1.bh = Oc, t1.bi = u, t1.bj = Dc, t1.bk = Tc, t1.bl = ia, t1.bm = Ac, t1.bn = y, t1.bo = h, t1.bp = iw, t1.bq = Jm, t1.br = De, t1.bs = function(t1, e) {
            const r = [];
            for(const n in t1)n in e || r.push(n);
            return r;
        }, t1.bt = Vt, t1.bu = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.bv = wt, t1.bw = function(t1) {
            var e = new r(16);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e[6] = t1[6], e[7] = t1[7], e[8] = t1[8], e[9] = t1[9], e[10] = t1[10], e[11] = t1[11], e[12] = t1[12], e[13] = t1[13], e[14] = t1[14], e[15] = t1[15], e;
        }, t1.bx = l, t1.by = m, t1.bz = a, t1.c = se, t1.c$ = 45, t1.c0 = fw, t1.c1 = z, t1.c2 = q, t1.c3 = J, t1.c4 = function(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], o = e[3], a = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + i * a, t1[1] = i * l - n * a, t1[2] = s * l + o * a, t1[3] = o * l - s * a, t1;
        }, t1.c5 = Q, t1.c6 = Kt, t1.c7 = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1;
        }, t1.c8 = x, t1.c9 = function(t1, e, r, n, i) {
            var s, o = 1 / Math.tan(e / 2);
            return t1[0] = o / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = o, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (s = 1 / (n - i)), t1[14] = 2 * i * n * s) : (t1[10] = -1, t1[14] = -2 * n), t1;
        }, t1.cA = yc, t1.cB = Vc, t1.cC = function(t1, e, r, n, i, s, o, a, l) {
            if ("globe" === l.name) return Vc(t1, e, new yc(r, n, i), !1);
            const u = Dg({
                z: r,
                x: n,
                y: i
            }, l);
            return new Nu([
                (s + u.x / u.scale) * e,
                e * (u.y / u.scale),
                o
            ], [
                (s + u.x2 / u.scale) * e,
                e * (u.y2 / u.scale),
                a
            ]);
        }, t1.cD = function(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1[3] = Math.min(e[3], r[3]), t1;
        }, t1.cE = function(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1[3] = Math.max(e[3], r[3]), t1;
        }, t1.cF = function(t1) {
            const e = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return St[e];
        }, t1.cG = iu, t1.cH = Z, t1.cI = Ll, t1.cJ = function(t1) {
            const e = l(new Float64Array(16));
            c(e, t1.pixelMatrix, t1.globeMatrix);
            const r = [
                0,
                Nl,
                0
            ], n = [
                0,
                jl,
                0
            ];
            return O(r, r, e), O(n, n, e), [
                r[0] > 0 && r[0] <= t1.width && r[1] > 0 && r[1] <= t1.height && !qc(t1, new Xl(t1.center.lat, 90)),
                n[0] > 0 && n[0] <= t1.width && n[1] > 0 && n[1] <= t1.height && !qc(t1, new Xl(t1.center.lat, -90))
            ];
        }, t1.cK = function(t1, e) {
            const { scale: r } = t1.tileTransform, n = r * Cn / (t1.tileSize * Math.pow(2, e.zoom - t1.tileID.overscaledZ + t1.tileID.canonical.z));
            return function(t1, e, r) {
                var n = e[1], i = e[2], s = e[3], o = r[0], a = r[1];
                return t1[0] = e[0] * o, t1[1] = n * o, t1[2] = i * a, t1[3] = s * a, t1;
            }(new Float32Array(4), e.inverseAdjustmentMatrix, [
                n,
                n
            ]);
        }, t1.cL = Mf, t1.cM = v, t1.cN = _f, t1.cO = function(t1) {
            const e = _f(t1, !0);
            return n([], [
                e[0],
                e[1],
                e[4],
                e[5]
            ]);
        }, t1.cP = p, t1.cQ = Fu, t1.cR = d, t1.cS = function(t1) {
            const { x: e, y: r } = t1.point, { lng: n, lat: i } = t1._center;
            return $c(e, r, t1.worldSize, n, i);
        }, t1.cT = P, t1.cU = It, t1.cV = vc, t1.cW = oc, t1.cX = Dl, t1.cY = function(t1, e, r) {
            let n = 0;
            for(let r = 0; r < 2; ++r){
                const i = 0;
                t1[r] > i && (n += (t1[r] - i) * (t1[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));
            }
            return n;
        }, t1.cZ = function(t1) {
            return t1 * t1 * t1 * t1 * t1;
        }, t1.c_ = Kl, t1.ca = function(t1, e, r, n, i, s, o) {
            var a = 1 / (e - r), l = 1 / (n - i), u = 1 / (s - o);
            return t1[0] = -2 * a, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e + r) * a, t1[13] = (i + n) * l, t1[14] = (o + s) * u, t1[15] = 1, t1;
        }, t1.cb = tu, t1.cc = function(t1, e, r) {
            t1[4 * e + 0] = r[0], t1[4 * e + 1] = r[1], t1[4 * e + 2] = r[2], t1[4 * e + 3] = r[3];
        }, t1.cd = hl, t1.ce = fl, t1.cf = pl, t1.cg = dl, t1.ch = xl, t1.ci = Xl, t1.cj = ix, t1.ck = function() {
            var t1 = new r(4);
            return r != Float32Array && (t1[1] = 0, t1[2] = 0), t1[0] = 1, t1[3] = 1, t1;
        }, t1.cl = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], o = e[3], a = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + s * a, t1[1] = i * l + o * a, t1[2] = n * -a + s * l, t1[3] = i * -a + o * l, t1;
        }, t1.cm = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
        }, t1.cn = $, t1.co = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
        }, t1.cp = it, t1.cq = N, t1.cr = gc, t1.cs = 3, t1.ct = 2, t1.cu = 7, t1.cv = 6, t1.cw = R, t1.cx = b, t1.cy = Uu, t1.cz = Af, t1.d = function(t1) {
            return ne.API_TILEJSON_REGEX.test(t1);
        }, t1.d$ = (t1, e, r, n, i, s, o, a, l, u)=>{
            const c = t1.transform, h = c.calculatePixelsToTileUnitsMatrix(e), p = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default"), d = c.pitch < 15 ? Mm(.07, .7, zt((14 - c.zoom) / 5, 0, 1)) : .07;
            return {
                u_matrix: Sm(t1, e, r, n),
                u_pixels_to_tile_units: h,
                u_device_pixel_ratio: s,
                u_width_scale: o,
                u_floor_width_scale: a,
                u_units_to_pixels: [
                    1 / c.pixelsToGLUnits[0],
                    1 / c.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: i,
                u_texsize: Em(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: Im(e, t1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: l,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_color: r.paint.get("line-trim-color").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),
                u_emissive_strength: r.paint.get("line-emissive-strength"),
                u_zbias_factor: d,
                u_tile_to_meter: lu(e.tileID.canonical, 0),
                u_ground_shadow_factor: u
            };
        }, t1.d0 = ml, t1.d1 = function(t1, e, r) {
            const n = Math.sqrt(t1 * t1 + e * e + r * r), i = n > 0 ? Math.acos(r / n) * At : 0;
            let s = 0 !== t1 || 0 !== e ? Math.atan2(-e, -t1) * At + 90 : 0;
            return s < 0 && (s += 360), [
                n,
                s,
                i
            ];
        }, t1.d2 = A, t1.d3 = Xt, t1.d4 = lu, t1.d5 = I, t1.d6 = Nu, t1.d7 = S, t1.d8 = function(t1) {
            return [
                Math.pow(t1[0], 1 / 2.2),
                Math.pow(t1[1], 1 / 2.2),
                Math.pow(t1[2], 1 / 2.2)
            ];
        }, t1.d9 = $x, t1.dA = Cc, t1.dB = function(t1) {
            const e = iu - 5;
            t1 = zt(t1, -e, e) / e * 90;
            const r = Math.pow(Math.abs(Math.sin(Mt(t1))), 3);
            return Math.round(r * (Ul.length - 1));
        }, t1.dC = function(t1, e, r, n) {
            const i = e.getNorth(), s = e.getSouth(), a = e.getWest(), l = e.getEast(), u = 1 << t1.z, c = l - a, h = i - s, p = c / Ol, d = -h / Ul[r], f = [
                0,
                p,
                0,
                d,
                0,
                0,
                i,
                a,
                0
            ];
            if (t1.z > 0) {
                const t1 = 180 / n;
                o(f, f, [
                    t1 / c + 1,
                    0,
                    0,
                    0,
                    t1 / h + 1,
                    0,
                    -.5 * t1 / p,
                    .5 * t1 / d,
                    1
                ]);
            }
            return f[2] = u, f[5] = t1.x, f[8] = t1.y, f;
        }, t1.dD = zc, t1.dE = function(t1, e, r) {
            const n = l(new Float64Array(16)), i = (e / (1 << t1) - .5) * Math.PI * 2;
            return f(n, r.globeMatrix, i), Float32Array.from(n);
        }, t1.dF = class {
            isDataAvailableAtPoint(t1) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t1.y < 0 || t1.y > 1) return !1;
                const r = e.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), s = Math.floor((t1.x - i) * n), o = Math.floor(t1.y * n), a = this.findDEMTileFor(new xc(r, i, r, s, o));
                return !(!a || !a.dem);
            }
            getAtPointOrZero(t1, e = 0) {
                return this.getAtPoint(t1, e) || 0;
            }
            getAtPoint(t1, e, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e && (e = null);
                const n = this._source();
                if (!n) return e;
                if (t1.y < 0 || t1.y > 1) return e;
                const i = n.getSource().maxzoom, s = 1 << i, o = Math.floor(t1.x), a = t1.x - o, l = new xc(i, o, i, Math.floor(a * s), Math.floor(t1.y * s)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (a * h - u.tileID.canonical.x) * c.dim, d = (t1.y * h - u.tileID.canonical.y) * c.dim, f = Math.floor(p), m = Math.floor(d);
                return (r ? this.exaggeration() : 1) * ur(ur(c.get(f, m), c.get(f, m + 1), d - m), ur(c.get(f + 1, m), c.get(f + 1, m + 1), d - m), p - f);
            }
            getAtTileOffset(t1, e, r) {
                const n = 1 << t1.canonical.z;
                return this.getAtPointOrZero(new uu(t1.wrap + (t1.canonical.x + e / Cn) / n, (t1.canonical.y + r / Cn) / n));
            }
            getAtTileOffsetFunc(t1, e, r, n) {
                return (i)=>{
                    const s = this.getAtTileOffset(t1, i.x, i.y), o = n.upVector(t1.canonical, i.x, i.y);
                    return z(o, o, s * n.upVectorScale(t1.canonical, e, r).metersToTile), o;
                };
            }
            getForTilePoints(t1, e, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = Wx.create(this, t1, n);
                return !!i && (e.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e = this.findDEMTileFor(t1);
                if (!e || !e.dem) return null;
                const r = e.dem.tree, n = e.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let s = t1.canonical.x / i - n.canonical.x, o = t1.canonical.y / i - n.canonical.y, a = 0;
                for(let e = 0; e < t1.canonical.z - n.canonical.z && !r.leaves[a]; e++){
                    s *= 2, o *= 2;
                    const t1 = 2 * Math.floor(o) + Math.floor(s);
                    a = r.childOffsets[a] + t1, s %= 1, o %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[a],
                    max: this.exaggeration() * r.maximums[a]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
                const t1 = this.visibleDemTiles;
                if (0 === t1.length) return null;
                let e = !1, r = Number.MAX_VALUE, n = Number.MIN_VALUE;
                for (const i of t1){
                    const t1 = this.getMinMaxForTile(i.tileID);
                    t1 && (r = Math.min(r, t1.min), n = Math.max(n, t1.max), e = !0);
                }
                return e ? {
                    min: r,
                    max: n
                } : null;
            }
        }, t1.dG = dh, t1.dH = Ic, t1.dI = function(t1, e) {
            return [
                Math.pow(t1[0], 2.2) * e,
                Math.pow(t1[1], 2.2) * e,
                Math.pow(t1[2], 2.2) * e
            ];
        }, t1.dJ = i, t1.dK = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, t1.dL = U, t1.dM = jc, t1.dN = te, t1.dO = ee, t1.dP = 256, t1.dQ = function(t1, e) {
            const r = [
                0,
                0,
                0
            ];
            return O(r, r, Oc(zc(e.canonical))), O(r, r, t1), r;
        }, t1.dR = (t1)=>({
                u_matrix: new xl(t1),
                u_texsize: new dl(t1),
                u_pixels_to_tile_units: new wl(t1),
                u_device_pixel_ratio: new pl(t1),
                u_width_scale: new pl(t1),
                u_floor_width_scale: new pl(t1),
                u_image: new hl(t1),
                u_units_to_pixels: new dl(t1),
                u_tile_units_to_pixels: new pl(t1),
                u_alpha_discard_threshold: new pl(t1),
                u_trim_offset: new dl(t1),
                u_trim_fade_range: new dl(t1),
                u_trim_color: new ml(t1),
                u_emissive_strength: new pl(t1),
                u_zbias_factor: new pl(t1),
                u_tile_to_meter: new pl(t1),
                u_ground_shadow_factor: new fl(t1),
                u_pattern_transition: new pl(t1)
            }), t1.dS = (t1)=>({
                u_matrix: new xl(t1),
                u_pixels_to_tile_units: new wl(t1),
                u_device_pixel_ratio: new pl(t1),
                u_width_scale: new pl(t1),
                u_floor_width_scale: new pl(t1),
                u_units_to_pixels: new dl(t1),
                u_dash_image: new hl(t1),
                u_gradient_image: new hl(t1),
                u_image_height: new pl(t1),
                u_texsize: new dl(t1),
                u_tile_units_to_pixels: new pl(t1),
                u_alpha_discard_threshold: new pl(t1),
                u_trim_offset: new dl(t1),
                u_trim_fade_range: new dl(t1),
                u_trim_color: new ml(t1),
                u_emissive_strength: new pl(t1),
                u_zbias_factor: new pl(t1),
                u_tile_to_meter: new pl(t1),
                u_ground_shadow_factor: new fl(t1)
            }), t1.dT = (t1)=>({
                u_camera_to_center_distance: new pl(t1),
                u_extrude_scale: new wl(t1),
                u_device_pixel_ratio: new pl(t1),
                u_matrix: new xl(t1),
                u_inv_rot_matrix: new xl(t1),
                u_merc_center: new dl(t1),
                u_tile_id: new fl(t1),
                u_zoom_transition: new pl(t1),
                u_up_dir: new fl(t1),
                u_emissive_strength: new pl(t1)
            }), t1.dU = _a, t1.dV = $m, t1.dW = Kc, t1.dX = (t1, e, r, n, i, s)=>{
            const o = t1.transform, a = "globe" === o.projection.name;
            let l;
            if ("map" === s.paint.get("circle-pitch-alignment")) if (a) {
                const t1 = jc(o.zoom, e.canonical) * o._pixelsPerMercatorPixel;
                l = Float32Array.from([
                    t1,
                    0,
                    0,
                    t1
                ]);
            } else l = o.calculatePixelsToTileUnitsMatrix(r);
            else l = new Float32Array([
                o.pixelsToGLUnits[0],
                0,
                0,
                o.pixelsToGLUnits[1]
            ]);
            const u = {
                u_camera_to_center_distance: t1.transform.getCameraToCenterDistance(o.projection),
                u_matrix: t1.translatePosMatrix(e.projMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: de.devicePixelRatio,
                u_extrude_scale: l,
                u_inv_rot_matrix: Yc,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_emissive_strength: s.paint.get("circle-emissive-strength")
            };
            if (a) {
                u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [
                    e.canonical.x,
                    e.canonical.y,
                    1 << e.canonical.z
                ], u.u_zoom_transition = Gc(o.zoom);
                const t1 = i[0] * Cn, r = i[1] * Cn;
                u.u_up_dir = o.projection.upVector(new yc(0, 0, 0), t1, r);
            }
            return u;
        }, t1.dY = Pm, t1.dZ = Dr, t1.d_ = (t1, e, r, n, i, s, o, a, l, u)=>{
            const c = t1.transform, h = c.pitch < 15 ? Mm(.07, .7, zt((14 - c.zoom) / 5, 0, 1)) : .07, p = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default");
            return {
                u_matrix: Sm(t1, e, r, n),
                u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_pixels_to_tile_units: c.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: i,
                u_width_scale: s,
                u_floor_width_scale: o,
                u_image: 0,
                u_tile_units_to_pixels: Im(e, c),
                u_units_to_pixels: [
                    1 / c.pixelsToGLUnits[0],
                    1 / c.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0,
                u_trim_offset: a,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_color: r.paint.get("line-trim-color").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),
                u_emissive_strength: r.paint.get("line-emissive-strength"),
                u_zbias_factor: h,
                u_tile_to_meter: lu(e.tileID.canonical, 0),
                u_ground_shadow_factor: l,
                u_pattern_transition: u
            };
        }, t1.da = function(t1, e) {
            return t1.readFields(yv, {
                icons: []
            }, e);
        }, t1.db = Fd, t1.dc = rg, t1.dd = eg, t1.de = Ce, t1.df = ho, t1.dg = me, t1.dh = We, t1.di = Nt, t1.dj = function(t1) {
            const e = t1.indexOf(Xo);
            return e >= 0 ? t1.slice(0, e) : t1;
        }, t1.dk = function(t1) {
            return t1.indexOf(Xo) >= 0;
        }, t1.dl = function(t1) {
            const e = t1.lastIndexOf(Xo);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.dm = function(t1) {
            const e = [], r = t1.id;
            return void 0 === r && e.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e;
        }, t1.dn = function(t1, e, r, n) {
            return "custom" === t1.type ? new Ox(t1, e) : new lv[t1.type](t1, e, r, n);
        }, t1.dp = Ut, t1.dq = function(t1) {
            const e = t1.indexOf(Xo);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.dr = class extends uw {
            constructor(t1, e){
                super(t1._vectorTileFeature, t1._z, t1._x, t1._y, t1.id), t1.state && (this.state = Object.assign({}, t1.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t1.source, this.sourceLayer = t1.sourceLayer, this.layer = t1.layer);
            }
            toJSON() {
                const t1 = super.toJSON();
                return t1.target = this.target, t1.namespace = this.namespace, t1;
            }
        }, t1.ds = fo, t1.dt = Fe, t1.du = function(t1) {
            return t1({
                pluginStatus: uo,
                pluginURL: co
            }), fo.on("pluginStateChange", t1), t1;
        }, t1.dv = yl, t1.dw = class extends cl {
            constructor(t1){
                super(t1), this.current = vl;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.dx = Pt, t1.dy = function(t1, e, r) {
            const n = Gc(r.zoom), i = t1.style.map._antialias, s = t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !s;
        }, t1.dz = function(t1) {
            const e = t1.pixelsPerMeter, r = e / tu(1, t1.center.lat), n = l(new Float64Array(16));
            return h(n, n, [
                t1.point.x,
                t1.point.y,
                0
            ]), p(n, n, [
                r,
                r,
                e
            ]), Float32Array.from(n);
        }, t1.e = ne, t1.e$ = mo, t1.e0 = Lt, t1.e1 = fh, t1.e2 = nu, t1.e3 = bc, t1.e4 = nd, t1.e5 = hd, t1.e6 = Hp, t1.e7 = 450, t1.e8 = 7, t1.e9 = ou, t1.eA = function(t1, e, n, i, s, o, a, l, u, c, h, p, d, f, m, y) {
            var g = new r(16);
            return g[0] = t1, g[1] = e, g[2] = n, g[3] = i, g[4] = s, g[5] = o, g[6] = a, g[7] = l, g[8] = u, g[9] = c, g[10] = h, g[11] = p, g[12] = d, g[13] = f, g[14] = m, g[15] = y, g;
        }, t1.eB = Hl, t1.eC = Ta, t1.eD = za, t1.eE = class {
            constructor(){
                this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
                    min: new bt(1 / 0, 1 / 0),
                    max: new bt(-1 / 0, -1 / 0)
                };
            }
            clear() {
                this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
                return this._updateTime;
            }
            getReplacementRegionsForTile(t1, e = !1) {
                const r = Tp(new bt(0, 0), new bt(Cn, Cn), t1), n = [];
                if (e && !kp(r, this._globalClipBounds)) return n;
                for (const e of this._activeRegions){
                    if (e.hiddenByOverlap) continue;
                    if (!kp(r, e)) continue;
                    const i = Bp(e.min, e.max, t1);
                    n.push({
                        min: i.min,
                        max: i.max,
                        sourceId: this._sourceIds[e.priority],
                        footprint: e.footprint,
                        footprintTileId: e.tileId,
                        order: e.order,
                        clipMask: e.clipMask,
                        clipScope: e.clipScope
                    });
                }
                return n;
            }
            setSources(t1) {
                this._setSources(t1.map((t1)=>({
                        getSourceId: ()=>t1.cache.id,
                        getFootprints: ()=>{
                            const e = [];
                            for (const r of t1.cache.getVisibleCoordinates()){
                                const n = t1.cache.getTile(r).buckets[t1.layer];
                                n && n.updateFootprints(r.toUnwrapped(), e);
                            }
                            return e;
                        },
                        getOrder: ()=>t1.order,
                        getClipMask: ()=>t1.clipMask,
                        getClipScope: ()=>t1.clipScope
                    })));
            }
            _addSource(t1) {
                const e = t1.getFootprints();
                if (0 === e.length) return;
                const r = t1.getOrder(), n = t1.getClipMask(), i = t1.getClipScope();
                for (const t1 of e){
                    if (!t1.footprint) continue;
                    const e = Tp(t1.footprint.min, t1.footprint.max, t1.id);
                    this._activeRegions.push({
                        min: e.min,
                        max: e.max,
                        hiddenByOverlap: !1,
                        priority: this._sourceIds.length,
                        tileId: t1.id,
                        footprint: t1.footprint,
                        order: r,
                        clipMask: n,
                        clipScope: i
                    });
                }
                this._sourceIds.push(t1.getSourceId());
            }
            _computeReplacement() {
                this._activeRegions.sort((t1, e)=>t1.priority - e.priority || Pp(t1.min, e.min) || Pp(t1.max, e.max) || t1.order - e.order || t1.clipMask - e.clipMask || function(t1, e) {
                        const r = (t1, e)=>t1 + e;
                        return t1.length - e.length || t1.reduce(r, "").localeCompare(e.reduce(r, ""));
                    }(t1.clipScope, e.clipScope));
                let t1 = this._activeRegions.length !== this._prevRegions.length;
                if (!t1) {
                    let e = 0;
                    for(; !t1 && e !== this._activeRegions.length;){
                        const r = this._activeRegions[e], n = this._prevRegions[e];
                        t1 = r.priority !== n.priority || !Ep(r, n) || r.order !== n.order || r.clipMask !== n.clipMask || !wt(r.clipScope, n.clipScope), ++e;
                    }
                }
                if (t1) {
                    ++this._updateTime;
                    for (const t1 of this._activeRegions)t1.order !== Mp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t1.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t1.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t1.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t1.max.y));
                    const t1 = (t1)=>{
                        const e = this._activeRegions;
                        if (t1 >= e.length) return t1;
                        const r = e[t1].priority;
                        for(; t1 < e.length && e[t1].priority === r;)++t1;
                        return t1;
                    };
                    if (this._sourceIds.length > 1) {
                        let e = 0, r = t1(e);
                        for(; e !== r;){
                            let n = e;
                            const i = e;
                            for(; n !== r;){
                                const t1 = this._activeRegions[n];
                                t1.hiddenByOverlap = !1;
                                for(let e = 0; e < i; e++){
                                    const r = this._activeRegions[e];
                                    if (!r.hiddenByOverlap && t1.order === Mp && kp(t1, r) && (t1.hiddenByOverlap = Cp(t1.footprint, t1.tileId, r.footprint, r.tileId), t1.hiddenByOverlap)) break;
                                }
                                ++n;
                            }
                            e = r, r = t1(e);
                        }
                    }
                }
            }
            _setSources(t1) {
                [this._prevRegions, this._activeRegions] = [
                    this._activeRegions,
                    []
                ], this._sourceIds = [];
                for(let e = t1.length - 1; e >= 0; e--)this._addSource(t1[e]);
                this._computeReplacement();
            }
        }, t1.eF = Mp, t1.eG = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t1, e) {
                const r = new na, n = new Ma, i = [], s = t1 + 1 + 2, o = e[0] + 1, a = e[0] + 1 + (1 + e.length), l = (t1, e, r)=>{
                    let n = t1 === s - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e
                    ];
                };
                for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < o; ++t1)for(let e = 0; e < s; ++e)r.emplaceBack(...l(e, t1, (0 === e || e === s - 1) && !0));
                for(let t1 = 0; t1 < e.length; ++t1){
                    const n = e[t1];
                    for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e.length; ++t1){
                    const o = n.length, l = e[t1] + 1 + 2, u = new Ma;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, o = i ? s * (a - e.length + t1 - r) : s;
                        for(let t1 = 0; t1 < s - 1; t1++){
                            const e = r * s + t1;
                            0 === r || i || 0 === t1 || t1 === s - 2 ? (u.emplaceBack(e + 1, e, e + o), u.emplaceBack(e + o, e + o + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + o), n.emplaceBack(e + o, e + o + 1, e + 1));
                        }
                    }
                    const c = el.simpleSegment(0, o, r.length, n.length - o);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = el.simpleSegment(0, o, r.length, n.length - o);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e = this._fillGridMeshWithLods(Ol, Ul);
                this._gridSegments = e.segments, this._gridBuffer = t1.createVertexBuffer(e.vertices, Mc.members), this._gridIndexBuffer = t1.createIndexBuffer(e.indices, !0);
            }
            _createPoles(t1) {
                const e = new Ma;
                for(let t1 = 0; t1 <= Ol; t1++)e.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e, !0);
                const r = new Ea, n = new Ea, i = new Ea, s = new Ea;
                this._poleSegments = [];
                for(let t1 = 0, e = 0; t1 < Dl; t1++){
                    const o = 360 / (1 << t1);
                    r.emplaceBack(0, -Fl, 0, .5, 0), n.emplaceBack(0, -Fl, 0, .5, 1), i.emplaceBack(0, -Fl, 0, .5, .5), s.emplaceBack(0, -Fl, 0, .5, .5);
                    for(let t1 = 0; t1 <= Ol; t1++){
                        let e = t1 / Ol, a = 0;
                        const l = ur(0, o, e), [u, c, h] = $l(Zc, Wc, l, Fl);
                        r.emplaceBack(u, c, h, e, a), n.emplaceBack(u, c, h, e, 1 - a);
                        const p = Mt(l);
                        e = .5 + .5 * Math.sin(p), a = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, a), s.emplaceBack(u, c, h, e, 1 - a);
                    }
                    this._poleSegments.push(el.simpleSegment(e, 0, 66, 64)), e += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, _c, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, _c, !1), this._texturedPoleNorthVertexBuffer = t1.createVertexBuffer(i, _c, !1), this._texturedPoleSouthVertexBuffer = t1.createVertexBuffer(s, _c, !1);
            }
            getGridBuffers(t1, e) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1, e) {
                return [
                    e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer,
                    e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
        }, t1.eH = Ip, t1.eI = Et, t1.eJ = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t1.eK = kt, t1.eL = au, t1.eM = function(t1, e, r) {
            return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1;
        }, t1.eN = H, t1.eO = Gl, t1.eP = V, t1.eQ = M, t1.eR = function([t1, e, r]) {
            const n = Math.hypot(t1, e, r), i = Math.atan2(t1, r), s = .5 * Math.PI - Math.acos(-e / n);
            return new Xl(It(i), It(s));
        }, t1.eS = W, t1.eT = Sf, t1.eU = function(t1) {
            const e = t1.navigator ? t1.navigator.userAgent : null;
            return !!function(t1) {
                if (null == Yt) {
                    const e = t1.navigator ? t1.navigator.userAgent : null;
                    Yt = !!t1.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
                }
                return Yt;
            }(t1) && !(!e || !(e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
        }, t1.eV = function(t1, e) {
            ge = t1, xe = e;
        }, t1.eW = qc, t1.eX = Hc, t1.eY = function(t1) {
            const e = [
                0,
                0,
                0
            ], r = l(new Float64Array(16));
            return c(r, t1.pixelMatrix, t1.globeMatrix), O(e, e, r), new bt(e[0], e[1]);
        }, t1.eZ = function() {
            const t1 = Vd;
            t1 && (t1.isPreloaded() && 1 === t1.numActive() ? (t1.release(zd), Vd = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t1.e_ = function() {
            Fd().acquire(zd);
        }, t1.ea = function(t1, e) {
            if (t1 === e) {
                var r = e[1], n = e[2], i = e[3], s = e[6], o = e[7], a = e[11];
                t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = r, t1[6] = e[9], t1[7] = e[13], t1[8] = n, t1[9] = s, t1[11] = e[14], t1[12] = i, t1[13] = o, t1[14] = a;
            } else t1[0] = e[0], t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = e[1], t1[5] = e[5], t1[6] = e[9], t1[7] = e[13], t1[8] = e[2], t1[9] = e[6], t1[10] = e[10], t1[11] = e[14], t1[12] = e[3], t1[13] = e[7], t1[14] = e[11], t1[15] = e[15];
            return t1;
        }, t1.eb = Tx, t1.ec = ea, t1.ed = La, t1.ee = 256, t1.ef = Uc, t1.eg = ha, t1.eh = f, t1.ei = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[4], t1[4] = e[5], t1[5] = e[6], t1[6] = e[8], t1[7] = e[9], t1[8] = e[10], t1;
        }, t1.ej = Ea, t1.ek = ka, t1.el = hs, t1.em = function(t1, e, r, n, i) {
            return zt((t1 - e) / (r - e) * (i - n) + n, n, i);
        }, t1.en = tt, t1.eo = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], h = c * o - a * u, p = -c * s + a * l, d = u * s - o * l, f = r * h + n * p + i * d;
            return f ? (t1[0] = h * (f = 1 / f), t1[1] = (-c * n + i * u) * f, t1[2] = (a * n - i * o) * f, t1[3] = p * f, t1[4] = (c * r - i * l) * f, t1[5] = (-a * r + i * s) * f, t1[6] = d * f, t1[7] = (-u * r + n * l) * f, t1[8] = (o * r - n * s) * f, t1) : null;
        }, t1.ep = 2, t1.eq = C, t1.er = zf, t1.es = [
            1,
            1,
            1
        ], t1.et = class {
            constructor(t1, e, r, n){
                this.context = t1, this.format = n, this.size = r, this.texture = t1.gl.createTexture();
                const [i, s, o] = this.size, { gl: a } = t1;
                a.bindTexture(a.TEXTURE_3D, this.texture), t1.pixelStoreUnpackFlipY.set(!1), t1.pixelStoreUnpack.set(1), t1.pixelStoreUnpackPremultiplyAlpha.set(!1), a.texImage3D(a.TEXTURE_3D, 0, this.format, i, s, o, 0, hf(this.format), pf(this.format), e.data);
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_3D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }, t1.eu = Wx, t1.ev = X, t1.ew = function(t1, e, r, n) {
            var i = e[0], s = e[1], o = e[2], a = e[3];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = o + n * (r[2] - o), t1[3] = a + n * (r[3] - a), t1;
        }, t1.ex = Vf, t1.ey = va, t1.ez = Ba, t1.f = function(t1) {
            return btoa(encodeURIComponent(t1).replace(/%([0-9A-F]{2})/g, (t1, e)=>String.fromCharCode(Number("0x" + e))));
        }, t1.f0 = function(t1, e, r = !1) {
            if (uo === ao.deferred || uo === ao.loading || uo === ao.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            co = de.resolveURL(t1), uo = ao.deferred, lo = e, po(), r || yo();
        }, t1.f1 = function(t1) {
            Ud = de.resolveURL(t1), jd || (jd = new Bd(Fd(), new tr)), jd.broadcast("setMeshoptUrl", Ud);
        }, t1.f2 = Xd, t1.f3 = function(t1) {
            Rd = de.resolveURL(t1), jd || (jd = new Bd(Fd(), new tr)), jd.broadcast("setDracoUrl", Rd);
        }, t1.f4 = qd, t1.f5 = kd, t1.f6 = function(t1) {
            const e = _e();
            if (!e) return;
            const r = e.delete(ye);
            t1 && r.then(()=>t1()).catch(t1);
        }, t1.f7 = Td, t1.f8 = qs, t1.f9 = hh, t1.fa = tg, t1.fb = aw, t1.fc = cw, t1.fd = mm, t1.fe = Su, t1.ff = "hd_road_elevation", t1.fg = Gu, t1.fh = Ot, t1.fi = Kh, t1.fj = Wy, t1.fk = Xy, t1.fl = function(t1, e, r, n, i, s, o, a = 1, l, u, c) {
            t1.createArrays(), t1.tilePixelRatio = Cn / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const h = t1.layers[0].layout, p = t1.layers[0]._unevaluatedLayout._values, d = {};
            d.scaleFactor = a, d.textSizeScaleRange = h.get("text-size-scale-range"), d.iconSizeScaleRange = h.get("icon-size-scale-range");
            const [f, m] = d.textSizeScaleRange, [y, g] = d.iconSizeScaleRange;
            d.textScaleFactor = zt(d.scaleFactor, f, m), d.iconScaleFactor = zt(d.scaleFactor, y, g);
            const x = p["text-size"], v = p["icon-size"];
            if ("composite" === t1.textSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.textSizeData;
                d.compositeTextSizes = [
                    x.possiblyEvaluate(new xo(e, {
                        worldview: c
                    }), s),
                    x.possiblyEvaluate(new xo(r, {
                        worldview: c
                    }), s)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.iconSizeData;
                d.compositeIconSizes = [
                    v.possiblyEvaluate(new xo(e, {
                        worldview: c
                    }), s),
                    v.possiblyEvaluate(new xo(r, {
                        worldview: c
                    }), s)
                ];
            }
            d.layoutTextSize = x.possiblyEvaluate(new xo(o + 1, {
                worldview: c
            }), s), d.layoutIconSize = v.possiblyEvaluate(new xo(o + 1, {
                worldview: c
            }), s), d.textMaxSize = x.possiblyEvaluate(new xo(18, {
                worldview: c
            }), s);
            const b = h.get("symbol-placement"), w = "map" === h.get("text-rotation-alignment") && "point" !== b, _ = h.get("text-size");
            let A = !1;
            const M = [];
            for (const o of t1.features){
                const a = h.get("text-font").evaluate(o, {}, s).join(","), f = _.evaluate(o, {}, s) * d.textScaleFactor, m = d.layoutTextSize.evaluate(o, {}, s) * d.textScaleFactor, y = d.layoutIconSize.evaluate(o, {}, s) * d.iconScaleFactor, g = {
                    horizontal: {},
                    vertical: void 0
                }, x = o.text;
                let v, I = [
                    0,
                    0
                ];
                if (x) {
                    const n = x.toString(), u = h.get("text-letter-spacing").evaluate(o, {}, s) * Gm, c = h.get("text-line-height").evaluate(o, {}, s) * Gm, p = Qs(n) ? u : 0, d = h.get("text-anchor").evaluate(o, {}, s), y = h.get("text-variable-anchor");
                    if (!y) {
                        const t1 = h.get("text-radial-offset").evaluate(o, {}, s);
                        if (t1) I = gg(d, [
                            t1 * Gm,
                            mg
                        ]);
                        else {
                            const t1 = h.get("text-offset").evaluate(o, {}, s);
                            I = [
                                t1[0] * Gm,
                                t1[1] * Gm
                            ];
                        }
                    }
                    let v = w ? "center" : h.get("text-justify").evaluate(o, {}, s);
                    const _ = "point" === b, A = _ ? h.get("text-max-width").evaluate(o, {}, s) * Gm : 1 / 0, M = (s)=>{
                        t1.allowVerticalPlacement && Js(n) && (g.vertical = xy(x, e, r, i, a, A, c, d, s, p, I, my.vertical, !0, m, f, l));
                    };
                    if (!w && y) {
                        const t1 = "auto" === v ? y.map((t1)=>Ig(t1)) : [
                            v
                        ];
                        let n = !1;
                        for(let s = 0; s < t1.length; s++){
                            const o = t1[s];
                            if (!g.horizontal[o]) if (n) g.horizontal[o] = g.horizontal[0];
                            else {
                                const t1 = xy(x, e, r, i, a, A, c, "center", o, p, I, my.horizontal, !1, m, f, l);
                                t1 && (g.horizontal[o] = t1, n = 1 === t1.positionedLines.length);
                            }
                        }
                        M("left");
                    } else {
                        if ("auto" === v && (v = Ig(d)), _ || h.get("text-writing-mode").indexOf("horizontal") >= 0 || !Js(n)) {
                            const t1 = xy(x, e, r, i, a, A, c, d, v, p, I, my.horizontal, !1, m, f, l);
                            t1 && (g.horizontal[v] = t1);
                        }
                        M(_ ? "left" : v);
                    }
                }
                let S, P, E, k, z, T, B = !1;
                const V = h.get("icon-text-fit").evaluate(o, {}, s);
                if (o.icon && o.icon.hasPrimary()) {
                    const e = bg(o.icon, t1.iconSizeData, p["icon-size"], s, t1.zoom, o, l, d.iconScaleFactor, c);
                    S = e.iconPrimary, E = e.iconSecondary;
                    const r = S.toString();
                    if (P = n.get(r), P && (z = h.get("icon-offset").evaluate(o, {}, s), T = h.get("icon-anchor").evaluate(o, {}, s), v = ky(i.get(r), E ? i.get(E.toString()) : void 0, z, T), B = P.sdf, void 0 === t1.sdfIcons ? t1.sdfIcons = P.sdf : t1.sdfIcons !== P.sdf && Gt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (P.pixelRatio !== t1.pixelRatio || 0 !== h.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0)), E) {
                        const t1 = E.toString();
                        k = n.get(t1);
                    }
                }
                A = A || !(!o.icon || !o.icon.hasSecondary());
                const C = Tg(g.horizontal) || g.vertical;
                t1.iconsInText || (t1.iconsInText = !!C && C.iconsInText);
                const F = m * d.textScaleFactor / Gm, { defaultShapedIcon: D, verticallyShapedIcon: L } = Sg(t1, v, h, o, s, g, F, z, V);
                "none" !== V && v && (Ty(v) || By(v)) && (xg(0, P, S, v, D, V, u, n, i), xg(0, k, E, v, D, V, u, n, i), L && (xg(0, P, S, v, L, V, u, n, i), xg(0, k, E, v, L, V, u, n, i))), v = D, M.push({
                    feature: o,
                    shapedTextOrientations: g,
                    shapedText: C,
                    shapedIcon: v,
                    iconPrimary: S,
                    iconSecondary: E,
                    iconOffset: z,
                    iconAnchor: T,
                    verticallyShapedIcon: L,
                    layoutTextSize: m,
                    layoutIconSize: y,
                    textOffset: I,
                    isSDFIcon: B,
                    iconTextFit: V
                });
            }
            return {
                featureData: M,
                sizes: d,
                hasAnySecondaryIcon: A,
                textAlongLine: w,
                symbolPlacement: b
            };
        }, t1.fm = Yy, t1.fn = function(t1, e, r, n, i, s, o, a, l, u) {
            const { featureData: c, hasAnySecondaryIcon: h, sizes: p, textAlongLine: d, symbolPlacement: f } = e;
            for (const e of c){
                const { shapedIcon: r, verticallyShapedIcon: s, feature: c, shapedTextOrientations: m, shapedText: y, layoutTextSize: g, textOffset: x, isSDFIcon: v, iconPrimary: b, iconSecondary: w, iconTextFit: _, iconOffset: A } = e;
                _g(r, u.iconPositions, b, w), _g(s, u.iconPositions, b, w), Ag(m, u.iconPositions), wg(b, w, u.iconPositions), (y || r) && Pg(t1, c, m, r, s, l, p, g, 0, x, v, n, i, o, a, h, _, A, d, f);
            }
            r && t1.generateCollisionDebugBuffers(s, t1.collisionBoxArray, p.textScaleFactor);
        }, t1.fo = Mu, t1.fp = fb, t1.fq = vu, t1.fr = function(t1) {
            let e = 0;
            if (new Uint32Array(t1, 0, 1)[0] !== nf) {
                const r = new Uint32Array(t1, 0, 7), [, , n, i, s, o] = r;
                e = r.byteLength + i + s + o + s, (n !== t1.byteLength || e >= t1.byteLength) && Gt("Invalid b3dm header information.");
            }
            return cf(t1, e);
        }, t1.fs = function(t1, e) {
            const r = Xf(t1);
            for (const t1 of r){
                for (const e of t1.meshes)Zf(e);
                t1.lights && (t1.lightMeshIndex = t1.meshes.length, t1.meshes.push(Yf(t1.lights, e)));
            }
            return r;
        }, t1.ft = rv, t1.fu = Zt, t1.fv = Ed, t1.fw = go, t1.fx = ao, t1.fy = function(t1) {
            Ae(), null != be && be.then((e)=>{
                e.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e.delete(r[n]).catch((t1)=>Gt(t1.message));
                }).catch((t1)=>Gt(t1.message));
            }).catch((t1)=>Gt(t1.message));
        }, t1.g = function(t1, e) {
            return Fe(Ct(t1, {
                method: "GET"
            }), e);
        }, t1.h = Ct, t1.i = function(t1) {
            return ne.API_STYLE_REGEX.test(t1) && !se(t1);
        }, t1.j = function(t1) {
            return 0 === t1.indexOf("mapbox:");
        }, t1.k = ie, t1.l = Ie, t1.m = function(t1) {
            return decodeURIComponent(atob(t1).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, t1.n = function(t1, e) {
            return Fe(Ct(t1, {
                type: "json"
            }), e);
        }, t1.o = Ne, t1.p = function(t1, e) {
            return Fe(Ct(t1, {
                method: "POST"
            }), e);
        }, t1.q = de, t1.r = ph, t1.s = function(t1) {
            try {
                const e = self[t1];
                return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }, t1.t = pe, t1.u = function() {
            return function t1(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t1);
            }();
        }, t1.v = function(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }, t1.w = Gt, t1.x = function() {
            return Cd || (Cd = new Td), Cd;
        }, t1.y = rb, t1.z = Ke;
    });
    define([
        "./shared"
    ], function(e) {
        function t1(e) {
            const t1 = e ? e.url.toString() : void 0;
            return t1 ? performance.getEntriesByName(t1) : [];
        }
        function s(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);
            if (Array.isArray(e)) {
                let t1 = "[";
                for (const i of e)t1 += `${s(i)},`;
                return `${t1}]`;
            }
            let t1 = "{";
            for (const i of Object.keys(e).sort())t1 += `${i}:${s(e[i])},`;
            return `${t1}}`;
        }
        function i(t1) {
            let i = "";
            for (const o of e.bu)i += `/${s(t1[o])}`;
            return i;
        }
        class o {
            constructor(e){
                this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);
            }
            replace(e, t1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e, [], t1);
            }
            update(t1, o, n) {
                this._options = n;
                for (const s of t1)this._layerConfigs[s.id] = s, (this._layers[s.id] = e.dn(s, this.scope, null, this._options)).compileFilter(n), this.keyCache[s.id] && delete this.keyCache[s.id];
                for (const e of o)delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
                this.familiesBySource = {};
                const r = function(e, t1) {
                    const o = {};
                    for(let n = 0; n < e.length; n++){
                        const r = e[n];
                        let a = t1 && t1[r.id];
                        a || ("symbol" === r.type ? a = r.id : (a = i(r), "line" === r.type && r.paint && function e(t1) {
                            return "string" == typeof t1 && "line-progress" === t1 || (Array.isArray(t1) ? t1.some(e) : !(!t1 || "object" != typeof t1) && Object.values(t1).some(e));
                        }(r.paint["line-width"]) && (a += `/${s(r.paint["line-width"])}`))), t1 && (t1[r.id] = a);
                        let l = o[a];
                        l || (l = o[a] = []), l.push(r);
                    }
                    const n = [];
                    for(const e in o)n.push(o[e]);
                    return n;
                }(Object.values(this._layerConfigs), this.keyCache);
                for (const e of r){
                    const t1 = e.map((e)=>this._layers[e.id]), s = t1[0];
                    if ("none" === s.visibility) continue;
                    const i = s.source || "";
                    let o = this.familiesBySource[i];
                    o || (o = this.familiesBySource[i] = {});
                    const n = s.sourceLayer || "_geojsonTileLayer";
                    let r = o[n];
                    r || (r = o[n] = []), r.push(t1);
                }
            }
        }
        const n = 1 * e.fa;
        class r {
            constructor(t1){
                const s = {}, i = [];
                for(const e in t1){
                    const o = t1[e], r = s[e] = {};
                    for(const e in o.glyphs){
                        const t1 = o.glyphs[+e];
                        if (!t1 || 0 === t1.bitmap.width || 0 === t1.bitmap.height) continue;
                        const s = t1.metrics.localGlyph ? n : 1, a = {
                            x: 0,
                            y: 0,
                            w: t1.bitmap.width + 2 * s,
                            h: t1.bitmap.height + 2 * s
                        };
                        i.push(a), r[e] = a;
                    }
                }
                const { w: o, h: r } = e.H(i), a = new e.f9({
                    width: o || 1,
                    height: r || 1
                });
                for(const i in t1){
                    const o = t1[i];
                    for(const t1 in o.glyphs){
                        const r = o.glyphs[+t1];
                        if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;
                        const l = s[i][t1], c = r.metrics.localGlyph ? n : 1;
                        e.f9.copy(r.bitmap, a, {
                            x: 0,
                            y: 0
                        }, {
                            x: l.x + c,
                            y: l.y + c
                        }, r.bitmap);
                    }
                }
                this.image = a, this.positions = s;
            }
        }
        e.f8(r, "GlyphAtlas");
        class a {
            constructor(t1){
                this.tileID = new e.aM(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.lut = t1.lut, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.scope = t1.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.request && t1.request.collectResourceTiming, this.promoteId = t1.promoteId, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = e.aW(t1.tileID.canonical, t1.projection), this.projection = t1.projection, this.worldview = t1.worldview, this.localizableLayerIds = t1.localizableLayerIds, this.brightness = t1.brightness, this.extraShadowCaster = !!t1.extraShadowCaster, this.tessellationStep = t1.tessellationStep, this.scaleFactor = t1.scaleFactor, this.worldview = t1.worldview;
            }
            parse(t1, s, i, o, n, a) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new e.b0;
                const c = new e.fb(Object.keys(t1.layers).sort()), h = new e.fc(this.tileID, this.promoteId);
                h.bucketLayerIDs = [];
                const u = {}, d = new e.fd(256, 256), f = {
                    featureIndex: h,
                    iconDependencies: new Map,
                    patternDependencies: new Map,
                    glyphDependencies: {},
                    lineAtlas: d,
                    availableImages: i,
                    brightness: this.brightness,
                    scaleFactor: this.scaleFactor,
                    elevationFeatures: void 0
                }, p = [], g = s.familiesBySource[this.source];
                for(const s in g){
                    const n = t1.layers[s];
                    if (!n) continue;
                    let r = !1, a = !1, d = !1;
                    for (const e of g[s])"symbol" === e[0].type ? r = !0 : a = !0, e[0].is3D() && "model" !== e[0].type && (d = !0);
                    if (this.extraShadowCaster && !d) continue;
                    if (!0 === this.isSymbolTile && !r) continue;
                    if (!1 === this.isSymbolTile && !a) continue;
                    1 === n.version && e.w(`Vector tile source "${this.source}" layer "${s}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const m = c.encode(s), y = [];
                    let w = !1;
                    for(let t1 = 0, i = 0; t1 < n.length; t1++){
                        const o = n.feature(t1), r = h.getId(o, s);
                        if (this.localizableLayerIds && this.localizableLayerIds.has(s)) {
                            const e = o.properties ? o.properties.worldview : null;
                            if (this.worldview && "string" == typeof e) if ("all" === e) o.properties.$localized = !0;
                            else {
                                if (!e.split(",").includes(this.worldview)) continue;
                                o.properties.$localized = !0, o.properties.worldview = this.worldview;
                            }
                        }
                        !w && o.properties && o.properties.hasOwnProperty(e.fe) && (w = !0), y.push({
                            feature: o,
                            id: r,
                            index: i,
                            sourceLayerIndex: m
                        }), i++;
                    }
                    w && !f.elevationFeatures && t1.layers.hasOwnProperty(e.ff) && (f.elevationFeatures = e.fg.parseFrom(t1.layers[e.ff], this.canonical));
                    for (const t1 of g[s]){
                        const s = t1[0];
                        if (this.extraShadowCaster && (!s.is3D() || "model" === s.type)) continue;
                        if (void 0 !== this.isSymbolTile && "symbol" === s.type !== this.isSymbolTile) continue;
                        if (s.minzoom && this.zoom < Math.floor(s.minzoom)) continue;
                        if (s.maxzoom && this.zoom >= s.maxzoom) continue;
                        if ("none" === s.visibility) continue;
                        l(t1, this.zoom, f.brightness, i, this.worldview);
                        const n = u[s.id] = s.createBucket({
                            index: h.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            lut: this.lut,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: m,
                            sourceID: this.source,
                            projection: this.projection.spec,
                            tessellationStep: this.tessellationStep,
                            styleDefinedModelURLs: o,
                            worldview: this.worldview
                        });
                        h.bucketLayerIDs.push(t1.map((t1)=>e.C(t1.id, t1.scope)));
                        let r = n.prepare ? n.prepare() : null;
                        null != r ? (r = r.then(()=>n.populate(y, f, this.tileID.canonical, this.tileTransform)), p.push(r)) : n.populate(y, f, this.tileID.canonical, this.tileTransform);
                    }
                }
                const m = ()=>{
                    let s, o, p, g, m, y;
                    d.trim();
                    const w = {
                        type: "maybePrepare",
                        isSymbolTile: this.isSymbolTile,
                        zoom: this.zoom
                    }, b = ()=>{
                        if (s) return this.status = "done", a(s);
                        if (this.extraShadowCaster) this.status = "done", a(null, {
                            buckets: Object.values(u).filter((e)=>!e.isEmpty()),
                            featureIndex: h,
                            collisionBoxArray: null,
                            glyphAtlasImage: null,
                            lineAtlas: null,
                            imageAtlas: null,
                            brightness: f.brightness,
                            glyphMap: null,
                            iconMap: null,
                            glyphPositions: null
                        });
                        else if (o && p && g) {
                            const t1 = new r(o), s = new Map;
                            for (const [t1, i] of p.entries()){
                                const { imagePosition: o } = e.fj(t1, i, e.fk);
                                s.set(t1, o);
                            }
                            const a = {};
                            for(const n in u){
                                const r = u[n];
                                r instanceof e.b1 && (l(r.layers, this.zoom, f.brightness, i, this.worldview), a[n] = e.fl(r, o, t1.positions, p, s, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, m, this.worldview));
                            }
                            const c = {
                                iconsPending: !0,
                                patternsPending: !0
                            };
                            this.rasterizeIfNeeded(n, p, m, ()=>{
                                c.iconsPending = !1, x(a, t1, c);
                            }), this.rasterizeIfNeeded(n, g, y, ()=>{
                                c.patternsPending = !1, x(a, t1, c);
                            });
                        }
                    }, x = (t1, s, o, n)=>{
                        if (o.iconsPending || o.patternsPending) return;
                        const r = new e.fm(p, g, this.lut);
                        for(const s in u){
                            const o = u[s];
                            if (s in t1) e.fn(o, t1[s], this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, p, r);
                            else if (o.hasPattern && (o instanceof e.b7 || o instanceof e.b8 || o instanceof e.e4)) {
                                l(o.layers, this.zoom, f.brightness, i, this.worldview);
                                const e = Object.fromEntries(r.patternPositions);
                                o.addFeatures(f, this.tileID.canonical, e, i, this.tileTransform, this.brightness);
                            }
                        }
                        this.status = "done", a(null, {
                            buckets: Object.values(u).filter((e)=>!e.isEmpty()),
                            featureIndex: h,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: s.image,
                            lineAtlas: d,
                            imageAtlas: r,
                            brightness: f.brightness
                        });
                    };
                    if (!this.extraShadowCaster) {
                        const t1 = e.fh(f.glyphDependencies, (e)=>Object.keys(e).map(Number));
                        Object.keys(t1).length ? n.send("getGlyphs", {
                            uid: this.uid,
                            stacks: t1
                        }, (e, t1)=>{
                            s || (s = e, o = t1, b());
                        }, void 0, !1, w) : o = {};
                        const i = Array.from(f.iconDependencies.keys()).map((t1)=>e.I.parse(t1));
                        i.length ? n.send("getImages", {
                            images: i,
                            source: this.source,
                            scope: this.scope,
                            tileID: this.tileID,
                            type: "icons"
                        }, (e, t1)=>{
                            s || (s = e, p = new Map, m = this.updateImageMapAndGetImageTaskQueue(p, t1, f.iconDependencies), b());
                        }, void 0, !1, w) : (p = new Map, m = new Map);
                        const r = Array.from(f.patternDependencies.keys()).map((t1)=>e.I.parse(t1));
                        r.length ? n.send("getImages", {
                            images: r,
                            source: this.source,
                            scope: this.scope,
                            tileID: this.tileID,
                            type: "patterns"
                        }, (e, t1)=>{
                            s || (s = e, g = new Map, y = this.updateImageMapAndGetImageTaskQueue(g, t1, f.patternDependencies), b());
                        }, void 0, !1, w) : (g = new Map, y = new Map);
                    }
                    if (f.elevationFeatures && f.elevationFeatures.length > 0) {
                        const s = [];
                        for (const t1 of Object.values(u))if (t1 instanceof e.b8) {
                            const e = t1.getUnevaluatedPortalGraph();
                            e && s.push(e);
                        }
                        const i = e.fi.evaluate(s);
                        for (const s of Object.values(u))if (s instanceof e.b8) {
                            const e = t1.layers[c.decode(s.sourceLayerIndex)];
                            s.setEvaluatedPortalGraph(i, e, this.tileID.canonical, f.availableImages, f.brightness);
                        }
                    }
                    b();
                };
                p.length > 0 ? Promise.allSettled(p).then(m).catch(a) : m();
            }
            rasterizeIfNeeded(e, t1, s, i) {
                Array.from(t1.values()).some((e)=>e.usvg) ? this.rasterize(e, t1, s, i) : i();
            }
            updateImageMapAndGetImageTaskQueue(e, t1, s) {
                const i = new Map;
                for (const o of t1.keys()){
                    const n = s.get(o) || [];
                    for (const s of n){
                        const o = s.toString(), n = t1.get(s.id.toString());
                        n.usvg ? i.has(o) || (i.set(o, s), e.set(o, Object.assign({}, n))) : e.set(o, n);
                    }
                }
                return i;
            }
            rasterize(e, t1, s, i) {
                this.rasterizeTask = e.send("rasterizeImages", {
                    scope: this.scope,
                    tasks: s
                }, (e, s)=>{
                    if (!e) for (const [e, i] of s.entries()){
                        const s = Object.assign(t1.get(e), {
                            data: i
                        });
                        t1.set(e, s);
                    }
                    i();
                });
            }
            cancelRasterize() {
                this.rasterizeTask && this.rasterizeTask.cancel();
            }
        }
        function l(t1, s, i, o, n) {
            const r = new e.aa(s, {
                brightness: i,
                worldview: n
            });
            for (const e of t1)e.recalculate(r, o);
        }
        class c extends e.E {
            constructor(t1, s, i, o, n, r, a){
                super(), this.actor = t1, this.layerIndex = s, this.availableImages = i, this.availableModels = o, this.loadVectorData = r || e.aJ, this.loading = {}, this.loaded = {}, this.deduped = new e.aI(t1.scheduler), this.isSpriteLoaded = n, this.scheduler = t1.scheduler, this.brightness = a;
            }
            loadTile(s, i) {
                const o = s.uid, n = s && s.request, r = n && n.collectResourceTiming, l = this.loading[o] = new a(s);
                l.abort = this.loadVectorData(s, (a, c)=>{
                    const h = !this.loading[o];
                    if (delete this.loading[o], l.cancelRasterize(), h || a || !c) return l.status = "done", h || (this.loaded[o] = l), i(a);
                    const u = c.rawData, d = {};
                    c.expires && (d.expires = c.expires), c.cacheControl && (d.cacheControl = c.cacheControl), l.vectorTile = c.vectorTile || new e.fo(new e.bq(u));
                    const f = ()=>{
                        l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (s, o)=>{
                            if (s || !o) return i(s);
                            const a = {};
                            if (r) {
                                const e = t1(n);
                                e.length > 0 && (a.resourceTiming = JSON.parse(JSON.stringify(e)));
                            }
                            i(null, e.h({
                                rawTileData: u.slice(0)
                            }, o, d, a));
                        });
                    };
                    this.isSpriteLoaded ? f() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(f, {
                            type: "parseTile",
                            isSymbolTile: s.isSymbolTile,
                            zoom: s.tileZoom
                        }) : f();
                    }), this.loaded = this.loaded || {}, this.loaded[o] = l;
                });
            }
            reloadTile(t1, s) {
                const i = this.loaded, o = t1.uid;
                if (i && i[o]) {
                    const n = i[o];
                    n.scaleFactor = t1.scaleFactor, n.showCollisionBoxes = t1.showCollisionBoxes, n.projection = t1.projection, n.brightness = t1.brightness, n.tileTransform = e.aW(t1.tileID.canonical, t1.projection), n.extraShadowCaster = t1.extraShadowCaster, n.lut = t1.lut, n.worldview = t1.worldview;
                    const r = (e, t1)=>{
                        const i = n.reloadCallback;
                        i && (delete n.reloadCallback, n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i)), s(e, t1);
                    };
                    "parsing" === n.status ? n.reloadCallback = r : "done" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, r) : r());
                } else s(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, i = this.loading[s];
                i && (i.abort && i.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class h {
            loadTile(t1, s) {
                const { uid: i, encoding: o, rawImageData: n, padding: r } = t1, a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;
                s(null, new e.fp(i, a, o, r < 1));
            }
            reloadTile(e, t1) {
                t1(null, null);
            }
            abortTile(e, t1) {
                t1();
            }
            removeTile(e, t1) {
                t1();
            }
            getImageData(e, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const s = this.offscreenCanvasContext.getImageData(-t1, -t1, e.width + 2 * t1, e.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;
            }
        }
        e.bp.setPbf(e.bq);
        class u {
            constructor(t1){
                this._mrt = new e.bp(t1.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = t1.uid, this.tileID = t1.tileID, this.source = t1.source;
            }
            parse(t1, s) {
                const i = this._mrt;
                this.status = "parsing", this._entireBuffer = t1;
                try {
                    i.parseHeader(t1), this._isHeaderLoaded = !0;
                    const o = [];
                    for(const s in i.layers){
                        const n = i.getLayer(s), r = n.getDataRange(n.getBandList()), a = i.createDecodingTask(r), l = t1.slice(r.firstByte, r.lastByte + 1), c = e.bp.performDecoding(l, a).then((e)=>a.complete(null, e)).catch((e)=>a.complete(e, null));
                        o.push(c);
                    }
                    Promise.allSettled(o).then(()=>s(null, i)).catch((e)=>s(e));
                } catch (e) {
                    s(e);
                }
            }
        }
        class d {
            constructor(e){
                this.actor = e, this.loading = {}, this.loaded = {};
            }
            loadTile(t1, s) {
                const i = t1.uid, o = t1.request, n = this.loading[i] = new u(t1), { cancel: r } = e.br(o, (e, t1, o, r)=>{
                    const a = !this.loading[i];
                    if (delete this.loading[i], a || e || !t1) return n.status = "done", a || (this.loaded[i] = n), s(e);
                    n.parse(t1, (e, t1)=>{
                        if (e || !t1) return s(e);
                        s(null, t1, o, r);
                    }), this.loaded[i] = n;
                });
                n.abort = r;
            }
            reloadTile(e, t1) {
                t1(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, i = this.loading[s];
                i && (i.abort && i.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = e.uid;
                this.loaded[s] && delete this.loaded[s], t1();
            }
            decodeRasterArray(t1, s) {
                e.bp.performDecoding(t1.buffer, t1.task).then((e)=>s(null, e)).catch((e)=>s(e));
            }
        }
        const f = e.fq.prototype.toGeoJSON;
        class p {
            constructor(t1){
                this._feature = t1, this.extent = e.aj, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const s of this._feature.geometry)t1.push([
                        new e.P(s[0], s[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const s of this._feature.geometry){
                        const i = [];
                        for (const t1 of s)i.push(new e.P(t1[0], t1[1]));
                        t1.push(i);
                    }
                    return t1;
                }
            }
            toGeoJSON(e, t1, s) {
                return f.call(this, e, t1, s);
            }
        }
        class g {
            constructor(t1, s){
                this.name = t1, this.extent = e.aj, this.length = s.length, this._jsonFeatures = s;
            }
            feature(e) {
                return new p(this._jsonFeatures[e]);
            }
        }
        class m {
            constructor(t1){
                this.layers = {}, this.extent = e.aj;
                for (const e of Object.keys(t1))this.layers[e] = new g(e, t1[e]);
            }
        }
        const y = 64 / 4096, w = 128;
        class b {
            constructor(){
                this.features = new Map;
            }
            clear() {
                this.features.clear();
            }
            load(e = [], t1) {
                for (const s of e){
                    const e = s.id;
                    if (null == e) continue;
                    let i = this.features.get(e);
                    i && this.updateCache(i, t1), s.geometry ? (i = v(s), this.updateCache(i, t1), this.features.set(e, i)) : this.features.delete(e), this.updateCache(i, t1);
                }
            }
            updateCache(e, t1) {
                for (const { canonical: s, uid: i } of Object.values(t1)){
                    const { z: o, x: n, y: r } = s;
                    x(e, Math.pow(2, o), n, r) && delete t1[i];
                }
            }
            getTile(e, t1, s) {
                const i = Math.pow(2, e), o = [];
                for (const e of this.features.values())x(e, i, t1, s) && o.push(P(e, i, t1, s));
                return {
                    features: o
                };
            }
            getFeatures() {
                return [
                    ...this.features.values()
                ];
            }
        }
        function x({ minX: e, minY: t1, maxX: s, maxY: i }, o, n, r) {
            return e < (n + 1 + y) / o && t1 < (r + 1 + y) / o && s > (n - y) / o && i > (r - y) / o;
        }
        function v(e) {
            const { id: t1, geometry: s, properties: i } = e;
            if (!s) return;
            if ("GeometryCollection" === s.type) throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: o, coordinates: n } = s, r = {
                id: t1,
                type: 1,
                geometry: [],
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }, a = r.geometry;
            if ("Point" === o) I(n, a, r);
            else if ("MultiPoint" === o) for (const e of n)I(e, a, r);
            else if ("LineString" === o) r.type = 2, S(n, a, r);
            else if ("MultiLineString" === o) r.type = 2, M(n, a, r);
            else if ("Polygon" === o) r.type = 3, M(n, a, r, !0);
            else {
                if ("MultiPolygon" !== o) throw new Error("Input data is not a valid GeoJSON object.");
                r.type = 3;
                for (const e of n)M(e, a, r, !0);
            }
            return r;
        }
        function I([t1, s], i, o) {
            const n = e.aD(t1);
            let r = e.aH(s);
            r = r < 0 ? 0 : r > 1 ? 1 : r, i.push(n, r), o.minX = Math.min(o.minX, n), o.minY = Math.min(o.minY, r), o.maxX = Math.max(o.maxX, n), o.maxY = Math.max(o.maxY, r);
        }
        function S(e, t1, s, i = !1, o = !1) {
            const n = [];
            for (const t1 of e)I(t1, n, s);
            t1.push(n), i && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(n, o);
        }
        function M(e, t1, s, i = !1) {
            for(let o = 0; o < e.length; o++)S(e[o], t1, s, i, 0 === o);
        }
        function P(t1, s, i, o) {
            const { id: n, type: r, geometry: a, tags: l } = t1, c = [];
            if (1 === r) !function(t1, s, i, o, n) {
                for(let r = 0; r < t1.length; r += 2){
                    const a = Math.round(e.aj * (t1[r + 0] * s - i)), l = Math.round(e.aj * (t1[r + 1] * s - o));
                    n.push([
                        a,
                        l
                    ]);
                }
            }(a, s, i, o, c);
            else for (const e of a)T(e, s, i, o, c);
            return {
                id: n,
                type: r,
                geometry: c,
                tags: l
            };
        }
        function T(t1, s, i, o, n) {
            const r = -w, a = e.aj + w;
            let l;
            for(let c = 0; c < t1.length - 2; c += 2){
                let h = Math.round(e.aj * (t1[c + 0] * s - i)), u = Math.round(e.aj * (t1[c + 1] * s - o)), d = Math.round(e.aj * (t1[c + 2] * s - i)), f = Math.round(e.aj * (t1[c + 3] * s - o));
                const p = d - h, g = f - u;
                h < r && d < r || (h < r ? (u += Math.round(g * ((r - h) / p)), h = r) : d < r && (f = u + Math.round(g * ((r - h) / p)), d = r), u < r && f < r || (u < r ? (h += Math.round(p * ((r - u) / g)), u = r) : f < r && (d = h + Math.round(p * ((r - u) / g)), f = r), h >= a && d >= a || (h >= a ? (u += Math.round(g * ((a - h) / p)), h = a) : d >= a && (f = u + Math.round(g * ((a - h) / p)), d = a), u >= a && f >= a || (u >= a ? (h += Math.round(p * ((a - u) / g)), u = a) : f >= a && (d = h + Math.round(p * ((a - u) / g)), f = a), l && h === l[l.length - 1][0] && u === l[l.length - 1][1] || (l = [
                    [
                        h,
                        u
                    ]
                ], n.push(l)), l.push([
                    d,
                    f
                ])))));
            }
        }
        function k({ name: t1, features: s }, i) {
            i.writeStringField(1, t1), i.writeVarintField(5, e.aj);
            const o = new Map, n = new Map, r = {
                keys: o,
                values: n,
                feature: null
            };
            for (const e of s)r.feature = e, i.writeMessage(2, L, r);
            for (const e of o.keys())i.writeStringField(3, e);
            for (const e of n.keys())i.writeMessage(4, D, e);
        }
        function L(e, t1) {
            const s = e.feature;
            void 0 === s.id || isNaN(+s.id) || t1.writeVarintField(1, +s.id), s.tags && t1.writeMessage(2, j, e), t1.writeVarintField(3, s.type), t1.writeMessage(4, z, s);
        }
        function j({ keys: e, values: t1, feature: s }, i) {
            for (const o of Object.keys(s.tags)){
                let n = s.tags[o];
                if (null === n) continue;
                let r = e.get(o);
                void 0 === r && (r = e.size, e.set(o, r)), i.writeVarint(r);
                const a = typeof n;
                "string" !== a && "boolean" !== a && "number" !== a && (n = JSON.stringify(n));
                let l = t1.get(n);
                void 0 === l && (l = t1.size, t1.set(n, l)), i.writeVarint(l);
            }
        }
        function _(e, t1) {
            return (t1 << 3) + (7 & e);
        }
        function C(e) {
            return e << 1 ^ e >> 31;
        }
        function z(e, t1) {
            const { geometry: s, type: i } = e;
            let o = 0, n = 0;
            if (1 === i) {
                t1.writeVarint(_(1, s.length));
                for (const e of s){
                    const s = e[0] - o, i = e[1] - n;
                    t1.writeVarint(C(s)), t1.writeVarint(C(i)), o += s, n += i;
                }
            } else for (const e of s){
                t1.writeVarint(_(1, 1));
                const s = e.length - (3 === i ? 1 : 0);
                for(let i = 0; i < s; i++){
                    1 === i && t1.writeVarint(_(2, s - 1));
                    const r = e[i][0] - o, a = e[i][1] - n;
                    t1.writeVarint(C(r)), t1.writeVarint(C(a)), o += r, n += a;
                }
                3 === i && t1.writeVarint(_(7, 1));
            }
        }
        function D(e, t1) {
            const s = typeof e;
            "string" === s ? t1.writeStringField(1, e) : "boolean" === s ? t1.writeBooleanField(7, e) : "number" === s && (e % 1 != 0 ? t1.writeDoubleField(3, e) : e < 0 ? t1.writeSVarintField(6, e) : t1.writeVarintField(5, e));
        }
        const O = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e)=>e
        }, F = Math.fround || (A = new Float32Array(1), (e)=>(A[0] = +e, A[0]));
        var A;
        const Z = 3, N = 5, B = 6;
        class R {
            constructor(e){
                this.options = Object.assign(Object.create(O), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e) {
                const { log: t1, minZoom: s, maxZoom: i } = this.options;
                t1 && console.time("total time");
                const o = `prepare ${e.length} points`;
                t1 && console.time(o), this.points = e;
                const n = [];
                for(let t1 = 0; t1 < e.length; t1++){
                    const s = e[t1];
                    if (!s.geometry) continue;
                    const [i, o] = s.geometry.coordinates, r = F(Y(i)), a = F(J(o));
                    n.push(r, a, 1 / 0, t1, -1, 1), this.options.reduce && n.push(0);
                }
                let r = this.trees[i + 1] = this._createTree(n);
                t1 && console.timeEnd(o);
                for(let e = i; e >= s; e--){
                    const s = +Date.now();
                    r = this.trees[e] = this._createTree(this._cluster(r, e)), t1 && console.log("z%d: %d clusters in %dms", e, r.numItems, +Date.now() - s);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e, t1) {
                let s = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e[1]));
                let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360) s = -180, o = 180;
                else if (s > o) {
                    const e = this.getClusters([
                        s,
                        i,
                        180,
                        n
                    ], t1), r = this.getClusters([
                        -180,
                        i,
                        o,
                        n
                    ], t1);
                    return e.concat(r);
                }
                const r = this.trees[this._limitZoom(t1)], a = r.range(Y(s), J(n), Y(o), J(i)), l = r.data, c = [];
                for (const e of a){
                    const t1 = this.stride * e;
                    c.push(l[t1 + N] > 1 ? X(l, t1, this.clusterProps) : this.points[l[t1 + Z]]);
                }
                return c;
            }
            getChildren(e) {
                const t1 = this._getOriginId(e), s = this._getOriginZoom(e), i = "No cluster with the specified id.", o = this.trees[s];
                if (!o) throw new Error(i);
                const n = o.data;
                if (t1 * this.stride >= n.length) throw new Error(i);
                const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)), a = o.within(n[t1 * this.stride], n[t1 * this.stride + 1], r), l = [];
                for (const t1 of a){
                    const s = t1 * this.stride;
                    n[s + 4] === e && l.push(n[s + N] > 1 ? X(n, s, this.clusterProps) : this.points[n[s + Z]]);
                }
                if (0 === l.length) throw new Error(i);
                return l;
            }
            getLeaves(e, t1, s) {
                const i = [];
                return this._appendLeaves(i, e, t1 = t1 || 10, s = s || 0, 0), i;
            }
            getTile(e, t1, s) {
                const i = this.trees[this._limitZoom(e)], o = Math.pow(2, e), { extent: n, radius: r } = this.options, a = r / n, l = (s - a) / o, c = (s + 1 + a) / o, h = {
                    features: []
                };
                return this._addTileFeatures(i.range((t1 - a) / o, l, (t1 + 1 + a) / o, c), i.data, t1, s, o, h), 0 === t1 && this._addTileFeatures(i.range(1 - a / o, l, 1, c), i.data, o, s, o, h), t1 === o - 1 && this._addTileFeatures(i.range(0, l, a / o, c), i.data, -1, s, o, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e) {
                let t1 = this._getOriginZoom(e) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const s = this.getChildren(e);
                    if (t1++, 1 !== s.length) break;
                    e = s[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e, t1, s, i, o) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? o + n.point_count <= i ? o += n.point_count : o = this._appendLeaves(e, n.cluster_id, s, i, o) : o < i ? o++ : e.push(t1), e.length === s) break;
                }
                return o;
            }
            _createTree(t1) {
                const s = new e.c0(t1.length / this.stride | 0, this.options.nodeSize, Float32Array);
                for(let e = 0; e < t1.length; e += this.stride)s.add(t1[e], t1[e + 1]);
                return s.finish(), s.data = t1, s;
            }
            _addTileFeatures(e, t1, s, i, o, n) {
                for (const r of e){
                    const e = r * this.stride, a = t1[e + N] > 1;
                    let l, c, h;
                    if (a) l = E(t1, e, this.clusterProps), c = t1[e], h = t1[e + 1];
                    else {
                        const s = this.points[t1[e + Z]];
                        l = s.properties;
                        const [i, o] = s.geometry.coordinates;
                        c = Y(i), h = J(o);
                    }
                    const u = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (c * o - s)),
                                Math.round(this.options.extent * (h * o - i))
                            ]
                        ],
                        tags: l
                    };
                    let d;
                    d = a || this.options.generateId ? t1[e + Z] : this.points[t1[e + Z]].id, void 0 !== d && (u.id = d), n.features.push(u);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }
            _cluster(e, t1) {
                const { radius: s, extent: i, reduce: o, minPoints: n } = this.options, r = s / (i * Math.pow(2, t1)), a = e.data, l = [], c = this.stride;
                for(let s = 0; s < a.length; s += c){
                    if (a[s + 2] <= t1) continue;
                    a[s + 2] = t1;
                    const i = a[s], h = a[s + 1], u = e.within(a[s], a[s + 1], r), d = a[s + N];
                    let f = d;
                    for (const e of u){
                        const s = e * c;
                        a[s + 2] > t1 && (f += a[s + N]);
                    }
                    if (f > d && f >= n) {
                        let e, n = i * d, r = h * d, p = -1;
                        const g = (s / c << 5) + (t1 + 1) + this.points.length;
                        for (const i of u){
                            const l = i * c;
                            if (a[l + 2] <= t1) continue;
                            a[l + 2] = t1;
                            const h = a[l + N];
                            n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), p = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));
                        }
                        a[s + 4] = g, l.push(n / f, r / f, 1 / 0, g, -1, f), o && l.push(p);
                    } else {
                        for(let e = 0; e < c; e++)l.push(a[s + e]);
                        if (f > 1) for (const e of u){
                            const s = e * c;
                            if (!(a[s + 2] <= t1)) {
                                a[s + 2] = t1;
                                for(let e = 0; e < c; e++)l.push(a[s + e]);
                            }
                        }
                    }
                }
                return l;
            }
            _getOriginId(e) {
                return e - this.points.length >> 5;
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }
            _map(e, t1, s) {
                if (e[t1 + N] > 1) {
                    const i = this.clusterProps[e[t1 + B]];
                    return s ? Object.assign({}, i) : i;
                }
                const i = this.points[e[t1 + Z]].properties, o = this.options.map(i);
                return s && o === i ? Object.assign({}, o) : o;
            }
        }
        function X(e, t1, s) {
            return {
                type: "Feature",
                id: e[t1 + Z],
                properties: E(e, t1, s),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (i = e[t1], 360 * (i - .5)),
                        G(e[t1 + 1])
                    ]
                }
            };
            //TURBOPACK unreachable
            ;
            var i;
        }
        function E(e, t1, s) {
            const i = e[t1 + N], o = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + "k" : i, n = e[t1 + B], r = -1 === n ? {} : Object.assign({}, s[n]);
            return Object.assign(r, {
                cluster: !0,
                cluster_id: e[t1 + Z],
                point_count: i,
                point_count_abbreviated: o
            });
        }
        function Y(e) {
            return e / 360 + .5;
        }
        function J(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function G(e) {
            const t1 = (180 - 360 * e) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function V(e, t1, s, i) {
            let o = i;
            const n = t1 + (s - t1 >> 1);
            let r, a = s - t1;
            const l = e[t1], c = e[t1 + 1], h = e[s], u = e[s + 1];
            for(let i = t1 + 3; i < s; i += 3){
                const t1 = $(e[i], e[i + 1], l, c, h, u);
                if (t1 > o) r = i, o = t1;
                else if (t1 === o) {
                    const e = Math.abs(i - n);
                    e < a && (r = i, a = e);
                }
            }
            o > i && (r - t1 > 3 && V(e, t1, r, i), e[r + 2] = o, s - r > 3 && V(e, r, s, i));
        }
        function $(e, t1, s, i, o, n) {
            let r = o - s, a = n - i;
            if (0 !== r || 0 !== a) {
                const l = ((e - s) * r + (t1 - i) * a) / (r * r + a * a);
                l > 1 ? (s = o, i = n) : l > 0 && (s += r * l, i += a * l);
            }
            return r = e - s, a = t1 - i, r * r + a * a;
        }
        function q(e, t1, s, i) {
            const o = {
                id: e ?? null,
                type: t1,
                geometry: s,
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            if ("Point" === t1 || "MultiPoint" === t1 || "LineString" === t1) U(o, s);
            else if ("Polygon" === t1) U(o, s[0]);
            else if ("MultiLineString" === t1) for (const e of s)U(o, e);
            else if ("MultiPolygon" === t1) for (const e of s)U(o, e[0]);
            return o;
        }
        function U(e, t1) {
            for(let s = 0; s < t1.length; s += 3)e.minX = Math.min(e.minX, t1[s]), e.minY = Math.min(e.minY, t1[s + 1]), e.maxX = Math.max(e.maxX, t1[s]), e.maxY = Math.max(e.maxY, t1[s + 1]);
        }
        function W(e, t1, s, i) {
            if (!t1.geometry) return;
            const o = t1.geometry.coordinates;
            if (o && 0 === o.length) return;
            const n = t1.geometry.type, r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);
            let a = [], l = t1.id;
            if (s.promoteId ? l = t1.properties[s.promoteId] : s.generateId && (l = i || 0), "Point" === n) H(o, a);
            else if ("MultiPoint" === n) for (const e of o)H(e, a);
            else if ("LineString" === n) Q(o, a, r, !1);
            else if ("MultiLineString" === n) {
                if (s.lineMetrics) {
                    for (const s of o)a = [], Q(s, a, r, !1), e.push(q(l, "LineString", a, t1.properties));
                    return;
                }
                K(o, a, r, !1);
            } else if ("Polygon" === n) K(o, a, r, !0);
            else {
                if ("MultiPolygon" !== n) {
                    if ("GeometryCollection" === n) {
                        for (const o of t1.geometry.geometries)W(e, {
                            id: l,
                            geometry: o,
                            properties: t1.properties
                        }, s, i);
                        return;
                    }
                    throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (const e of o){
                    const t1 = [];
                    K(e, t1, r, !0), a.push(t1);
                }
            }
            e.push(q(l, n, a, t1.properties));
        }
        function H(e, t1) {
            t1.push(ee(e[0]), te(e[1]), 0);
        }
        function Q(e, t1, s, i) {
            let o, n, r = 0;
            for(let s = 0; s < e.length; s++){
                const a = ee(e[s][0]), l = te(e[s][1]);
                t1.push(a, l, 0), s > 0 && (r += i ? (o * l - a * n) / 2 : Math.sqrt(Math.pow(a - o, 2) + Math.pow(l - n, 2))), o = a, n = l;
            }
            const a = t1.length - 3;
            t1[2] = 1, V(t1, 0, a, s), t1[a + 2] = 1, t1.size = Math.abs(r), t1.start = 0, t1.end = t1.size;
        }
        function K(e, t1, s, i) {
            for(let o = 0; o < e.length; o++){
                const n = [];
                Q(e[o], n, s, i), t1.push(n);
            }
        }
        function ee(e) {
            return e / 360 + .5;
        }
        function te(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function se(e, t1, s, i, o, n, r, a) {
            if (i /= t1, n >= (s /= t1) && r < i) return e;
            if (r < s || n >= i) return null;
            const l = [];
            for (const t1 of e){
                const e = t1.geometry;
                let n = t1.type;
                const r = 0 === o ? t1.minX : t1.minY, c = 0 === o ? t1.maxX : t1.maxY;
                if (r >= s && c < i) {
                    l.push(t1);
                    continue;
                }
                if (c < s || r >= i) continue;
                let h = [];
                if ("Point" === n || "MultiPoint" === n) ie(e, h, s, i, o);
                else if ("LineString" === n) oe(e, h, s, i, o, !1, a.lineMetrics);
                else if ("MultiLineString" === n) re(e, h, s, i, o, !1);
                else if ("Polygon" === n) re(e, h, s, i, o, !0);
                else if ("MultiPolygon" === n) for (const t1 of e){
                    const e = [];
                    re(t1, e, s, i, o, !0), e.length && h.push(e);
                }
                if (h.length) {
                    if (a.lineMetrics && "LineString" === n) {
                        for (const e of h)l.push(q(t1.id, n, e, t1.tags));
                        continue;
                    }
                    "LineString" !== n && "MultiLineString" !== n || (1 === h.length ? (n = "LineString", h = h[0]) : n = "MultiLineString"), "Point" !== n && "MultiPoint" !== n || (n = 3 === h.length ? "Point" : "MultiPoint"), l.push(q(t1.id, n, h, t1.tags));
                }
            }
            return l.length ? l : null;
        }
        function ie(e, t1, s, i, o) {
            for(let n = 0; n < e.length; n += 3){
                const r = e[n + o];
                r >= s && r <= i && ae(t1, e[n], e[n + 1], e[n + 2]);
            }
        }
        function oe(e, t1, s, i, o, n, r) {
            let a = ne(e);
            const l = 0 === o ? le : ce;
            let c, h, u = e.start;
            for(let d = 0; d < e.length - 3; d += 3){
                const f = e[d], p = e[d + 1], g = e[d + 2], m = e[d + 3], y = e[d + 4], w = 0 === o ? f : p, b = 0 === o ? m : y;
                let x = !1;
                r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(p - y, 2))), w < s ? b > s && (h = l(a, f, p, m, y, s), r && (a.start = u + c * h)) : w > i ? b < i && (h = l(a, f, p, m, y, i), r && (a.start = u + c * h)) : ae(a, f, p, g), b < s && w >= s && (h = l(a, f, p, m, y, s), x = !0), b > i && w <= i && (h = l(a, f, p, m, y, i), x = !0), !n && x && (r && (a.end = u + c * h), t1.push(a), a = ne(e)), r && (u += c);
            }
            let d = e.length - 3;
            const f = e[d], p = e[d + 1], g = 0 === o ? f : p;
            g >= s && g <= i && ae(a, f, p, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && ae(a, a[0], a[1], a[2]), a.length && t1.push(a);
        }
        function ne(e) {
            const t1 = [];
            return t1.size = e.size, t1.start = e.start, t1.end = e.end, t1;
        }
        function re(e, t1, s, i, o, n) {
            for (const r of e)oe(r, t1, s, i, o, n, !1);
        }
        function ae(e, t1, s, i) {
            e.push(t1, s, i);
        }
        function le(e, t1, s, i, o, n) {
            const r = (n - t1) / (i - t1);
            return ae(e, n, s + (o - s) * r, 1), r;
        }
        function ce(e, t1, s, i, o, n) {
            const r = (n - s) / (o - s);
            return ae(e, t1 + (i - t1) * r, n, 1), r;
        }
        function he(e, t1) {
            const s = [];
            for(let i = 0; i < e.length; i++){
                const o = e[i], n = o.type;
                let r;
                if ("Point" === n || "MultiPoint" === n || "LineString" === n) r = ue(o.geometry, t1);
                else if ("MultiLineString" === n || "Polygon" === n) {
                    r = [];
                    for (const e of o.geometry)r.push(ue(e, t1));
                } else if ("MultiPolygon" === n) {
                    r = [];
                    for (const e of o.geometry){
                        const s = [];
                        for (const i of e)s.push(ue(i, t1));
                        r.push(s);
                    }
                }
                s.push(q(o.id, n, r, o.tags));
            }
            return s;
        }
        function ue(e, t1) {
            const s = [];
            s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);
            for(let i = 0; i < e.length; i += 3)s.push(e[i] + t1, e[i + 1], e[i + 2]);
            return s;
        }
        function de(e, t1) {
            if (e.transformed) return e;
            const s = 1 << e.z, i = e.x, o = e.y;
            for (const n of e.features){
                const e = n.geometry, r = n.type;
                if (n.geometry = [], 1 === r) for(let r = 0; r < e.length; r += 2)n.geometry.push(fe(e[r], e[r + 1], t1, s, i, o));
                else for(let r = 0; r < e.length; r++){
                    const a = [];
                    for(let n = 0; n < e[r].length; n += 2)a.push(fe(e[r][n], e[r][n + 1], t1, s, i, o));
                    n.geometry.push(a);
                }
            }
            return e.transformed = !0, e;
        }
        function fe(e, t1, s, i, o, n) {
            return [
                Math.round(s * (e * i - o)),
                Math.round(s * (t1 * i - n))
            ];
        }
        function pe(e, t1, s, i, o) {
            const n = t1 === o.maxZoom ? 0 : o.tolerance / ((1 << t1) * o.extent), r = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: e.length,
                source: null,
                x: s,
                y: i,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            };
            for (const t1 of e)ge(r, t1, n, o);
            return r;
        }
        function ge(e, t1, s, i) {
            const o = t1.geometry, n = t1.type, r = [];
            if (e.minX = Math.min(e.minX, t1.minX), e.minY = Math.min(e.minY, t1.minY), e.maxX = Math.max(e.maxX, t1.maxX), e.maxY = Math.max(e.maxY, t1.maxY), "Point" === n || "MultiPoint" === n) for(let t1 = 0; t1 < o.length; t1 += 3)r.push(o[t1], o[t1 + 1]), e.numPoints++, e.numSimplified++;
            else if ("LineString" === n) me(r, o, e, s, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(let t1 = 0; t1 < o.length; t1++)me(r, o[t1], e, s, "Polygon" === n, 0 === t1);
            else if ("MultiPolygon" === n) for(let t1 = 0; t1 < o.length; t1++){
                const i = o[t1];
                for(let t1 = 0; t1 < i.length; t1++)me(r, i[t1], e, s, !0, 0 === t1);
            }
            if (r.length) {
                let s = t1.tags || null;
                if ("LineString" === n && i.lineMetrics) {
                    s = {};
                    for(const e in t1.tags)s[e] = t1.tags[e];
                    s.mapbox_clip_start = o.start / o.size, s.mapbox_clip_end = o.end / o.size;
                }
                const a = {
                    geometry: r,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: s
                };
                null !== t1.id && (a.id = t1.id), e.features.push(a);
            }
        }
        function me(e, t1, s, i, o, n) {
            const r = i * i;
            if (i > 0 && t1.size < (o ? r : i)) return void (s.numPoints += t1.length / 3);
            const a = [];
            for(let e = 0; e < t1.length; e += 3)(0 === i || t1[e + 2] > r) && (s.numSimplified++, a.push(t1[e], t1[e + 1])), s.numPoints++;
            o && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(a, n), e.push(a);
        }
        const ye = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        };
        class we {
            constructor(e, t1){
                const s = (t1 = this.options = function(e, t1) {
                    for(const s in t1)e[s] = t1[s];
                    return e;
                }(Object.create(ye), t1)).debug;
                if (s && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
                let i = function(e, t1) {
                    const s = [];
                    if ("FeatureCollection" === e.type) for(let i = 0; i < e.features.length; i++)W(s, e.features[i], t1, i);
                    else W(s, "Feature" === e.type ? e : {
                        geometry: e
                    }, t1);
                    return s;
                }(e, t1);
                this.tiles = {}, this.tileCoords = [], s && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function(e, t1) {
                    const s = t1.buffer / t1.extent;
                    let i = e;
                    const o = se(e, 1, -1 - s, s, 0, -1, 2, t1), n = se(e, 1, 1 - s, 2 + s, 0, -1, 2, t1);
                    return (o || n) && (i = se(e, 1, -s, 1 + s, 0, -1, 2, t1) || [], o && (i = he(o, 1).concat(i)), n && (i = i.concat(he(n, -1)))), i;
                }(i, t1), i.length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e, t1, s, i, o, n, r) {
                const a = [
                    e,
                    t1,
                    s,
                    i
                ], l = this.options, c = l.debug;
                for(; a.length;){
                    i = a.pop(), s = a.pop(), t1 = a.pop(), e = a.pop();
                    const h = 1 << t1, u = be(t1, s, i);
                    let d = this.tiles[u];
                    if (!d && (c > 1 && console.time("creation"), d = this.tiles[u] = pe(e, t1, s, i, l), this.tileCoords.push({
                        z: t1,
                        x: s,
                        y: i
                    }), c)) {
                        c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, s, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation"));
                        const e = `z${t1}`;
                        this.stats[e] = (this.stats[e] || 0) + 1, this.total++;
                    }
                    if (d.source = e, null == o) {
                        if (t1 === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;
                    } else {
                        if (t1 === l.maxZoom || t1 === o) continue;
                        if (null != o) {
                            const e = o - t1;
                            if (s !== n >> e || i !== r >> e) continue;
                        }
                    }
                    if (d.source = null, 0 === e.length) continue;
                    c > 1 && console.time("clipping");
                    const f = .5 * l.buffer / l.extent, p = .5 - f, g = .5 + f, m = 1 + f;
                    let y = null, w = null, b = null, x = null, v = se(e, h, s - f, s + g, 0, d.minX, d.maxX, l), I = se(e, h, s + p, s + m, 0, d.minX, d.maxX, l);
                    e = null, v && (y = se(v, h, i - f, i + g, 1, d.minY, d.maxY, l), w = se(v, h, i + p, i + m, 1, d.minY, d.maxY, l), v = null), I && (b = se(I, h, i - f, i + g, 1, d.minY, d.maxY, l), x = se(I, h, i + p, i + m, 1, d.minY, d.maxY, l), I = null), c > 1 && console.timeEnd("clipping"), a.push(y || [], t1 + 1, 2 * s, 2 * i), a.push(w || [], t1 + 1, 2 * s, 2 * i + 1), a.push(b || [], t1 + 1, 2 * s + 1, 2 * i), a.push(x || [], t1 + 1, 2 * s + 1, 2 * i + 1);
                }
            }
            getTile(e, t1, s) {
                e = +e, t1 = +t1, s = +s;
                const i = this.options, { extent: o, debug: n } = i;
                if (e < 0 || e > 24) return null;
                const r = 1 << e, a = be(e, t1 = t1 + r & r - 1, s);
                if (this.tiles[a]) return de(this.tiles[a], o);
                n > 1 && console.log("drilling down to z%d-%d-%d", e, t1, s);
                let l, c = e, h = t1, u = s;
                for(; !l && c > 0;)c--, h >>= 1, u >>= 1, l = this.tiles[be(c, h, u)];
                return l && l.source ? (n > 1 && (console.log("found parent tile z%d-%d-%d", c, h, u), console.time("drilling down")), this.splitTile(l.source, c, h, u, e, t1, s), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? de(this.tiles[a], o) : null) : null;
            }
        }
        function be(e, t1, s) {
            return 32 * ((1 << e) * s + t1) + e;
        }
        function xe(t1, s) {
            const i = t1.tileID.canonical;
            if (!this._geoJSONIndex) return void s(null, null);
            const o = this._geoJSONIndex.getTile(i.z, i.x, i.y);
            if (!o) return void s(null, null);
            const n = (e)=>e.tags && "3d_elevation_id" in e.tags && "source" in e.tags && "elevation" === e.tags.source, r = o.features.filter((e)=>n(e));
            let a = {
                _geojsonTileLayer: o.features
            };
            r.length > 0 && (a = {
                _geojsonTileLayer: o.features.filter((e)=>!n(e)),
                hd_road_elevation: r
            });
            const l = new m(a), c = function(t1) {
                const s = new e.bq;
                for (const e of Object.keys(t1))s.writeMessage(3, k, {
                    name: e,
                    features: t1[e]
                });
                return s.finish();
            }(a).buffer;
            s(null, {
                vectorTile: l,
                rawData: c
            });
        }
        class ve extends c {
            constructor(e, t1, s, i, o, n, r){
                super(e, t1, s, i, o, xe, r), n && (this.loadGeoJSON = n), this._dynamicIndex = new b;
            }
            loadData(s, i) {
                const o = s && s.request, n = o && o.collectResourceTiming;
                this._geoJSONIndex = null, this.loadGeoJSON(s, (r, a)=>{
                    if (r || !a) return i(r);
                    if ("object" != typeof a) return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));
                    {
                        try {
                            if (s.filter) {
                                const t1 = e.X(s.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === t1.result) throw new Error(t1.value.map((e)=>`${e.key}: ${e.message}`).join(", "));
                                a.features = a.features.filter((e)=>t1.value.evaluate({
                                        zoom: 0
                                    }, e));
                            }
                            s.dynamic ? ("Feature" === a.type && (a = {
                                type: "FeatureCollection",
                                features: [
                                    a
                                ]
                            }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new R(function({ superclusterOptions: t1, clusterProperties: s }) {
                                if (!s || !t1) return t1;
                                const i = {}, o = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, r = {
                                    properties: null
                                }, a = Object.keys(s);
                                for (const t1 of a){
                                    const [n, r] = s[t1], a = e.X(r), l = e.X("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    i[t1] = a.value, o[t1] = l.value;
                                }
                                return t1.map = (e)=>{
                                    r.properties = e;
                                    const t1 = {};
                                    for (const e of a)t1[e] = i[e].evaluate(n, r);
                                    return t1;
                                }, t1.reduce = (e, t1)=>{
                                    r.properties = t1;
                                    for (const t1 of a)n.accumulated = e[t1], e[t1] = o[t1].evaluate(n, r);
                                }, t1;
                            }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function(e, t1) {
                                return new we(e, t1);
                            }(a, s.geojsonVtOptions);
                        } catch (e) {
                            return i(e);
                        }
                        const r = {};
                        if (n) {
                            const e = t1(o);
                            e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));
                        }
                        i(null, r);
                    }
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded;
                return s && s[e.uid] ? e.partial ? t1(null, void 0) : super.reloadTile(e, t1) : this.loadTile(e, t1);
            }
            loadGeoJSON(t1, s) {
                if (t1.request) e.n(t1.request, s);
                else {
                    if ("string" != typeof t1.data) return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    setTimeout(()=>{
                        try {
                            return s(null, JSON.parse(t1.data));
                        } catch (e) {
                            return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                        }
                    }, 0);
                }
            }
            getClusterExpansionZoom(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterChildren(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterLeaves(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t1(e);
                }
            }
        }
        class Ie {
            constructor(t1, s, i){
                this.tileID = new e.aM(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t1.projection, this.brightness = s, this.worldview = i;
            }
            parse(t1, s, i, o) {
                this.status = "parsing";
                const n = new e.aM(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y), r = [], a = s.familiesBySource[i.source], l = new e.fc(n, i.promoteId);
                l.bucketLayerIDs = [], l.is3DTile = !0, e.fr(t1).then((t1)=>{
                    if (!t1) return o(new Error("Could not parse tile"));
                    const s = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("MAPBOX_mesh_features") || t1.json.asset.extras && t1.json.asset.extras.MAPBOX_mesh_features, c = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("EXT_meshopt_compression"), h = new e.aa(this.zoom, {
                        brightness: this.brightness,
                        worldview: this.worldview
                    });
                    for(const o in a)for (const u of a[o]){
                        const o = u[0];
                        l.bucketLayerIDs.push(u.map((t1)=>e.C(t1.id, t1.scope))), o.recalculate(h, []);
                        const a = e.fs(t1, 1 / e.d4(i.tileID.canonical)), d = new e.ft(u, a, n, s, c, this.brightness, l, this.worldview);
                        s || (d.needsUpload = !0), r.push(d), d.evaluate(o);
                    }
                    this.status = "done", o(null, {
                        buckets: r,
                        featureIndex: l,
                        collisionBoxArray: null,
                        glyphAtlasImage: null,
                        lineAtlas: null,
                        imageAtlas: null,
                        brightness: null
                    });
                }).catch((e)=>o(new Error(e.message)));
            }
        }
        class Se {
            constructor(e, t1, s, i, o, n, r, a){
                this.actor = e, this.layerIndex = t1, this.availableImages = s, this.availableModels = i, this.brightness = r, this.loading = {}, this.loaded = {}, this.worldview = a;
            }
            loadTile(t1, s) {
                const i = t1.uid, o = this.loading[i] = new Ie(t1, this.brightness, this.worldview);
                e.br(t1.request, (e, n)=>{
                    const r = !this.loading[i];
                    return delete this.loading[i], r || e ? (o.status = "done", r || (this.loaded[i] = o), s(e)) : n && 0 !== n.byteLength ? void o.parse(n, this.layerIndex, t1, (e, t1)=>{
                        o.status = "done", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t1 ? s(e) : s(null, t1);
                    }) : (o.status = "done", this.loaded[i] = o, s());
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded, i = e.uid;
                if (s && s[i]) {
                    const o = s[i];
                    o.projection = e.projection, o.brightness = e.brightness;
                    const n = (s, i)=>{
                        o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t1)), t1(s, i);
                    };
                    "parsing" === o.status ? o.reloadCallback = n : "done" === o.status && this.loadTile(e, t1);
                }
            }
            abortTile(e, t1) {
                const s = e.uid;
                this.loading[s] && delete this.loading[s], t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class Me {
            constructor(t1){
                this.self = t1, this.actor = new e.fv(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.y, this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = e.cj({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: c,
                    geojson: ve,
                    "raster-dem": h,
                    "raster-array": d,
                    "batched-model": Se
                }, this.workerSources = {}, this.self.registerWorkerSource = (e, t1)=>{
                    if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
                    this.workerSourceTypes[e] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e.fw.isParsed()) throw new Error("RTL text plugin already registered.");
                    e.fw.setState({
                        pluginStatus: e.fx.parsed,
                        pluginURL: e.fw.getPluginURL()
                    }), e.fw.applyArabicShaping = t1.applyArabicShaping, e.fw.processBidirectionalText = t1.processBidirectionalText, e.fw.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                    for (const e of this.rtlPluginParsingListeners)e(null, !0);
                    this.rtlPluginParsingListeners = [];
                };
            }
            clearCaches(e, t1, s) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.availableModels[e], delete this.workerSources[e], s();
            }
            checkIfReady(e, t1, s) {
                s();
            }
            setReferrer(e, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, s) {
                this.isSpriteLoaded[t1] || (this.isSpriteLoaded[t1] = {});
                const { scope: i, isLoaded: o } = s;
                if (this.isSpriteLoaded[t1][i] = o, this.workerSources[t1] && this.workerSources[t1][i]) for(const s in this.workerSources[t1][i]){
                    const n = this.workerSources[t1][i][s];
                    for(const t1 in n){
                        const s = n[t1];
                        s instanceof c && (s.isSpriteLoaded = o, s.fire(new e.A("isSpriteLoaded")));
                    }
                }
            }
            setImages(e, t1, s) {
                this.availableImages[e] || (this.availableImages[e] = {});
                const { scope: i, images: o } = t1;
                if (this.availableImages[e][i] = o, this.workerSources[e] && this.workerSources[e][i]) {
                    for(const t1 in this.workerSources[e][i]){
                        const s = this.workerSources[e][i][t1];
                        for(const e in s)s[e].availableImages = o;
                    }
                    s();
                } else s();
            }
            setModels(e, { scope: t1, models: s }, i) {
                if (this.availableModels[e] || (this.availableModels[e] = {}), this.availableModels[e][t1] = s, this.workerSources[e] && this.workerSources[e][t1]) {
                    for(const i in this.workerSources[e][t1]){
                        const o = this.workerSources[e][t1][i];
                        for(const e in o)o[e].availableModels = s;
                    }
                    i();
                } else i();
            }
            setProjection(t1, s) {
                this.projections[t1] = e.cj(s);
            }
            setBrightness(e, t1, s) {
                this.brightness = t1, s();
            }
            setWorldview(e, t1, s) {
                this.worldview = t1, s();
            }
            setLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).replace(t1.layers, t1.options), s();
            }
            updateLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).update(t1.layers, t1.removedIds, t1.options), s();
            }
            loadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).loadTile(t1, s);
            }
            decodeRasterArray(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).decodeRasterArray(t1, s);
            }
            reloadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).reloadTile(t1, s);
            }
            abortTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).abortTile(t1, s);
            }
            removeTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).removeTile(t1, s);
            }
            removeSource(e, t1, s) {
                if (!(this.workerSources[e] && this.workerSources[e][t1.scope] && this.workerSources[e][t1.scope][t1.type] && this.workerSources[e][t1.scope][t1.type][t1.source])) return;
                const i = this.workerSources[e][t1.scope][t1.type][t1.source];
                delete this.workerSources[e][t1.scope][t1.type][t1.source], void 0 !== i.removeSource ? i.removeSource(t1, s) : s();
            }
            loadWorkerSource(e, t1, s) {
                try {
                    this.self.importScripts(t1.url), s();
                } catch (e) {
                    s(e.toString());
                }
            }
            syncRTLPluginState(t1, s, i) {
                if (e.fw.isParsed()) i(null, !0);
                else if (e.fw.isParsing()) this.rtlPluginParsingListeners.push(i);
                else try {
                    e.fw.setState(s);
                    const t1 = e.fw.getPluginURL();
                    !e.fw.isLoaded() || e.fw.isParsed() || e.fw.isParsing() || null == t1 || (e.fw.setState({
                        pluginStatus: e.fx.parsing,
                        pluginURL: e.fw.getPluginURL()
                    }), this.self.importScripts(t1), e.fw.isParsed() ? i(null, !0) : this.rtlPluginParsingListeners.push(i));
                } catch (e) {
                    i(e.toString());
                }
            }
            setDracoUrl(e, t1) {
                this.dracoUrl = t1;
            }
            getAvailableImages(e, t1) {
                this.availableImages[e] || (this.availableImages[e] = {});
                let s = this.availableImages[e][t1];
                return s || (s = []), s;
            }
            getAvailableModels(e, t1) {
                this.availableModels[e] || (this.availableModels[e] = {});
                let s = this.availableModels[e][t1];
                return s || (s = {}), s;
            }
            getLayerIndex(e, t1) {
                this.layerIndexes[e] || (this.layerIndexes[e] = {});
                let s = this.layerIndexes[e][t1];
                return s || (s = this.layerIndexes[e][t1] = new o, s.scope = t1), s;
            }
            getWorkerSource(e, t1, s, i) {
                const o = this.workerSources;
                return o[e] || (o[e] = {}), o[e][i] || (o[e][i] = {}), o[e][i][t1] || (o[e][i][t1] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), o[e][i][t1][s] || (o[e][i][t1][s] = new this.workerSourceTypes[t1]({
                    send: (t1, s, i, o, n, r)=>this.actor.send(t1, s, i, e, n, r),
                    scheduler: this.actor.scheduler
                }, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.getAvailableModels(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness, this.worldview)), o[e][i][t1][s];
            }
            rasterizeImagesWorker(e, t1, s) {
                const i = new Map;
                for (const [s, { image: o, imageVariant: n }] of t1.tasks.entries()){
                    const r = this.imageRasterizer.rasterize(n, o, t1.scope, e);
                    i.set(s, r);
                }
                s(void 0, i);
            }
            removeRasterizedImages(e, t1, s) {
                this.imageRasterizer.removeImagesFromCacheByIds(t1.imageIds, t1.scope, e), s();
            }
            enforceCacheSizeLimit(t1, s) {
                e.fy(s);
            }
            getWorkerPerformanceMetrics(e, t1, s) {
                s(void 0, void 0);
            }
        }
        return e.fu(self) && (self.worker = new Me(self)), Me;
    });
    define([
        "./shared"
    ], function(e) {
        var t1 = "3.14.0";
        const i = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, o = {
            mark (e) {
                performance.mark(e);
            },
            measure (e, t1, i) {
                performance.measure(e, t1, i);
            }
        };
        function r(t1) {
            const i = t1.name.split("?")[0];
            return e.a(i) && i.includes("mapbox-gl.js") ? "javascript" : e.a(i) && i.includes("mapbox-gl.css") ? "css" : e.b(i) ? "fontRange" : e.c(i) ? "sprite" : e.i(i) ? "style" : e.d(i) ? "tilejson" : "other";
        }
        var s, n = {}, a = function() {
            if (s) return n;
            function e(e) {
                return !t1(e);
            }
            function t1(t1) {
                return ("TURBOPACK compile-time truthy", 1) ? "not a browser" : "TURBOPACK unreachable";
                //TURBOPACK unreachable
                ;
                var o;
            }
            s = 1, n.supported = e, n.notSupportedReason = t1;
            var i = {};
            return e.webGLContextAttributes = {
                antialias: !1,
                alpha: !0,
                stencil: !0,
                depth: !0
            }, n;
        }();
        function l(e, t1, i) {
            const o = document.createElement(e);
            return null != t1 && (o.className = t1), i && i.appendChild(o), o;
        }
        function c(e, t1, i) {
            const o = document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const e of Object.keys(t1))o.setAttributeNS(null, e, String(t1[e]));
            return i && i.appendChild(o), o;
        }
        const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
        let u;
        function _() {
            h && d && (u = h[d], h[d] = "none");
        }
        function p() {
            h && d && (h[d] = u);
        }
        function f(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", f, !0);
        }
        function m() {
            window.addEventListener("click", f, !0), window.setTimeout(()=>{
                window.removeEventListener("click", f, !0);
            }, 0);
        }
        function g(e, t1) {
            const i = e.getBoundingClientRect();
            return x(e, i, t1);
        }
        function v(e, t1) {
            const i = e.getBoundingClientRect(), o = [];
            for(let r = 0; r < t1.length; r++)o.push(x(e, i, t1[r]));
            return o;
        }
        function y(e) {
            return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e.button && e.ctrlKey ? 0 : e.button;
        }
        function x(t1, i, o) {
            const r = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e.P((o.clientX - i.left) * r, (o.clientY - i.top) * r);
        }
        const b = "01", w = "NO_ACCESS_TOKEN";
        class T {
            constructor(e, t1, i){
                this._transformRequestFn = e, this._customAccessToken = t1, this._silenceAuthErrors = !!i, this._createSkuToken();
            }
            _createSkuToken() {
                const e = function() {
                    let e = "";
                    for(let t1 = 0; t1 < 10; t1++)e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            b,
                            e
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(e, t1) {
                return this._transformRequestFn && this._transformRequestFn(e, t1) || {
                    url: e
                };
            }
            normalizeStyleURL(i, o) {
                if (!e.j(i)) return i;
                const r = S(i);
                return r.params.push(`sdk=js-${t1}`), r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || o);
            }
            normalizeGlyphsURL(t1, i) {
                if (!e.j(t1)) return t1;
                const o = S(t1);
                return o.path = `/fonts/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeModelURL(t1, i) {
                if (!e.j(t1)) return t1;
                const o = S(t1);
                return o.path = `/models/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeSourceURL(t1, i, o, r) {
                if (!e.j(t1)) return t1;
                const s = S(t1);
                return s.path = `/v4/${s.authority}.json`, s.params.push("secure"), o && s.params.push(`language=${o}`), r && s.params.push(`worldview=${r}`), this._makeAPIURL(s, this._customAccessToken || i);
            }
            normalizeIconsetURL(t1, i) {
                const o = S(t1);
                return e.j(t1) ? (o.path = `/styles/v1${o.path}/iconset.pbf`, this._makeAPIURL(o, this._customAccessToken || i)) : I(o);
            }
            normalizeSpriteURL(t1, i, o, r) {
                const s = S(t1);
                return e.j(t1) ? (s.path = `/styles/v1${s.path}/sprite${i}${o}`, this._makeAPIURL(s, this._customAccessToken || r)) : (s.path += `${i}${o}`, I(s));
            }
            normalizeTileURL(t1, i, o) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !e.j(t1)) return t1;
                const r = S(t1);
                r.path = r.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i || o && "raster" !== r.authority && 512 === o ? "@2x" : ""}${e.l.supported ? ".webp" : "$1"}`), "raster" === r.authority ? r.path = `/${e.e.RASTER_URL_PREFIX}${r.path}` : "rasterarrays" === r.authority ? r.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${r.path}` : "3dtiles" === r.authority ? r.path = `/${e.e.TILES3D_URL_PREFIX}${r.path}` : (r.path = r.path.replace(/^.+\/v4\//, "/"), r.path = `/${e.e.TILE_URL_VERSION}${r.path}`);
                const s = this._customAccessToken || function(e) {
                    for (const t1 of e){
                        const e = t1.match(/^access_token=(.*)$/);
                        if (e) return e[1];
                    }
                    return null;
                }(r.params) || e.e.ACCESS_TOKEN;
                return e.e.REQUIRE_ACCESS_TOKEN && s && this._skuToken && r.params.push(`sku=${this._skuToken}`), this._makeAPIURL(r, s);
            }
            canonicalizeTileURL(t1, i) {
                const o = S(t1);
                if (!o.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o.path.match(/\.[\w]+$/)) return t1;
                let r = "mapbox://";
                o.path.match(/^\/raster\/v1\//) ? r += `raster/${o.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o.path.match(/^\/rasterarrays\/v1\//) ? r += `rasterarrays/${o.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : r += `tiles/${o.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
                let s = o.params;
                return i && (s = s.filter((e)=>!e.match(/^access_token=/))), s.length && (r += `?${s.join("&")}`), r;
            }
            canonicalizeTileset(t1, i) {
                const o = !!i && e.j(i), r = [];
                for (const i of t1.tiles || [])e.k(i) ? r.push(this.canonicalizeTileURL(i, o)) : r.push(i);
                return r;
            }
            _makeAPIURL(t1, i) {
                const o = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", r = S(e.e.API_URL);
                if (t1.protocol = r.protocol, t1.authority = r.authority, "http" === t1.protocol) {
                    const e = t1.params.indexOf("secure");
                    e >= 0 && t1.params.splice(e, 1);
                }
                if ("/" !== r.path && (t1.path = `${r.path}${t1.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return I(t1);
                if (i = i || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!i) throw new Error(`An API access token is required to use Mapbox GL. ${o}`);
                    if ("s" === i[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`);
                }
                return t1.params = t1.params.filter((e)=>-1 === e.indexOf("access_token")), t1.params.push(`access_token=${i || ""}`), I(t1);
            }
        }
        const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function S(e) {
            const t1 = e.match(E);
            if (!t1) throw new Error("Unable to parse URL object");
            return {
                protocol: t1[1],
                authority: t1[2],
                path: t1[3] || "/",
                params: t1[4] ? t1[4].split("&") : []
            };
        }
        function I(e) {
            const t1 = e.params.length ? `?${e.params.join("&")}` : "";
            return `${e.protocol}://${e.authority}${e.path}${t1}`;
        }
        const C = "mapbox.eventData";
        function R(t1) {
            if (!t1) return null;
            const i = t1.split(".");
            if (!i || 3 !== i.length) return null;
            try {
                return JSON.parse(e.m(i[1]));
            } catch (e) {
                return null;
            }
        }
        class A {
            constructor(e){
                this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const i = R(e.e.ACCESS_TOKEN);
                let o = "";
                return o = i && i.u ? e.f(i.u) : e.e.ACCESS_TOKEN || "", t1 ? `${C}.${t1}:${o}` : `${C}:${o}`;
            }
            fetchEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid");
                if (t1) try {
                    const e = localStorage.getItem(i);
                    e && (this.eventData = JSON.parse(e));
                    const t1 = localStorage.getItem(o);
                    t1 && (this.anonId = t1);
                } catch (t1) {
                    e.w("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid"), r = this.anonId;
                if (t1 && r) try {
                    localStorage.setItem(o, r), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData));
                } catch (t1) {
                    e.w("Unable to write to LocalStorage");
                }
            }
            processRequests(e) {}
            postEvent(t1, i, o, r) {
                if (!e.e.EVENTS_URL) return;
                const s = S(e.e.EVENTS_URL);
                s.params.push(`access_token=${r || e.e.ACCESS_TOKEN || ""}`);
                const n = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, a = i ? e.h(n, i) : n, l = {
                    url: I(s),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        a
                    ])
                };
                this.pendingRequest = e.p(l, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(r);
                });
            }
            queueRequest(e, t1) {
                this.queue.push(e), this.processRequests(t1);
            }
        }
        const D = new class extends A {
            constructor(e){
                super("appUserTurnstile"), this._customAccessToken = e;
            }
            postTurnstileEvent(t1, i) {
                e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>e.j(t1) || e.k(t1)) && this.queueRequest(Date.now(), i);
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const o = R(e.e.ACCESS_TOKEN), r = o ? o.u : e.e.ACCESS_TOKEN;
                let s = r !== this.eventData.tokenU;
                e.v(this.anonId) || (this.anonId = e.u(), s = !0);
                const n = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const e = new Date(this.eventData.lastSuccess), t1 = new Date(n), i = (n - this.eventData.lastSuccess) / 864e5;
                    s = s || i >= 1 || i < -1 || e.getDate() !== t1.getDate();
                } else s = !0;
                s ? this.postEvent(n, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (e)=>{
                    e || (this.eventData.lastSuccess = n, this.eventData.tokenU = r);
                }, i) : this.processRequests();
            }
        }, P = D.postTurnstileEvent.bind(D), L = new class extends A {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, i, o, r) {
                this.skuToken = i, this.errorCb = r, e.e.EVENTS_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: o, timestamp: r } = this.queue.shift();
                o && this.success[o] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(r, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (e)=>{
                    e ? this.errorCb(e) : o && (this.success[o] = !0);
                }, i));
            }
            remove() {
                this.errorCb = null;
            }
        }, z = L.postMapLoadEvent.bind(L), M = new class extends A {
            constructor(){
                super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap;
            }
            getMapInstanceId(t1) {
                let i = this.mapInstanceIdMap.get(t1);
                return i || (i = e.u(), this.mapInstanceIdMap.set(t1, i)), i;
            }
            getEventId(e) {
                const t1 = this.eventIdPerMapInstanceMap.get(e) || 0;
                return this.eventIdPerMapInstanceMap.set(e, t1 + 1), t1;
            }
            postStyleLoadEvent(t1, i) {
                const { map: o, style: r, importedStyles: s } = i;
                if (!e.e.EVENTS_URL || !t1 && !e.e.ACCESS_TOKEN) return;
                const n = this.getMapInstanceId(o), a = {
                    mapInstanceId: n,
                    eventId: this.getEventId(n),
                    style: r
                };
                s.length && (a.importedStyles = s), this.queueRequest({
                    timestamp: Date.now(),
                    payload: a
                }, t1);
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: t1, payload: i } = this.queue.shift();
                this.postEvent(t1, i, ()=>{}, e);
            }
        }, O = M.postStyleLoadEvent.bind(M), F = new class extends A {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, i) {
                e.e.EVENTS_URL && (t1 || e.e.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: i
                }, t1);
            }
            processRequests(o) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: s, performanceData: n } = this.queue.shift(), a = function(o) {
                    const s = performance.getEntriesByType("resource"), n = performance.getEntriesByType("mark"), a = function(e) {
                        const t1 = {};
                        if (e) {
                            for(const i in e)if ("other" !== i) for (const o of e[i]){
                                const e = `${i}ResolveRangeMin`, r = `${i}ResolveRangeMax`, s = `${i}RequestCount`, n = `${i}RequestCachedCount`;
                                t1[e] = Math.min(t1[e] || 1 / 0, o.startTime), t1[r] = Math.max(t1[r] || -1 / 0, o.responseEnd);
                                const a = (e)=>{
                                    void 0 === t1[e] && (t1[e] = 0), ++t1[e];
                                };
                                void 0 !== o.transferSize && 0 === o.transferSize && a(n), a(s);
                            }
                        }
                        return t1;
                    }(function(e, t1) {
                        const i = {};
                        if (e) for (const o of e){
                            const e = t1(o);
                            void 0 === i[e] && (i[e] = []), i[e].push(o);
                        }
                        return i;
                    }(s, r)), l = window.devicePixelRatio, c = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h = c ? c.effectiveType : void 0, d = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, u = (e, t1, i)=>{
                        null != i && e.push({
                            name: t1,
                            value: i.toString()
                        });
                    };
                    for(const e in a)u(d.counters, e, a[e]);
                    if (o.interactionRange[0] !== 1 / 0 && o.interactionRange[1] !== -1 / 0 && (u(d.counters, "interactionRangeMin", o.interactionRange[0]), u(d.counters, "interactionRangeMax", o.interactionRange[1])), n) for (const e of Object.keys(i)){
                        const t1 = i[e], o = n.find((e)=>e.name === t1);
                        o && u(d.counters, t1, o.startTime);
                    }
                    return u(d.counters, "visibilityHidden", o.visibilityHidden), u(d.attributes, "style", function(t1) {
                        if (t1) for (const i of t1){
                            const t1 = i.name.split("?")[0];
                            if (e.i(t1)) {
                                const e = t1.split("/").slice(-2);
                                if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                            }
                        }
                    }(s)), u(d.attributes, "terrainEnabled", o.terrainEnabled ? "true" : "false"), u(d.attributes, "fogEnabled", o.fogEnabled ? "true" : "false"), u(d.attributes, "projection", o.projection), u(d.attributes, "zoom", o.zoom), u(d.metadata, "devicePixelRatio", l), u(d.metadata, "connectionEffectiveType", h), u(d.metadata, "navigatorUserAgent", navigator.userAgent), u(d.metadata, "screenWidth", window.screen.width), u(d.metadata, "screenHeight", window.screen.height), u(d.metadata, "windowWidth", window.innerWidth), u(d.metadata, "windowHeight", window.innerHeight), u(d.metadata, "mapWidth", o.width / l), u(d.metadata, "mapHeight", o.height / l), u(d.metadata, "webglRenderer", o.renderer), u(d.metadata, "webglVendor", o.vendor), u(d.metadata, "sdkVersion", t1), u(d.metadata, "sdkIdentifier", "mapbox-gl-js"), d;
                }(n);
                for (const e of a.metadata);
                for (const e of a.counters);
                for (const e of a.attributes);
                this.postEvent(s, a, ()=>{}, o);
            }
        }, B = F.postPerformanceEvent.bind(F), k = new class extends A {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, i, o, r) {
                if (!e.e.API_URL || !e.e.SESSION_PATH) return;
                const s = S(e.e.API_URL + e.e.SESSION_PATH);
                s.params.push(`sku=${i || ""}`), s.params.push(`access_token=${r || e.e.ACCESS_TOKEN || ""}`);
                const n = {
                    url: I(s),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = e.g(n, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(r);
                });
            }
            getSessionAPI(t1, i, o, r) {
                this.skuToken = i, this.errorCb = r, e.e.SESSION_PATH && e.e.API_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: t1, timestamp: i } = this.queue.shift();
                t1 && this.success[t1] || this.getSession(i, this.skuToken, (e)=>{
                    e ? this.errorCb(e) : t1 && (this.success[t1] = !0);
                }, e);
            }
            remove() {
                this.errorCb = null;
            }
        }, N = k.getSessionAPI.bind(k), U = new Set;
        function j(e, t1) {
            t1 ? U.add(e) : U.delete(e);
        }
        class G {
            constructor(){
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = {};
            }
            isDirty() {
                return this._changed;
            }
            setDirty() {
                this._changed = !0;
            }
            getUpdatedSourceCaches() {
                return this._updatedSourceCaches;
            }
            updateSourceCache(e, t1) {
                this._updatedSourceCaches[e] = t1, this.setDirty();
            }
            discardSourceCacheUpdate(e) {
                delete this._updatedSourceCaches[e];
            }
            updateLayer(e) {
                const t1 = e.scope;
                this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._updatedLayers[t1].add(e.id), this.setDirty();
            }
            removeLayer(e) {
                const t1 = e.scope;
                this._removedLayers[t1] = this._removedLayers[t1] || {}, this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._removedLayers[t1][e.id] = e, this._updatedLayers[t1].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();
            }
            getRemovedLayer(e) {
                return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;
            }
            discardLayerRemoval(e) {
                this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];
            }
            getLayerUpdatesByScope() {
                const e = {};
                for(const t1 in this._updatedLayers)e[t1] = e[t1] || {}, e[t1].updatedIds = Array.from(this._updatedLayers[t1].values());
                for(const t1 in this._removedLayers)e[t1] = e[t1] || {}, e[t1].removedIds = Object.keys(this._removedLayers[t1]);
                return e;
            }
            getUpdatedPaintProperties() {
                return this._updatedPaintProps;
            }
            updatePaintProperties(e) {
                this._updatedPaintProps.add(e.fqid), this.setDirty();
            }
            getUpdatedImages(e) {
                return this._updatedImages[e] ? Array.from(this._updatedImages[e].values()) : [];
            }
            updateImage(t1, i) {
                this._updatedImages[i] = this._updatedImages[i] || new Set, this._updatedImages[i].add(e.I.toString(t1)), this.setDirty();
            }
            resetUpdatedImages(e) {
                this._updatedImages[e] && this._updatedImages[e].clear();
            }
            reset() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
            }
        }
        function V(e) {
            const { userImage: t1 } = e;
            return !!(t1 && t1.render && t1.render()) && (e.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class q extends e.E {
            constructor(t1){
                super(), this.imageProviders = new Map, this.images = new Map, this.updatedImages = new Map, this.callbackDispatchedThisFrame = new Map, this.loaded = new Map, this.requestors = [], this.patterns = new Map, this.patternsInFlight = new Set, this.atlasImage = new Map, this.atlasTexture = new Map, this.dirty = !0, this.spriteFormat = t1, "raster" !== t1 && e.t() && (this.imageRasterizerDispatcher = new e.D(e.x(), this, "Image Rasterizer Worker", 1));
            }
            addScope(t1) {
                this.loaded.set(t1, !1), this.imageProviders.set(t1, new Map), this.images.set(t1, new Map), this.updatedImages.set(t1, new Set), this.callbackDispatchedThisFrame.set(t1, new Set), this.patterns.set(t1, new Map), this.atlasImage.set(t1, new e.r({
                    width: 1,
                    height: 1
                }));
            }
            removeScope(e) {
                this.loaded.delete(e), this.imageProviders.delete(e), this.images.delete(e), this.updatedImages.delete(e), this.callbackDispatchedThisFrame.delete(e), this.patterns.delete(e), this.atlasImage.delete(e);
                const t1 = this.atlasTexture.get(e);
                t1 && (t1.destroy(), this.atlasTexture.delete(e));
            }
            addImageProvider(e, t1) {
                this.imageProviders.has(t1) || this.imageProviders.set(t1, new Map), this.imageProviders.get(t1).set(e.id, e);
            }
            removeImageProvider(e, t1) {
                this.imageProviders.has(t1) && this.imageProviders.get(t1).delete(e);
            }
            getPendingImageProviders() {
                const e = [];
                for (const t1 of this.imageProviders.values())for (const i of t1.values())i.hasPendingRequests() && e.push(i);
                return e;
            }
            get imageRasterizer() {
                return this._imageRasterizer || (this._imageRasterizer = new e.y), this._imageRasterizer;
            }
            isLoaded() {
                for (const e of this.loaded.keys())if (!this.loaded.get(e)) return !1;
                return !0;
            }
            setLoaded(e, t1) {
                if (this.loaded.get(t1) !== e && (this.loaded.set(t1, e), e)) {
                    for (const { ids: e, callback: i } of this.requestors)this._notify(e, t1, i);
                    this.requestors = [];
                }
            }
            hasImage(e, t1) {
                return !!this.getImage(e, t1);
            }
            getImage(e, t1) {
                return this.images.get(t1).get(e.toString());
            }
            addImage(e, t1, i) {
                this._validate(e, i) && this.images.get(t1).set(e.toString(), i);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.z(new Error(`Image "${t1.name}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.z(new Error(`Image "${t1.name}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.z(new Error(`Image "${t1.name}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e, t1) {
                if (!e) return !0;
                let i = 0;
                for (const o of e){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e, t1) {
                if (!e) return !0;
                if (4 !== e.length) return !1;
                if (!t1.usvg) {
                    if (e[0] < 0 || t1.data.width < e[0]) return !1;
                    if (e[1] < 0 || t1.data.height < e[1]) return !1;
                    if (e[2] < 0 || t1.data.width < e[2]) return !1;
                    if (e[3] < 0 || t1.data.height < e[3]) return !1;
                }
                return !(e[2] < e[0] || e[3] < e[1]);
            }
            updateImage(e, t1, i) {
                const o = this.images.get(t1).get(e.toString());
                i.version = o.version + 1, this.images.get(t1).set(e.toString(), i), this.updatedImages.get(t1).add(e), this.removeFromImageRasterizerCache(e, t1);
            }
            clearUpdatedImages(e) {
                this.updatedImages.get(e).clear();
            }
            removeFromImageRasterizerCache(t1, i) {
                "raster" !== this.spriteFormat && (e.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
                    imageIds: [
                        t1
                    ],
                    scope: i
                }) : this.imageRasterizer.removeImagesFromCacheByIds([
                    t1
                ], i));
            }
            removeImage(e, t1) {
                const i = this.images.get(t1), o = i.get(e.toString());
                i.delete(e.toString()), this.patterns.get(t1).delete(e.toString()), this.removeFromImageRasterizerCache(e, t1), o.userImage && o.userImage.onRemove && o.userImage.onRemove();
            }
            listImages(t1) {
                return Array.from(this.images.get(t1).keys()).map((t1)=>e.I.from(t1));
            }
            getImages(e, t1, i) {
                const o = [], r = [], s = this.imageProviders.get(t1);
                for (const i of e){
                    if (!i.iconsetId) {
                        o.push(i);
                        continue;
                    }
                    const e = s.get(i.iconsetId);
                    e && (this.getImage(i, t1) ? r.push(i) : e.addPendingRequest(i));
                }
                if (0 === o.length) return void this._notify(r, t1, i);
                let n = !0;
                const a = !!this.loaded.get(t1), l = this.images.get(t1);
                if (!a) for (const e of o)l.has(e.toString()) || (n = !1);
                a || n ? this._notify(o, t1, i) : this.requestors.push({
                    ids: o,
                    scope: t1,
                    callback: i
                });
            }
            rasterizeImages(e, t1) {
                const i = new Map, { tasks: o, scope: r } = e;
                for (const [e, t1] of o.entries()){
                    const o = this.getImage(t1.id, r);
                    o && i.set(e, {
                        image: o,
                        imageVariant: t1
                    });
                }
                this._rasterizeImages(r, i, t1);
            }
            _rasterizeImages(t1, i, o) {
                if (e.t()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", {
                    tasks: i,
                    scope: t1
                }, o);
                else {
                    const e = new Map;
                    for (const [o, { image: r, imageVariant: s }] of i.entries())e.set(o, this.imageRasterizer.rasterize(s, r, t1, 0));
                    o(void 0, e);
                }
            }
            getUpdatedImages(e) {
                return this.updatedImages.get(e) || new Set;
            }
            _notify(t1, i, o) {
                const r = this.images.get(i), s = new Map;
                for (const i of t1){
                    if (!r.get(i.toString())) {
                        if (i.iconsetId) continue;
                        this.fire(new e.A("styleimagemissing", {
                            id: i.name
                        }));
                    }
                    const t1 = r.get(i.toString());
                    if (!t1) {
                        e.w(`Image "${i.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                        continue;
                    }
                    const o = {
                        data: t1.usvg ? null : t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        usvg: t1.usvg,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    };
                    t1.usvg && Object.assign(o, {
                        width: t1.icon.usvg_tree.width,
                        height: t1.icon.usvg_tree.height
                    }), s.set(e.I.toString(i), o);
                }
                o(null, s);
            }
            getPixelSize(e) {
                const { width: t1, height: i } = this.atlasImage.get(e);
                return {
                    width: t1,
                    height: i
                };
            }
            getPattern(t1, i, o) {
                const r = t1.toString(), s = this.patterns.get(i), n = s.get(r), a = this.getImage(t1, i);
                if (!a) return null;
                if (n) {
                    if (n.position.version === a.version) return n.position;
                    n.position.version = a.version;
                } else {
                    if (a.usvg && !a.data) {
                        const s = this.getPatternInFlightId(r, i);
                        if (this.patternsInFlight.has(s)) return null;
                        this.patternsInFlight.add(s);
                        const n = new e.B(t1).scaleSelf(e.q.devicePixelRatio), l = new Map([
                            [
                                n.toString(),
                                {
                                    image: a,
                                    imageVariant: n
                                }
                            ]
                        ]);
                        return this._rasterizeImages(i, l, (e, t1)=>this.storePatternImage(n, i, a, o, t1)), null;
                    }
                    this.storePattern(t1, i, a);
                }
                return this._updatePatternAtlas(i, o), s.get(r).position;
            }
            getPatternInFlightId(t1, i) {
                return e.C(t1, i);
            }
            hasPatternsInFlight() {
                return 0 !== this.patternsInFlight.size;
            }
            storePatternImage(e, t1, i, o, r) {
                const s = e.toString(), n = r ? r.get(s) : void 0;
                n && (i.data = n, this.storePattern(e.id, t1, i), this._updatePatternAtlas(t1, o), this.patternsInFlight.delete(this.getPatternInFlightId(e.id.toString(), t1)));
            }
            storePattern(t1, i, o) {
                const r = {
                    w: o.data.width + 2 * e.F,
                    h: o.data.height + 2 * e.F,
                    x: 0,
                    y: 0
                }, s = new e.G(r, o, e.F);
                this.patterns.get(i).set(t1.toString(), {
                    bin: r,
                    position: s
                });
            }
            destroyAtlasTextures() {
                for (const e of this.atlasTexture.values())e && e.destroy();
                this.atlasTexture.clear();
            }
            bind(t1, i) {
                const o = t1.gl;
                let r = this.atlasTexture.get(i);
                r ? this.dirty && (r.update(this.atlasImage.get(i)), this.dirty = !1) : (r = new e.T(t1, this.atlasImage.get(i), o.RGBA8), this.atlasTexture.set(i, r)), r.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t1, i) {
                const o = this.patterns.get(t1), r = Array.from(o.values()).map(({ bin: e })=>e), { w: s, h: n } = e.H(r), a = this.atlasImage.get(t1);
                a.resize({
                    width: s || 1,
                    height: n || 1
                });
                const l = this.images.get(t1);
                for (const [t1, { bin: r, position: s }] of o.entries()){
                    let o = s.padding;
                    const n = r.x + o, c = r.y + o, h = l.get(t1).data, d = h.width, u = h.height;
                    o = o > 1 ? o - 1 : o, e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n,
                        y: c
                    }, {
                        width: d,
                        height: u
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: u - o
                    }, {
                        x: n,
                        y: c - o
                    }, {
                        width: d,
                        height: o
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n,
                        y: c + u
                    }, {
                        width: d,
                        height: o
                    }, i), e.r.copy(h, a, {
                        x: d - o,
                        y: 0
                    }, {
                        x: n - o,
                        y: c
                    }, {
                        width: o,
                        height: u
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n + d,
                        y: c
                    }, {
                        width: o,
                        height: u
                    }, i), e.r.copy(h, a, {
                        x: d - o,
                        y: u - o
                    }, {
                        x: n - o,
                        y: c - o
                    }, {
                        width: o,
                        height: o
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: u - o
                    }, {
                        x: n + d,
                        y: c - o
                    }, {
                        width: o,
                        height: o
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: n + d,
                        y: c + u
                    }, {
                        width: o,
                        height: o
                    }, i), e.r.copy(h, a, {
                        x: d - o,
                        y: 0
                    }, {
                        x: n - o,
                        y: c + u
                    }, {
                        width: o,
                        height: o
                    }, i);
                }
                this.dirty = !0;
            }
            beginFrame() {
                for (const e of this.images.keys())this.callbackDispatchedThisFrame.set(e, new Set);
            }
            dispatchRenderCallbacks(e, t1) {
                const i = this.images.get(t1);
                for (const o of e){
                    if (this.callbackDispatchedThisFrame.get(t1).has(o.toString())) continue;
                    this.callbackDispatchedThisFrame.get(t1).add(o.toString());
                    const e = i.get(o.toString());
                    V(e) && this.updateImage(o, t1, e);
                }
            }
            destroy() {
                this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove();
            }
        }
        function H(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec || {}, s = t1.objectElementValidators || {}, n = t1.style, a = t1.styleSpec;
            let l = [];
            const c = e.J(o);
            if ("object" !== c) return [
                new e.V(i, o, `object expected, ${c} found`)
            ];
            for(const t1 in o){
                const c = t1.split(".")[0];
                let h;
                s[c] ? h = s[c] : r[c] ? h = _e : s["*"] ? h = s["*"] : r["*"] && (h = _e), h ? l = l.concat(h({
                    key: (i ? `${i}.` : i) + t1,
                    value: o[t1],
                    valueSpec: r[c] || r["*"],
                    style: n,
                    styleSpec: a,
                    object: o,
                    objectKey: t1
                }, o)) : l.push(new e.K(i, o[t1], `unknown property "${t1}"`));
            }
            for(const t1 in r)s[t1] || r[t1].required && void 0 === r[t1].default && void 0 === o[t1] && l.push(new e.V(i, o, `missing required property "${t1}"`));
            return l;
        }
        function Z(t1) {
            const i = t1.value, o = t1.valueSpec, r = t1.style, s = t1.styleSpec, n = t1.key, a = t1.arrayElementValidator || _e;
            if ("array" !== e.J(i)) return [
                new e.V(n, i, `array expected, ${e.J(i)} found`)
            ];
            if (o.length && i.length !== o.length) return [
                new e.V(n, i, `array length ${o.length} expected, length ${i.length} found`)
            ];
            if (o["min-length"] && i.length < o["min-length"]) return [
                new e.V(n, i, `array length at least ${o["min-length"]} expected, length ${i.length} found`)
            ];
            let l = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0
            };
            s.$version < 7 && (l.function = o.function), "object" === e.J(o.value) && (l = o.value);
            let c = [];
            for(let e = 0; e < i.length; e++)c = c.concat(a({
                array: i,
                arrayIndex: e,
                value: i[e],
                valueSpec: l,
                style: r,
                styleSpec: s,
                key: `${n}[${e}]`
            }, !0));
            return c;
        }
        function W(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec;
            let s = e.J(o);
            if ("number" === s && o != o && (s = "NaN"), "number" !== s) return [
                new e.V(i, o, `number expected, ${s} found`)
            ];
            if ("minimum" in r) {
                let s = r.minimum;
                if ("array" === e.J(r.minimum) && (s = r.minimum[t1.arrayIndex]), o < s) return [
                    new e.V(i, o, `${o} is less than the minimum value ${s}`)
                ];
            }
            if ("maximum" in r) {
                let s = r.maximum;
                if ("array" === e.J(r.maximum) && (s = r.maximum[t1.arrayIndex]), o > s) return [
                    new e.V(i, o, `${o} is greater than the maximum value ${s}`)
                ];
            }
            return [];
        }
        function $(t1) {
            const i = t1.valueSpec, o = e.M(t1.value.type);
            let r, s, n, a = {};
            const l = "categorical" !== o && void 0 === t1.value.property, c = !l, h = "array" === e.J(t1.value.stops) && "array" === e.J(t1.value.stops[0]) && "object" === e.J(t1.value.stops[0][0]), d = H({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === o) return [
                            new e.V(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let i = [];
                        const r = t1.value;
                        return i = i.concat(Z({
                            key: t1.key,
                            value: r,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: u
                        })), "array" === e.J(r) && 0 === r.length && i.push(new e.V(t1.key, r, "array must have at least one stop")), i;
                    },
                    default: function(e) {
                        return _e({
                            key: e.key,
                            value: e.value,
                            valueSpec: i,
                            style: e.style,
                            styleSpec: e.styleSpec
                        });
                    }
                }
            });
            return "identity" === o && l && d.push(new e.V(t1.key, t1.value, 'missing required property "property"')), "identity" === o || t1.value.stops || d.push(new e.V(t1.key, t1.value, 'missing required property "stops"')), "exponential" === o && t1.valueSpec.expression && !e.N(t1.valueSpec) && d.push(new e.V(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (c && !e.O(t1.valueSpec) ? d.push(new e.V(t1.key, t1.value, "property functions not supported")) : l && !e.Q(t1.valueSpec) && d.push(new e.V(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== o && !h || void 0 !== t1.value.property || d.push(new e.V(t1.key, t1.value, '"property" property is required')), d;
            //TURBOPACK unreachable
            ;
            function u(t1) {
                let o = [];
                const r = t1.value, l = t1.key;
                if ("array" !== e.J(r)) return [
                    new e.V(l, r, `array expected, ${e.J(r)} found`)
                ];
                if (2 !== r.length) return [
                    new e.V(l, r, `array length 2 expected, length ${r.length} found`)
                ];
                if (h) {
                    if ("object" !== e.J(r[0])) return [
                        new e.V(l, r, `object expected, ${e.J(r[0])} found`)
                    ];
                    if (void 0 === r[0].zoom) return [
                        new e.V(l, r, "object stop key must have zoom")
                    ];
                    if (void 0 === r[0].value) return [
                        new e.V(l, r, "object stop key must have value")
                    ];
                    const i = e.M(r[0].zoom);
                    if ("number" != typeof i) return [
                        new e.V(l, r[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (n && n > i) return [
                        new e.V(l, r[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    i !== n && (n = i, s = void 0, a = {}), o = o.concat(H({
                        key: `${l}[0]`,
                        value: r[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: W,
                            value: _
                        }
                    }));
                } else o = o.concat(_({
                    key: `${l}[0]`,
                    value: r[0],
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, r));
                return e.S(e.U(r[1])) ? o.concat([
                    new e.V(`${l}[1]`, r[1], "expressions are not allowed in function stops.")
                ]) : o.concat(_e({
                    key: `${l}[1]`,
                    value: r[1],
                    valueSpec: i,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function _(t1, n) {
                const l = e.J(t1.value), c = e.M(t1.value), h = null !== t1.value ? t1.value : n;
                if (r) {
                    if (l !== r) return [
                        new e.V(t1.key, h, `${l} stop domain type must match previous stop domain type ${r}`)
                    ];
                } else r = l;
                if ("number" !== l && "string" !== l && "boolean" !== l && "number" != typeof c && "string" != typeof c && "boolean" != typeof c) return [
                    new e.V(t1.key, h, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== l && "categorical" !== o) {
                    let r = `number expected, ${l} found`;
                    return e.O(i) && void 0 === o && (r += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new e.V(t1.key, h, r)
                    ];
                }
                return "categorical" !== o || "number" !== l || "number" == typeof c && isFinite(c) && Math.floor(c) === c ? "categorical" !== o && "number" === l && "number" == typeof c && "number" == typeof s && void 0 !== s && c < s ? [
                    new e.V(t1.key, h, "stop domain values must appear in ascending order")
                ] : (s = c, "categorical" === o && c in a ? [
                    new e.V(t1.key, h, "stop domain values must be unique")
                ] : (a[c] = !0, [])) : [
                    new e.V(t1.key, h, `integer expected, found ${String(c)}`)
                ];
            }
        }
        function X(t1) {
            const i = ("property" === t1.expressionContext ? e.W : e.X)(e.U(t1.value), t1.valueSpec);
            if ("error" === i.result) return i.value.map((i)=>new e.V(`${t1.key}${i.key}`, t1.value, i.message));
            const o = i.value.expression || i.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !o.outputDefined()) return [
                new e.V(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !e.Y(o)) return [
                new e.V(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return Y(o, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!e.Z(o, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new e.V(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !e._(o)) return [
                    new e.V(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function Y(t1, i) {
            const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters)o.delete(e);
            if (0 === o.size) return [];
            const r = [];
            return t1 instanceof e.$ && o.has(t1.name) ? [
                new e.V(i.key, i.value, `["${t1.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)
            ] : (t1.eachChild((e)=>{
                r.push(...Y(e, i));
            }), r);
        }
        function K(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec, s = [];
            return Array.isArray(r.values) ? -1 === r.values.indexOf(e.M(o)) && s.push(new e.V(i, o, `expected one of [${r.values.join(", ")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(r.values).indexOf(e.M(o)) && s.push(new e.V(i, o, `expected one of [${Object.keys(r.values).join(", ")}], ${JSON.stringify(o)} found`)), s;
        }
        function J(t1) {
            return e.a1(e.U(t1.value)) ? X(e.L({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : Q(t1);
        }
        function Q(t1) {
            const i = t1.value, o = t1.key;
            if ("array" !== e.J(i)) return [
                new e.V(o, i, `array expected, ${e.J(i)} found`)
            ];
            const r = t1.styleSpec;
            let s, n = [];
            if (i.length < 1) return [
                new e.V(o, i, "filter array must have at least 1 element")
            ];
            switch(n = n.concat(K({
                key: `${o}[0]`,
                value: i[0],
                valueSpec: r.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), e.M(i[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    i.length >= 2 && "$type" === e.M(i[1]) && n.push(new e.V(o, i, `"$type" cannot be use with operator "${i[0]}"`));
                case "==":
                case "!=":
                    3 !== i.length && n.push(new e.V(o, i, `filter array for operator "${i[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    i.length >= 2 && (s = e.J(i[1]), "string" !== s && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${s} found`)));
                    for(let a = 2; a < i.length; a++)s = e.J(i[a]), "$type" === e.M(i[1]) ? n = n.concat(K({
                        key: `${o}[${a}]`,
                        value: i[a],
                        valueSpec: r.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== s && "number" !== s && "boolean" !== s && n.push(new e.V(`${o}[${a}]`, i[a], `string, number, or boolean expected, ${s} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let e = 1; e < i.length; e++)n = n.concat(Q({
                        key: `${o}[${e}]`,
                        value: i[e],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    s = e.J(i[1]), 2 !== i.length ? n.push(new e.V(o, i, `filter array for "${i[0]}" operator must have 2 elements`)) : "string" !== s && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${s} found`));
            }
            return n;
        }
        function ee(t1, i) {
            const o = t1.key, r = t1.style, s = t1.layer, n = t1.styleSpec, a = t1.value, l = t1.objectKey, c = n[`${i}_${t1.layerType}`];
            if (!c) return [];
            const h = l.match(/^(.*)-use-theme$/);
            if ("paint" === i && h && c[h[1]]) return e.S(a) ? [].concat(_e({
                key: t1.key,
                value: a,
                valueSpec: {
                    type: "string",
                    expression: {
                        interpolated: !1,
                        parameters: [
                            "zoom",
                            "feature"
                        ]
                    },
                    "property-type": "data-driven"
                },
                style: r,
                styleSpec: n,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            })) : _e({
                key: o,
                value: a,
                valueSpec: {
                    type: "string"
                },
                style: r,
                styleSpec: n
            });
            const d = l.match(/^(.*)-transition$/);
            if ("paint" === i && d && c[d[1]] && c[d[1]].transition) return _e({
                key: o,
                value: a,
                valueSpec: n.transition,
                style: r,
                styleSpec: n
            });
            const u = t1.valueSpec || c[l];
            if (!u) return [
                new e.K(o, a, `unknown property "${l}"`)
            ];
            let _;
            if ("string" === e.J(a) && e.O(u) && !u.tokens && (_ = /^{([^}]+)}$/.exec(a))) {
                const t1 = `\`{ "type": "identity", "property": ${_ ? JSON.stringify(_[1]) : '"_"'} }\``;
                return [
                    new e.V(o, a, `"${l}" does not support interpolation syntax\nUse an identity property function instead: ${t1}.`)
                ];
            }
            const p = [];
            if ("symbol" === t1.layerType) "text-field" !== l || !r || r.glyphs || r.imports || p.push(new e.V(o, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l && e.a2(e.U(a)) && "identity" === e.M(a.type) && p.push(new e.V(o, a, '"text-font" does not support identity functions'));
            else if ("model" === t1.layerType && "paint" === i && s && s.layout && s.layout.hasOwnProperty("model-id") && e.O(u) && (e.a3(u) || e.Q(u))) {
                const t1 = e.W(e.U(a), u), i = t1.value.expression || t1.value._styleExpression.expression;
                i && !e.Z(i, [
                    "measure-light"
                ]) && ("model-emissive-strength" === l && e._(i) && e.Y(i) || p.push(new e.V(o, a, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return p.concat(_e({
                key: t1.key,
                value: a,
                valueSpec: u,
                style: r,
                styleSpec: n,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            }));
        }
        function te(e) {
            return ee(e, "paint");
        }
        function ie(e) {
            return ee(e, "layout");
        }
        function oe(t1) {
            let i = [];
            const o = t1.value, r = t1.key, s = t1.style, n = t1.styleSpec;
            o.type || o.ref || i.push(new e.V(r, o, 'either "type" or "ref" is required'));
            let a = e.M(o.type);
            const l = e.M(o.ref);
            if (o.id) {
                const n = e.M(o.id);
                for(let a = 0; a < t1.arrayIndex; a++){
                    const t1 = s.layers[a];
                    e.M(t1.id) === n && i.push(new e.V(r, o.id, `duplicate layer id "${o.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in o) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in o && i.push(new e.V(r, o[t1], `"${t1}" is prohibited for ref layers`));
                }), s.layers.forEach((i)=>{
                    e.M(i.id) === l && (t1 = i);
                }), t1 ? t1.ref ? i.push(new e.V(r, o.ref, "ref cannot reference another ref layer")) : a = e.M(t1.type) : "string" == typeof l && i.push(new e.V(r, o.ref, `ref layer "${l}" not found`));
            } else if ("background" !== a && "sky" !== a && "slot" !== a) if (o.source) {
                const t1 = s.sources && s.sources[o.source], n = t1 && e.M(t1.type);
                t1 ? "vector" === n && "raster" === a ? i.push(new e.V(r, o.source, `layer "${o.id}" requires a raster source`)) : "raster" === n && "raster" !== a ? i.push(new e.V(r, o.source, `layer "${o.id}" requires a vector source`)) : "vector" !== n || o["source-layer"] ? "raster-dem" === n && "hillshade" !== a ? i.push(new e.V(r, o.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n || [
                    "raster",
                    "raster-particle"
                ].includes(a) ? "line" === a && o.paint && (o.paint["line-gradient"] || o.paint["line-trim-offset"]) && "geojson" === n && !t1.lineMetrics ? i.push(new e.V(r, o, `layer "${o.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a && "raster-array" !== n && i.push(new e.V(r, o.source, `layer "${o.id}" requires a 'raster-array' source.`)) : i.push(new e.V(r, o.source, "raster-array source can only be used with layer type 'raster'.")) : i.push(new e.V(r, o, `layer "${o.id}" must specify a "source-layer"`)) : i.push(new e.V(r, o.source, `source "${o.source}" not found`));
            } else i.push(new e.V(r, o, 'missing required property "source"'));
            return i = i.concat(H({
                key: r,
                value: o,
                valueSpec: n.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>_e({
                            key: `${r}.type`,
                            value: o.type,
                            valueSpec: n.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: o,
                            objectKey: "type"
                        }),
                    filter: (t1)=>J(e.L({
                            layerType: a
                        }, t1)),
                    layout: (t1)=>H({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>ie(e.L({
                                        layerType: a
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>H({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>te(e.L({
                                        layerType: a,
                                        layer: o
                                    }, t1))
                            }
                        })
                }
            })), i;
        }
        function re(t1) {
            const i = t1.value, o = t1.key, r = e.J(i);
            return "string" !== r ? [
                new e.V(o, i, `string expected, ${r} found`)
            ] : [];
        }
        const se = {
            promoteId: function t1({ key: i, value: o }) {
                if ("string" === e.J(o)) return re({
                    key: i,
                    value: o
                });
                if (Array.isArray(o)) {
                    const t1 = [], r = e.U(o), s = e.X(r);
                    return "error" === s.result && s.value.forEach((o)=>{
                        t1.push(new e.V(`${i}${o.key}`, null, `${o.message}`));
                    }), e.Z(s.value.expression, [
                        "zoom",
                        "heatmap-density",
                        "line-progress",
                        "raster-value",
                        "sky-radial-progress",
                        "accumulated",
                        "is-supported-script",
                        "pitch",
                        "distance-from-center",
                        "measure-light",
                        "raster-particle-speed"
                    ]) || t1.push(new e.V(`${i}`, null, "promoteId expression should be only feature dependent")), t1;
                }
                {
                    const e = [];
                    for(const r in o)e.push(...t1({
                        key: `${i}.${r}`,
                        value: o[r]
                    }));
                    return e;
                }
            }
        };
        function ne(t1) {
            const i = t1.value, o = t1.key, r = t1.styleSpec, s = t1.style;
            if (!i.type) return [
                new e.V(o, i, '"type" is required')
            ];
            const n = e.M(i.type);
            let a = [];
            switch([
                "vector",
                "raster",
                "raster-dem",
                "raster-array"
            ].includes(n) && (i.url || i.tiles || a.push(new e.K(o, i, 'Either "url" or "tiles" is required.'))), n){
                case "vector":
                case "raster":
                case "raster-dem":
                case "raster-array":
                    return a = a.concat(H({
                        key: o,
                        value: i,
                        valueSpec: r[`source_${n.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: r,
                        objectElementValidators: se
                    })), a;
                case "geojson":
                    if (a = H({
                        key: o,
                        value: i,
                        valueSpec: r.source_geojson,
                        style: s,
                        styleSpec: r,
                        objectElementValidators: se
                    }), i.cluster) for(const e in i.clusterProperties){
                        const [t1, r] = i.clusterProperties[e], s = "string" == typeof t1 ? [
                            t1,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                e
                            ]
                        ] : t1;
                        a.push(...X({
                            key: `${o}.${e}.map`,
                            value: r,
                            expressionContext: "cluster-map"
                        })), a.push(...X({
                            key: `${o}.${e}.reduce`,
                            value: s,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return a;
                case "video":
                    return H({
                        key: o,
                        value: i,
                        valueSpec: r.source_video,
                        style: s,
                        styleSpec: r
                    });
                case "image":
                    return H({
                        key: o,
                        value: i,
                        valueSpec: r.source_image,
                        style: s,
                        styleSpec: r
                    });
                case "canvas":
                    return [
                        new e.V(o, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return K({
                        key: `${o}.type`,
                        value: i.type,
                        valueSpec: {
                            values: ae(r)
                        }
                    });
            }
        }
        function ae(e) {
            return e.source.reduce((t1, i)=>{
                const o = e[i];
                return "enum" === o.type.type && (t1 = t1.concat(Object.keys(o.type.values))), t1;
            }, []);
        }
        function le(t1) {
            const i = t1.value, o = t1.styleSpec, r = o.light, s = t1.style;
            let n = [];
            const a = e.J(i);
            if (void 0 === i) return n;
            if ("object" !== a) return n = n.concat([
                new e.V("light", i, `object expected, ${a} found`)
            ]), n;
            for(const t1 in i){
                const a = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                n = n.concat(l && r[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: s,
                    styleSpec: o
                }) : a && r[a[1]] && r[a[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: o.transition,
                    style: s,
                    styleSpec: o
                }) : r[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: r[t1],
                    style: s,
                    styleSpec: o
                }) : [
                    new e.V(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        function ce(t1) {
            const i = t1.value;
            let o = [];
            if (!i) return o;
            const r = e.J(i);
            if ("object" !== r) return o = o.concat([
                new e.V("light-3d", i, `object expected, ${r} found`)
            ]), o;
            const s = t1.styleSpec, n = s["light-3d"], a = t1.key, l = t1.style, c = t1.style.lights;
            for (const t1 of [
                "type",
                "id"
            ])if (!(t1 in i)) return o = o.concat([
                new e.V("light-3d", i, `missing property ${t1} on light`)
            ]), o;
            if (i.type && c) for(let r = 0; r < t1.arrayIndex; r++){
                const t1 = e.M(i.type), s = c[r];
                e.M(s.type) === t1 && o.push(new e.V(a, i.id, `duplicate light type "${i.type}", previously defined at line ${s.id.__line__}`));
            }
            const h = `properties_light_${i.type}`;
            if (!(h in s)) return o = o.concat([
                new e.V("light-3d", i, `Invalid light type ${i.type}`)
            ]), o;
            const d = s[h];
            for(const r in i)if ("properties" === r) {
                const n = i[r], a = e.J(n);
                if ("object" !== a) return o = o.concat([
                    new e.V("properties", n, `object expected, ${a} found`)
                ]), o;
                for(const a in n){
                    const c = a.match(/^(.*)-transition$/), h = a.match(/^(.*)-use-theme$/);
                    o = o.concat(h && d[h[1]] ? _e({
                        key: r,
                        value: n[a],
                        valueSpec: {
                            type: "string"
                        },
                        style: l,
                        styleSpec: s
                    }) : c && d[c[1]] && d[c[1]].transition ? _e({
                        key: r,
                        value: i[r],
                        valueSpec: s.transition,
                        style: l,
                        styleSpec: s
                    }) : d[a] ? _e({
                        key: a,
                        value: n[a],
                        valueSpec: d[a],
                        style: l,
                        styleSpec: s
                    }) : [
                        new e.K(t1.key, n[a], `unknown property "${a}"`)
                    ]);
                }
            } else o = o.concat(n[r] ? _e({
                key: r,
                value: i[r],
                valueSpec: n[r],
                style: l,
                styleSpec: s
            }) : [
                new e.K(r, i[r], `unknown property "${r}"`)
            ]);
            return o;
        }
        function he(t1) {
            const i = t1.value, o = t1.key, r = t1.style, s = t1.styleSpec, n = s.terrain;
            let a = [];
            const l = e.J(i);
            if (void 0 === i) return a;
            if ("null" === l) return a;
            if ("object" !== l) return a = a.concat([
                new e.V("terrain", i, `object expected, ${l} found`)
            ]), a;
            for(const t1 in i){
                const o = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                a = a.concat(l && n[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: r,
                    styleSpec: s
                }) : o && n[o[1]] && n[o[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: s.transition,
                    style: r,
                    styleSpec: s
                }) : n[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: n[t1],
                    style: r,
                    styleSpec: s
                }) : [
                    new e.K(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            if (i.source) {
                const t1 = r.sources && r.sources[i.source], s = t1 && e.M(t1.type);
                t1 ? "raster-dem" !== s && a.push(new e.V(o, i.source, `terrain cannot be used with a source of type ${String(s)}, it only be used with a "raster-dem" source type`)) : a.push(new e.V(o, i.source, `source "${i.source}" not found`));
            } else a.push(new e.V(o, i, 'terrain is missing required property "source"'));
            return a;
        }
        function de(t1) {
            const i = t1.value, o = t1.style, r = t1.styleSpec, s = r.fog;
            let n = [];
            const a = e.J(i);
            if (void 0 === i) return n;
            if ("object" !== a) return n = n.concat([
                new e.V("fog", i, `object expected, ${a} found`)
            ]), n;
            for(const t1 in i){
                const a = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                n = n.concat(l && s[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: o,
                    styleSpec: r
                }) : a && s[a[1]] && s[a[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: r.transition,
                    style: o,
                    styleSpec: r
                }) : s[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: s[t1],
                    style: o,
                    styleSpec: r
                }) : [
                    new e.K(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        const ue = {
            "*": ()=>[],
            array: Z,
            boolean: function(t1) {
                const i = t1.value, o = t1.key, r = e.J(i);
                return "boolean" !== r ? [
                    new e.V(o, i, `boolean expected, ${r} found`)
                ] : [];
            },
            number: W,
            color: function(t1) {
                const i = t1.key, o = t1.value, r = e.J(o);
                return "string" !== r ? [
                    new e.V(i, o, `color expected, ${r} found`)
                ] : null === e.a0.parseCSSColor(o) ? [
                    new e.V(i, o, `color expected, "${o}" found`)
                ] : [];
            },
            enum: K,
            filter: J,
            function: $,
            layer: oe,
            object: H,
            source: ne,
            model: e.a4,
            light: le,
            "light-3d": ce,
            terrain: he,
            fog: de,
            string: re,
            formatted: function(e) {
                return 0 === re(e).length ? [] : X(e);
            },
            resolvedImage: function(e) {
                return 0 === re(e).length ? [] : X(e);
            },
            projection: function(t1) {
                const i = t1.value, o = t1.styleSpec, r = o.projection, s = t1.style;
                let n = [];
                const a = e.J(i);
                if ("object" === a) for(const e in i)n = n.concat(_e({
                    key: e,
                    value: i[e],
                    valueSpec: r[e],
                    style: s,
                    styleSpec: o
                }));
                else "string" !== a && (n = n.concat([
                    new e.V("projection", i, `object or string expected, ${a} found`)
                ]));
                return n;
            },
            import: function(t1) {
                const { value: i, styleSpec: o } = t1, { data: r, ...s } = i;
                Object.defineProperty(s, "__line__", {
                    value: i.__line__,
                    enumerable: !1
                });
                let n = H(e.L({}, t1, {
                    value: s,
                    valueSpec: o.import
                }));
                return "" === e.M(s.id) && n.push(new e.V(`${t1.key}.id`, s, "import id can't be an empty string")), r && (n = n.concat(fe(r, o, {
                    key: `${t1.key}.data`
                }))), n;
            },
            iconset: function(t1) {
                const i = t1.value, o = t1.key, r = t1.styleSpec, s = t1.style;
                if (!i.type) return [
                    new e.V(o, i, '"type" is required')
                ];
                const n = e.M(i.type);
                let a = [];
                if (a = a.concat(H({
                    key: o,
                    value: i,
                    valueSpec: r[`iconset_${n}`],
                    style: s,
                    styleSpec: r
                })), "source" === n && i.source) {
                    const t1 = s.sources && s.sources[i.source], r = t1 && e.M(t1.type);
                    t1 ? "raster-array" !== r && a.push(new e.V(o, i.source, `iconset cannot be used with a source of type ${String(r)}, it only be used with a "raster-array" source type`)) : a.push(new e.V(o, i.source, `source "${i.source}" not found`));
                }
                return a;
            }
        };
        function _e(t1, i = !1) {
            const o = t1.value, r = t1.valueSpec, s = t1.styleSpec;
            if (r.expression && e.a2(e.M(o))) return $(t1);
            if (r.expression && e.S(e.U(o))) return X(t1);
            if (r.type && ue[r.type]) {
                const o = ue[r.type](t1);
                return !0 === i && o.length > 0 && "array" === e.J(t1.value) ? X(t1) : o;
            }
            return H(e.L({}, t1, {
                valueSpec: r.type ? s[r.type] : r
            }));
        }
        function pe(t1) {
            const i = t1.value, o = t1.key, r = re(t1);
            return r.length || (-1 === i.indexOf("{fontstack}") && r.push(new e.V(o, i, '"glyphs" url must include a "{fontstack}" token')), -1 === i.indexOf("{range}") && r.push(new e.V(o, i, '"glyphs" url must include a "{range}" token'))), r;
        }
        function fe(t1, i = e.a5, o = {}) {
            return _e({
                key: o.key || "",
                value: t1,
                valueSpec: i.$root,
                styleSpec: i,
                style: t1,
                objectElementValidators: {
                    glyphs: pe,
                    "*": ()=>[]
                }
            });
        }
        function me(t1, i = e.a5) {
            return Ae(fe(t1, i));
        }
        const ge = (e)=>Ae(ne(e)), ve = (e)=>Ae(le(e)), ye = (e)=>Ae(ce(e)), xe = (e)=>Ae(he(e)), be = (e)=>Ae(de(e)), we = (t1)=>Ae(function(t1) {
                const i = t1.value, o = t1.style, r = t1.styleSpec, s = r.snow;
                let n = [];
                const a = e.J(i);
                if (void 0 === i) return n;
                if ("object" !== a) return n = n.concat([
                    new e.V("snow", i, `object expected, ${a} found`)
                ]), n;
                for(const t1 in i){
                    const a = t1.match(/^(.*)-transition$/);
                    n = n.concat(a && s[a[1]] && s[a[1]].transition ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: r.transition,
                        style: o,
                        styleSpec: r
                    }) : s[t1] ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: s[t1],
                        style: o,
                        styleSpec: r
                    }) : [
                        new e.K(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return n;
            }(t1)), Te = (t1)=>Ae(function(t1) {
                const i = t1.value, o = t1.style, r = t1.styleSpec, s = r.rain;
                let n = [];
                const a = e.J(i);
                if (void 0 === i) return n;
                if ("object" !== a) return n = n.concat([
                    new e.V("rain", i, `object expected, ${a} found`)
                ]), n;
                for(const t1 in i){
                    const a = t1.match(/^(.*)-transition$/);
                    n = n.concat(a && s[a[1]] && s[a[1]].transition ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: r.transition,
                        style: o,
                        styleSpec: r
                    }) : s[t1] ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: s[t1],
                        style: o,
                        styleSpec: r
                    }) : [
                        new e.K(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return n;
            }(t1)), Ee = (e)=>Ae(oe(e)), Se = (e)=>Ae(J(e)), Ie = (e)=>Ae(te(e)), Ce = (e)=>Ae(ie(e)), Re = (t1)=>Ae(e.a4(t1));
        function Ae(e) {
            return e.slice().sort((e, t1)=>e.line && t1.line ? e.line - t1.line : 0);
        }
        function De(t1, i) {
            let o = !1;
            if (i && i.length) for (const r of i)r instanceof e.K ? e.w(r.message) : (t1.fire(new e.z(new Error(r.message))), o = !0);
            return o;
        }
        let Pe;
        class Le extends e.E {
            constructor(t1, i = "flat"){
                super(), this._transitionable = new e.a6(Pe || (Pe = new e.a7({
                    anchor: new e.a8(e.a5.light.anchor),
                    position: new e.a9(e.a5.light.position),
                    color: new e.a8(e.a5.light.color),
                    intensity: new e.a8(e.a5.light.intensity)
                }))), this.setLight(t1, i), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(e, t1, i = {}) {
                this._validate(ve, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && De(this, t1.call(me, e.h({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a5
                })));
            }
        }
        let ze = class extends e.E {
            constructor(t1, i, o, r, s){
                super(), this.scope = o, this._transitionable = new e.a6(new e.a7({
                    source: new e.a8(e.a5.terrain.source),
                    exaggeration: new e.a8(e.a5.terrain.exaggeration)
                }), o, r), this._transitionable.setTransitionOrValue(t1, r), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i, this.worldview = s;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(e, t1) {
                this._transitionable.setTransitionOrValue(e, t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            getExaggeration(t1) {
                return this._transitioning.possiblyEvaluate(new e.aa(t1, {
                    worldview: this.worldview
                })).get("exaggeration");
            }
            getAttenuationRange() {
                if (!this.isZoomDependent()) return null;
                const t1 = this._transitionable._values.exaggeration;
                if (!t1) return null;
                const i = t1.value.expression;
                if (!i) return null;
                let o = -1, r = -1, s = 1;
                for (const t1 of i.zoomStops)s = i.evaluate(new e.aa(t1, {
                    worldview: this.worldview
                })), s > .01 ? (o = t1, r = -1) : r = t1;
                return s < .01 && o > 0 && r > o ? [
                    o,
                    r
                ] : null;
            }
            isZoomDependent() {
                const t1 = this._transitionable._values.exaggeration;
                return null != t1 && null != t1.value && null != t1.value.expression && t1.value.expression instanceof e.ab;
            }
        };
        const Me = 45, Oe = 65, Fe = .05;
        function Be(t1, i, o, r) {
            const s = e.af(Me, Oe, o), [n, a] = ke(t1, r);
            let l = 1 - Math.min(1, Math.exp((i - n) / (a - n) * -6));
            return l *= l * l, l = Math.min(1, 1.00747 * l), l * s * t1.alpha;
        }
        function ke(e, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e.range[0] + i,
                e.range[1] + i
            ];
        }
        function Ne(t1, i, o, r, s) {
            const n = e.ad([], [
                i,
                o,
                r
            ], s.mercatorFogMatrix);
            return Be(t1, e.ae(n), s.pitch, s._fov);
        }
        function Ue(t1, i, o, r, s, n, a) {
            const l = [
                [
                    o,
                    r,
                    0
                ],
                [
                    s,
                    r,
                    0
                ],
                [
                    s,
                    n,
                    0
                ],
                [
                    o,
                    n,
                    0
                ]
            ];
            let c = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (const t1 of l){
                const o = e.ad([], t1, i), r = e.ae(o);
                c = Math.min(c, r), h = Math.max(h, r);
            }
            return [
                Be(t1, c, a.pitch, a._fov),
                Be(t1, h, a.pitch, a._fov)
            ];
        }
        class je extends e.E {
            constructor(t1, i, o, r){
                super();
                const s = new e.a7({
                    range: new e.a8(e.a5.fog.range),
                    color: new e.a8(e.a5.fog.color),
                    "color-use-theme": new e.a8({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "high-color": new e.a8(e.a5.fog["high-color"]),
                    "high-color-use-theme": new e.a8({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "space-color": new e.a8(e.a5.fog["space-color"]),
                    "space-color-use-theme": new e.a8({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "horizon-blend": new e.a8(e.a5.fog["horizon-blend"]),
                    "star-intensity": new e.a8(e.a5.fog["star-intensity"]),
                    "vertical-range": new e.a8(e.a5.fog["vertical-range"])
                });
                this._transitionable = new e.a6(s, o, new Map(r)), this.set(t1, r), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.ag(s), this.scope = o;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e.ah(t1.zoom), r = this.properties.get("range"), s = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e.ai(s[0], r[0], o),
                        e.ai(s[1], r[1], o)
                    ] : r,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(be, t1, o)) return;
                const r = e.h({}, t1);
                for (const t1 of Object.keys(e.a5.fog))void 0 === r[t1] && (r[t1] = e.a5.fog[t1].default);
                this._options = r, this._transitionable.setTransitionOrValue(this._options, i);
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e.af(Me, Oe, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const r = e.ac.fromLngLat(i), s = o.elevation ? o.elevation.getAtPointOrZero(r) : 0;
                    return Ne(t1, r.x, r.y, s, o);
                }(this.state, t1, i) : 0;
            }
            getOpacityForTile(t1) {
                if (!this._transform.projection.supportsFog) return [
                    1,
                    1
                ];
                const i = this._transform.calculateFogTileMatrix(t1.toUnwrapped());
                return Ue(this.state, i, 0, 0, e.aj, e.aj, this._transform);
            }
            getOpacityForBounds(e, t1, i, o, r) {
                return this._transform.projection.supportsFog ? Ue(this.state, e, t1, i, o, r, this._transform) : [
                    1,
                    1
                ];
            }
            getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? ke(this.state, e) : [
                    0,
                    1
                ];
            }
            isVisibleOnFrustum(t1) {
                if (!this._transform.projection.supportsFog) return !1;
                const i = [
                    4,
                    5,
                    6,
                    7
                ];
                for (const o of i){
                    const i = t1.points[o];
                    let r;
                    if (i[2] >= 0) r = i;
                    else {
                        const s = t1.points[o - 4];
                        r = e.ak(s, i, s[2] / (s[2] - i[2]));
                    }
                    if (Ne(this.state, r[0], r[1], 0, this._transform) >= Fe) return !0;
                }
                return !1;
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && De(this, t1.call(me, e.h({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a5
                })));
            }
        }
        let Ge, Ve, qe, He, Ze = class extends e.E {
            constructor(t1, i, o, r){
                super();
                const s = Ge || (Ge = new e.a7({
                    density: new e.a8(e.a5.snow.density),
                    intensity: new e.a8(e.a5.snow.intensity),
                    color: new e.a8(e.a5.snow.color),
                    opacity: new e.a8(e.a5.snow.opacity),
                    vignette: new e.a8(e.a5.snow.vignette),
                    "vignette-color": new e.a8(e.a5.snow["vignette-color"]),
                    "center-thinning": new e.a8(e.a5.snow["center-thinning"]),
                    direction: new e.a8(e.a5.snow.direction),
                    "flake-size": new e.a8(e.a5.snow["flake-size"])
                }));
                this._transitionable = new e.a6(s, o, new Map(r)), this.set(t1, r), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ag(s), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), r = e.al(o[0]), s = -Math.max(e.al(o[1]), .01), n = [
                    Math.cos(r) * Math.cos(s),
                    Math.sin(r) * Math.cos(s),
                    Math.sin(s)
                ], a = this.properties.get("vignette"), l = this.properties.get("vignette-color");
                return l.a = a, {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.am(i.r, i.g, i.b, i.a * t1),
                    direction: n,
                    centerThinning: this.properties.get("center-thinning"),
                    flakeSize: this.properties.get("flake-size"),
                    vignetteColor: l
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(we, t1, o)) return;
                const r = e.h({}, t1);
                for (const t1 of Object.keys(e.a5.snow))void 0 === r[t1] && (r[t1] = e.a5.snow[t1].default);
                this._options = r, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && De(this, t1.call(me, e.h({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a5
                })));
            }
        }, We = class extends e.E {
            constructor(t1, i, o, r){
                super();
                const s = Ve || (Ve = new e.a7({
                    density: new e.a8(e.a5.rain.density),
                    intensity: new e.a8(e.a5.rain.intensity),
                    color: new e.a8(e.a5.rain.color),
                    opacity: new e.a8(e.a5.rain.opacity),
                    vignette: new e.a8(e.a5.rain.vignette),
                    "vignette-color": new e.a8(e.a5.rain["vignette-color"]),
                    "center-thinning": new e.a8(e.a5.rain["center-thinning"]),
                    direction: new e.a8(e.a5.rain.direction),
                    "droplet-size": new e.a8(e.a5.rain["droplet-size"]),
                    "distortion-strength": new e.a8(e.a5.rain["distortion-strength"])
                }));
                this._transitionable = new e.a6(s, o, new Map(r)), this.set(t1, r), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ag(s), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), r = e.al(o[0]), s = -Math.max(e.al(o[1]), .01), n = [
                    Math.cos(r) * Math.cos(s),
                    Math.sin(r) * Math.cos(s),
                    Math.sin(s)
                ], a = this.properties.get("vignette-color");
                return a.a = this.properties.get("vignette"), {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.am(i.r, i.g, i.b, i.a * t1),
                    direction: n,
                    centerThinning: this.properties.get("center-thinning"),
                    dropletSize: this.properties.get("droplet-size"),
                    distortionStrength: this.properties.get("distortion-strength"),
                    vignetteColor: a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(Te, t1, o)) return;
                const r = e.h({}, t1);
                for (const t1 of Object.keys(e.a5.rain))void 0 === r[t1] && (r[t1] = e.a5.rain[t1].default);
                this._options = r, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && De(this, t1.call(me, e.h({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a5
                })));
            }
        };
        class $e extends e.E {
            constructor(t1, i, o, r){
                super(), this.scope = o, this._options = t1, this.properties = new e.ag(i), this._transitionable = new e.a6(i, o, new Map(r)), this._transitionable.setTransitionOrValue(t1.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            get() {
                return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e, t1) {
                this._options = e, this._transitionable.setTransitionOrValue(e.properties, t1);
            }
            shadowsEnabled() {
                return !!this.properties && !0 === this.properties.get("cast-shadows");
            }
        }
        class Xe {
            constructor(e, t1, i){
                this.screenBounds = e, this.cameraPoint = i.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = t1, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, i);
            }
            static createFromScreenPoints(t1, i) {
                let o, r;
                if (t1 instanceof e.P || "number" == typeof t1[0]) {
                    const s = e.P.convert(t1);
                    o = [
                        s
                    ], r = i.isPointAboveHorizon(s);
                } else {
                    const s = e.P.convert(t1[0]), n = e.P.convert(t1[1]), a = s.add(n)._div(2);
                    o = [
                        s,
                        n
                    ], r = e.ao(s, n).every((e)=>i.isPointAboveHorizon(e)) && i.isPointAboveHorizon(a);
                }
                return new Xe(o, r, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e.ao(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r = e.ao(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.ap(r, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r = e.ao(i, o, t1), s = this.cameraPoint.clone();
                switch(3 * ((s.y > i.y) + (s.y > o.y)) + ((s.x > i.x) + (s.x > o.x))){
                    case 0:
                        r[0] = s, r[4] = s.clone();
                        break;
                    case 1:
                        r.splice(1, 0, s);
                        break;
                    case 2:
                        r[1] = s;
                        break;
                    case 3:
                        r.splice(4, 0, s);
                        break;
                    case 5:
                        r.splice(2, 0, s);
                        break;
                    case 6:
                        r[3] = s;
                        break;
                    case 7:
                        r.splice(3, 0, s);
                        break;
                    case 8:
                        r[2] = s;
                }
                return r;
            }
            containsTile(t1, i, o, r = 0) {
                const s = t1.queryPadding / i._pixelsPerMercatorPixel + 1, n = o ? this._bufferedCameraMercator(s, i) : this._bufferedScreenMercator(s, i);
                let a = t1.tileID.wrap + (n.unwrapped ? r : 0);
                const l = n.polygon.map((i)=>e.aq(t1.tileTransform, i, a));
                if (!e.ar(l, 0, 0, e.aj, e.aj)) return;
                a = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e.as(t1.tileTransform, i, a)), h = c.map((t1)=>new e.P(t1[0], t1[1])), d = i.getFreeCameraOptions().position || new e.ac(0, 0, 0), u = e.as(t1.tileTransform, d, a), _ = c.map((t1)=>{
                    const i = e.at(t1, t1, u);
                    return e.au(i, i), new e.av(u, i);
                }), p = e.aw(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: _,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (f = e.ax(l), f.min.x = e.ay(f.min.x, 0, e.aj), f.min.y = e.ay(f.min.y, 0, e.aj), f.max.x = e.ay(f.max.x, 0, e.aj), f.max.y = e.ay(f.max.y, 0, e.aj), f),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
                //TURBOPACK unreachable
                ;
                var f;
            }
            _bufferedScreenMercator(e, t1) {
                const i = Je(e);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t1) : {
                        polygon: this.bufferedScreenGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e, t1) {
                const i = Je(e);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t1) : {
                        polygon: this.bufferedCameraGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e.az([], i.pixelMatrix, i.globeMatrix), r = [
                        0,
                        -e.aB,
                        0,
                        1
                    ], s = [
                        0,
                        e.aB,
                        0,
                        1
                    ], n = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e.aA(r, r, o), e.aA(s, s, o), e.aA(n, n, o);
                    const a = new e.P(r[0] / r[3], r[1] / r[3]), l = new e.P(s[0] / s[3], s[1] / s[3]), c = e.aC(t1, a) && r[3] < n[3], h = e.aC(t1, l) && s[3] < n[3];
                    if (!c && !h) return null;
                    const d = function(e, t1, i) {
                        for(let o = 1; o < e.length; o++){
                            const r = Ke(t1.pointCoordinate3D(e[o - 1]).x), s = Ke(t1.pointCoordinate3D(e[o]).x);
                            if (i < 0) {
                                if (r < s) return {
                                    idx: o,
                                    t: -r / (s - 1 - r)
                                };
                            } else if (s < r) return {
                                idx: o,
                                t: (1 - r) / (s + 1 - r)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!d) return null;
                    const { idx: u, t: _ } = d;
                    let p = u > 1 ? Ye(t1.slice(0, u), i) : [], f = u < t1.length ? Ye(t1.slice(u), i) : [];
                    p = p.map((t1)=>new e.P(Ke(t1.x), t1.y)), f = f.map((t1)=>new e.P(Ke(t1.x), t1.y));
                    const m = [
                        ...p
                    ];
                    0 === m.length && m.push(f[f.length - 1]);
                    const g = e.ai(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);
                    let v;
                    return v = c ? [
                        new e.P(0, g),
                        new e.P(0, 0),
                        new e.P(1, 0),
                        new e.P(1, g)
                    ] : [
                        new e.P(1, g),
                        new e.P(1, 1),
                        new e.P(0, 1),
                        new e.P(0, g)
                    ], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {
                        polygon: m.map((t1)=>new e.ac(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const r = function(t1, i) {
                    let o = !1, r = -1 / 0, s = 0;
                    for(let e = 0; e < t1.length - 1; e++)t1[e].x > r && (r = t1[e].x, s = e);
                    for(let e = 0; e < t1.length - 1; e++){
                        const i = (s + e) % (t1.length - 1), r = t1[i], n = t1[i + 1];
                        Math.abs(r.x - n.x) > .5 && (r.x < n.x ? (r.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (n.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const n = e.aD(i.center.lng);
                    return o && n < Math.abs(n - 1) && t1.forEach((e)=>{
                        e.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(Ye(t1, i).map((t1)=>new e.P(Ke(t1.x), t1.y)), i);
                return {
                    polygon: r.polygon.map((t1)=>new e.ac(t1.x, t1.y)),
                    unwrapped: r.unwrapped
                };
            }
        }
        function Ye(t1, i) {
            return e.aE(t1, (e)=>{
                const t1 = i.pointCoordinate3D(e);
                e.x = t1.x, e.y = t1.y;
            }, 1 / 256);
        }
        function Ke(e) {
            return e < 0 ? 1 + e % 1 : e % 1;
        }
        function Je(e) {
            return 100 * e | 0;
        }
        function Qe(t1, i, o, r, s) {
            const n = function(o, r) {
                if (o) return s(o);
                if (r) {
                    if (t1.url && r.tiles && t1.tiles && delete t1.tiles, r.variants) {
                        if (!Array.isArray(r.variants)) return s(new Error("variants must be an array"));
                        for (const t1 of r.variants){
                            if (null == t1 || "object" != typeof t1 || t1.constructor !== Object) return s(new Error("variant must be an object"));
                            if (!Array.isArray(t1.capabilities)) return s(new Error("capabilities must be an array"));
                            if (1 === t1.capabilities.length && "meshopt" === t1.capabilities[0]) {
                                r = e.h(r, t1);
                                break;
                            }
                        }
                    }
                    const o = e.aF(e.h({}, r, t1), [
                        "tilejson",
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "extra_bounds",
                        "scheme",
                        "tileSize",
                        "encoding",
                        "vector_layers",
                        "raster_layers",
                        "worldview_options",
                        "worldview_default",
                        "worldview"
                    ]);
                    o.tiles = i.canonicalizeTileset(o, t1.url), s(null, o);
                }
            }, a = function(e, t1, i) {
                if (!e) return null;
                if (!t1 && !i) return e;
                i = i || e.worldview_default;
                const o = Object.values(e.language || {});
                if (0 === o.length) return null;
                const r = Object.values(e.worldview || {});
                if (0 === r.length) return null;
                const s = o.every((e)=>e === t1), n = r.every((e)=>e === i);
                return s && n ? e : t1 in (e.language_options || {}) || i in (e.worldview_options || {}) ? null : e.language_options && e.worldview_options ? e : null;
            }(t1.data, o, r);
            return a ? e.q.frame(()=>n(null, a)) : t1.url ? e.n(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, r), e.R.Source), n) : e.q.frame(()=>{
                const { data: e, ...i } = t1;
                n(null, i);
            });
        }
        function et(t1, i) {
            const o = Math.pow(2, i.z), r = Math.floor(e.aD(t1.getWest()) * o), s = Math.floor(e.aH(t1.getNorth()) * o), n = Math.ceil(e.aD(t1.getEast()) * o), a = Math.ceil(e.aH(t1.getSouth()) * o);
            return i.x >= r && i.x < n && i.y >= s && i.y < a;
        }
        class tt {
            constructor(t1, i, o){
                this.bounds = t1 ? e.aG.convert(this.validateBounds(t1)) : null, this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [
                    Math.max(-180, e[0]),
                    Math.max(-90, e[1]),
                    Math.min(180, e[2]),
                    Math.min(90, e[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            addExtraBounds(t1) {
                if (t1) {
                    this.extraBounds || (this.extraBounds = []);
                    for (const i of t1)this.extraBounds.push(e.aG.convert(this.validateBounds(i)));
                }
            }
            contains(e) {
                if (e.z > this.maxzoom || e.z < this.minzoom) return !1;
                if (this.bounds && !et(this.bounds, e)) return !1;
                if (!this.extraBounds) return !0;
                for (const t1 of this.extraBounds)if (et(t1, e)) return !0;
                return !1;
            }
            static fromTileJSON(e) {
                if (!e.bounds && !e.extra_bounds) return null;
                const t1 = new tt(e.bounds, e.minzoom, e.maxzoom);
                return t1.addExtraBounds(e.extra_bounds), t1;
            }
        }
        class it extends e.E {
            constructor(t1, i, o, r){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.h(this, e.aF(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = e.h({
                    type: "vector"
                }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.aI;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.A("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (r, s)=>{
                    if (this._tileJSONRequest = null, this._loaded = !0, r) i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.z(r));
                    else if (s) {
                        if (e.h(this, s), this.hasWorldviews = !!s.worldview_options, s.worldview_default && (this.worldviewDefault = s.worldview_default), s.vector_layers) {
                            this.vectorLayers = s.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set;
                            for (const e of s.vector_layers)this.vectorLayerIds.push(e.id), s.worldview && s.worldview[e.source] && this.localizableLayerIds.add(e.id);
                        }
                        this.tileBounds = tt.fromTileJSON(s), P(s.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.A("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }));
                    }
                    t1 && t1(r);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.C(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.h({}, this._options);
            }
            loadTile(t1, i) {
                const o = t1.tileID.canonical.url(this.tiles, this.scheme), r = this.map._requestManager.normalizeTileURL(o), s = this.map._requestManager.transformRequest(r, e.R.Tile), n = this.map.style ? this.map.style.getLut(this.scope) : null, a = n ? {
                    image: n.image.clone()
                } : null, l = {
                    request: s,
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    maxZoom: this.maxzoom,
                    lut: a,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    pixelRatio: e.q.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile,
                    brightness: this.map.style && this.map.style.getBrightness() || 0,
                    extraShadowCaster: t1.isExtraShadowCaster,
                    tessellationStep: this.map._tessellationStep,
                    scaleFactor: this.map.getScaleFactor(),
                    worldview: this.map.getWorldview() || this.worldviewDefault
                };
                if (this.hasWorldviews && e.j(o) && (l.localizableLayerIds = this.localizableLayerIds), l.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", l, c.bind(this));
                else if (t1.actor = this._tileWorkers[r] = this._tileWorkers[r] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", l, c.bind(this), void 0, !0);
                else {
                    const i = e.aJ.call({
                        deduped: this._deduped
                    }, l, (e, i)=>{
                        e || !i ? c.call(this, e) : (l.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0)
                        }, t1.actor && t1.actor.send("loadTile", l, c.bind(this), void 0, !0));
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function c(o, r) {
                    return delete t1.request, t1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t1.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t1.setExpiryData(r), t1.loadVectorData(r, this.map.painter), e.aK(this.dispatcher), i(null), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                e.actor && e.actor.send("removeTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                }), e.destroy();
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class ot extends e.E {
            constructor(t1, i, o, r){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.h({
                    type: "raster"
                }, i), e.h(this, e.aF(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.A("dataloading", {
                    dataType: "source"
                }));
                const i = this.map.getWorldview();
                this._tileJSONRequest = Qe(this._options, this.map._requestManager, null, i, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.z(i)) : o && (e.h(this, o), o.raster_layers && (this.rasterLayers = o.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e)=>e.id)), this.tileBounds = tt.fromTileJSON(o), P(o.tiles), this.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.C(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.h({}, this._options);
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(t1, i) {
                const o = e.q.devicePixelRatio >= 2, r = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e.o(this.map._requestManager.transformRequest(r, e.R.Tile), (o, r, s, n)=>(delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : o ? (t1.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: s,
                        expires: n
                    }), t1.setTexture(r, this.map.painter), t1.state = "loaded", e.aK(this.dispatcher), void i(null)) : i(null)));
            }
            abortTile(e, t1) {
                e.request && (e.request.cancel(), delete e.request), t1 && t1();
            }
            unloadTile(t1, i) {
                t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), i && i();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class rt extends ot {
            constructor(t1, i, o, r){
                super(t1, i, o, r), this.type = "raster-array", this.maxzoom = 22, this.partial = !0, this._options = e.h({
                    type: "raster-array"
                }, i);
            }
            triggerRepaint(e) {
                const t1 = this.map.painter._terrain, i = this.map.style.getSourceCache(this.id);
                t1 && t1.enabled && i && t1._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), r = this.map._requestManager.transformRequest(o, e.R.Tile), s = {
                    request: r,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    partial: this.partial
                };
                t1.source = this.id, t1.scope = this.scope, t1.requestParams = r, t1.actor || (t1.actor = this.dispatcher.getActor());
                const n = (e, o, r, s)=>{
                    if (delete t1.request, t1.aborted) return t1.state = "unloaded", i(null);
                    if (e) {
                        if ("AbortError" === e.name) return;
                        return t1.state = "errored", i(e);
                    }
                    if (this.map._refreshExpiredTiles && o && t1.setExpiryData({
                        cacheControl: r,
                        expires: s
                    }), this.partial) t1.state = "empty";
                    else {
                        if (!o) return i(null);
                        t1.state = "loaded", t1._isHeaderLoaded = !0, t1._mrt = o;
                    }
                    i(null);
                };
                t1.request = this.partial ? t1.fetchHeader(void 0, n.bind(this)) : t1.actor.send("loadTile", s, n.bind(this), void 0, !0);
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                const i = e.texturePerLayer;
                if (e.flushAllQueues(), i.size) {
                    e.destroy(!0);
                    for (const e of i.values())this.map.painter.saveTileTexture(e);
                } else e.destroy();
            }
            prepareTile(t1, i, o, r) {
                t1._isHeaderLoaded && ("empty" !== t1.state && (t1.state = "reloading"), t1.fetchBand(i, o, r, (i, r)=>{
                    if (i) return t1.state = "errored", this.fire(new e.z(i)), void this.triggerRepaint(t1);
                    r && (t1._isHeaderLoaded = !0, t1.setTexturePerLayer(o, r, this.map.painter), t1.state = "loaded", this.triggerRepaint(t1));
                }));
            }
            getInitialBand(e) {
                if (!this.rasterLayers) return 0;
                const t1 = this.rasterLayers.find(({ id: t1 })=>t1 === e), i = t1 && t1.fields, o = i && i.bands && i.bands;
                return o ? o[0] : 0;
            }
            getTextureDescriptor(t1, i, o) {
                if (!t1) return;
                const r = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                if (!r) return;
                let s = null;
                i instanceof e.aN ? s = i.paint.get("raster-array-band") : i instanceof e.aO && (s = i.paint.get("raster-particle-array-band"));
                const n = s || this.getInitialBand(r);
                if (null == n) return;
                if (!t1.textureDescriptorPerLayer.get(i.id)) return void this.prepareTile(t1, r, i.id, n);
                if (t1.updateNeeded(i.id, n) && !o) return;
                const a = t1.textureDescriptorPerLayer.get(i.id);
                return Object.assign({}, a, {
                    texture: t1.texturePerLayer.get(i.id)
                });
            }
            getImages(t1, i) {
                const o = new Map;
                for (const r of t1)for (const t1 of i){
                    const [i, s] = t1.split("/"), n = r.getLayer(i);
                    if (!n) continue;
                    if (!n.hasBand(s) || !n.hasDataForBand(s)) continue;
                    const { bytes: a, tileSize: l, buffer: c } = n.getBandView(s), h = l + 2 * c, d = {
                        data: new e.r({
                            width: h,
                            height: h
                        }, a),
                        pixelRatio: 2,
                        sdf: !1,
                        usvg: !1,
                        version: 0
                    };
                    o.set(t1, d);
                }
                return o;
            }
        }
        const st = {
            vector: it,
            raster: ot,
            "raster-dem": class extends ot {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.h({
                        type: "raster-dem"
                    }, i), this.encoding = i.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function r(e, o) {
                        e && (t1.state = "errored", i(e)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e.o(this.map._requestManager.transformRequest(o, e.R.Tile), (function(o, s, n, a) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (s) {
                            this.map._refreshExpiredTiles && t1.setExpiryData({
                                cacheControl: n,
                                expires: a
                            });
                            const i = ImageBitmap && s instanceof ImageBitmap && e.t(), o = 1 - (s.width - e.aL(s.width)) / 2;
                            o < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = i ? s : e.q.getImageData(s, o), c = {
                                uid: t1.uid,
                                tileID: t1.tileID,
                                source: this.id,
                                type: this.type,
                                scope: this.scope,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: o
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadTile", c, r.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), r = (i.x - 1 + o) % o, s = 0 === i.x ? t1.wrap - 1 : t1.wrap, n = (i.x + 1 + o) % o, a = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e.aM(t1.overscaledZ, s, i.z, r, i.y).key] = {
                        backfilled: !1
                    }, l[new e.aM(t1.overscaledZ, a, i.z, n, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e.aM(t1.overscaledZ, s, i.z, r, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aM(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aM(t1.overscaledZ, a, i.z, n, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e.aM(t1.overscaledZ, s, i.z, r, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aM(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aM(t1.overscaledZ, a, i.z, n, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
            },
            "raster-array": rt,
            geojson: class extends e.E {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.h({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const s = e.aj / this.tileSize;
                    this.workerOptions = e.h({
                        source: this.id,
                        scope: this.scope,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * s,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * s,
                            extent: e.aj,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e.aj,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * s,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter,
                        dynamic: i.dynamic
                    }, i.workerOptions);
                }
                onAdd(e) {
                    this.map = e, this.setData(this._data);
                }
                setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }
                updateData(t1) {
                    if (!this._options.dynamic) return this.fire(new e.z(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                    if ("string" != typeof t1 && ("Feature" === t1.type && (t1 = {
                        type: "FeatureCollection",
                        features: [
                            t1
                        ]
                    }), "FeatureCollection" !== t1.type)) return this.fire(new e.z(new Error("Data to update should be a feature or a feature collection.")));
                    if (this._coalesce && "string" != typeof t1 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                        const e = new Map;
                        for (const t1 of this._data.features)e.set(t1.id, t1);
                        for (const i of t1.features)e.set(i.id, i);
                        this._data.features = [
                            ...e.values()
                        ];
                    } else this._data = t1;
                    return this._updateWorkerData(!0), this;
                }
                getClusterExpansionZoom(e, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterChildren(e, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterLeaves(e, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        scope: this.scope,
                        clusterId: e,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData(t1 = !1) {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e.A("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const i = e.h({
                        append: t1
                    }, this.workerOptions);
                    i.scope = this.scope;
                    const o = this._data;
                    "string" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.q.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i, (i, o)=>{
                        if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.z(i));
                        else {
                            const i = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t1 && (this._partialReload = !0), this.fire(new e.A("data", i)), this._partialReload = !1, this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(t1), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                reload() {
                    const t1 = e.C(this.id, this.scope);
                    this.map.style.clearSource(t1), this._updateWorkerData();
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor;
                    const r = this.map.style ? this.map.style.getLut(this.scope) : null, s = r ? {
                        image: r.image.clone()
                    } : null, n = this._partialReload, a = {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        lut: s,
                        scope: this.scope,
                        pixelRatio: e.q.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        extraShadowCaster: t1.isExtraShadowCaster,
                        scaleFactor: this.map.getScaleFactor(),
                        partial: n,
                        worldview: this.map.getWorldview()
                    };
                    t1.request = this.actor.send(o, a, (e, r)=>n && !r ? (t1.state = "loaded", i(null)) : (delete t1.request, t1.destroy(), t1.aborted ? i(null) : e ? i(e) : (t1.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }
                unloadTile(e, t1) {
                    this.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    }), e.destroy();
                }
                onRemove(e) {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e.h({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends e.aP {
                constructor(e, t1, i, o){
                    super(e, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);
                    e.aQ(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e.z(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e.z(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t1, this.video, i.RGBA8), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: e.aP,
            model: class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.id = e, this.type = "model", this.models = [], this._loaded = !1, this._options = t1;
                }
                load() {
                    const t1 = [];
                    for(const i in this._options.models){
                        const o = this._options.models[i], r = e.aS(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then((t1)=>{
                            if (!t1) return;
                            const r = e.aT(t1), s = new e.aU(i, o.position, o.orientation, r);
                            s.computeBoundsAndApplyParent(), this.models.push(s);
                        }).catch((t1)=>{
                            this.fire(new e.z(new Error(`Could not load model ${i} from ${o.uri}: ${t1.message}`)));
                        });
                        t1.push(r);
                    }
                    Promise.allSettled(t1).then(()=>{
                        this._loaded = !0, this.fire(new e.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        }));
                    }).catch((t1)=>{
                        this._loaded = !0, this.fire(new e.z(new Error(`Could not load models: ${t1.message}`)));
                    });
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                hasTransition() {
                    return !1;
                }
                loaded() {
                    return this._loaded;
                }
                getModels() {
                    return this.models;
                }
                loadTile(e, t1) {}
                serialize() {
                    return this._options;
                }
            },
            "batched-model": class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.type = "batched-model", this.id = e, this.tileSize = 512, this._options = t1, this.tiles = this._options.tiles, this.maxzoom = t1.maxzoom || 19, this.minzoom = t1.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(o);
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                reload() {
                    this.cancelTileJSONRequest();
                    const t1 = e.C(this.id, this.scope);
                    this.load(()=>this.map.style.clearSource(t1));
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
                }
                load(t1) {
                    this._loaded = !1, this.fire(new e.A("dataloading", {
                        dataType: "source"
                    }));
                    const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                    this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (r, s)=>{
                        this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.z(r))) : s && (e.h(this, s), s.bounds && (this.tileBounds = new tt(s.bounds, this.minzoom, this.maxzoom)), P(s.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.A("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }))), t1 && t1(r);
                    });
                }
                hasTransition() {
                    return !1;
                }
                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), r = {
                        request: this.map._requestManager.transformRequest(o, e.R.Tile),
                        data: void 0,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        isSymbolTile: t1.isSymbolTile,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        pixelRatio: e.q.devicePixelRatio,
                        promoteId: this.promoteId
                    };
                    if (t1.actor && "expired" !== t1.state) if ("loading" === t1.state) t1.reloadCallback = i;
                    else {
                        if (t1.buckets) {
                            const e = Object.values(t1.buckets);
                            for (const t1 of e)t1.dirty = !0;
                            return void (t1.state = "loaded");
                        }
                        t1.request = t1.actor.send("reloadTile", r, s.bind(this));
                    }
                    else t1.actor = this.dispatcher.getActor(), t1.request = t1.actor.send("loadTile", r, s.bind(this), void 0, !0);
                    function s(e, o) {
                        return t1.aborted ? i(null) : e && 404 !== e.status ? i(e) : (this.map._refreshExpiredTiles && o && t1.setExpiryData(o), t1.loadModelData(o, this.map.painter), t1.state = "loaded", void i(null));
                    }
                }
                serialize() {
                    return e.h({}, this._options);
                }
            },
            canvas: class extends e.aP {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e)=>!Array.isArray(e) || 2 !== e.length || e.some((e)=>"number" != typeof e)) || this.fire(new e.z(new e.V(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.z(new e.V(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.z(new e.V(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.z(new e.V(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.z(new e.V(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove(e) {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? !t1 && !this._playing || this.texture instanceof e.aR || this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA8, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e) || e <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e.E {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new tt(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.h(this, e.aF(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e.aF(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this.map = t1, this._loaded = !1, this.fire(new e.A("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }
                hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t1, y: i, z: o } = e.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loadTile(e, t1) {
                    const { x: i, y: o, z: r } = e.tileID.canonical, s = new AbortController;
                    e.request = Promise.resolve(this._implementation.loadTile({
                        x: i,
                        y: o,
                        z: r
                    }, {
                        signal: s.signal
                    })).then((function(i) {
                        return delete e.request, e.aborted ? (e.state = "unloaded", t1(null)) : void 0 === i ? (e.state = "errored", t1(null)) : null === i ? (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), e.state = "loaded", t1(null)) : function(e) {
                            return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;
                        }(i) ? (this.loadTileData(e, i), e.state = "loaded", void t1(null)) : (e.state = "errored", t1(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((i)=>{
                        "AbortError" !== i.name && (e.state = "errored", t1(i));
                    }), e.request.cancel = ()=>s.abort();
                }
                loadTileData(e, t1) {
                    e.setTexture(t1, this.map.painter);
                }
                unloadTile(t1, i) {
                    if (t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), this._implementation.unloadTile) {
                        const { x: e, y: i, z: o } = t1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: o
                        });
                    }
                    i && i();
                }
                abortTile(e, t1) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t1 && t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this.map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e)=>({
                            x: e.canonical.x,
                            y: e.canonical.y,
                            z: e.canonical.z
                        }));
                }
                _clearTiles() {
                    const t1 = e.C(this.id, this.scope);
                    this.map.style.clearSource(t1);
                }
                _update() {
                    this.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, nt = function(t1, i, o, r) {
            const s = new st[i.type](t1, i, o, r);
            if (s.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${s.id}`);
            return e.aV([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], s), s;
        };
        function at(e, t1, i = "") {
            return `${i}:${t1.id || ""}:${t1.layer.id}:${function(e) {
                if ("layerId" in e) return `layer:${e.layerId}`;
                {
                    const { featuresetId: t1, importId: i } = e;
                    return `featureset:${t1}${i ? `:import:${i}` : ""}`;
                }
            }(e.target)}`;
        }
        function lt(e, t1, i, o = "") {
            if (e.uniqueFeatureID) {
                const r = at(e, t1, o);
                if (i.has(r)) return !0;
                i.add(r);
            }
            return !1;
        }
        function ct(e, t1, i, o, r = !1) {
            const s = t1.sourceCache.transform, n = t1.sourceCache.tilesIn(e, t1.has3DLayers, r);
            n.sort(ut);
            const a = [];
            for (const e of n){
                const n = e.tile.queryRenderedFeatures(t1, e, i, o, s, r);
                Object.keys(n).length && a.push({
                    wrappedTileID: e.tile.tileID.wrapped().key,
                    queryResults: n
                });
            }
            return 0 === a.length ? {} : function(e) {
                const t1 = {}, i = {};
                for (const o of e){
                    const e = o.queryResults, r = o.wrappedTileID, s = i[r] = i[r] || {};
                    for(const i in e){
                        const o = e[i], r = s[i] = s[i] || {}, n = t1[i] = t1[i] || [];
                        for (const e of o)r[e.featureIndex] || (r[e.featureIndex] = !0, n.push(e));
                    }
                }
                return t1;
            }(a);
        }
        function ht(e, t1, i, o, r, s) {
            const n = {}, a = o.queryRenderedSymbols(e), l = [];
            for (const e of Object.keys(a).map(Number))l.push(r[e]);
            l.sort(ut);
            for (const e of l){
                const o = e.featureIndex.lookupSymbolFeatures(a[e.bucketInstanceId], e.bucketIndex, e.sourceLayerIndex, t1, i, s);
                for(const t1 in o){
                    const i = n[t1] = n[t1] || [], r = o[t1];
                    r.sort((t1, i)=>{
                        const o = e.featureSortOrder;
                        if (o) {
                            const e = o.indexOf(t1.featureIndex);
                            return o.indexOf(i.featureIndex) - e;
                        }
                        return i.featureIndex - t1.featureIndex;
                    });
                    for (const e of r)i.push(e);
                }
            }
            return n;
        }
        function dt(e, t1) {
            const i = e.getRenderableIds().map((t1)=>e.getTileByID(t1)), o = [], r = {};
            for(let e = 0; e < i.length; e++){
                const s = i[e], n = s.tileID.canonical.key;
                r[n] || (r[n] = !0, s.querySourceFeatures(o, t1));
            }
            return o;
        }
        function ut(e, t1) {
            const i = e.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        function _t(e, t1) {
            const i = {};
            if (!t1) return i;
            for (const o of e){
                const e = o.layerIds.map((e)=>t1.getLayer(e)).filter(Boolean);
                if (0 !== e.length) {
                    o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map((t1)=>e.filter((e)=>e.id === t1)[0]));
                    for (const t1 of e)i[t1.fqid] = o;
                }
            }
            return i;
        }
        const pt = 32, ft = 33, mt = new Uint16Array(8184);
        for(let e = 0; e < 2046; e++){
            let t1 = e + 2, i = 0, o = 0, r = 0, s = 0, n = 0, a = 0;
            for(1 & t1 ? r = s = n = pt : i = o = a = pt; (t1 >>= 1) > 1;){
                const e = i + r >> 1, l = o + s >> 1;
                1 & t1 ? (r = i, s = o, i = n, o = a) : (i = r, o = s, r = n, s = a), n = e, a = l;
            }
            const l = 4 * e;
            mt[l + 0] = i, mt[l + 1] = o, mt[l + 2] = r, mt[l + 3] = s;
        }
        const gt = new Uint16Array(2178), vt = new Uint8Array(1089), yt = new Uint16Array(1089);
        function xt(e) {
            return 0 === e ? -.03125 : 32 === e ? .03125 : 0;
        }
        const bt = (()=>({
                type: 2,
                extent: e.aj,
                loadGeometry: ()=>[
                        [
                            new e.P(0, 0),
                            new e.P(e.aj + 1, 0),
                            new e.P(e.aj + 1, e.aj + 1),
                            new e.P(0, e.aj + 1),
                            new e.P(0, 0)
                        ]
                    ]
            }))();
        class wt {
            constructor(t1, i, o, r, s, n){
                this.tileID = t1, this.uid = e.a$(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = s, r && r.style && (this._lastUpdatedBrightness = r.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r && r.transform && (this.projection = r.transform.projection), this.worldview = n;
            }
            registerFadeDuration(t1) {
                const i = t1 + this.timeAdded;
                i < e.q.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = e.aW(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, i, o) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = _t(t1.buckets, i.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.b1) {
                            if (this.hasSymbolBuckets = !0, !o) break;
                            i.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.b1 && i.hasRTLText) {
                            this.hasRTLText = !0, e.b2();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const e in this.buckets){
                        const t1 = this.buckets[e], o = i.style.getOwnLayer(e);
                        if (!o) continue;
                        const r = o.queryRadius(t1);
                        this.queryPadding = Math.max(this.queryPadding, r);
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas), this._lastUpdatedBrightness = t1.brightness;
                } else this.collisionBoxArray = new e.b0;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const e in this.buckets)this.buckets[e].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            loadModelData(e, t1, i) {
                e && (e.resourceTiming && (this.resourceTiming = e.resourceTiming), this.buckets = Object.assign({}, this.buckets, _t(e.buckets, t1.style)), e.featureIndex && (this.latestFeatureIndex = e.featureIndex));
            }
            getBucket(e) {
                return this.buckets[e.fqid];
            }
            upload(t1) {
                for(const e in this.buckets){
                    const i = this.buckets[e];
                    i.uploadPending() && i.upload(t1);
                }
                const i = t1.gl, o = this.imageAtlas;
                o && !o.uploaded && (this.imageAtlasTexture = new e.T(t1, o.image, i.RGBA8, {
                    useMipmap: !!o.patternPositions.size
                }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t1, this.glyphAtlasImage, i.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t1, this.lineAtlas.image, i.R8), this.lineAtlas.uploaded = !0);
            }
            prepare(e, t1, i) {
                if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t1 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
                const o = t1.style.getBrightness();
                (this._lastUpdatedBrightness || o) && (this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this.updateBuckets(t1, this._lastUpdatedBrightness !== o), this._lastUpdatedBrightness = o));
            }
            queryRenderedFeatures(t1, i, o, r, s, n) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
                const a = function(t1, i) {
                    const o = e.bn([], [
                        .5 * t1.width,
                        .5 * -t1.height,
                        1
                    ]);
                    return e.bo(o, o, [
                        1,
                        -1,
                        0
                    ]), e.az(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
                }(s, this.tileID);
                return this.latestFeatureIndex.query(t1, {
                    tilespaceGeometry: i,
                    pixelPosMatrix: a,
                    transform: r,
                    availableImages: o,
                    tileTransform: this.tileTransform,
                    worldview: this.worldview
                });
            }
            querySourceFeatures(t1, i) {
                const o = this.latestFeatureIndex;
                if (!o || !o.rawTileData) return;
                const r = o.loadVTLayers(), s = i ? i.sourceLayer : "", n = r._geojsonTileLayer || r[s];
                if (!n) return;
                const a = e.b3(i && i.filter), { z: l, x: c, y: h } = this.tileID.canonical, d = {
                    z: l,
                    x: c,
                    y: h
                };
                for(let i = 0; i < n.length; i++){
                    const r = n.feature(i);
                    if (a.needGeometry) {
                        const t1 = e.b4(r, !0);
                        if (!a.filter(new e.aa(this.tileID.overscaledZ, {
                            worldview: this.worldview
                        }), t1, this.tileID.canonical)) continue;
                    } else if (!a.filter(new e.aa(this.tileID.overscaledZ, {
                        worldview: this.worldview
                    }), r)) continue;
                    const u = o.getId(r, s), _ = new e.b5(r, l, c, h, u);
                    _.tile = d, t1.push(_);
                }
            }
            loaded() {
                return "loaded" === this.state || "errored" === this.state;
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
            }
            setExpiryData(t1) {
                const i = this.expirationTime;
                if (t1.cacheControl) {
                    const i = e.b6(t1.cacheControl);
                    i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const e = Date.now();
                    let t1 = !1;
                    if (this.expirationTime > e) t1 = !1;
                    else if (i) if (this.expirationTime < i) t1 = !0;
                    else {
                        const o = this.expirationTime - i;
                        o ? this.expirationTime = e + Math.max(o, 3e4) : t1 = !0;
                    }
                    else t1 = !0;
                    t1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            refreshFeatureState(e) {
                this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e && this.updateBuckets(e);
            }
            updateBuckets(t1, i) {
                if (!this.latestFeatureIndex) return;
                if (!t1.style) return;
                const o = this.latestFeatureIndex.loadVTLayers(), r = t1.style.listImages(), s = t1.style.getBrightness();
                for(const n in this.buckets){
                    if (!t1.style.hasLayer(n)) continue;
                    const a = this.buckets[n], l = a.layers[0], c = l.sourceLayer || "_geojsonTileLayer", h = o[c], d = t1.style.getLayerSourceCache(l);
                    let u = {};
                    d && (u = d._state.getState(c, void 0));
                    const _ = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, p = Object.keys(u).length > 0 && !i;
                    p && !a.stateDependentLayers.length && !i || a.update(u, h, r, _, p ? a.stateDependentLayers : a.layers, i, s), (a instanceof e.b7 || a instanceof e.b8) && t1._terrain && t1._terrain.enabled && d && a.uploadPending() && t1._terrain._clearRenderCacheForTile(d.id, this.tileID);
                    const f = t1 && t1.style && t1.style.getOwnLayer(n);
                    f && (this.queryPadding = Math.max(this.queryPadding, f.queryRadius(a)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.q.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = e.q.now() + t1;
            }
            setTexture(t1, i) {
                const o = i.context, r = o.gl;
                this.texture = this.texture || i.getTileTexture(t1.width), this.texture && this.texture instanceof e.T ? this.texture.update(t1) : (this.texture = new e.T(o, t1, r.RGBA8, {
                    useMipmap: !0
                }), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            }
            setDependencies(e, t1) {
                const i = {};
                for (const e of t1)i[e] = !0;
                this.dependencies[e] = i;
            }
            hasDependency(e, t1) {
                for (const i of e){
                    const e = this.dependencies[i];
                    if (e) {
                        for (const i of t1)if (e[i]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, i) {
                if (!i || "mercator" === i.name || this._tileDebugBuffer) return;
                const o = e.b9(bt, this.tileID.canonical, this.tileTransform)[0], r = new e.ba, s = new e.bb;
                for(let e = 0; e < o.length; e++){
                    const { x: t1, y: i } = o[e];
                    r.emplaceBack(t1, i), s.emplaceBack(e);
                }
                s.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(s), this._tileDebugBuffer = t1.createVertexBuffer(r, e.bc.members), this._tileDebugSegments = e.bd.simpleSegment(0, 0, r.length, s.length);
            }
            _makeTileBoundsBuffers(t1, i) {
                if (this._tileBoundsBuffer || !i || "mercator" === i.name) return;
                const o = e.b9(bt, this.tileID.canonical, this.tileTransform)[0];
                let r, s;
                if (this.isRaster) {
                    const t1 = function(t1, i) {
                        const o = e.aW(t1, i), r = Math.pow(2, t1.z);
                        for(let s = 0; s < ft; s++)for(let n = 0; n < ft; n++){
                            const a = e.aX((t1.x + (n + xt(n)) / pt) / r), l = e.aY((t1.y + (s + xt(s)) / pt) / r), c = i.project(a, l), h = s * ft + n;
                            gt[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.aj), gt[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.aj);
                        }
                        vt.fill(0), yt.fill(0);
                        for(let e = 2045; e >= 0; e--){
                            const t1 = 4 * e, i = mt[t1 + 0], o = mt[t1 + 1], r = mt[t1 + 2], s = mt[t1 + 3], n = i + r >> 1, a = o + s >> 1, l = n + a - o, c = a + i - n, h = o * ft + i, d = s * ft + r, u = a * ft + n, _ = Math.hypot((gt[2 * h + 0] + gt[2 * d + 0]) / 2 - gt[2 * u + 0], (gt[2 * h + 1] + gt[2 * d + 1]) / 2 - gt[2 * u + 1]) >= 16;
                            vt[u] = vt[u] || (_ ? 1 : 0), e < 1022 && (vt[u] = vt[u] || vt[(o + c >> 1) * ft + (i + l >> 1)] || vt[(s + c >> 1) * ft + (r + l >> 1)]);
                        }
                        const s = new e.aZ, n = new e.a_;
                        let a = 0;
                        function l(t1, i) {
                            const o = i * ft + t1;
                            return 0 === yt[o] && (s.emplaceBack(gt[2 * o + 0], gt[2 * o + 1], t1 * e.aj / pt, i * e.aj / pt), yt[o] = ++a), yt[o] - 1;
                        }
                        function c(e, t1, i, o, r, s) {
                            const a = e + i >> 1, h = t1 + o >> 1;
                            if (Math.abs(e - r) + Math.abs(t1 - s) > 1 && vt[h * ft + a]) c(r, s, e, t1, a, h), c(i, o, r, s, a, h);
                            else {
                                const a = l(e, t1), c = l(i, o), h = l(r, s);
                                n.emplaceBack(a, c, h);
                            }
                        }
                        return c(0, 0, pt, pt, pt, 0), c(pt, pt, 0, 0, 0, pt), {
                            vertices: s,
                            indices: n
                        };
                    }(this.tileID.canonical, i);
                    r = t1.vertices, s = t1.indices;
                } else {
                    r = new e.aZ, s = new e.a_;
                    for (const { x: e, y: t1 } of o)r.emplaceBack(e, t1, 0, 0);
                    const t1 = e.be(r.int16.subarray(0, 4 * r.length), void 0, 4);
                    for(let e = 0; e < t1.length; e += 3)s.emplaceBack(t1[e], t1[e + 1], t1[e + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(r, e.bf.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(s), this._tileBoundsSegments = e.bd.simpleSegment(0, 0, r.length, s.length);
            }
            _makeGlobeTileDebugBuffers(t1, i) {
                const o = i.projection;
                if (!o || "globe" !== o.name || i.freezeTileCoverage) return;
                const r = this.tileID.canonical, s = e.bg(r, i), n = e.bh(s), a = e.ah(i.zoom);
                let l;
                a > 0 && (l = e.bi(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t1, r, i, n, l, a), this._makeGlobeTileDebugTextBuffer(t1, r, i, n, l, a);
            }
            _globePoint(t1, i, o, r, s, n, a) {
                let l = e.bj(t1, i, o);
                if (n) {
                    const s = 1 << o.z, c = e.aD(r.center.lng), h = e.aH(r.center.lat), d = (o.x + .5) / s - c;
                    let u = 0;
                    d > .5 ? u = -1 : d < -.5 && (u = 1);
                    let _ = (t1 / e.aj + o.x) / s + u, p = (i / e.aj + o.y) / s;
                    _ = (_ - c) * r._pixelsPerMercatorPixel + c, p = (p - h) * r._pixelsPerMercatorPixel + h;
                    const f = [
                        _ * r.worldSize,
                        p * r.worldSize,
                        0
                    ];
                    e.ad(f, f, n), l = e.bk(l, f, a);
                }
                return e.ad(l, l, s);
            }
            _makeGlobeTileDebugBorderBuffer(t1, i, o, r, s, n) {
                const a = new e.ba, l = new e.bb, c = new e.bl, h = (e, t1, h, d, u)=>{
                    const _ = (h - e) / (u - 1), p = (d - t1) / (u - 1), f = a.length;
                    for(let h = 0; h < u; h++){
                        const d = e + h * _, u = t1 + h * p;
                        a.emplaceBack(d, u);
                        const m = this._globePoint(d, u, i, o, r, s, n);
                        c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);
                    }
                }, d = e.aj;
                h(0, 0, d, 0, 16), h(d, 0, d, d, 16), h(d, d, 0, d, 16), h(0, d, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(l), this._tileDebugBuffer = t1.createVertexBuffer(a, e.bc.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(c, e.bm.members), this._tileDebugSegments = e.bd.simpleSegment(0, 0, a.length, l.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, i, o, r, s, n) {
                const a = e.aj / 4, l = new e.ba, c = new e.a_, h = new e.bl, d = 25;
                c.reserve(32), l.reserve(d), h.reserve(d);
                const u = (e, t1)=>d * e + t1;
                for(let e = 0; e < d; e++){
                    const t1 = e * a;
                    for(let e = 0; e < d; e++){
                        const c = e * a;
                        l.emplaceBack(c, t1);
                        const d = this._globePoint(c, t1, i, o, r, s, n);
                        h.emplaceBack(d[0], d[1], d[2]);
                    }
                }
                for(let e = 0; e < 4; e++)for(let t1 = 0; t1 < 4; t1++){
                    const i = u(e, t1), o = u(e, t1 + 1), r = u(e + 1, t1), s = u(e + 1, t1 + 1);
                    c.emplaceBack(i, o, r), c.emplaceBack(r, o, s);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(c), this._tileDebugTextBuffer = t1.createVertexBuffer(l, e.bc.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(h, e.bm.members), this._tileDebugTextSegments = e.bd.simpleSegment(0, 0, d, 32);
            }
            destroy(t1 = !1) {
                for(const e in this.buckets)this.buckets[e].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t1 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
        }
        e.bp.setPbf(e.bq);
        class Tt extends wt {
            constructor(e, t1, i, o, r){
                super(e, t1, i, o, r), this._workQueuePerLayer = new Map, this._fetchQueuePerLayer = new Map, this._isHeaderLoaded = !1, this.textureDescriptorPerLayer = new Map, this.texturePerLayer = new Map;
            }
            getLayers() {
                return this._mrt ? Object.values(this._mrt.layers) : [];
            }
            getLayer(e) {
                return this._mrt && this._mrt.getLayer(e);
            }
            setTexturePerLayer(t1, i, o) {
                const r = o.context, s = r.gl;
                let n = this.texturePerLayer.get(t1) || o.getTileTexture(i.width);
                n && n instanceof e.T ? n.update(i, {
                    premultiply: !1
                }) : n = new e.T(r, i, s.RGBA8, {
                    premultiply: !1
                }), this.texturePerLayer.has(t1) || this.texturePerLayer.set(t1, n);
            }
            flushQueues(e) {
                const t1 = this._workQueuePerLayer.get(e) || [], i = this._fetchQueuePerLayer.get(e) || [];
                for(; t1.length;)t1.pop()();
                for(; i.length;)i.pop()();
            }
            flushAllQueues() {
                for (const e of this._workQueuePerLayer.keys()){
                    const t1 = this._workQueuePerLayer.get(e) || [];
                    for(; t1.length;)t1.pop()();
                }
                for (const e of this._fetchQueuePerLayer.keys()){
                    const t1 = this._fetchQueuePerLayer.get(e) || [];
                    for(; t1.length;)t1.pop()();
                }
            }
            fetchHeader(t1 = 16384, i) {
                const o = this._mrt = new e.bp(30), r = Object.assign({}, this.requestParams, {
                    headers: {
                        Range: "bytes=0-" + (t1 - 1)
                    }
                });
                return this.entireBuffer = null, this.request = e.br(r, (e, r, s, n)=>{
                    if (e) i(e);
                    else try {
                        const e = o.getHeaderLength(r);
                        if (e > t1) return void (this.request = this.fetchHeader(e, i));
                        o.parseHeader(r), this._isHeaderLoaded = !0;
                        let a = 0;
                        for (const e of Object.values(o.layers))a = Math.max(a, e.dataIndex[e.dataIndex.length - 1].lastByte);
                        r.byteLength >= a && (this.entireBuffer = r), i(null, this.entireBuffer || r, s, n);
                    } catch (e) {
                        i(e);
                    }
                }), this.request;
            }
            fetchBand(t1, i, o, r) {
                const s = this._mrt;
                if (!this._isHeaderLoaded || !s) return void r(new Error("Tile header is not ready"));
                const n = this.actor;
                if (!n) return void r(new Error("Can't fetch tile band without an actor"));
                let a;
                const l = (e, s)=>{
                    if (a.complete(e, s), e) return void r(e);
                    this.updateTextureDescriptor(t1, i, o);
                    const n = this.textureDescriptorPerLayer.get(i);
                    r(null, n && n.img);
                }, c = (e, t1)=>{
                    if (e) return r(e);
                    const o = n.send("decodeRasterArray", {
                        type: "raster-array",
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        uid: this.uid,
                        buffer: t1,
                        task: a
                    }, l, void 0, !0), s = this._workQueuePerLayer.get(i) || [];
                    s.push(()=>{
                        o && o.cancel(), a.cancel();
                    }), this._workQueuePerLayer.has(i) || this._workQueuePerLayer.set(i, s);
                }, h = s.getLayer(t1);
                if (!h) return void r(new Error(`Unknown sourceLayer "${t1}"`));
                if (h.hasDataForBand(o)) {
                    this.updateTextureDescriptor(t1, i, o);
                    const e = this.textureDescriptorPerLayer.get(i);
                    return void r(null, e ? e.img : null);
                }
                const d = h.getDataRange([
                    o
                ]);
                if (a = s.createDecodingTask(d), !a || a.tasks.length) if (this.flushQueues(i), this.entireBuffer) c(null, this.entireBuffer.slice(d.firstByte, d.lastByte + 1));
                else {
                    const t1 = Object.assign({}, this.requestParams, {
                        headers: {
                            Range: `bytes=${d.firstByte}-${d.lastByte}`
                        }
                    }), o = e.br(t1, c), r = this._fetchQueuePerLayer.get(i) || [];
                    r.push(()=>{
                        o.cancel(), a.cancel();
                    }), this._fetchQueuePerLayer.has(i) || this._fetchQueuePerLayer.set(i, r);
                }
                else r(null);
            }
            updateNeeded(e, t1) {
                return (!this.textureDescriptorPerLayer.get(e) || this.textureDescriptorPerLayer.get(e).band !== t1) && "errored" !== this.state;
            }
            updateTextureDescriptor(t1, i, o) {
                if (!this._mrt) return;
                const r = this._mrt.getLayer(t1);
                if (!r || !r.hasBand(o) || !r.hasDataForBand(o)) return;
                const { bytes: s, tileSize: n, buffer: a, offset: l, scale: c } = r.getBandView(o), h = n + 2 * a, d = new e.r({
                    width: h,
                    height: h
                }, s), u = this.texturePerLayer.get(i);
                u && u instanceof e.T && u.update(d, {
                    premultiply: !1
                }), this.textureDescriptorPerLayer.set(i, {
                    layer: t1,
                    band: o,
                    img: d,
                    buffer: a,
                    offset: l,
                    tileSize: n,
                    format: r.pixelFormat,
                    mix: [
                        c,
                        256 * c,
                        65536 * c,
                        16777216 * c
                    ]
                });
            }
            destroy(t1 = !1) {
                if (super.destroy(t1), delete this._mrt, !t1) for (const t1 of this.texturePerLayer.values())t1 && t1 instanceof e.T && t1.destroy();
                this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = !1;
            }
        }
        class Et {
            constructor(e, t1){
                this.max = e, this.onRemove = t1, this.reset();
            }
            reset() {
                for(const e in this.data)for (const t1 of this.data[e])t1.timeout && clearTimeout(t1.timeout), this.onRemove(t1.value);
                return this.data = {}, this.order = [], this;
            }
            add(e, t1, i) {
                const o = e.wrapped().key;
                void 0 === this.data[o] && (this.data[o] = []);
                const r = {
                    value: t1,
                    timeout: void 0
                };
                if (void 0 !== i && (r.timeout = setTimeout(()=>{
                    this.remove(e, r);
                }, i)), this.data[o].push(r), this.order.push(o), this.order.length > this.max) {
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            has(e) {
                return e.wrapped().key in this.data;
            }
            getAndRemove(e) {
                return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
            }
            _getAndRemoveByKey(e) {
                const t1 = this.data[e].shift();
                return t1.timeout && clearTimeout(t1.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t1.value;
            }
            getByKey(e) {
                const t1 = this.data[e];
                return t1 ? t1[0].value : null;
            }
            get(e) {
                return this.has(e) ? this.data[e.wrapped().key][0].value : null;
            }
            remove(e, t1) {
                if (!this.has(e)) return this;
                const i = e.wrapped().key, o = void 0 === t1 ? 0 : this.data[i].indexOf(t1), r = this.data[i][o];
                return this.data[i].splice(o, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(r.value), this.order.splice(this.order.indexOf(i), 1), this;
            }
            setMaxSize(e) {
                for(this.max = e; this.order.length > this.max;){
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            filter(e) {
                const t1 = [];
                for(const i in this.data)for (const o of this.data[i])e(o.value) || t1.push(o);
                for (const e of t1)this.remove(e.value.tileID, e);
            }
        }
        class St {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t1, i, o) {
                const r = String(i);
                if (this.stateChanges[t1] = this.stateChanges[t1] || {}, this.stateChanges[t1][r] = this.stateChanges[t1][r] || {}, e.h(this.stateChanges[t1][r], o), null === this.deletedStates[t1]) {
                    this.deletedStates[t1] = {};
                    for(const e in this.state[t1])e !== r && (this.deletedStates[t1][e] = null);
                } else if (this.deletedStates[t1] && null === this.deletedStates[t1][r]) {
                    this.deletedStates[t1][r] = {};
                    for(const e in this.state[t1][r])o[e] || (this.deletedStates[t1][r][e] = null);
                } else for(const e in o)this.deletedStates[t1] && this.deletedStates[t1][r] && null === this.deletedStates[t1][r][e] && delete this.deletedStates[t1][r][e];
            }
            removeFeatureState(e, t1, i) {
                if (null === this.deletedStates[e]) return;
                const o = String(t1);
                if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t1) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);
                else if (void 0 !== t1) if (this.stateChanges[e] && this.stateChanges[e][o]) for(i in this.deletedStates[e][o] = {}, this.stateChanges[e][o])this.deletedStates[e][o][i] = null;
                else this.deletedStates[e][o] = null;
                else this.deletedStates[e] = null;
            }
            getState(t1, i) {
                const o = this.state[t1] || {}, r = this.stateChanges[t1] || {}, s = this.deletedStates[t1];
                if (null === s) return {};
                if (void 0 !== i) {
                    const t1 = String(i), n = e.h({}, o[t1], r[t1]);
                    if (s) {
                        const e = s[i];
                        if (null === e) return {};
                        for(const t1 in e)delete n[t1];
                    }
                    return n;
                }
                const n = e.h({}, o, r);
                if (s) for(const e in s)delete n[e];
                return n;
            }
            initializeTileState(e, t1) {
                e.refreshFeatureState(t1);
            }
            coalesceChanges(t1, i) {
                const o = {};
                for(const t1 in this.stateChanges){
                    this.state[t1] = this.state[t1] || {};
                    const i = {};
                    for(const o in this.stateChanges[t1])this.state[t1][o] || (this.state[t1][o] = {}), e.h(this.state[t1][o], this.stateChanges[t1][o]), i[o] = this.state[t1][o];
                    o[t1] = i;
                }
                for(const t1 in this.deletedStates){
                    this.state[t1] = this.state[t1] || {};
                    const i = {};
                    if (null === this.deletedStates[t1]) for(const e in this.state[t1])i[e] = {}, this.state[t1][e] = {};
                    else for(const e in this.deletedStates[t1]){
                        if (null === this.deletedStates[t1][e]) this.state[t1][e] = {};
                        else if (this.state[t1][e]) for (const i of Object.keys(this.deletedStates[t1][e]))delete this.state[t1][e][i];
                        i[e] = this.state[t1][e];
                    }
                    o[t1] = o[t1] || {}, e.h(o[t1], i);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for(const e in t1)t1[e].refreshFeatureState(i);
            }
        }
        class It extends e.E {
            constructor(e, t1, i){
                super(), this.id = e, this._onlySymbols = i, t1.on("data", (e)=>{
                    "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), t1.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = t1, this._tiles = {}, this._cache = new Et(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new St, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(e) {
                this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const e in this._tiles)if (!this._tiles[e].loaded()) return !1;
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const e = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(e, t1) {
                return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t1);
            }
            _unloadTile(e) {
                if (this._source.unloadTile) return this._source.unloadTile(e);
            }
            _abortTile(e) {
                if (this._source.abortTile) return this._source.abortTile(e);
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(e) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    i.upload(e), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
                }
            }
            getIds() {
                return Object.values(this._tiles).map((e)=>e.tileID).sort(Ct).map((e)=>e.key);
            }
            getRenderableIds(t1, i) {
                const o = [];
                for(const e in this._tiles)this._isIdRenderable(+e, t1, i) && o.push(this._tiles[e]);
                return t1 ? o.sort((t1, i)=>{
                    const o = t1.tileID, r = i.tileID, s = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), n = new e.P(r.canonical.x, r.canonical.y)._rotate(this.transform.angle);
                    return o.overscaledZ - r.overscaledZ || n.y - s.y || n.x - s.x;
                }).map((e)=>e.tileID.key) : o.map((e)=>e.tileID).sort(Ct).map((e)=>e.key);
            }
            hasRenderableParent(e) {
                const t1 = this.findLoadedParent(e, 0);
                return !!t1 && this._isIdRenderable(t1.tileID.key);
            }
            _isIdRenderable(e, t1, i) {
                return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t1 || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const e in this._tiles)"errored" !== this._tiles[e].state && this._reloadTile(+e, "reloading");
                }
            }
            _reloadTile(e, t1) {
                const i = this._tiles[e];
                i && ("loading" !== i.state && (i.state = t1), this._loadTile(i, this._tileLoaded.bind(this, i, e, t1)));
            }
            _tileLoaded(t1, i, o, r) {
                if (r) if (t1.state = "errored", 404 !== r.status) this._source.fire(new e.z(r, {
                    tile: t1
                }));
                else {
                    if (this._source.fire(new e.A("data", {
                        dataType: "source",
                        sourceDataType: "error",
                        sourceId: this._source.id,
                        tile: t1
                    })), !(t1.tileID.key in this._loadedParentTiles)) return;
                    if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const e = this.map.painter.terrain;
                        this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                }
                else t1.timeAdded = e.q.now(), "expired" === o && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null), this._source.fire(new e.A("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(e) {
                const t1 = this.getRenderableIds();
                for(let o = 0; o < t1.length; o++){
                    const r = t1[o];
                    if (e.neighboringTiles && e.neighboringTiles[r]) {
                        const t1 = this.getTileByID(r);
                        i(e, t1), i(t1, e);
                    }
                }
                function i(e, t1) {
                    if (!e.dem || e.dem.borderReady) return;
                    e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;
                    let i = t1.tileID.canonical.x - e.tileID.canonical.x;
                    const o = t1.tileID.canonical.y - e.tileID.canonical.y, r = Math.pow(2, e.tileID.canonical.z), s = t1.tileID.key;
                    0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)), t1.dem && e.dem && (e.dem.backfillBorder(t1.dem, i, o), e.neighboringTiles && e.neighboringTiles[s] && (e.neighboringTiles[s].backfilled = !0)));
                }
            }
            getTile(e) {
                return this.getTileByID(e.key);
            }
            getTileByID(e) {
                return this._tiles[e];
            }
            _retainLoadedChildren(e, t1, i, o) {
                for(const r in this._tiles){
                    let s = this._tiles[r];
                    if (o[r] || !s.hasData() || s.tileID.overscaledZ <= t1 || s.tileID.overscaledZ > i) continue;
                    let n = s.tileID;
                    for(; s && s.tileID.overscaledZ > t1 + 1;){
                        const e = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
                        s = this._tiles[e.key], s && s.hasData() && (n = e);
                    }
                    let a = n;
                    for(; a.overscaledZ > t1;)if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) {
                        o[n.key] = n;
                        break;
                    }
                }
            }
            findLoadedParent(e, t1) {
                if (e.key in this._loadedParentTiles) {
                    const i = this._loadedParentTiles[e.key];
                    return i && i.tileID.overscaledZ >= t1 ? i : null;
                }
                for(let i = e.overscaledZ - 1; i >= t1; i--){
                    const t1 = e.scaledTo(i), o = this._getLoadedTile(t1);
                    if (o) return o;
                }
            }
            _getLoadedTile(e) {
                const t1 = this._tiles[e.key];
                return t1 && t1.hasData() ? t1 : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);
            }
            updateCacheSize(e, t1) {
                t1 = t1 || this._source.tileSize;
                const i = Math.ceil(e.width / t1) + 1, o = Math.ceil(e.height / t1) + 1, r = Math.floor(i * o * 5), s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r) : r, n = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
                this._cache.setMaxSize(n);
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);
                if (this._prevLng = e, t1) {
                    const e = {};
                    for(const i in this._tiles){
                        const o = this._tiles[i];
                        o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t1), e[o.tileID.key] = o;
                    }
                    this._tiles = e;
                    for(const e in this._timers)clearTimeout(this._timers[e]), delete this._timers[e];
                    for(const e in this._tiles)this._setTileReloadTimer(+e, this._tiles[e]);
                }
            }
            update(t1, i, o, r, s) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !o) return;
                this.updateCacheSize(t1, i), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
                const n = "batched-model" === this._source.type;
                let a, l = this._source.maxzoom;
                const c = this.map && this.map.painter ? this.map.painter._terrain : null;
                if (c && c.sourceCache === this && c.attenuationRange()) {
                    const e = c.attenuationRange()[0], t1 = Math.floor(e) - Math.log2(c.getDemUpscale());
                    l > t1 && (l = t1);
                }
                if (this.used || this.usedForTerrain) {
                    if (this._source.tileID) a = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new e.aM(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y));
                    else if (0 !== this.tileCoverLift) {
                        const r = t1.clone();
                        r.tileCoverLift = this.tileCoverLift, a = r.coveringTiles({
                            tileSize: i || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: l,
                            roundZoom: this._source.roundZoom && !o,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain,
                            calculateQuadrantVisibility: n
                        }), this._source.minzoom <= 1 && "globe" === t1.projection.name && (a.push(new e.aM(1, 0, 1, 0, 0)), a.push(new e.aM(1, 0, 1, 1, 0)), a.push(new e.aM(1, 0, 1, 0, 1)), a.push(new e.aM(1, 0, 1, 1, 1)));
                    } else if (a = t1.coveringTiles({
                        tileSize: i || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: l,
                        roundZoom: this._source.roundZoom && !o,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain,
                        calculateQuadrantVisibility: n
                    }), this._source.hasTile) {
                        const e = this._source.hasTile.bind(this._source);
                        a = a.filter((t1)=>e(t1));
                    }
                } else a = [];
                if (a.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Rt(this._source.type)) {
                    const e = t1.coveringZoomLevel({
                        tileSize: i || this._source.tileSize,
                        roundZoom: this._source.roundZoom && !o
                    }), l = Math.min(e, this._source.maxzoom);
                    if (n) {
                        const e = t1.extendTileCover(a, l);
                        for (const t1 of e)a.push(t1);
                    } else if (s) {
                        const e = t1.extendTileCoverToNearPlane(a, this.transform.getFrustum(l), l);
                        for (const t1 of e)a.push(t1);
                    } else if (this.castsShadows && r) {
                        const e = t1.extendTileCover(a, l, r);
                        for (const t1 of e)this._shadowCasterTiles[t1.key] = !0, a.push(t1);
                    }
                }
                const h = this._updateRetainedTiles(a);
                if (Rt(this._source.type) && 0 !== a.length) {
                    const t1 = {}, i = {}, o = Object.keys(h);
                    for (const r of o){
                        const o = h[r], s = this._tiles[r];
                        if (!s || s.fadeEndTime && s.fadeEndTime <= e.q.now()) continue;
                        const n = this.findLoadedParent(o, Math.max(o.overscaledZ - It.maxOverzooming, this._source.minzoom));
                        n && (this._addTile(n.tileID), t1[n.tileID.key] = n.tileID), i[r] = o;
                    }
                    const r = a[a.length - 1].overscaledZ;
                    for(const e in this._tiles){
                        const t1 = this._tiles[e];
                        if (h[e] || !t1.hasData()) continue;
                        let o = t1.tileID;
                        for(; o.overscaledZ > r;){
                            o = o.scaledTo(o.overscaledZ - 1);
                            const r = this._tiles[o.key];
                            if (r && r.hasData() && i[o.key]) {
                                h[e] = t1.tileID;
                                break;
                            }
                        }
                    }
                    for(const e in t1)h[e] || (this._coveredTiles[e] = !0, h[e] = t1[e]);
                }
                for(const e in h)this._tiles[e].clearFadeHold();
                const d = e.bs(this._tiles, h);
                for (const e of d){
                    const t1 = this._tiles[e];
                    t1.hasSymbolBuckets && !t1.holdingForFade() ? t1.setHoldDuration(this.map._fadeDuration) : t1.hasSymbolBuckets && !t1.symbolFadeFinished() || this._removeTile(+e);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const e in this._tiles)this._tiles[e].holdingForFade() && this._removeTile(+e);
            }
            _updateRetainedTiles(e) {
                const t1 = {};
                if (0 === e.length) return t1;
                const i = {}, o = e.reduce((e, t1)=>Math.min(e, t1.overscaledZ), 1 / 0), r = e[0].overscaledZ, s = Math.max(r - It.maxOverzooming, this._source.minzoom), n = Math.max(r + It.maxUnderzooming, this._source.minzoom), a = {};
                for (const i of e){
                    const e = this._addTile(i);
                    t1[i.key] = i, e.hasData() || o < this._source.maxzoom && (a[i.key] = i);
                }
                this._retainLoadedChildren(a, o, n, t1);
                for (const o of e){
                    let e = this._tiles[o.key];
                    if (e.hasData()) continue;
                    if (o.canonical.z >= this._source.maxzoom) {
                        const e = o.children(this._source.maxzoom)[0], i = this.getTile(e);
                        if (i && i.hasData()) {
                            t1[e.key] = e;
                            continue;
                        }
                    } else {
                        const e = o.children(this._source.maxzoom);
                        if (t1[e[0].key] && t1[e[1].key] && t1[e[2].key] && t1[e[3].key]) continue;
                    }
                    let r = e.wasRequested();
                    for(let n = o.overscaledZ - 1; n >= s; --n){
                        const s = o.scaledTo(n);
                        if (i[s.key]) break;
                        if (i[s.key] = !0, e = this.getTile(s), !e && r && (e = this._addTile(s)), e && (t1[s.key] = s, r = e.wasRequested(), e.hasData())) break;
                    }
                }
                return t1;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const e in this._tiles){
                    const t1 = [];
                    let i, o = this._tiles[e].tileID;
                    for(; o.overscaledZ > 0;){
                        if (o.key in this._loadedParentTiles) {
                            i = this._loadedParentTiles[o.key];
                            break;
                        }
                        t1.push(o.key);
                        const e = o.scaledTo(o.overscaledZ - 1);
                        if (i = this._getLoadedTile(e), i) break;
                        o = e;
                    }
                    for (const e of t1)this._loadedParentTiles[e] = i;
                }
            }
            _addTile(t1) {
                let i = this._tiles[t1.key];
                if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t1.key] || this._reloadTile(t1.key, "reloading"), i;
                i = this._cache.getAndRemove(t1), i && (this._setTileReloadTimer(t1.key, i), i.tileID = t1, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, i)));
                const o = Boolean(i);
                if (!o) {
                    const e = this.map ? this.map.painter : null, o = this._source.tileSize * t1.overscaleFactor();
                    i = "raster-array" === this._source.type ? new Tt(t1, o, this.transform.tileZoom, e, this._isRaster) : new wt(t1, o, this.transform.tileZoom, e, this._isRaster, this._source.worldview), this._loadTile(i, this._tileLoaded.bind(this, i, t1.key, i.state));
                }
                return i.uses++, this._tiles[t1.key] = i, o || this._source.fire(new e.A("dataloading", {
                    tile: i,
                    coord: i.tileID,
                    dataType: "source"
                })), i;
            }
            _setTileReloadTimer(e, t1) {
                e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
                const i = t1.getExpiryTimeout();
                i && (this._timers[e] = setTimeout(()=>{
                    this._reloadTile(e, "expired"), delete this._timers[e];
                }, i));
            }
            _removeTile(e) {
                const t1 = this._tiles[e];
                t1 && (t1.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t1.uses > 0 || (t1.hasData() && "reloading" !== t1.state || "empty" === t1.state ? this._cache.add(t1.tileID, t1, t1.getExpiryTimeout()) : (t1.aborted = !0, this._abortTile(t1), this._unloadTile(t1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const e in this._tiles)this._removeTile(+e);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, i, o) {
                const r = [], s = this.transform;
                if (!s) return r;
                const n = "globe" === s.projection.name, a = e.aD(s.center.lng);
                for(const l in this._tiles){
                    const c = this._tiles[l];
                    if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;
                    let h;
                    if (n) {
                        const t1 = c.tileID.canonical;
                        if (0 === t1.z) {
                            const i = [
                                Math.abs(e.ay(a, ...At(t1, -1)) - a),
                                Math.abs(e.ay(a, ...At(t1, 1)) - a)
                            ];
                            h = [
                                0,
                                2 * i.indexOf(Math.min(...i)) - 1
                            ];
                        } else {
                            const i = [
                                Math.abs(e.ay(a, ...At(t1, -1)) - a),
                                Math.abs(e.ay(a, ...At(t1, 0)) - a),
                                Math.abs(e.ay(a, ...At(t1, 1)) - a)
                            ];
                            h = [
                                i.indexOf(Math.min(...i)) - 1
                            ];
                        }
                    } else h = [
                        0
                    ];
                    for (const e of h){
                        const o = t1.containsTile(c, s, i, e);
                        o && r.push(o);
                    }
                }
                return r;
            }
            getShadowCasterCoordinates() {
                return this._getRenderableCoordinates(!1, !0);
            }
            getVisibleCoordinates(e) {
                return this._getRenderableCoordinates(e);
            }
            _getRenderableCoordinates(e, t1) {
                const i = this.getRenderableIds(e, t1).map((e)=>this._tiles[e].tileID), o = "globe" === this.transform.projection.name;
                for (const e of i)e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;
                return i;
            }
            sortCoordinatesByDistance(e) {
                const t1 = e.slice(), i = this.transform._camera.position, o = this.transform._camera.forward(), r = {};
                for (const e of t1){
                    const t1 = 1 / (1 << e.canonical.z);
                    r[e.key] = ((e.canonical.x + .5) * t1 + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t1 - i[1]) * o[1] - i[2] * o[2];
                }
                return t1.sort((e, t1)=>r[e.key] - r[t1.key]), t1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (Rt(this._source.type)) for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.q.now()) return !0;
                }
                return !1;
            }
            setFeatureState(e, t1, i) {
                this._state.updateState(e = e || "_geojsonTileLayer", t1, i);
            }
            removeFeatureState(e, t1, i) {
                this._state.removeFeatureState(e = e || "_geojsonTileLayer", t1, i);
            }
            getFeatureState(e, t1) {
                return this._state.getState(e = e || "_geojsonTileLayer", t1);
            }
            setDependencies(e, t1, i) {
                const o = this._tiles[e];
                o && o.setDependencies(t1, i);
            }
            reloadTilesForDependencies(e, t1) {
                for(const i in this._tiles)this._tiles[i].hasDependency(e, t1) && this._reloadTile(+i, "reloading");
                this._cache.filter((i)=>!i.hasDependency(e, t1));
            }
            _preloadTiles(t1, i) {
                if (!this._sourceLoaded) {
                    const e = ()=>{
                        this._sourceLoaded && (this._source.off("data", e), this._preloadTiles(t1, i));
                    };
                    return void this._source.on("data", e);
                }
                const o = new Map, r = Array.isArray(t1) ? t1 : [
                    t1
                ], s = this.map.painter.terrain, n = this.usedForTerrain && s ? s.getScaledDemTileSize() : this._source.tileSize;
                for (const e of r){
                    const t1 = e.coveringTiles({
                        tileSize: n,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const e of t1)o.set(e.key, e);
                    this.usedForTerrain && e.updateElevation(!1);
                }
                const a = Array.from(o.values());
                e.bt(a, (e, t1)=>{
                    const i = new wt(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);
                    this._loadTile(i, (e)=>{
                        "raster-dem" === this._source.type && i.dem && this._backfillDEM(i), t1(e, i);
                    });
                }, i);
            }
        }
        function Ct(e, t1) {
            const i = Math.abs(2 * e.wrap) - +(e.wrap < 0), o = Math.abs(2 * t1.wrap) - +(t1.wrap < 0);
            return e.overscaledZ - t1.overscaledZ || o - i || t1.canonical.y - e.canonical.y || t1.canonical.x - e.canonical.x;
        }
        function Rt(e) {
            return "raster" === e || "image" === e || "video" === e || "custom" === e;
        }
        function At(e, t1) {
            const i = 1 << e.z;
            return [
                e.x / i + t1,
                (e.x + 1) / i + t1
            ];
        }
        It.maxOverzooming = 10, It.maxUnderzooming = 3;
        class Dt {
            constructor(e){
                this.style = e, this.layersGotHidden = !1, this.layers = [];
            }
            processLayersChanged() {
                this.layers = [];
                const e = !1, t1 = !1;
                for(const i in this.style._mergedLayers){
                    const o = this.style._mergedLayers[i];
                    if ("fill-extrusion" === o.type || "building" === o.type) this.layers.push({
                        layer: o,
                        visible: e,
                        visibilityChanged: t1
                    });
                    else if ("model" === o.type) {
                        const i = this.style.getLayerSource(o);
                        i && "batched-model" === i.type && this.layers.push({
                            layer: o,
                            visible: e,
                            visibilityChanged: t1
                        });
                    }
                }
            }
            onNewFrame(e) {
                this.layersGotHidden = !1;
                for (const t1 of this.layers){
                    const i = t1.layer;
                    let o = !1;
                    "fill-extrusion" === i.type ? o = !i.isHidden(e) && i.paint.get("fill-extrusion-opacity") > 0 : "building" === i.type ? o = !i.isHidden(e) && i.paint.get("building-opacity") > 0 : "model" === i.type && (o = !i.isHidden(e) && i.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o && t1.visible, t1.visible = o;
                }
            }
            updateZOffset(e, t1) {
                this.currentBuildingBuckets = [];
                for (const e of this.layers){
                    const i = e.layer, o = this.style.getLayerSourceCache(i);
                    let r = 1;
                    "fill-extrusion" === i.type ? r = e.visible ? i.paint.get("fill-extrusion-vertical-scale") : 0 : "building" === i.type && (r = e.visible ? i.paint.get("building-vertical-scale") : 0);
                    let s = o ? o.getTile(t1) : null;
                    if (!s && o) for(const e in o._tiles){
                        const i = o._tiles[e];
                        if (t1.canonical.isChildOf(i.tileID.canonical)) {
                            s = i;
                            break;
                        }
                    }
                    this.currentBuildingBuckets.push({
                        bucket: s ? s.getBucket(i) : null,
                        tileID: s ? s.tileID : t1,
                        verticalScale: r
                    });
                }
                e.hasAnyZOffset = !1;
                let i = !1;
                for(let o = 0; o < e.symbolInstances.length; o++){
                    const r = e.symbolInstances.get(o), s = r.zOffset, n = this._getHeightAtTileOffset(t1, r.tileAnchorX, r.tileAnchorY);
                    r.zOffset = n !== Number.NEGATIVE_INFINITY ? n : s, i || s === r.zOffset || (i = !0), e.hasAnyZOffset || 0 === r.zOffset || (e.hasAnyZOffset = !0);
                }
                i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);
            }
            _mapCoordToOverlappingTile(t1, i, o, r) {
                let s = i, n = o;
                if (t1.canonical.z !== r.canonical.z) {
                    const a = r.canonical, l = 1 / (1 << t1.canonical.z - a.z);
                    s = (i + t1.canonical.x * e.aj) * l - a.x * e.aj | 0, n = (o + t1.canonical.y * e.aj) * l - a.y * e.aj | 0;
                }
                return {
                    tileX: s,
                    tileY: n
                };
            }
            _getHeightAtTileOffset(e, t1, i) {
                let o, r;
                for(let s = 0; s < this.layers.length; ++s){
                    const n = this.layers[s].layer;
                    if ("fill-extrusion" !== n.type && "building" !== n.type) continue;
                    const { bucket: a, tileID: l, verticalScale: c } = this.currentBuildingBuckets[s];
                    if (!a) continue;
                    const { tileX: h, tileY: d } = this._mapCoordToOverlappingTile(e, t1, i, l), u = a.getHeightAtTileCoord(h, d);
                    u && void 0 !== u.height && (u.hidden ? o = u.height : r = Math.max(u.height * c, r || 0));
                }
                if (void 0 !== r) return r;
                for(let r = 0; r < this.layers.length; ++r){
                    const s = this.layers[r];
                    if ("model" !== s.layer.type || !s.visible) continue;
                    const { bucket: n, tileID: a } = this.currentBuildingBuckets[r];
                    if (!n) continue;
                    const { tileX: l, tileY: c } = this._mapCoordToOverlappingTile(e, t1, i, a), h = n.getHeightAtTileCoord(l, c);
                    if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;
                }
                return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
        }
        function Pt(t1, i) {
            const o = {};
            for(const e in t1)"ref" !== e && (o[e] = t1[e]);
            return e.bu.forEach((e)=>{
                e in i && (o[e] = i[e]);
            }), o;
        }
        function Lt(e) {
            e = e.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e.length; i++)t1[e[i].id] = e[i];
            for(let i = 0; i < e.length; i++)"ref" in e[i] && (e[i] = Pt(e[i], t1[e[i].ref]));
            return e;
        }
        const zt = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setSlot: "setSlot",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setSnow: "setSnow",
            setRain: "setRain",
            setCamera: "setCamera",
            setLights: "setLights",
            setProjection: "setProjection",
            addImport: "addImport",
            removeImport: "removeImport",
            updateImport: "updateImport",
            addIconset: "addIconset",
            removeIconset: "removeIconset"
        };
        function Mt(e, t1, i) {
            i.push({
                command: zt.addSource,
                args: [
                    e,
                    t1[e]
                ]
            });
        }
        function Ot(e, t1, i) {
            t1.push({
                command: zt.removeSource,
                args: [
                    e
                ]
            }), i[e] = !0;
        }
        function Ft(e, t1, i, o) {
            Ot(e, i, o), Mt(e, t1, i);
        }
        function Bt(t1, i, o) {
            let r;
            for(r in t1[o])if (t1[o].hasOwnProperty(r) && "data" !== r && !e.bv(t1[o][r], i[o][r])) return !1;
            for(r in i[o])if (i[o].hasOwnProperty(r) && "data" !== r && !e.bv(t1[o][r], i[o][r])) return !1;
            return !0;
        }
        function kt(t1, i, o, r, s, n) {
            let a;
            for(a in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(a) && (e.bv(t1[a], i[a]) || o.push({
                command: n,
                args: [
                    r,
                    a,
                    i[a],
                    s
                ]
            }));
            for(a in i)i.hasOwnProperty(a) && !t1.hasOwnProperty(a) && (e.bv(t1[a], i[a]) || o.push({
                command: n,
                args: [
                    r,
                    a,
                    i[a],
                    s
                ]
            }));
        }
        function Nt(e) {
            return e.id;
        }
        function Ut(e, t1) {
            return e[t1.id] = t1, e;
        }
        function jt(t1, i, o) {
            const r = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e.az(new Float32Array(16), t1.projMatrix, r);
        }
        function Gt(e, t1, i) {
            if (t1.projection.name === i.projection.name) return e.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), jt(o, t1.getProjection(), e);
        }
        function Vt(e, t1, i) {
            return t1.name === i.projection.name ? e.projMatrix : jt(i, t1, e);
        }
        class qt {
            constructor(e, t1){
                this.reset(e, t1);
            }
            reset(e, t1) {
                this.points = e || [], this._distances = [
                    0
                ];
                for(let e = 1; e < this.points.length; e++)this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e.ay(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const r = t1 * this.paddedLength + this.padding;
                for(; o < r && i < this._distances.length;)o = this._distances[++i];
                const s = i - 1, n = this._distances[s], a = o - n, l = a > 0 ? (r - n) / a : 0;
                return this.points[s].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class Ht {
            constructor(e, t1, i){
                const o = this.boxCells = [], r = this.circleCells = [];
                this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e = 0; e < this.xCellCount * this.yCellCount; e++)o.push([]), r.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t1, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e, t1, i, o, r) {
                this._forEachCell(t1, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }
            insertCircle(e, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e, t1, i, o, r, s) {
                this.boxCells[r].push(s);
            }
            _insertCircleCell(e, t1, i, o, r, s) {
                this.circleCells[r].push(s);
            }
            _query(e, t1, i, o, r, s) {
                if (i < 0 || e > this.width || o < 0 || t1 > this.height) return !r && [];
                const n = [];
                if (e <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;
                    for(let e = 0; e < this.boxKeys.length; e++)n.push({
                        key: this.boxKeys[e],
                        x1: this.bboxes[4 * e],
                        y1: this.bboxes[4 * e + 1],
                        x2: this.bboxes[4 * e + 2],
                        y2: this.bboxes[4 * e + 3]
                    });
                    for(let e = 0; e < this.circleKeys.length; e++){
                        const t1 = this.circles[3 * e], i = this.circles[3 * e + 1], o = this.circles[3 * e + 2];
                        n.push({
                            key: this.circleKeys[e],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return s ? n.filter(s) : n;
                }
                return this._forEachCell(e, t1, i, o, this._queryCell, n, {
                    hitTest: r,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, s), r ? n.length > 0 : n;
            }
            _queryCircle(e, t1, i, o, r) {
                const s = e - i, n = e + i, a = t1 - i, l = t1 + i;
                if (n < 0 || s > this.width || l < 0 || a > this.height) return !o && [];
                const c = [];
                return this._forEachCell(s, a, n, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), o ? c.length > 0 : c;
            }
            query(e, t1, i, o, r) {
                return this._query(e, t1, i, o, !1, r);
            }
            hitTest(e, t1, i, o, r) {
                return this._query(e, t1, i, o, !0, r);
            }
            hitTestCircle(e, t1, i, o) {
                return this._queryCircle(e, t1, i, !0, o);
            }
            _queryCell(e, t1, i, o, r, s, n, a) {
                const l = n.seenUids, c = this.boxCells[r];
                if (null !== c) {
                    const r = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e <= r[c + 2] && t1 <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
                            if (n.hitTest) return s.push(!0), !0;
                            s.push({
                                key: this.boxKeys[h],
                                x1: r[c],
                                y1: r[c + 1],
                                x2: r[c + 2],
                                y2: r[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[r];
                if (null !== h) {
                    const r = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t1, i, o) && (!a || a(this.circleKeys[c]))) {
                            if (n.hitTest) return s.push(!0), !0;
                            {
                                const e = r[h], t1 = r[h + 1], i = r[h + 2];
                                s.push({
                                    key: this.circleKeys[c],
                                    x1: e - i,
                                    y1: t1 - i,
                                    x2: e + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e, t1, i, o, r, s, n, a) {
                const l = n.circle, c = n.seenUids, h = this.boxCells[r];
                if (null !== h) {
                    const e = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t1]))) return s.push(!0), !0;
                    }
                }
                const d = this.circleCells[r];
                if (null !== d) {
                    const e = this.circles;
                    for (const t1 of d)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t1]))) return s.push(!0), !0;
                    }
                }
            }
            _forEachCell(e, t1, i, o, r, s, n, a) {
                const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), d = this._convertToYCellCoord(o);
                for(let u = l; u <= h; u++)for(let l = c; l <= d; l++)if (r.call(this, e, t1, i, o, this.xCellCount * l + u, s, n, a)) return;
            }
            _convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }
            _convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }
            _circlesCollide(e, t1, i, o, r, s) {
                const n = o - e, a = r - t1, l = i + s;
                return l * l > n * n + a * a;
            }
            _circleAndRectCollide(e, t1, i, o, r, s, n) {
                const a = (s - o) / 2, l = Math.abs(e - (o + a));
                if (l > a + i) return !1;
                const c = (n - r) / 2, h = Math.abs(t1 - (r + c));
                if (h > c + i) return !1;
                if (l <= a || h <= c) return !0;
                const d = l - a, u = h - c;
                return d * d + u * u <= i * i;
            }
        }
        const Zt = {
            unknown: 0,
            flipRequired: 1,
            flipNotRequired: 2
        }, Wt = Math.tan(85 * Math.PI / 180);
        function $t(t1, i, o, r, s, n, a) {
            const l = e.bz();
            if (o) if ("globe" === n.name) {
                const t1 = e.bA(s, i);
                e.az(l, l, t1);
            } else {
                const t1 = e.bB([], a);
                l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], r || e.by(l, l, s.angle);
            }
            else e.az(l, s.labelPlaneMatrix, t1);
            return l;
        }
        function Xt(e, t1, i, o, r, s, n) {
            const a = $t(e, t1, i, o, r, s, n);
            return "globe" === s.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
        }
        function Yt(t1, i, o, r, s, n, a) {
            if (o) {
                if ("globe" === n.name) {
                    const l = $t(t1, i, o, r, s, n, a);
                    return e.bi(l, l), e.az(l, t1, l), l;
                }
                {
                    const i = e.bw(t1), o = e.bx([]);
                    return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.az(i, i, o), r || e.by(i, i, -s.angle), i;
                }
            }
            return s.glCoordMatrix;
        }
        function Kt(t1, i, o, r) {
            const s = [
                t1,
                i,
                o,
                1
            ];
            o ? e.aA(s, s, r) : li(s, s, r);
            const n = s[3];
            return s[0] /= n, s[1] /= n, s[2] /= n, s;
        }
        function Jt(e, t1) {
            return Math.min(.5 + e / t1 * .5, 1.5);
        }
        function Qt(e, t1) {
            const i = e[0] / e[3], o = e[1] / e[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function ei(t1, i, o, r, s, n, a, l, c, h) {
            const d = o.transform, u = r ? t1.textSizeData : t1.iconSizeData, _ = e.bH(u, o.transform.zoom), p = "globe" === d.projection.name, f = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], m = r ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            m.clear();
            let g = null;
            p && (g = r ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const v = t1.lineVertexArray, y = r ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, x = o.transform.width / o.transform.height;
            let b, w = !1;
            for(let r = 0; r < y.length; r++){
                const p = y.get(r), { numGlyphs: T, writingMode: E } = p;
                if (E !== e.bI.vertical || w || b === e.bI.horizontal || (w = !0), b = E, (p.hidden || E === e.bI.vertical) && !w) {
                    ai(T, m);
                    continue;
                }
                w = !1;
                const S = new e.P(p.tileAnchorX, p.tileAnchorY);
                let { x: I, y: C, z: R } = d.projection.projectTilePoint(S.x, S.y, h.canonical);
                if (c) {
                    const [e, t1, i] = c(S);
                    I += e, C += t1, R += i;
                }
                const A = [
                    I,
                    C,
                    R,
                    1
                ];
                if (e.aA(A, A, i), !Qt(A, f)) {
                    ai(T, m);
                    continue;
                }
                const D = A[3], P = Jt(o.transform.getCameraToCenterDistance(d.projection), D), L = e.bJ(u, _, p), z = a ? L / P : L * P, M = Kt(I, C, R, s);
                if (M[3] <= 0) {
                    ai(T, m);
                    continue;
                }
                let O = {};
                const F = e.al(t1.layers[0].layout.get("text-max-angle")), B = Math.cos(F), k = a ? null : c, N = oi(p, z, !1, l, i, s, n, t1.glyphOffsetArray, v, m, g, M, S, O, x, k, d.projection, h, a, B);
                w = N.useVertical, k && N.needsFlipping && (O = {}), (N.notEnoughRoom || w || N.needsFlipping && oi(p, z, !0, l, i, s, n, t1.glyphOffsetArray, v, m, g, M, S, O, x, k, d.projection, h, a, B).notEnoughRoom) && ai(T, m);
            }
            r ? (t1.text.dynamicLayoutVertexBuffer.updateData(m), g && t1.text.globeExtVertexBuffer && t1.text.globeExtVertexBuffer.updateData(g)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(m), g && t1.icon.globeExtVertexBuffer && t1.icon.globeExtVertexBuffer.updateData(g));
        }
        function ti(e, t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m) {
            const { lineStartIndex: g, glyphStartIndex: v, segment: y } = a, x = v + a.numGlyphs, b = g + a.lineLength, w = t1.getoffsetX(v), T = t1.getoffsetX(x - 1), E = ni(e * w, i, o, r, s, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);
            if (!E) return null;
            const S = ni(e * T, i, o, r, s, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);
            return S ? {
                first: E,
                last: S
            } : null;
        }
        function ii(t1, i, o, r) {
            return t1 === e.bI.horizontal && Math.abs(r) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e.bI.vertical ? r > 0 ? {
                needsFlipping: !0
            } : null : i !== Zt.unknown && function(e, t1) {
                return 0 === e || Math.abs(t1 / e) > Wt;
            }(o, r) ? i === Zt.flipRequired ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function oi(t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
            const b = i / 24, w = t1.lineOffsetX * b, T = t1.lineOffsetY * b, { lineStartIndex: E, glyphStartIndex: S, numGlyphs: I, segment: C, writingMode: R, flipState: A } = t1, D = E + t1.lineLength, P = (t1)=>{
                if (d) {
                    const [i, o, r] = t1.up, s = h.length;
                    e.bK(d, s + 0, i, o, r), e.bK(d, s + 1, i, o, r), e.bK(d, s + 2, i, o, r), e.bK(d, s + 3, i, o, r);
                }
                const [i, o, r] = t1.point;
                e.bL(h, i, o, r, t1.angle);
            };
            if (I > 1) {
                const e = ti(b, l, w, T, o, u, _, t1, c, n, p, m, !1, g, v, y, x);
                if (!e) return {
                    notEnoughRoom: !0
                };
                if (r && !o) {
                    let [i, o, r] = e.first.point, [s, n, l] = e.last.point;
                    [i, o] = Kt(i, o, r, a), [s, n] = Kt(s, n, l, a);
                    const c = ii(R, A, (s - i) * f, n - o);
                    if (t1.flipState = c && c.needsFlipping ? Zt.flipRequired : Zt.flipNotRequired, c) return c;
                }
                P(e.first);
                for(let e = S + 1; e < S + I - 1; e++){
                    const t1 = ni(b * l.getoffsetX(e), w, T, o, u, _, C, E, D, c, n, p, m, !1, !1, g, v, y, x);
                    if (!t1) return h.length -= 4 * (e - S), {
                        notEnoughRoom: !0
                    };
                    P(t1);
                }
                P(e.last);
            } else {
                if (r && !o) {
                    const i = Kt(_.x, _.y, 0, s), o = E + C + 1, r = new e.P(c.getx(o), c.gety(o)), n = Kt(r.x, r.y, 0, s), a = n[3] > 0 ? n : si(_, r, i, 1, s, void 0, g, v.canonical), l = ii(R, A, (a[0] - i[0]) * f, a[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? Zt.flipRequired : Zt.flipNotRequired, l) return l;
                }
                const i = ni(b * l.getoffsetX(S), w, T, o, u, _, C, E, D, c, n, p, m, !1, !1, g, v, y, x);
                if (!i) return {
                    notEnoughRoom: !0
                };
                P(i);
            }
            return {};
        }
        function ri(e, t1, i, o, r) {
            const { x: s, y: n, z: a } = o.projectTilePoint(e.x, e.y, t1);
            if (!r) return Kt(s, n, a, i);
            const [l, c, h] = r(e);
            return Kt(s + l, n + c, a + h, i);
        }
        function si(t1, i, o, r, s, n, a, l) {
            const c = ri(t1.sub(i)._unit()._add(t1), l, s, a, n);
            return e.at(c, o, c), e.au(c, c), e.bE(c, o, c, r);
        }
        function ni(t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y) {
            const x = r ? t1 - i : t1 + i;
            let b = x > 0 ? 1 : -1, w = 0;
            r && (b *= -1, w = Math.PI), b < 0 && (w += Math.PI);
            let T = l + a + (b > 0 ? 0 : 1) | 0, E = s, S = s, I = 0, C = 0;
            const R = Math.abs(x), A = [], D = [];
            let P = n, L = P, z = e.bC([]);
            const M = ()=>si(L, P, S, R - I + 1, d, _, m, g.canonical);
            for(; I + C <= R;){
                if (T += b, T < l || T >= c) return null;
                if (S = E, L = P, A.push(S), p && D.push(L), P = new e.P(h.getx(T), h.gety(T)), E = u[T], !E) {
                    const e = ri(P, g.canonical, d, m, _);
                    E = e[3] > 0 ? u[T] = e : M();
                }
                I += C;
                const t1 = e.at([], E, S), i = e.bD(S, E);
                if (o && i > 0 && C > 0 && e.bG(z, t1) / (C * i) < y) return null;
                C = i, z = t1;
            }
            f && _ && (u[T] && (E = M(), C = e.bD(S, E), z = e.at([], E, S)), u[T] = E);
            const O = (R - I) / C, F = P.sub(L)._mult(O)._add(L), B = e.bE([], S, z, O);
            let k = [
                0,
                0,
                1
            ], N = z[0], U = z[1];
            if (v && (k = m.upVector(g.canonical, F.x, F.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t1 = [
                    k[2],
                    0,
                    -k[0]
                ], i = e.bF([], k, t1);
                e.au(t1, t1), e.au(i, i), N = e.bG(z, t1), U = e.bG(z, i);
            }
            if (o) {
                const t1 = e.bF([], k, z);
                e.au(t1, t1), e.bE(B, B, t1, o * b);
            }
            const j = w + Math.atan2(U, N);
            return A.push(B), p && D.push(F), {
                point: B,
                angle: j,
                path: A,
                tilePath: D,
                up: k
            };
        }
        function ai(e, t1) {
            const i = t1.length, o = i + 4 * e;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function li(e, t1, i) {
            const o = t1[0], r = t1[1];
            return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;
        }
        const ci = 100;
        class hi {
            constructor(e, t1, i = new Ht(e.width + 200, e.height + 200, 25), o = new Ht(e.width + 200, e.height + 200, 25)){
                this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + ci, this.screenBottomBoundary = e.height + ci, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t1;
            }
            placeCollisionBox(t1, i, o, r, s, n, a, l, c, h, d) {
                let u = o.projectedAnchorX, _ = o.projectedAnchorY, p = o.projectedAnchorZ;
                const f = o.tileAnchorX, m = o.tileAnchorY, g = o.elevation, v = o.tileID, y = t1.getProjection();
                if (g && v) {
                    const [e, t1, i] = y.upVector(v.canonical, o.tileAnchorX, o.tileAnchorY), r = y.upVectorScale(v.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    u += e * g * r, _ += t1 * g * r, p += i * g * r;
                }
                const x = "globe" === t1.projection.name, b = "globe" === t1.projection.name ? e.ah(this.transform.zoom) : 0;
                if (v && x && b < 1 && !n) {
                    const t1 = 1 << v.canonical.z, i = e.bM(f, m);
                    e.bN(i, i, 1 / e.aj), e.bO(i, i, e.bM(v.canonical.x, v.canonical.y)), e.bN(i, i, 1 / t1), e.bP(i, i, e.bM(r[0], r[1])), i[0] = e.bQ(i[0], -.5, .5), e.bN(i, i, e.aj);
                    const o = e.bR(i[0], i[1], e.aj / (2 * Math.PI), 1);
                    e.aA(o, o, s), u = e.ai(u, o[0], b), _ = e.ai(_, o[1], b), p = e.ai(p, o[2], b);
                }
                const w = this.projectAndGetPerspectiveRatio(h, u, _, p, o.tileID, "globe" === y.name || !!g || this.transform.pitch > 0, y), T = c * w.perspectiveRatio, E = (o.x1 * i + a.x - o.padding) * T + w.point.x, S = (o.y1 * i + a.y - o.padding) * T + w.point.y, I = (o.x2 * i + a.x + o.padding) * T + w.point.x, C = (o.y2 * i + a.y + o.padding) * T + w.point.y, R = w.perspectiveRatio <= .55 || w.occluded;
                return !this.isInsideGrid(E, S, I, C) || !l && this.grid.hitTest(E, S, I, C, d) || R ? {
                    box: [],
                    offscreen: !1,
                    occluded: w.occluded
                } : {
                    box: [
                        E,
                        S,
                        I,
                        C
                    ],
                    offscreen: this.isOffscreen(E, S, I, C),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f) {
                const m = [], g = this.transform.elevation, v = t1.getProjection(), y = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null, x = new e.P(o.tileAnchorX, o.tileAnchorY);
                let { x: b, y: w, z: T } = v.projectTilePoint(x.x, x.y, f.canonical);
                if (y) {
                    const [e, t1, i] = y(x);
                    b += e, w += t1, T += i;
                }
                const E = "globe" === v.name, S = this.projectAndGetPerspectiveRatio(a, b, w, T, f, E || !!g || this.transform.pitch > 0, v), { perspectiveRatio: I } = S, C = (d ? n / I : n * I) / e.bU, R = Kt(b, w, T, l), A = o.lineOffsetX * C, D = o.lineOffsetY * C, P = e.al(t1.layers[0].layout.get("text-max-angle")), L = Math.cos(P), z = S.signedDistanceFromCamera > 0 ? ti(C, s, A, D, !1, R, x, o, r, l, {}, g && !d ? y : null, d && !!g, v, f, d, L) : null;
                let M = !1, O = !1, F = !0;
                if (z && !S.occluded) {
                    const t1 = .5 * _ * I + p, o = new e.P(-100, -100), r = new e.P(this.screenRightBoundary, this.screenBottomBoundary), s = new qt, { first: n, last: a } = z, l = n.path.length;
                    let d = [];
                    for(let e = l - 1; e >= 1; e--)d.push(n.path[e]);
                    for(let e = 1; e < a.path.length; e++)d.push(a.path[e]);
                    const f = 2.5 * t1;
                    c && (d = d.map(([e, t1, i], o)=>(y && !E && (i = y(o < l - 1 ? n.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), Kt(e, t1, i, c))), d.some((e)=>e[3] <= 0) && (d = []));
                    let g = [];
                    if (d.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, s = 1 / 0, n = -1 / 0;
                        for (const e of d)t1 = Math.min(t1, e[0]), s = Math.min(s, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);
                        i >= o.x && t1 <= r.x && n >= o.y && s <= r.y && (g = [
                            d.map((t1)=>new e.P(t1[0], t1[1]))
                        ], (t1 < o.x || i > r.x || s < o.y || n > r.y) && (g = e.bS(g, o.x, o.y, r.x, r.y)));
                    }
                    for (const e of g){
                        s.reset(e, .25 * t1);
                        let o = 0;
                        o = s.length <= .5 * t1 ? 1 : Math.ceil(s.paddedLength / f) + 1;
                        for(let e = 0; e < o; e++){
                            const r = e / Math.max(o - 1, 1), n = s.lerp(r), a = n.x + ci, l = n.y + ci;
                            m.push(a, l, t1, 0);
                            const c = a - t1, d = l - t1, _ = a + t1, p = l + t1;
                            if (F = F && this.isOffscreen(c, d, _, p), O = O || this.isInsideGrid(c, d, _, p), !i && this.grid.hitTestCircle(a, l, t1, u) && (M = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: M,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && M || !O ? [] : m,
                    offscreen: F,
                    collisionDetected: M,
                    occluded: S.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, r = 1 / 0, s = -1 / 0, n = -1 / 0;
                for (const a of t1){
                    const t1 = new e.P(a.x + ci, a.y + ci);
                    o = Math.min(o, t1.x), r = Math.min(r, t1.y), s = Math.max(s, t1.x), n = Math.max(n, t1.y), i.push(t1);
                }
                const a = this.grid.query(o, r, s, n).concat(this.ignoredGrid.query(o, r, s, n)), l = {}, c = {};
                for (const t1 of a){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const r = [
                        new e.P(t1.x1, t1.y1),
                        new e.P(t1.x2, t1.y1),
                        new e.P(t1.x2, t1.y2),
                        new e.P(t1.x1, t1.y2)
                    ];
                    e.bT(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e, t1, i, o, r) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                }, e[0], e[1], e[2], e[3]);
            }
            insertCollisionCircles(e, t1, i, o, r) {
                const s = t1 ? this.ignoredGrid : this.grid, n = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                };
                for(let t1 = 0; t1 < e.length; t1 += 4)s.insertCircle(n, e[t1], e[t1 + 1], e[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, r, s, n, a) {
                const l = [
                    i,
                    o,
                    r,
                    1
                ];
                let c = !1;
                if (r || this.transform.pitch > 0) {
                    if (e.aA(l, l, t1), this.fogState && s && "globe" !== a.name) {
                        const t1 = function(t1, i, o, r, s, n) {
                            const a = n.calculateFogTileMatrix(s), l = [
                                i,
                                o,
                                r
                            ];
                            return e.ad(l, l, a), Be(t1, e.ae(l), n.pitch, n._fov);
                        }(this.fogState, i, o, r, s.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else li(l, l, t1);
                const h = l[3];
                return {
                    point: new e.P((l[0] / h + 1) / 2 * this.transform.width + ci, (-l[1] / h + 1) / 2 * this.transform.height + ci),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: n && l[2] > h || c
                };
            }
            isOffscreen(e, t1, i, o) {
                return i < ci || e >= this.screenRightBoundary || o < ci || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e, t1, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e.bx([]);
                return e.bo(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        class di {
            constructor(e, t1, i, o){
                this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class ui {
            constructor(e, t1, i, o, r, s = !1){
                this.text = new di(e ? e.text : null, t1, i, r), this.icon = new di(e ? e.icon : null, t1, o, r), this.clipped = s;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class _i {
            constructor(e, t1, i, o = !1){
                this.text = e, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class pi {
            constructor(){
                this.invProjMatrix = e.bz(), this.viewportMatrix = e.bz(), this.circles = [];
            }
        }
        class fi {
            constructor(e, t1, i, o, r){
                this.bucketInstanceId = e, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
            }
        }
        class mi {
            constructor(e){
                this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                        ID: t1,
                        predicate: (e)=>e.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e];
            }
        }
        function gi(t1, i, o, r, s) {
            const { horizontalAlign: n, verticalAlign: a } = e.bZ(t1), l = -(n - .5) * i, c = -(a - .5) * o, h = e.b_(t1, r);
            return new e.P(l + h[0] * s, c + h[1] * s);
        }
        function vi(t1, i, o, r, s) {
            const n = new e.P(t1, i);
            return o && n._rotate(r ? s : -s), n;
        }
        class yi {
            constructor(e, t1, i, o, r, s){
                this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new hi(this.transform, r), this.buildingIndex = s, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new mi(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t1, i, o, r, s = 1) {
                const n = o.getBucket(i), a = o.latestFeatureIndex;
                if (!n || !a || i.fqid !== n.layerIds[0]) return;
                const l = n.layers[0].layout, c = n.layers[0].paint, h = o.collisionBoxArray, d = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), u = o.tileSize / e.aj, _ = o.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const p = (f = o.tileID, m = n.getProjection(), g = this.transform, m.name === this.projection ? g.calculateProjMatrix(f.toUnwrapped()) : jt(g, m, f));
                var f, m, g;
                const v = "map" === l.get("text-pitch-alignment"), y = "map" === l.get("text-rotation-alignment");
                i.compileFilter(i.options);
                const x = i.dynamicFilter(), b = i.dynamicFilterNeedsFeature(), w = this.transform.calculatePixelsToTileUnitsMatrix(o), T = Xt(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);
                let E = null;
                const S = n.getProjection().createInversionMatrix(this.transform, o.tileID.canonical);
                if (v) {
                    const t1 = Yt(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);
                    E = e.az([], this.transform.labelPlaneMatrix, t1);
                }
                let I = null;
                x && o.latestFeatureIndex && (I = {
                    unwrappedTileID: _,
                    dynamicFilter: x,
                    dynamicFilterNeedsFeature: b
                }), this.retainedQueryData[n.bucketInstanceId] = new fi(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);
                const [C, R] = n.layers[0].layout.get("text-size-scale-range"), A = e.ay(s, C, R), [D, P] = l.get("icon-size-scale-range"), L = e.ay(s, D, P), z = {
                    bucket: n,
                    layout: l,
                    paint: c,
                    posMatrix: p,
                    invMatrix: S,
                    mercatorCenter: [
                        e.aD(this.transform.center.lng),
                        e.aH(this.transform.center.lat)
                    ],
                    textLabelPlaneMatrix: T,
                    labelToScreenMatrix: E,
                    clippingData: I,
                    scale: d,
                    textPixelRatio: u,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: h,
                    partiallyEvaluatedTextSize: e.bH(n.textSizeData, this.transform.zoom, A),
                    partiallyEvaluatedIconSize: e.bH(n.iconSizeData, this.transform.zoom, L),
                    collisionGroup: this.collisionGroups.get(n.sourceID),
                    latestFeatureIndex: o.latestFeatureIndex
                };
                if (r) for (const e of n.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: r } = e;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: r,
                        parameters: z
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n.symbolInstances.length,
                    parameters: z
                });
            }
            attemptAnchorPlacement(e, t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
                const { textOffset0: b, textOffset1: w, crossTileID: T } = p, E = [
                    b,
                    w
                ], S = gi(e, s, n, E, a), I = this.collisionIndex.placeCollisionBox(m, a, t1, i, o, r, vi(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate);
                if (v) {
                    const e = m.getSymbolInstanceIconSize(x, this.transform.zoom, p.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(m, e, v, i, o, r, vi(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate).box.length) return;
                }
                if (I.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[T] && this.prevPlacement.placements[T] && this.prevPlacement.placements[T].text && (t1 = this.prevPlacement.variableOffsets[T].anchor), this.variableOffsets[T] = {
                        textOffset: E,
                        width: s,
                        height: n,
                        anchor: e,
                        textScale: a,
                        prevAnchor: t1
                    }, this.markUsedJustification(m, e, p, g), m.allowVerticalPlacement && (this.markUsedOrientation(m, g, p), this.placedOrientations[T] = g), {
                        shift: S,
                        placedGlyphBoxes: I
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, r, s = 1) {
                const { bucket: n, layout: a, paint: l, posMatrix: c, textLabelPlaneMatrix: h, labelToScreenMatrix: d, clippingData: u, textPixelRatio: _, mercatorCenter: p, invMatrix: f, holdingForFade: m, collisionBoxArray: g, partiallyEvaluatedTextSize: v, partiallyEvaluatedIconSize: y, collisionGroup: x, latestFeatureIndex: b } = t1.parameters, w = a.get("text-optional"), T = a.get("icon-optional"), E = a.get("text-allow-overlap"), S = a.get("icon-allow-overlap"), I = "map" === a.get("text-rotation-alignment"), C = "map" === a.get("icon-rotation-alignment"), R = "map" === a.get("text-pitch-alignment"), A = l.get("symbol-z-offset"), D = "sea" === a.get("symbol-elevation-reference"), P = a.get("symbol-placement"), [L, z] = a.get("text-size-scale-range"), [M, O] = a.get("icon-size-scale-range"), F = e.ay(s, L, z), B = e.ay(s, M, O), k = a.get("text-variable-anchor"), N = I && "point" !== P, U = C && "point" !== P, j = k && n.hasTextData(), G = n.hasIconTextFit() && j && n.hasIconData();
                this.transform.setProjection(n.projection);
                const V = j || N, q = U || G;
                let H = E && (S || !n.hasIconData() || T), Z = S && (E || !n.hasTextData() || w);
                const W = !A.isConstant();
                !n.collisionArrays && g && n.deserializeCollisionBoxes(g), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, g, F, B);
                const $ = (t1, r, l)=>{
                    const { crossTileID: g, numVerticalGlyphVertices: C } = t1;
                    let P = null;
                    if (u && u.dynamicFilterNeedsFeature || W) {
                        const e = this.retainedQueryData[n.bucketInstanceId];
                        P = b.loadFeature({
                            featureIndex: t1.featureIndex,
                            bucketIndex: e.bucketIndex,
                            sourceLayerIndex: e.sourceLayerIndex,
                            layoutVertexArrayOffset: 0
                        });
                    }
                    if (u && !(0, u.dynamicFilter)({
                        zoom: this.transform.zoom,
                        pitch: this.transform.pitch
                    }, P, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.P(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[g] = new _i(!1, !1, !1, !0), void i.add(g);
                    const L = A.evaluate(P, {});
                    if (i.has(g)) return;
                    if (m) return void (this.placements[g] = new _i(!1, !1, !1));
                    let z = !1, M = !1, O = !0, F = !1, B = !1, N = null, U = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, j = {
                        box: null
                    }, G = null, $ = null, X = null, Y = 0, K = 0, J = 0;
                    l.textFeatureIndex ? Y = l.textFeatureIndex : t1.useRuntimeCollisionCircles && (Y = t1.featureIndex), l.verticalTextFeatureIndex && (K = l.verticalTextFeatureIndex);
                    const Q = (e)=>{
                        e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;
                        const i = this.transform.elevation;
                        e.elevation = D ? L : L + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0), e.elevation += t1.zOffset;
                    }, ee = l.textBox;
                    if (ee) {
                        Q(ee);
                        const i = (i)=>{
                            let o = e.bI.horizontal;
                            if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e = this.prevPlacement.placedOrientations[g];
                                e && (this.placedOrientations[g] = e, o = e, this.markUsedOrientation(n, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (n.allowVerticalPlacement && C > 0 && l.verticalTextBox) {
                                for (const o of n.writingModes)if (o === e.bI.vertical ? (U = i(), j = U) : U = t1(), U && U.box && U.box.length) break;
                            } else U = t1();
                        };
                        if (k) {
                            let s = k;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[g]) {
                                const e = this.prevPlacement.variableOffsets[g];
                                s.indexOf(e.anchor) > 0 && (s = s.filter((t1)=>t1 !== e.anchor), s.unshift(e.anchor));
                            }
                            const a = (e, i, o)=>{
                                const a = n.getSymbolInstanceTextSize(v, t1, this.transform.zoom, r), l = (e.x2 - e.x1) * a + 2 * e.padding, h = (e.y2 - e.y1) * a + 2 * e.padding, d = t1.hasIconTextFit && !S ? i : null;
                                d && Q(d);
                                let u = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const m = E ? 2 * s.length : s.length;
                                for(let i = 0; i < m; ++i){
                                    const m = this.attemptAnchorPlacement(s[i % s.length], e, p, f, V, l, h, a, I, R, _, c, x, i >= s.length, t1, r, n, o, d, v, y);
                                    if (m && (u = m.placedGlyphBoxes, u && u.box && u.box.length)) {
                                        z = !0, N = m.shift;
                                        break;
                                    }
                                }
                                return u;
                            };
                            o(()=>a(ee, l.iconBox, e.bI.horizontal), ()=>{
                                const t1 = l.verticalTextBox;
                                return t1 && Q(t1), n.allowVerticalPlacement && !(U && U.box && U.box.length) && C > 0 && t1 ? a(t1, l.verticalIconBox, e.bI.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), U && (z = U.box, O = U.offscreen, F = U.occluded);
                            const h = i(!(!U || !U.box));
                            if (!z && this.prevPlacement) {
                                const e = this.prevPlacement.variableOffsets[g];
                                e && (this.variableOffsets[g] = e, this.markUsedJustification(n, e.anchor, t1, h));
                            }
                        } else {
                            const a = (i, o)=>{
                                const a = n.getSymbolInstanceTextSize(v, t1, this.transform.zoom, r, s), l = this.collisionIndex.placeCollisionBox(n, a, i, p, f, V, new e.P(0, 0), E, _, c, x.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t1), this.placedOrientations[g] = o), l;
                            };
                            o(()=>a(ee, e.bI.horizontal), ()=>{
                                const t1 = l.verticalTextBox;
                                return n.allowVerticalPlacement && C > 0 && t1 ? (Q(t1), a(t1, e.bI.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(!!(U && U.box && U.box.length));
                        }
                    }
                    if (G = U, z = G && G.box && G.box.length > 0, O = G && G.offscreen, F = G && G.occluded, t1.useRuntimeCollisionCircles) {
                        const i = n.text.placedSymbolArray.get(t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex), r = e.bJ(n.textSizeData, v, i), s = a.get("text-padding");
                        $ = this.collisionIndex.placeCollisionCircles(n, E, i, n.lineVertexArray, n.glyphOffsetArray, r, c, h, d, o, R, x.predicate, t1.collisionCircleDiameter * r / e.bU, s, this.retainedQueryData[n.bucketInstanceId].tileID), z = E || $.circles.length > 0 && !$.collisionDetected, O = O && $.offscreen, F = $.occluded;
                    }
                    if (l.iconFeatureIndex && (J = l.iconFeatureIndex), l.iconBox) {
                        const i = (i)=>{
                            Q(i);
                            const o = t1.hasIconTextFit && N ? vi(N.x, N.y, I, R, this.transform.angle) : new e.P(0, 0), r = n.getSymbolInstanceIconSize(y, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(n, r, i, p, f, q, o, S, _, c, x.predicate);
                        };
                        j && j.box && j.box.length && l.verticalIconBox ? (X = i(l.verticalIconBox), M = X.box.length > 0) : (X = i(l.iconBox), M = X.box.length > 0), O = O && X.offscreen, B = X.occluded;
                    }
                    const te = w || 0 === t1.numHorizontalGlyphVertices && 0 === C, ie = T || 0 === t1.numIconVertices;
                    if (te || ie ? ie ? te || (M = M && z) : z = M && z : M = z = M && z, z && G && G.box && this.collisionIndex.insertCollisionBox(G.box, a.get("text-ignore-placement"), n.bucketInstanceId, j && j.box && K ? K : Y, x.ID), M && X && this.collisionIndex.insertCollisionBox(X.box, a.get("icon-ignore-placement"), n.bucketInstanceId, J, x.ID), $ && (z && this.collisionIndex.insertCollisionCircles($.circles, a.get("text-ignore-placement"), n.bucketInstanceId, Y, x.ID), o)) {
                        const e = n.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e] = new pi);
                        for(let e = 0; e < $.circles.length; e += 4)t1.circles.push($.circles[e + 0]), t1.circles.push($.circles[e + 1]), t1.circles.push($.circles[e + 2]), t1.circles.push($.collisionDetected ? 1 : 0);
                    }
                    const oe = "globe" !== n.projection.name;
                    H = H && (oe || !F), Z = Z && (oe || !B), this.placements[g] = new _i(z || H, M || Z, O || n.justReloaded), i.add(g);
                }, X = this.retainedQueryData[n.bucketInstanceId].tileID;
                if ("offset" === n.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n, X), "road" === n.elevationType && n.updateRoadElevation(X.canonical), n.updateZOffset(), n.sortFeaturesByY) {
                    const t1 = n.getSortedSymbolIndexes(this.transform.angle);
                    for(let e = t1.length - 1; e >= 0; --e){
                        const i = t1[e];
                        $(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                    n.hasAnyZOffset && e.w(`${n.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
                } else if (n.hasAnyZOffset) {
                    const e = n.getSortedIndexesByZOffset();
                    for(let t1 = 0; t1 < e.length; ++t1){
                        const i = e[t1];
                        $(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else for(let e = t1.symbolInstanceStart; e < t1.symbolInstanceEnd; e++)$(n.symbolInstances.get(e), e, n.collisionArrays[e]);
                if (o && n.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[n.bucketInstanceId];
                    e.bi(t1.invProjMatrix, c), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, r) {
                const { leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o, h = e.b$(i), d = r === e.bI.vertical ? l : "left" === h ? s : "center" === h ? n : "right" === h ? a : -1;
                s >= 0 && (t1.text.placedSymbolArray.get(s).crossTileID = d >= 0 && s !== d ? 0 : c), n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = d >= 0 && n !== d ? 0 : c), a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = d >= 0 && a !== d ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = d >= 0 && l !== d ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const r = i === e.bI.horizontal || i === e.bI.horizontalOnly ? i : 0, s = i === e.bI.vertical ? i : 0, { leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o, h = t1.text.placedSymbolArray;
                n >= 0 && (h.get(n).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = s);
            }
            commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e) : 1, r = t1 ? t1.opacities : {}, s = t1 ? t1.variableOffsets : {}, n = t1 ? t1.placedOrientations : {};
                for(const e in this.placements){
                    const t1 = this.placements[e], s = r[e];
                    s ? (this.opacities[e] = new ui(s, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== s.text.placed || t1.icon !== s.icon.placed) : (this.opacities[e] = new ui(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e in r){
                    const t1 = r[e];
                    if (!this.opacities[e]) {
                        const r = new ui(t1, o, !1, !1);
                        r.isHidden() || (this.opacities[e] = r, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e in s)this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = s[e]);
                for(const e in n)this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);
                i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e);
            }
            updateLayerOpacities(e, t1, i, o) {
                const r = new Set;
                for (const s of t1){
                    const t1 = s.getBucket(e);
                    t1 && s.latestFeatureIndex && e.fqid === t1.layerIds[0] && (this.updateBucketOpacities(t1, r, s, s.collisionBoxArray, i, o, s.tileID, e.scope), "offset" === t1.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t1, s.tileID), "road" === t1.elevationType && t1.updateRoadElevation(s.tileID.canonical), t1.updateZOffset());
                }
            }
            updateBucketOpacities(t1, i, o, r, s, n, a, l) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const c = t1.layers[0].layout, h = t1.layers[0].paint, d = !!t1.layers[0].dynamicFilter(), u = new ui(null, 0, !1, !1, !0), _ = c.get("text-allow-overlap"), p = c.get("icon-allow-overlap"), f = c.get("text-variable-anchor"), m = "map" === c.get("text-rotation-alignment"), g = "map" === c.get("text-pitch-alignment"), v = h.get("symbol-z-offset"), y = "sea" === c.get("symbol-elevation-reference"), x = !v.isConstant(), b = new ui(null, 0, _ && (p || !t1.hasIconData() || c.get("icon-optional")), p && (_ || !t1.hasTextData() || c.get("text-optional")), !0);
                !t1.collisionArrays && r && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(r);
                const w = (e, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e.opacityVertexArray.emplaceBack(i);
                };
                let T = 0;
                n && t1.updateReplacement(a, n);
                for(let r = 0; r < t1.symbolInstances.length; r++){
                    const c = t1.symbolInstances.get(r), { numHorizontalGlyphVertices: h, numVerticalGlyphVertices: _, crossTileID: p, numIconVertices: E, tileAnchorX: S, tileAnchorY: I } = c;
                    let C = null;
                    const R = this.retainedQueryData[t1.bucketInstanceId];
                    x && c && R && (C = o.latestFeatureIndex.loadFeature({
                        featureIndex: c.featureIndex,
                        bucketIndex: R.bucketIndex,
                        sourceLayerIndex: R.sourceLayerIndex,
                        layoutVertexArrayOffset: 0
                    }));
                    const A = v.evaluate(C, {}), D = i.has(p);
                    let P = this.opacities[p];
                    D ? P = u : P || (P = b, this.opacities[p] = P), i.add(p);
                    const L = h > 0 || _ > 0, z = E > 0, M = this.placedOrientations[p], O = M === e.bI.vertical, F = M === e.bI.horizontal || M === e.bI.horizontalOnly;
                    !L && !z || P.isHidden() || T++;
                    let B = !1;
                    if ((L || z) && n) for (const i of t1.activeReplacements){
                        if (e.bV(i, s, e.bW.Symbol, l)) continue;
                        if (i.min.x > S || S > i.max.x || i.min.y > I || I > i.max.y) continue;
                        const t1 = e.bX(S, I, a.canonical, i.footprintTileId.canonical);
                        if (B = e.bY(t1, i.footprint), B) break;
                    }
                    if (L) {
                        const e = B ? Ai : Ri(P.text);
                        w(t1.text, h, O ? Ai : e), w(t1.text, _, F ? Ai : e);
                        const i = P.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: r, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: n } = c, a = t1.text.placedSymbolArray, l = i || O ? 1 : 0;
                        o >= 0 && (a.get(o).hidden = l), r >= 0 && (a.get(r).hidden = l), s >= 0 && (a.get(s).hidden = l), n >= 0 && (a.get(n).hidden = i || F ? 1 : 0);
                        const d = this.variableOffsets[p];
                        d && this.markUsedJustification(t1, d.anchor, c, M);
                        const u = this.placedOrientations[p];
                        u && (this.markUsedJustification(t1, "left", c, u), this.markUsedOrientation(t1, u, c));
                    }
                    if (z) {
                        const e = B ? Ai : Ri(P.icon), { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = c, r = t1.icon.placedSymbolArray, s = P.icon.isHidden() ? 1 : 0;
                        i >= 0 && (w(t1.icon, E, O ? Ai : e), r.get(i).hidden = s), o >= 0 && (w(t1.icon, c.numVerticalIconVertices, F ? Ai : e), r.get(o).hidden = s);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[r];
                        if (i) {
                            let o = new e.P(0, 0), r = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (f) {
                                    const e = this.variableOffsets[p];
                                    e ? (o = gi(e.anchor, e.width, e.height, e.textOffset, e.textScale), m && o._rotate(g ? this.transform.angle : -this.transform.angle)) : r = !1;
                                }
                                d && (r = !P.clipped), i.textBox && xi(t1.textCollisionBox.collisionVertexArray, P.text.placed, !r || O, A, y, o.x, o.y), i.verticalTextBox && xi(t1.textCollisionBox.collisionVertexArray, P.text.placed, !r || F, A, y, o.x, o.y);
                            }
                            const s = r && Boolean(!F && i.verticalIconBox);
                            i.iconBox && xi(t1.iconCollisionBox.collisionVertexArray, P.icon.placed, s, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0), i.verticalIconBox && xi(t1.iconCollisionBox.collisionVertexArray, P.icon.placed, !s, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === T, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e.invProjMatrix, t1.placementViewportMatrix = e.viewportMatrix, t1.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }
            hasTransitions(e) {
                return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function xi(e, t1, i, o, r, s, n) {
            e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, s || 0, n || 0, o, r ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, s || 0, n || 0, o, r ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, s || 0, n || 0, o, r ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, s || 0, n || 0, o, r ? 1 : 0);
        }
        const bi = Math.pow(2, 25), wi = Math.pow(2, 24), Ti = Math.pow(2, 17), Ei = Math.pow(2, 16), Si = Math.pow(2, 9), Ii = Math.pow(2, 8), Ci = Math.pow(2, 1);
        function Ri(e) {
            if (0 === e.opacity && !e.placed) return 0;
            if (1 === e.opacity && e.placed) return 4294967295;
            const t1 = e.placed ? 1 : 0, i = Math.floor(127 * e.opacity);
            return i * bi + t1 * wi + i * Ti + t1 * Ei + i * Si + t1 * Ii + i * Ci + t1;
        }
        const Ai = 0;
        class Di {
            constructor(e){
                this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = [];
            }
            continuePlacement(e, t1, i, o, r, s) {
                const n = this._bucketParts;
                for(; this._currentTileIndex < e.length;)if (t1.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles, s), this._currentTileIndex++, r()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t1)=>e.sortKey - t1.sortKey)); this._currentPartIndex < n.length;){
                    const e = n[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart, s), this._currentPartIndex++, r()) return !0;
                }
                return !1;
            }
        }
        class Pi {
            constructor(e, t1, i, o, r, s, n, a, l){
                this.placement = new yi(e, r, s, n, a, l), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o, r, s) {
                const n = e.q.now(), a = ()=>{
                    const t1 = e.q.now() - n;
                    return !this._forceFullPlacement && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const n = i[t1[this._currentPlacementIndex]], l = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === n.type && (!n.minzoom || n.minzoom <= l) && (!n.maxzoom || n.maxzoom > l)) {
                        const t1 = n, i = t1.layout.get("symbol-z-elevate"), l = void 0 !== t1.layout.get("symbol-sort-key").constantOr(1), c = t1.layout.get("symbol-z-order"), h = "viewport-y" === c || "auto" === c && !("viewport-y" !== c && l), d = t1.layout.get("text-allow-overlap") || t1.layout.get("icon-allow-overlap") || t1.layout.get("text-ignore-placement") || t1.layout.get("icon-ignore-placement"), u = h && d, _ = this._inProgressLayer = this._inProgressLayer || new Di(t1), p = e.C(n.source, n.scope);
                        if (_.continuePlacement(i || u ? r[p] : o[p], this.placement, this._showCollisionBoxes, n, a, s)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }
        const Li = 512 / e.aj / 2;
        class zi {
            constructor(t1, i, o){
                this.tileID = t1, this.bucketInstanceId = o, this.index = new e.c0(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                const r = t1.canonical.x * e.aj, s = t1.canonical.y * e.aj;
                for(let e = 0; e < i.length; e++){
                    const { key: t1, crossTileID: o, tileAnchorX: n, tileAnchorY: a } = i.get(e), l = Math.floor((r + n) * Li), c = Math.floor((s + a) * Li);
                    this.index.add(l, c), this.keys.push(t1), this.crossTileIDs.push(o);
                }
                this.index.finish();
            }
            findMatches(t1, i, o) {
                const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z), s = Li / Math.pow(2, i.canonical.z - this.tileID.canonical.z), n = i.canonical.x * e.aj, a = i.canonical.y * e.aj;
                for(let e = 0; e < t1.length; e++){
                    const i = t1.get(e);
                    if (i.crossTileID) continue;
                    const { key: l, tileAnchorX: c, tileAnchorY: h } = i, d = Math.floor((n + c) * s), u = Math.floor((a + h) * s), _ = this.index.range(d - r, u - r, d + r, u + r).sort((e, t1)=>e - t1);
                    for (const e of _){
                        const t1 = this.crossTileIDs[e];
                        if (this.keys[e] === l && !o.has(t1)) {
                            o.add(t1), i.crossTileID = t1;
                            break;
                        }
                    }
                }
            }
        }
        class Mi {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Oi {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - this.lng) / 360);
                if (0 !== t1) for(const e in this.indexes){
                    const i = this.indexes[e], o = {};
                    for(const e in i){
                        const r = i[e];
                        r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t1), o[r.tileID.key] = r;
                    }
                    this.indexes[e] = o;
                }
                this.lng = e;
            }
            addBucket(e, t1, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }
                for(let e = 0; e < t1.symbolInstances.length; e++)t1.symbolInstances.get(e).crossTileID = 0;
                this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set);
                const o = this.usedCrossTileIDs[e.overscaledZ];
                for(const i in this.indexes){
                    const r = this.indexes[i];
                    if (Number(i) > e.overscaledZ) for(const i in r){
                        const s = r[i];
                        s.tileID.isChildOf(e) && s.findMatches(t1.symbolInstances, e, o);
                    }
                    else {
                        const s = r[e.scaledTo(Number(i)).key];
                        s && s.findMatches(t1.symbolInstances, e, o);
                    }
                }
                for(let e = 0; e < t1.symbolInstances.length; e++){
                    const r = t1.symbolInstances.get(e);
                    r.crossTileID || (r.crossTileID = i.generate(), o.add(r.crossTileID));
                }
                return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new zi(e, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e, t1) {
                for (const i of t1.crossTileIDs)this.usedCrossTileIDs[e].delete(i);
            }
            removeStaleBuckets(e) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const r in o)e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t1 = !0);
                }
                return t1;
            }
        }
        class Fi {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Mi, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e, t1, i, o) {
                let r = this.layerIndexes[e.fqid];
                void 0 === r && (r = this.layerIndexes[e.fqid] = new Oi);
                let s = !1;
                const n = {};
                "globe" !== o.name && r.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e);
                    t1 && e.fqid === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t1, this.crossTileIDs) && (s = !0), n[t1.bucketInstanceId] = !0);
                }
                return r.removeStaleBuckets(n) && (s = !0), s;
            }
            pruneUnusedLayers(e) {
                const t1 = {};
                e.forEach((e)=>{
                    t1[e] = !0;
                });
                for(const e in this.layerIndexes)t1[e] || delete this.layerIndexes[e];
            }
        }
        const Bi = 771;
        class ki {
            constructor(e, t1, i, o){
                this.blendFunction = e, this.blendColor = t1.toNonPremultipliedRenderColor(null), this.mask = i, this.blendEquation = o;
            }
        }
        ki.Replace = [
            1,
            0,
            1,
            0
        ], ki.disabled = new ki(ki.Replace, e.am.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), ki.unblended = new ki(ki.Replace, e.am.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), ki.alphaBlended = new ki([
            1,
            Bi,
            1,
            Bi
        ], e.am.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), ki.alphaBlendedNonPremultiplied = new ki([
            770,
            Bi,
            770,
            Bi
        ], e.am.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), ki.multiply = new ki([
            774,
            0,
            774,
            0
        ], e.am.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        class Ni {
            constructor(e, t1, i){
                this.func = e, this.mask = t1, this.range = i;
            }
        }
        Ni.ReadOnly = !1, Ni.ReadWrite = !0, Ni.disabled = new Ni(519, Ni.ReadOnly, [
            0,
            1
        ]);
        const Ui = 7680;
        class ji {
            constructor(e, t1, i, o, r, s){
                this.test = e, this.ref = t1, this.mask = i, this.fail = o, this.depthFail = r, this.pass = s;
            }
        }
        ji.disabled = new ji({
            func: 519,
            mask: 0
        }, 0, 0, Ui, Ui, Ui);
        const Gi = 1029, Vi = 2305;
        class qi {
            constructor(e, t1, i){
                this.enable = e, this.mode = t1, this.frontFace = i;
            }
        }
        function Hi(t1, i) {
            const o = e.c6(t1, 3);
            e.c8(t1, i), e.cc(t1, 3, o);
        }
        function Zi(t1, i) {
            const o = e.c3([]);
            return e.c4(o, o, -i), e.c5(o, o, -t1), o;
        }
        function Wi(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], r = [
                i[0],
                i[1],
                0
            ];
            if (e.ae(o) >= 1e-15) {
                const t1 = e.au([], o);
                e.c1(r, t1, e.bG(r, t1)), i[0] = r[0], i[1] = r[1];
            }
            const s = e.bF([], i, t1);
            if (e.c2(s) < 1e-15) return null;
            const n = Math.atan2(-s[1], s[0]);
            return Zi(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), n);
        }
        qi.disabled = new qi(!1, Gi, Vi), qi.backCCW = new qi(!0, Gi, Vi), qi.backCW = new qi(!0, Gi, 2304), qi.frontCW = new qi(!0, 1028, 2304), qi.frontCCW = new qi(!0, 1028, Vi);
        class $i {
            constructor(e, t1){
                this.position = e, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e.ac ? t1 : new e.ac(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e.bQ(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i) {
                if (this.orientation = null, !this.position) return;
                const o = this.position, r = this._elevation ? this._elevation.getAtPointOrZero(e.ac.fromLngLat(t1)) : 0, s = e.ac.fromLngLat(t1, r), n = [
                    s.x - o.x,
                    s.y - o.y,
                    s.z - o.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = Wi(n, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = Zi(e.al(t1), e.al(-i));
            }
        }
        class Xi {
            constructor(t1, i){
                this._transform = e.bx([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e.ac(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e.c6(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e.cc(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e.c3([]), t1 && Hi(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
                };
            }
            setPitchBearing(e, t1) {
                this._orientation = Zi(e, t1), Hi(this._transform, this._orientation);
            }
            forward() {
                const t1 = e.c6(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e.c6(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e.c6(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e.bi(o, this.getWorldToCamera(t1, i)), o;
            }
            getCameraToWorldMercator() {
                return this._transform;
            }
            getWorldToCameraPosition(t1, i, o) {
                const r = this.position;
                e.c1(r, r, -t1);
                const s = new Float64Array(16);
                return e.bn(s, [
                    o,
                    o,
                    o
                ]), e.bo(s, s, r), s[10] *= i, s;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), r = new Float64Array(4), s = this.position;
                return e.c7(r, this._orientation), e.c1(s, s, -t1), e.c8(o, r), e.bo(o, o, s), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, r) {
                const s = new Float64Array(16);
                return e.c9(s, t1, i, o, r), s;
            }
            getCameraToClipOrthographic(t1, i, o, r, s, n) {
                const a = new Float64Array(16);
                return e.ca(a, t1, i, o, r, s, n), a;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e.cb(t1, i ? e.aY(this.position[1]) : this.position[1]), r = this.forward();
                return (o - this.position[2]) / r[2];
            }
            clone() {
                return new Xi([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        const Yi = {
            BaseColor: 5,
            MetallicRoughness: 6,
            Normal: 7,
            Occlusion: 8,
            Emission: 9,
            LUT: 10,
            ShadowMap0: 11
        };
        class Ki {
            constructor(e = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e) || e < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e.ai(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e.ai(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e.ai(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e.ai(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e.ay((this.left + t1 - this.right) / 2, 0, t1), r = e.ay((this.top + i - this.bottom) / 2, 0, i);
                return new e.P(o, r);
            }
            equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }
            clone() {
                return new Ki(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        const Ji = 15;
        class Qi {
            constructor(t1, i, o, r, s, n, a){
                this.tileSize = 512, this._renderWorldCopies = void 0 === s || s, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = o ?? 0, this._maxPitch = r ?? 60, this.setProjection(n), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.ci(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Ki, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Xi, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1;
            }
            clone() {
                const e = new Qi(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
                return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e._allowWorldUnderZoom = this._allowWorldUnderZoom, e;
            }
            get isOrthographic() {
                return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < Ji;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
                return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e.aF(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(t1) {
                this.projectionOptions = t1 || {
                    name: "mercator"
                };
                const i = this.projection ? this.getProjection() : void 0;
                this.projection = e.cj(this.projectionOptions);
                const o = this.getProjection(), r = !e.bv(i, o);
                return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
            }
            setOrthographicProjectionAtLowPitch(e) {
                return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e.cj({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e) {
                void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get cameraWorldSize() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e.cb(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e.P(this.width, this.height);
            }
            get bearing() {
                return e.bQ(this.rotation, -180, 180);
            }
            set bearing(e) {
                this.rotation = e;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.ck(), e.cl(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e.ay(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e.al(t1), this._calcMatrices());
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e);
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e) {
                const t1 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }
            get tileCoverLift() {
                return this._tileCoverLift;
            }
            set tileCoverLift(e) {
                this._tileCoverLift !== e && (this._tileCoverLift = e);
            }
            _updateCameraOnTerrain() {
                const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t1 = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t1 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const i = this._elevation;
                t1 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                if (void 0 === this._centerAltitudeValidForExaggeration) return;
                const e = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
                this._seaLevelZoom = this._zoomFromMercatorZ(e);
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let r = 0, s = 0;
                for(let n = 0; n < i.length; n++){
                    const a = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)), l = t1.pointCoordinate(a);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    r += l[3] * c, s += c;
                }
                return 0 === s ? NaN : r / s;
            }
            get center() {
                return this._center;
            }
            set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e), r = this._mercatorZfromZoom(this._maxZoom), s = Math.max(o - i, r);
                this._setZoom(this._zoomFromMercatorZ(s));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const r = e.ae(e.at([], this._camera.position, o));
                return e.ay(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e.cm(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e.cn(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new $i;
                return i.position = new e.ac(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e.co(t1)) return !1;
                e.cp(t1, t1);
                const i = e.cq([], [
                    0,
                    0,
                    -1
                ], t1), o = e.cq([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const r = Wi(i, o);
                return !!r && (this._camera.orientation = r, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
                t1[2] = e.ay(t1[2], r / o, r / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }
            interpolatePadding(e, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e) {
                const t1 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e.cr(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e.P(0, 0)), r = this.pointCoordinate(new e.P(this.width, 0)), s = this.pointCoordinate(new e.P(this.width, this.height)), n = this.pointCoordinate(new e.P(0, this.height)), a = Math.floor(Math.min(o.x, r.x, s.x, n.x)), l = Math.floor(Math.max(o.x, r.x, s.x, n.x)), c = 1;
                    for(let o = a - c; o <= l + c; o++)0 !== o && i.push(new e.cr(o, t1));
                }
                return i;
            }
            isLODDisabled(e) {
                return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCover(t1, i, o) {
                let r = [];
                const s = null != o, n = !s;
                if (n && this.zoom < i) return r;
                if (s && 0 === o[0] && 0 === o[1]) return r;
                const a = new Set, l = (t1, i, o, s, n)=>{
                    const l = e.cV(i, t1, o, s, n);
                    a.has(l) || (r.push(new e.aM(t1, i, o, s, n)), a.add(l));
                };
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    if (n && r.canonical.z !== i) continue;
                    const a = r.canonical, c = r.overscaledZ, h = r.wrap, d = 1 << a.z, u = a.x + 1 < d, _ = a.x > 0, p = a.y + 1 < d, f = a.y > 0, m = r.wrap - (_ ? 0 : 1), g = r.wrap + (u ? 0 : 1), v = _ ? a.x - 1 : d - 1, y = u ? a.x + 1 : 0;
                    if (s) o[0] < 0 ? (l(c, g, a.z, y, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))) : o[0] > 0 ? (l(c, m, a.z, v, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))) : o[1] < 0 && p ? l(c, h, a.z, a.x, a.y + 1) : f && l(c, h, a.z, a.x, a.y - 1);
                    else {
                        const e = r.visibleQuadrants;
                        1 & e && (l(c, m, a.z, v, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))), 2 & e && (l(c, g, a.z, y, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))), 4 & e && (l(c, m, a.z, v, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1))), 8 & e && (l(c, g, a.z, y, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)));
                    }
                }
                const c = [];
                for (const e of r)r.some((t1)=>e.isChildOf(t1)) || c.push(e);
                if (r = c.filter((e)=>!t1.some((t1)=>!!(e.overscaledZ < i && t1.isChildOf(e)) || e.equals(t1) || e.isChildOf(t1))), n) {
                    const e = 1 << i, t1 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o = [
                        e * t1.x,
                        e * t1.y
                    ], s = 4, n = s * s;
                    r = r.filter((e)=>{
                        const t1 = e.canonical.x + .5 - o[0], i = e.canonical.y + .5 - o[1];
                        return t1 * t1 + i * i < n;
                    });
                }
                return r;
            }
            extendTileCoverToNearPlane(t1, i, o) {
                const r = [], s = new Set;
                for (const e of t1)s.add(e.key);
                const n = (t1, i, o, n, a)=>{
                    const l = e.cV(i, t1, o, n, a);
                    s.has(l) || (r.push(new e.aM(t1, i, o, n, a)), s.add(l));
                }, a = t1.reduce((e, t1)=>Math.max(e, t1.overscaledZ), o), l = 1 << o, c = [
                    new e.P(0, 0),
                    new e.P(e.aj, 0),
                    new e.P(e.aj, e.aj),
                    new e.P(0, e.aj)
                ], h = new e.P(0, 0), d = new e.P(0, 0), u = (t1, i)=>{
                    const r = Math.floor(t1[0]), s = Math.floor(t1[1]), u = (t1[0] - r) * e.aj, _ = (t1[1] - s) * e.aj, p = Math.floor(i[0]), f = Math.floor(i[1]), m = (i[0] - p) * e.aj, g = (i[1] - f) * e.aj;
                    for(let t1 = -1; t1 <= 1; t1++){
                        const i = r + t1;
                        if (!(i < 0 || i >= l)) {
                            h.x = u - t1 * e.aj, d.x = m - (i - p) * e.aj;
                            for(let t1 = -1; t1 <= 1; t1++){
                                const r = s + t1;
                                h.y = _ - t1 * e.aj, d.y = g - (r - f) * e.aj, e.cW(h, d, c) && n(a, 0, o, i, r);
                            }
                        }
                    }
                }, _ = i.points, p = _[e.cs], f = _[e.ct], m = this._projectToGround(p, _[e.cu]), g = this._projectToGround(f, _[e.cv]);
                return u(p, m), u(f, g), r;
            }
            _projectToGround(t1, i) {
                return e.cw(e.cx(), t1, i, t1[2] / (t1[2] - i[2]));
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, r = this.elevation && this.elevation.exaggeration(), s = r && !t1.isTerrainDEM, n = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const a = this.locationCoordinate(this.center), l = this.center.lat, c = 1 << i, h = [
                    c * a.x,
                    c * a.y,
                    0
                ], d = "globe" === this.projection.name, u = !d, _ = e.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u), p = d ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f = c * e.cb(1, this.center.lat), m = this._camera.position[2] / e.cb(1, this.center.lat), g = [
                    c * p.x,
                    c * p.y,
                    m * (u ? 1 : f)
                ], v = d || r, y = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), x = this.isLODDisabled(!0) ? i : 0;
                let b;
                if (this._elevation && t1.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();
                else if (this._elevation) {
                    const e = this._elevation.getMinMaxForVisibleTiles();
                    b = e ? e.max : this._centerAltitude;
                } else b = this._centerAltitude;
                const w = t1.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T = this.projection.isReprojectedInTileSpace ? e.cz(this) : 1, E = (t1)=>{
                    const i = 1 / 4e4, o = new e.ac(t1.x + i, t1.y, t1.z), r = new e.ac(t1.x, t1.y + i, t1.z), s = t1.toLngLat(), n = o.toLngLat(), a = r.toLngLat(), l = this.locationCoordinate(s), c = this.locationCoordinate(n), h = this.locationCoordinate(a), d = Math.hypot(c.x - l.x, c.y - l.y), u = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(d * u) * T / i;
                }, S = (t1)=>{
                    const i = b, o = w;
                    return {
                        aabb: e.cC(this, c, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, I = [];
                let C = [];
                const R = i, A = t1.reparseOverscaled ? o : i, D = (m - this._centerAltitude) * f, P = (e)=>{
                    if (!this._elevation || !e.tileID || !n) return;
                    const t1 = this._elevation.getMinMaxForTile(e.tileID), i = e.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = z(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, L = (e, t1)=>{
                    if (.707 * t1 < e) return 1;
                    const i = t1 / e;
                    return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                }, z = (t1)=>{
                    if (t1.zoom < x) return !0;
                    if (t1.zoom === R) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(g), r = t1.aabb.distanceY(g);
                    let a = D, c = 1;
                    if (d) {
                        a = t1.aabb.distanceZ(g);
                        const i = Math.pow(2, t1.zoom), o = e.aY((t1.y + 1) / i), r = e.aY(t1.y / i), s = Math.min(Math.max(l, o), r), n = e.c_(s) / e.c_(l);
                        if (c = s === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n / this._mercatorScaleRatio), this.zoom <= e.cX && t1.zoom === R - 1 && n >= .9) return !0;
                    } else if (s && (a = t1.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = E(new e.ac((t1.x + .5) / i, (t1.y + .5) / i));
                        c = o > .85 ? 1 : o;
                    }
                    if (!n) {
                        const e = Math.sqrt(i * i + r * r + a * a);
                        let o = (1 << R - t1.zoom) * y * c;
                        return o *= L(Math.max(a, D), e), e < o;
                    }
                    let u = Number.MAX_VALUE, _ = 0;
                    const p = t1.aabb.getCorners(), m = [];
                    for (const t1 of p){
                        e.at(m, t1, g), d || (s ? m[2] *= f : m[2] = D);
                        const i = e.bG(m, this._camera.forward());
                        i < u && (u = i, _ = Math.abs(m[2]));
                    }
                    let v = (1 << R - t1.zoom) * y * c;
                    if (v *= L(Math.max(_, D), u), u < v) return !0;
                    const b = t1.aabb.closestPoint(h);
                    return b[0] === h[0] && b[1] === h[1];
                };
                if (this.renderWorldCopies) for(let e = 1; e <= 3; e++)I.push(S(-e)), I.push(S(e));
                for(I.push(S(0)); I.length > 0;){
                    const o = I.pop(), r = o.x, a = o.y;
                    let l = o.fullyVisible;
                    const u = ()=>"globe" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);
                    if (!l) {
                        let t1 = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);
                        if (0 === t1 && u()) {
                            const i = new e.cA(o.zoom, r, a);
                            t1 = e.cB(this, c, i, !0).intersects(_);
                        }
                        if (0 === t1) continue;
                        l = 2 === t1;
                    }
                    if (o.zoom !== R && z(o)) for(let t1 = 0; t1 < 4; t1++){
                        const i = (r << 1) + t1 % 2, h = (a << 1) + (t1 >> 1), u = {
                            aabb: n ? o.aabb.quadrant(t1) : e.cC(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: h,
                            wrap: o.wrap,
                            fullyVisible: l,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        s && !d && (u.tileID = new e.aM(o.zoom + 1 === R ? A : o.zoom + 1, o.wrap, o.zoom + 1, i, h), P(u)), I.push(u);
                    }
                    else {
                        const s = o.zoom === R ? A : o.zoom;
                        if (t1.minzoom && t1.minzoom > s) continue;
                        let n = 0;
                        if (!l) {
                            let i = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);
                            if (0 === i && u()) {
                                const t1 = new e.cA(o.zoom, r, a);
                                i = e.cB(this, c, t1, !0).intersectsPrecise(_);
                            }
                            if (0 === i) continue;
                            if (t1.calculateQuadrantVisibility) if (_.containsPoint(o.aabb.center)) n = 15;
                            else for(let e = 0; e < 4; e++)0 !== o.aabb.quadrant(e).intersects(_) && (n |= 1 << e);
                        }
                        const d = h[0] - (.5 + r + (o.wrap << o.zoom)) * (1 << i - o.zoom), p = h[1] - .5 - a, f = o.tileID ? o.tileID : new e.aM(s, o.wrap, o.zoom, r, a);
                        t1.calculateQuadrantVisibility && (f.visibleQuadrants = n), C.push({
                            tileID: f,
                            distanceSq: d * d + p * p
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    C = C.filter((r)=>{
                        const s = [
                            0,
                            0,
                            0,
                            1
                        ], n = [
                            e.aj,
                            e.aj,
                            0,
                            1
                        ], a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                        e.aA(s, s, a), e.aA(n, n, a);
                        const l = e.cD([], s, n), c = e.cE([], s, n), h = e.cY(l, c);
                        if (0 === h) return !0;
                        let d = !1;
                        const u = this._elevation;
                        if (u && h > i && 0 !== o) {
                            const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
                            let s;
                            t1.isTerrainDEM || (s = u.getMinMaxForTile(r.tileID)), s || (s = {
                                min: w,
                                max: b
                            });
                            const n = e.cF(this.rotation), a = [
                                n[0] * e.aj,
                                n[1] * e.aj,
                                s.max
                            ];
                            e.ad(a, a, i), d = (1 - a[1]) * this.height * .5 < o;
                        }
                        return h < i || d;
                    });
                }
                return C.sort((e, t1)=>e.distanceSq - t1.distanceSq).map((e)=>e.tileID);
            }
            resize(e, t1) {
                this.width = e, this.height = t1, this.pixelsToGLUnits = [
                    2 / e,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e) {
                return Math.pow(2, e);
            }
            scaleZoom(e) {
                return Math.log(e) / Math.LN2;
            }
            project(t1) {
                const i = e.ay(t1.lat, -e.cG, e.cG), o = this.projection.project(t1.lng, i);
                return new e.P(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e.cb(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, r;
                const s = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e = this.worldSize;
                    o = (i.x - s.x) / e, r = (i.y - s.y) / e;
                } else {
                    const e = this.pointCoordinate(i), t1 = this.pointCoordinate(s);
                    o = e.x - t1.x, r = e.y - t1.y;
                }
                const n = this.locationCoordinate(t1);
                this.setLocation(new e.ac(n.x - o, n.y - r));
            }
            setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e, t1) {
                return this.projection.locationPoint(this, e, t1);
            }
            locationPoint3D(e, t1) {
                return this.projection.locationPoint(this, e, t1, !0);
            }
            pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }
            pointLocation3D(e, t1) {
                return this.coordinateLocation(this.pointCoordinate3D(e, t1));
            }
            locationCoordinate(t1, i) {
                const o = i ? e.cb(i, t1.lat) : void 0, r = this.projection.project(t1.lng, t1.lat);
                return new e.ac(r.x, r.y, o);
            }
            coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, r = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], s = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aA(r, r, this.pixelMatrixInverse), e.aA(s, s, this.pixelMatrixInverse);
                const n = s[3];
                e.cH(r, r, 1 / r[3]), e.cH(s, s, 1 / n);
                const a = r[2], l = s[2];
                return {
                    p0: r,
                    p1: s,
                    t: a === l ? 0 : (o - a) / (l - a)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e.aA(i, i, this.pixelMatrixInverse), e.aA(o, o, this.pixelMatrixInverse), e.cH(i, i, 1 / i[3]), e.cH(o, o, 1 / o[3]), i[2] = e.cb(i[2], this._center.lat) * this.worldSize, o[2] = e.cb(o[2], this._center.lat) * this.worldSize, e.cH(i, i, 1 / this.worldSize), e.cH(o, o, 1 / this.worldSize), new e.av([
                    i[0],
                    i[1],
                    i[2]
                ], e.au([], e.at([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i, p1: o, t: r } = t1, s = e.cb(i[2], this._center.lat), n = e.cb(o[2], this._center.lat);
                return new e.ac(e.ai(i[0], o[0], r) / this.worldSize, e.ai(i[1], o[1], r) / this.worldSize, e.ai(s, n, r));
            }
            pointCoordinate(e, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t1);
            }
            pointCoordinate3D(t1, i) {
                if (!this.elevation) return this.pointCoordinate(t1, i);
                let o = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (o) return new e.ac(o[0], o[1], o[2]);
                let r = 0, s = this.horizonLineFromTop();
                if (t1.y > s) return this.pointCoordinate(t1, i);
                const n = .02 * s, a = t1.clone();
                for(let t1 = 0; t1 < 10 && s - r > n; t1++){
                    a.y = e.ai(r, s, .66);
                    const t1 = this.projection.pointCoordinate3D(this, a.x, a.y);
                    t1 ? (s = a.y, o = t1) : r = a.y;
                }
                return o ? new e.ac(o[0], o[1], o[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }
            isPointOnSurface(t1) {
                if (t1.y < 0 || t1.y > this.height || t1.x < 0 || t1.x > this.width) return !1;
                if (this.elevation || this.zoom >= e.cI) return !this.isPointAboveHorizon(t1);
                const i = this.pointCoordinate(t1);
                return i.y >= 0 && i.y <= 1;
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, r = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e.aA(r, r, this.pixelMatrix), r[3] > 0 ? new e.P(r[0] / r[3], r[1] / r[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, r = this.width - this._edgeInsets.right, s = this.pointLocation3D(new e.P(i, t1)), n = this.pointLocation3D(new e.P(r, t1)), a = this.pointLocation3D(new e.P(r, o)), l = this.pointLocation3D(new e.P(i, o));
                let c = Math.min(s.lng, n.lng, a.lng, l.lng), h = Math.max(s.lng, n.lng, a.lng, l.lng), d = Math.min(s.lat, n.lat, a.lat, l.lat), u = Math.max(s.lat, n.lat, a.lat, l.lat);
                const _ = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, f = (t1, i, o, r, s)=>{
                    const n = (t1 + o) / 2, a = (i + r) / 2, l = new e.P(n, a), { lng: m, lat: g } = this.pointLocation3D(l), v = Math.max(0, c - m, d - g, m - h, g - u);
                    c = Math.min(c, m), h = Math.max(h, m), d = Math.min(d, g), u = Math.max(u, g), (s < p || v > _) && (f(t1, i, n, a, s + 1), f(n, a, o, r, s + 1));
                };
                if (f(i, t1, r, t1, 1), f(r, t1, r, o, 1), f(r, o, i, o, 1), f(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e.cJ(this);
                    t1 ? (u = 90, h = 180, c = -180) : i && (d = -90, h = 180, c = -180);
                }
                return new e.aG(new e.ci(c, d), new e.ci(h, u));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o, left: r } = this._edgeInsets, s = this.height - this._edgeInsets.bottom, n = this.width - this._edgeInsets.right, a = new e.P(r, o), l = new e.P(n, o), c = new e.P(n, s), h = new e.P(r, s);
                let d = this.pointCoordinate(a, t1), u = this.pointCoordinate(l, t1);
                const _ = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), f = (e, t1)=>(t1.y - e.y) / (t1.x - e.x);
                return d.y > 1 && u.y >= 0 ? d = new e.ac((1 - p.y) / f(p, d) + p.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.ac(-p.y / f(p, d) + p.x, 0)), u.y > 1 && d.y >= 0 ? u = new e.ac((1 - _.y) / f(_, u) + _.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.ac(-_.y / f(_, u) + _.x, 0)), (new e.aG).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));
            }
            _getBoundsRectangularTerrain() {
                const e = this.elevation;
                if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e.visibleDemTiles.reduce((e, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
                    }
                    return e;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e.exaggeration(), t1.max * e.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e.cG, this.maxLat = e.cG, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aD(this.minLng) * this.tileSize, this.worldMaxX = e.aD(this.maxLng) * this.tileSize, this.worldMinY = e.aH(this.maxLat) * this.tileSize, this.worldMaxY = e.aH(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e, t1) {
                return this.projection.createTileMatrix(this, t1, e);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const r = t1.canonical, s = 1 / this.height, n = this.cameraWorldSize, a = n / this.zoomScale(r.z), l = (r.x + Math.pow(2, r.z) * t1.wrap) * a, c = r.y * a, h = this.point;
                h.x *= n / this.worldSize, h.y *= n / this.worldSize;
                const d = this.angle, u = Math.sin(-d), _ = -Math.cos(-d);
                return o[i] = {
                    bearing: [
                        u,
                        _
                    ],
                    center: [
                        (h.x - l) * s,
                        (h.y - c) * s
                    ],
                    scale: a / e.aj * s
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e.az(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
            }
            calculateProjMatrix(t1, i = !1, o = !1) {
                const r = t1.key;
                let s;
                if (s = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, s[r]) return s[r];
                const n = this.calculatePosMatrix(t1, this.worldSize);
                let a;
                return a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.az(n, a, n), s[r] = new Float32Array(n), s[r];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const r = e.cK(t1, this);
                return o[i] = r, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e.bn([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e.az(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e.cb(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), r = this._camera.forward(), s = e.cb(1, this._center.lat);
                o[2] /= s, r[2] /= s, e.au(r, r);
                const n = t1.raycast(o, r, t1.exaggeration());
                if (n) {
                    const t1 = e.bE([], o, r, n), i = new e.ac(t1[0], t1[1], e.cb(t1[2], e.aY(t1[1]))), a = (i.z + e.ae([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * s
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e.cb(1, this._center.lat) * this.worldSize, r = this._computeCameraPosition(o), s = i.getAtPointOrZero(new e.ac(...r)), n = this.pixelsPerMeter / this.worldSize * s, a = this._minimumHeightOverTerrain(), l = r[2] - n;
                if (l <= a) if (l < 0 || t1) {
                    const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                        r[0],
                        r[1],
                        t1.z - r[2]
                    ], o = e.ae(i);
                    i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                    const s = e.ae(i);
                    if (0 === s) return;
                    e.c1(i, i, o / s * this._pixelsPerMercatorPixel), this._camera.position = [
                        r[0],
                        r[1],
                        t1.z * this._pixelsPerMercatorPixel - i[2]
                    ], this._updateStateFromCamera();
                } else this._isCameraConstrained = !0;
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e.ay(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e.ay(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o, y: r } = this.point;
                let s = 0, n = o, a = r;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, d = this.worldMaxY * this.scale;
                if (r - c < h && (a = h + c), r + c > d && (a = d - c), d - h < this.height && (s = Math.max(s, this.height / (d - h)), a = (d + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e + t1) / 2;
                    n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t1 && (n = t1 - l), t1 - e < this.width && (s = Math.max(s, this.width / (t1 - e)), n = (t1 + e) / 2);
                }
                n === o && a === r || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n, a))), s && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(s)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = "globe" === this.projection.name, o = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e.cb(1, this.center.lat) / e.cb(1, e.c$));
                const r = e.cL(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const s = "meters" === this.projection.zAxisUnit ? o : 1, n = this._camera.getWorldToCamera(this.worldSize, s);
                let a;
                const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                if (l[8] = 2 * -t1.x / this.width, l[9] = 2 * t1.y / this.height, this.isOrthographic) {
                    let i = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), o = i * this.aspect, r = -o, s = -i;
                    o -= t1.x, r -= t1.x, i += t1.y, s += t1.y, a = this._camera.getCameraToClipOrthographic(r, o, s, i, this._nearZ, this._farZ), ((t1, i, o, r)=>{
                        for(let s = 0; s < 16; s++)t1[s] = e.ai(i[s], o[s], r);
                    })(a, a, l, e.cZ(this.pitch >= Ji ? 1 : this.pitch / Ji));
                } else a = l;
                const c = e.cM([], l, n);
                let h = e.cM([], a, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e.bx([]);
                    e.bo(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e.az(i, i, e.cN(this)), e.bo(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e.az(h, h, i), e.az(c, c, i), this.inverseAdjustmentMatrix = e.cO(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                if (this.mercatorMatrix = e.cP([], h, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / s,
                    1
                ]), this.projMatrix = h, this.invProjMatrix = e.bi(new Float64Array(16), this.projMatrix), i) {
                    const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                    i[8] = 2 * -t1.x / this.width, i[9] = 2 * t1.y / this.height, this.expandedFarZProjMatrix = e.cM([], i, n);
                } else this.expandedFarZProjMatrix = this.projMatrix;
                const d = e.bi([], a);
                this.frustumCorners = e.cQ.fromInvProjectionMatrix(d, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);
                const u = new Float32Array(16);
                e.bx(u), e.cP(u, u, [
                    1,
                    -1,
                    1
                ]), e.cR(u, u, this._pitch), e.by(u, u, this.angle);
                const _ = e.c9(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                this.starsProjMatrix = e.bw(_);
                const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                _[8] = 2 * -t1.x / this.width, _[9] = 2 * (t1.y + p) / this.height, this.skyboxMatrix = e.az(u, _, u);
                const f = this.point, m = f.x, g = f.y, v = this.width % 2 / 2, y = this.height % 2 / 2, x = Math.cos(this.angle), b = Math.sin(this.angle), w = m - Math.round(m) + x * v + b * y, T = g - Math.round(g) + x * y + b * v, E = new Float64Array(h);
                if (e.bo(E, E, [
                    w > .5 ? w - 1 : w,
                    T > .5 ? T - 1 : T,
                    0
                ]), this.alignedProjMatrix = E, h = e.bz(), e.cP(h, h, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e.bo(h, h, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = h, h = e.bz(), e.cP(h, h, [
                    1,
                    -1,
                    1
                ]), e.bo(h, h, [
                    -1,
                    -1,
                    0
                ]), e.cP(h, h, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = h, this.pixelMatrix = e.az(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.bi(new Float64Array(16), this.pixelMatrix), !h) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = h, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e.cS(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e.ad(t1, t1, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = h;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, r = 1 / this.height / this._pixelsPerMercatorPixel, s = [
                    t1,
                    t1,
                    i
                ];
                e.c1(s, s, r), e.c1(o, o, -1), e.cT(o, o, s);
                const n = e.bz();
                e.bo(n, n, o), e.cP(n, n, s), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, r);
            }
            _computeCameraPosition(e) {
                const t1 = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * r,
                    o.y / this.worldSize - i[1] * r,
                    e / this.worldSize * this._centerAltitude - i[2] * r
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], r = t1[2];
                let s = 1;
                this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (s = Math.min((i - o) / r, 1)), this._camera.position = e.bE([], this._camera.position, t1, s), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o, bearing: r } = this._camera.getPitchBearing(), s = e.cb(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.al(this._maxPitch)), a = Math.max((t1[2] - s) / Math.cos(o), n), l = this._zoomFromMercatorZ(a);
                e.bE(t1, t1, i, a), this._pitch = e.ay(o, e.al(this.minPitch), e.al(this.maxPitch)), this.angle = e.bQ(r, -Math.PI, Math.PI), this._setZoom(e.ay(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ac(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }
            _mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }
            _minimumHeightOverTerrain() {
                const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                return this._mercatorZfromZoom(e);
            }
            _zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, e) * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e.cI, r = 0, s = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e = i + .5 * (o - i), n = this.tileSize * Math.pow(2, e), a = this.getCameraToCenterDistance(this.projection, e, n), l = this.scaleZoom(a / (Math.max(0, t1) * this.tileSize)), c = Math.abs(e - l);
                    c < s && (s = c, r = e), e < l ? i = e : o = e;
                }
                return r;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), r = Math.max(t1.x, i.x), s = Math.min(t1.y, i.y), n = Math.max(t1.y, i.y);
                if (s < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const a = [
                    new e.P(o, s),
                    new e.P(r, n),
                    new e.P(o, n),
                    new e.P(r, s)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e of a){
                    const t1 = this.pointRayIntersection(e);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e.cU(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e.ae(e.at([], this._camera.position, t1)), r = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(r);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], r) {
                        const s = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e.aA(s, s, r);
                        const n = s[3] = Math.max(s[3], 1e-6);
                        return s[0] /= n, s[1] /= n, s[2] /= n, s;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e.P(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e.P(0, t1));
                }
            }
            getCameraToCenterDistance(t1, i = this.zoom, o = this.worldSize) {
                const r = e.cL(t1, i, this.width, this.height, 1024), s = t1.pixelSpaceConversion(this.center.lat, o, r);
                let n = .5 / Math.tan(.5 * this._fov) * this.height * s;
                return this.isOrthographic && (n = e.ai(1, n, e.cZ(this.pitch >= Ji ? 1 : this.pitch / Ji))), n;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e.az(t1, t1, this.globeMatrix), t1;
            }
            getFrustum(t1) {
                return e.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t1, "meters" === this.projection.zAxisUnit);
            }
        }
        const eo = (t1, i)=>{
            if (i > 0 && t1.terrain && e.w("Cutoff is currently disabled on terrain"), i <= 0 || t1.terrain) return {
                shouldRenderCutoff: !1,
                uniformValues: {
                    u_cutoff_params: [
                        0,
                        0,
                        0,
                        1
                    ]
                }
            };
            const o = t1.transform, r = Math.max(Math.abs(o._zoom - (t1.minCutoffZoom - 1)), 1), s = o.isLODDisabled(!1) ? e.af(60, 45, o.pitch) : e.af(30, 15, o.pitch), n = o._farZ - o._nearZ, a = i * o.height, l = ((1 - (c = s)) * o.cameraToCenterDistance + c * (o._farZ + a)) * r;
            var c;
            return {
                shouldRenderCutoff: s < 1,
                uniformValues: {
                    u_cutoff_params: [
                        o._nearZ,
                        o._farZ,
                        (l - o._nearZ) / n,
                        (l - a - o._nearZ) / n
                    ]
                }
            };
        }, to = {
            cascadeCount: 2,
            normalOffset: 3,
            shadowMapResolution: 2048
        };
        class io {
            constructor(e, t1){
                this.aabb = e, this.lastCascade = t1;
            }
        }
        class oo {
            add(e, t1) {
                const i = this.receivers[e.key];
                void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t1.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t1.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t1.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t1.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t1.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t1.max[2])) : this.receivers[e.key] = new io(t1, null);
            }
            clear() {
                this.receivers = {};
            }
            get(e) {
                return this.receivers[e.key];
            }
            computeRequiredCascades(t1, i, o) {
                const r = e.d6.fromPoints(t1.points);
                let s = 0;
                for(const t1 in this.receivers){
                    const n = this.receivers[t1];
                    if (!n) continue;
                    if (!r.intersectsAabb(n.aabb)) continue;
                    n.aabb.min = r.closestPoint(n.aabb.min), n.aabb.max = r.closestPoint(n.aabb.max);
                    const a = n.aabb.getCorners();
                    for(let t1 = 0; t1 < o.length; t1++){
                        let r = !0;
                        for (const s of a){
                            const n = [
                                s[0] * i,
                                s[1] * i,
                                s[2]
                            ];
                            if (e.ad(n, n, o[t1].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {
                                r = !1;
                                break;
                            }
                        }
                        if (n.lastCascade = t1, s = Math.max(s, t1), r) break;
                    }
                }
                return s + 1;
            }
        }
        class ro {
            constructor(e){
                this.painter = e, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new oo, this._depthMode = new Ni(e.context.gl.LEQUAL, Ni.ReadWrite, [
                    0,
                    1
                ]), this._uniformValues = {
                    u_light_matrix_0: new Float32Array(16),
                    u_light_matrix_1: new Float32Array(16),
                    u_shadow_intensity: 0,
                    u_fade_range: [
                        0,
                        0
                    ],
                    u_shadow_normal_offset: [
                        1,
                        1,
                        1
                    ],
                    u_shadow_texel_size: 1,
                    u_shadow_map_resolution: 1,
                    u_shadow_direction: [
                        0,
                        0,
                        1
                    ],
                    u_shadow_bias: [
                        36e-5,
                        .0012,
                        .012
                    ],
                    u_shadowmap_0: 0,
                    u_shadowmap_1: 0
                }, this._forceDisable = !1, this.useNormalOffset = !1, e.tp.registerParameter(this, [
                    "Shadows"
                ], "_forceDisable", {
                    label: "forceDisable"
                }, ()=>{
                    this.painter.style.map.triggerRepaint();
                }), e.tp.registerParameter(to, [
                    "Shadows"
                ], "cascadeCount", {
                    min: 1,
                    max: 2,
                    step: 1
                }), e.tp.registerParameter(to, [
                    "Shadows"
                ], "normalOffset", {
                    min: 0,
                    max: 10,
                    step: .05
                }), e.tp.registerParameter(to, [
                    "Shadows"
                ], "shadowMapResolution", {
                    min: 32,
                    max: 2048,
                    step: 32
                }), e.tp.registerBinding(this, [
                    "Shadows"
                ], "_numCascadesToRender", {
                    readonly: !0,
                    label: "numCascadesToRender"
                });
            }
            destroy() {
                for (const e of this._cascades)e.texture.destroy(), e.framebuffer.destroy();
                this._cascades = [];
            }
            updateShadowParameters(t1, i) {
                const o = this.painter;
                if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;
                const r = i.properties.get("shadow-intensity");
                if (!i.shadowsEnabled() || r <= 0) return;
                if (this._shadowLayerCount = o.style.order.reduce((e, i)=>{
                    const r = o.style._mergedLayers[i];
                    return e + (r.hasShadowPass() && !r.isHidden(t1.zoom) ? 1 : 0);
                }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
                const s = o.context, n = to.shadowMapResolution, a = to.shadowMapResolution;
                if (0 === this._cascades.length || to.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                    this._cascades = [];
                    for(let t1 = 0; t1 < to.cascadeCount; ++t1){
                        const t1 = o._shadowMapDebug, i = s.gl, r = s.createFramebuffer(n, a, t1, "texture"), l = new e.T(s, {
                            width: n,
                            height: a,
                            data: null
                        }, i.DEPTH_COMPONENT16);
                        if (r.depthAttachment.set(l.texture), t1) {
                            const t1 = new e.T(s, {
                                width: n,
                                height: a,
                                data: null
                            }, i.RGBA8);
                            r.colorAttachment.set(t1.texture);
                        }
                        this._cascades.push({
                            framebuffer: r,
                            texture: l,
                            matrix: [],
                            far: 0,
                            boundingSphereRadius: 0,
                            frustum: new e.cy,
                            scale: 0
                        });
                    }
                }
                this.shadowDirection = no(i);
                let l = 0;
                if (t1.elevation) {
                    const e = t1.elevation, i = [
                        1e4,
                        -1e4
                    ];
                    e.visibleDemTiles.filter((e)=>e.dem).forEach((e)=>{
                        const t1 = e.dem.tree;
                        i[0] = Math.min(i[0], t1.minimums[0]), i[1] = Math.max(i[1], t1.maximums[0]);
                    }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());
                }
                const c = 1.5 * t1.cameraToCenterDistance, h = 3 * c, d = new Float64Array(16);
                for(let i = 0; i < this._cascades.length; ++i){
                    const o = this._cascades[i];
                    let r = t1.height / 50, s = 1;
                    1 === to.cascadeCount ? s = h : 0 === i ? s = c : (r = c, s = h);
                    const [n, a] = lo(t1, this.shadowDirection, r, s, to.shadowMapResolution, l);
                    o.scale = t1.scale, o.matrix = n, o.boundingSphereRadius = a, e.bi(d, o.matrix), o.frustum = e.cy.fromInvProjectionMatrix(d, 1, 0, !0), o.far = s;
                }
                const u = this._cascades.length - 1;
                this._uniformValues.u_fade_range = [
                    .75 * this._cascades[u].far,
                    this._cascades[u].far
                ], this._uniformValues.u_shadow_intensity = r, this._uniformValues.u_shadow_direction = [
                    this.shadowDirection[0],
                    this.shadowDirection[1],
                    this.shadowDirection[2]
                ], this._uniformValues.u_shadow_texel_size = 1 / to.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = to.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Yi.ShadowMap0, this._uniformValues.u_shadowmap_1 = Yi.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({
                    tileSize: 512,
                    renderWorldCopies: !0
                });
                const _ = o.transform.elevation;
                for (const e of this._groundShadowTiles){
                    let t1 = {
                        min: 0,
                        max: 0
                    };
                    if (_) {
                        const i = _.getMinMaxForTile(e);
                        i && (t1 = i);
                    }
                    this.addShadowReceiver(e.toUnwrapped(), t1.min, t1.max);
                }
            }
            get enabled() {
                return this._enabled && !this._forceDisable;
            }
            set enabled(e) {
                this._enabled = e;
            }
            drawShadowPass(t1, i) {
                if (!this.enabled) return;
                const o = this.painter, r = o.context;
                this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), r.viewport.set([
                    0,
                    0,
                    to.shadowMapResolution,
                    to.shadowMapResolution
                ]);
                for(let s = 0; s < this._numCascadesToRender; ++s){
                    o.currentShadowCascade = s, r.bindFramebuffer.set(this._cascades[s].framebuffer.framebuffer), r.clear({
                        color: e.am.white,
                        depth: 1
                    });
                    for (const e of t1.order){
                        const r = t1._mergedLayers[e];
                        if (!r.hasShadowPass() || r.isHidden(o.transform.zoom)) continue;
                        const s = t1.getLayerSourceCache(r), n = s ? i[s.id] : void 0;
                        ("model" === r.type || n && n.length) && o.renderLayer(o, s, r, n);
                    }
                }
                o.currentShadowCascade = 0;
            }
            drawGroundShadows() {
                if (!this.enabled) return;
                const e = this.painter, t1 = e.style, i = e.context, o = i.gl, r = t1.directionalLight, s = t1.ambientLight;
                if (!r || !s) return;
                const n = [], a = eo(e, e.longestCutoffRange);
                a.shouldRenderCutoff && n.push("RENDER_CUTOFF"), n.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && n.push("NORMAL_OFFSET");
                const l = ao(t1, r, s), c = new Ni(o.LEQUAL, Ni.ReadOnly, e.depthRangeFor3D), h = new ji({
                    func: o.EQUAL,
                    mask: 255
                }, 0, 255, o.KEEP, o.KEEP, o.KEEP);
                for (const t1 of this._groundShadowTiles){
                    const r = t1.toUnwrapped(), s = e.isTileAffectedByFog(t1), d = e.getOrCreateProgram("groundShadow", {
                        defines: n,
                        overrideFog: s
                    });
                    this.setupShadows(r, d), e.uploadCommonUniforms(i, d, r, null, a);
                    const u = {
                        u_matrix: e.transform.calculateProjMatrix(r),
                        u_ground_shadow_factor: l
                    };
                    d.draw(e, o.TRIANGLES, c, h, ki.multiply, qi.disabled, u, "ground_shadow", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, null, e.transform.zoom, null, null);
                }
            }
            getShadowPassColorMode() {
                return this.painter._shadowMapDebug ? ki.unblended : ki.disabled;
            }
            getShadowPassDepthMode() {
                return this._depthMode;
            }
            getShadowCastingLayerCount() {
                return this._shadowLayerCount;
            }
            calculateShadowPassMatrixFromTile(t1) {
                const i = this.painter.transform, o = i.calculatePosMatrix(t1, i.worldSize);
                return e.az(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);
            }
            calculateShadowPassMatrixFromMatrix(t1) {
                return e.az(t1, this._cascades[this.painter.currentShadowCascade].matrix, t1), Float32Array.from(t1);
            }
            setupShadows(t1, i, o) {
                if (!this.enabled) return;
                const r = this.painter.transform, s = this.painter.context, n = s.gl, a = this._uniformValues, l = new Float64Array(16), c = r.calculatePosMatrix(t1, r.worldSize);
                for(let t1 = 0; t1 < this._cascades.length; t1++)e.az(l, this._cascades[t1].matrix, c), a[0 === t1 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(l), s.activeTexture.set(n.TEXTURE0 + Yi.ShadowMap0 + t1), this._cascades[t1].texture.bindExtraParam(n.LINEAR, n.LINEAR, n.CLAMP_TO_EDGE, n.CLAMP_TO_EDGE, n.GREATER);
                if (this.useNormalOffset = !!o, this.useNormalOffset) {
                    const i = e.d4(t1.canonical), s = 2 / r.tileSize * e.aj / to.shadowMapResolution, n = s * this._cascades[0].boundingSphereRadius, l = s * this._cascades[this._cascades.length - 1].boundingSphereRadius, c = ("vector-tile" === o ? 1 : 3) * function(t1, i, o, r, s) {
                        const n = e.ay((t1 - 22) / -22, 0, 1);
                        return .125 * (1 - n) + 4 * n;
                    }(r.zoom);
                    a.u_shadow_normal_offset = [
                        i,
                        n * c,
                        l * c
                    ], a.u_shadow_bias = [
                        1e-4,
                        .0012,
                        .012
                    ];
                } else a.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(s, a);
            }
            setupShadowsFromMatrix(t1, i, o = !1) {
                if (!this.enabled) return;
                const r = this.painter.context, s = r.gl, n = this._uniformValues, a = new Float64Array(16);
                for(let i = 0; i < to.cascadeCount; i++)e.az(a, this._cascades[i].matrix, t1), n[0 === i ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a), r.activeTexture.set(s.TEXTURE0 + Yi.ShadowMap0 + i), this._cascades[i].texture.bindExtraParam(s.LINEAR, s.LINEAR, s.CLAMP_TO_EDGE, s.CLAMP_TO_EDGE, s.GREATER);
                if (this.useNormalOffset = o, o) {
                    const e = to.normalOffset;
                    n.u_shadow_normal_offset = [
                        1,
                        e,
                        e
                    ], n.u_shadow_bias = [
                        6e-5,
                        .0012,
                        .012
                    ];
                } else n.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(r, n);
            }
            getShadowUniformValues() {
                return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
                return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t1, i, o, r) {
                if (r[2] >= 0) return {};
                const s = (function(t1, i, o) {
                    const r = o / (1 << t1.canonical.z);
                    return new e.d6([
                        t1.canonical.x * r + t1.wrap * o,
                        t1.canonical.y * r + t1.wrap * o,
                        0
                    ], [
                        (t1.canonical.x + 1) * r + t1.wrap * o,
                        (t1.canonical.y + 1) * r + t1.wrap * o,
                        i
                    ]);
                })(t1, i, o).getCorners(), n = i / -r[2];
                r[0] < 0 ? (e.d5(s[0], s[0], [
                    r[0] * n,
                    0,
                    0
                ]), e.d5(s[3], s[3], [
                    r[0] * n,
                    0,
                    0
                ])) : r[0] > 0 && (e.d5(s[1], s[1], [
                    r[0] * n,
                    0,
                    0
                ]), e.d5(s[2], s[2], [
                    r[0] * n,
                    0,
                    0
                ])), r[1] < 0 ? (e.d5(s[0], s[0], [
                    0,
                    r[1] * n,
                    0
                ]), e.d5(s[1], s[1], [
                    0,
                    r[1] * n,
                    0
                ])) : r[1] > 0 && (e.d5(s[2], s[2], [
                    0,
                    r[1] * n,
                    0
                ]), e.d5(s[3], s[3], [
                    0,
                    r[1] * n,
                    0
                ]));
                const a = {};
                return a.vertices = s, a.planes = [
                    so(s[1], s[0], s[4]),
                    so(s[2], s[1], s[5]),
                    so(s[3], s[2], s[6]),
                    so(s[0], s[3], s[7])
                ], a;
            }
            addShadowReceiver(t1, i, o) {
                this._receivers.add(t1, e.d6.fromTileIdAndHeight(t1, i, o));
            }
            getMaxCascadeForTile(e) {
                const t1 = this._receivers.get(e);
                return t1 && t1.lastCascade ? t1.lastCascade : 0;
            }
        }
        function so(t1, i, o) {
            const r = e.at([], o, i), s = e.at([], t1, i), n = e.bF([], r, s), a = e.ae(n);
            return 0 === a ? [
                0,
                0,
                1,
                0
            ] : (e.c1(n, n, 1 / a), [
                n[0],
                n[1],
                n[2],
                -e.bG(n, i)
            ]);
        }
        function no(t1) {
            const i = t1.properties.get("direction"), o = e.d1(i.x, i.y, i.z);
            o[2] = e.ay(o[2], 0, 75);
            const r = e.d3([
                o[0],
                o[1],
                o[2]
            ]);
            return e.d2(r.x, r.y, r.z);
        }
        function ao(t1, i, o) {
            const r = "none" === i.properties.get("color-use-theme"), s = i.properties.get("color"), n = i.properties.get("intensity"), a = i.properties.get("direction"), l = [
                a.x,
                a.y,
                a.z
            ], c = "none" === o.properties.get("color-use-theme"), h = o.properties.get("color"), d = o.properties.get("intensity"), u = Math.max(e.bG([
                0,
                0,
                1
            ], l), 0), _ = [
                0,
                0,
                0
            ];
            e.c1(_, h.toPremultipliedRenderColor(c ? null : t1.getLut(i.scope)).toArray01Linear().slice(0, 3), d);
            const p = [
                0,
                0,
                0
            ];
            return e.c1(p, s.toPremultipliedRenderColor(r ? null : t1.getLut(o.scope)).toArray01Linear().slice(0, 3), u * n), e.d8([
                _[0] > 0 ? _[0] / (_[0] + p[0]) : 0,
                _[1] > 0 ? _[1] / (_[1] + p[1]) : 0,
                _[2] > 0 ? _[2] / (_[2] + p[2]) : 0
            ]);
        }
        function lo(t1, i, o, r, s, n) {
            const a = t1.zoom, l = t1.scale, c = t1.worldSize, h = 1 / c, d = t1.aspect, u = Math.sqrt(1 + d * d) * Math.tan(.5 * t1.fovX), _ = u * u, p = r - o, f = r + o;
            let m, g;
            _ > p / f ? (m = r, g = r * u) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (r * r + o * o) * _ + f * f * _ * _));
            const v = t1.projection.pixelsPerMeter(t1.center.lat, c), y = t1._camera.getCameraToWorldMercator(), x = [
                0,
                0,
                -m * h
            ];
            e.ad(x, x, y);
            let b = g * h;
            const w = t1._edgeInsets;
            if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, "meters" === t1.projection.zAxisUnit ? v : 1), s = t1._camera.getCameraToClipPerspective(t1._fov, t1.width / t1.height, o, r);
                s[8] = 2 * -t1.centerOffset.x / t1.width, s[9] = 2 * t1.centerOffset.y / t1.height;
                const n = new Float64Array(16);
                e.cM(n, s, i);
                const h = new Float64Array(16);
                e.bi(h, n);
                const d = e.cy.fromInvProjectionMatrix(h, c, a, !0);
                for (const i of d.points){
                    const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.cb(T[2], t1._center.lat), T);
                    b = Math.max(b, e.c2(e.d7([], x, o)));
                }
            }
            var T;
            b *= s / (s - 1);
            const E = Math.acos(i[2]), S = Math.atan2(-i[0], -i[1]), I = new Xi;
            I.position = x, I.setPitchBearing(E, S);
            const C = I.getWorldToCamera(c, v), R = b * c, A = Math.min(t1._mercatorZfromZoom(17) * c * -2, -2 * R), D = I.getCameraToClipOrthographic(-R, R, -R, R, A, (R + n * v) / i[2]), P = new Float64Array(16);
            e.az(P, D, C);
            const L = e.d2(Math.floor(1e6 * x[0]) / 1e6 * c, Math.floor(1e6 * x[1]) / 1e6 * c, 0), z = .5 * s, M = [
                0,
                0,
                0
            ];
            e.ad(M, L, P), e.c1(M, M, z);
            const O = [
                Math.floor(M[0]),
                Math.floor(M[1]),
                Math.floor(M[2])
            ], F = [
                0,
                0,
                0
            ];
            e.at(F, M, O), e.c1(F, F, -1 / z);
            const B = new Float64Array(16);
            return e.bx(B), e.bo(B, B, F), e.az(P, B, P), [
                P,
                R
            ];
        }
        class co extends e.E {
            constructor(e){
                super(), this.requestManager = e, this.models = {
                    "": {}
                }, this.modelUris = {
                    "": {}
                }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            loadModel(t1, i) {
                return e.aS(this.requestManager.transformRequest(i, e.R.Model).url).then((i)=>{
                    if (!i) return;
                    const o = e.aT(i), r = new e.aU(t1, void 0, void 0, o);
                    return r.computeBoundsAndApplyParent(), r;
                }).catch((o)=>{
                    if (o && 404 === o.status) return null;
                    this.fire(new e.z(new Error(`Could not load model ${t1} from ${i}: ${o.message}`)));
                });
            }
            load(t1, i, o = {
                forceReload: !1
            }) {
                this.models[i] || (this.models[i] = {});
                const r = Object.keys(t1), s = [], n = [];
                for (const e of r){
                    const r = t1[e];
                    this.hasURLBeenRequested(r) && !o.forceReload || (this.modelByURL[r] = {
                        modelId: e,
                        scope: i
                    }, s.push(this.loadModel(e, r)), n.push(e)), this.models[i][e] || (this.models[i][e] = {
                        model: null,
                        numReferences: 1
                    });
                }
                this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + n.length, Promise.allSettled(s).then((t1)=>{
                    for(let e = 0; e < t1.length; e++){
                        const { status: o } = t1[e];
                        if ("rejected" === o) continue;
                        const { value: r } = t1[e];
                        this.models[i][n[e]] || (this.models[i][n[e]] = {
                            model: null,
                            numReferences: 1
                        }), this.models[i][n[e]].model = r;
                    }
                    this.numModelsLoading[i] -= n.length, this.fire(new e.A("data", {
                        dataType: "style"
                    }));
                }).catch((t1)=>{
                    this.fire(new e.z(new Error(`Could not load models: ${t1.message}`)));
                });
            }
            isLoaded() {
                for(const e in this.numModelsLoading)if (this.numModelsLoading[e] > 0) return !1;
                return !0;
            }
            hasModel(e, t1, i = {
                exactIdMatch: !1
            }) {
                return !!(i.exactIdMatch ? this.getModel(e, t1) : this.getModelByURL(this.modelUris[t1][e]));
            }
            getModel(e, t1) {
                return this.models[t1] || (this.models[t1] = {}), this.models[t1][e] ? this.models[t1][e].model : void 0;
            }
            getModelByURL(e) {
                if (!e) return null;
                const t1 = this.modelByURL[e];
                return t1 ? this.models[t1.scope][t1.modelId].model : null;
            }
            hasModelBeenAdded(e, t1) {
                return this.models[t1] && void 0 !== this.models[t1][e];
            }
            getModelURIs(e) {
                return this.modelUris[e] || {};
            }
            addModel(e, t1, i) {
                this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});
                const o = this.requestManager.normalizeModelURL(t1);
                if ((this.hasModel(e, i, {
                    exactIdMatch: !0
                }) || this.hasModelBeenAdded(e, i)) && this.modelUris[i][e] === o) this.models[i][e].numReferences++;
                else if (this.hasURLBeenRequested(o)) {
                    const { scope: e, modelId: t1 } = this.modelByURL[o];
                    this.models[e][t1].numReferences++;
                } else this.modelUris[i][e] = o, this.load({
                    [e]: this.modelUris[i][e]
                }, i);
            }
            addModelURLs(e, t1) {
                this.models[t1] || (this.models[t1] = {}), this.modelUris[t1] || (this.modelUris[t1] = {});
                const i = this.modelUris[t1];
                for(const t1 in e)i[t1] = this.requestManager.normalizeModelURL(e[t1]);
            }
            reloadModels(e) {
                this.load(this.modelUris[e], e, {
                    forceReload: !0
                });
            }
            addModelsFromBucket(t1, i) {
                this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});
                const o = {};
                for (const r of t1)this.hasModel(r, i, {
                    exactIdMatch: !0
                }) || this.hasURLBeenRequested(r) ? this.models[i][r].numReferences++ : this.modelUris[i][r] && !this.hasURLBeenRequested(r) ? o[r] = this.modelUris[i][r] : !this.hasURLBeenRequested(r) && e.d9(r, !1) && (this.modelUris[i][r] = this.requestManager.normalizeModelURL(r), o[r] = this.modelUris[i][r]);
                this.load(o, i);
            }
            hasURLBeenRequested(e) {
                return void 0 !== this.modelByURL[e];
            }
            removeModel(e, t1, i = !1, o = !1) {
                if (this.models[t1] && this.models[t1][e] && (this.models[t1][e].numReferences--, 0 === this.models[t1][e].numReferences || o)) {
                    const o = this.modelUris[t1][e];
                    i || delete this.modelUris[t1][e], delete this.modelByURL[o];
                    const r = this.models[t1][e].model;
                    if (!r) return;
                    delete this.models[t1][e], r.destroy();
                }
            }
            destroy() {
                for (const e of Object.keys(this.models))for (const t1 of Object.keys(this.models[e])){
                    const i = this.models[e][t1].model;
                    delete this.models[e][t1], i && i.destroy();
                }
                this.models = {
                    "": {}
                }, this.modelUris = {
                    "": {}
                }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            listModels(e) {
                return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);
            }
            upload(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                for(const i in this.models[t1])this.models[t1][i].model && this.models[t1][i].model.upload(e.context);
            }
        }
        const ho = new e.a7({
            data: new e.a8(e.a5.colorTheme.data)
        });
        class uo {
            constructor(e){
                this._scope = e, this._buildingQueryParams = {
                    target: {
                        featuresetId: "building-outline",
                        importId: this._scope
                    }
                }, this._floorQueryParams = {
                    target: {
                        featuresetId: "floor-outline",
                        importId: this._scope
                    }
                };
            }
            execute(e) {
                const t1 = this._makeBuildingsQueryArea(e), i = this._makeFloorsQueryArea(e), o = e.queryRenderedFeatures(t1, this._buildingQueryParams).filter((e)=>"building" === e.properties.shape_type).reduce((e, t1)=>{
                    const i = t1.properties.id;
                    return "building" !== t1.properties.shape_type || e.some((e)=>e.properties.id === i) || e.push(t1), e;
                }, []), r = e.queryRenderedFeatures(i, this._floorQueryParams).filter((e)=>"floor" === e.properties.shape_type).reduce((e, t1)=>{
                    const i = t1.properties.id;
                    return "floor" !== t1.properties.shape_type || e.some((e)=>e.properties.id === i) || e.push(t1), e;
                }, []), s = [
                    e.getCenter().lng,
                    e.getCenter().lat
                ];
                return {
                    floors: r,
                    building: this._findBuildingAtCenter(s, o) || (o.length > 0 ? o[0] : null)
                };
            }
            _makeBuildingsQueryArea(t1) {
                const i = t1.transform.width, o = t1.transform.height, r = Math.min(i, o), s = r * (1 / 8), n = r * (1 / 8), a = .5 * (i - s), l = .5 * (o - n);
                return [
                    new e.P(a, l),
                    new e.P(a + s, l + n)
                ];
            }
            _makeFloorsQueryArea(t1) {
                const i = t1.transform.width, o = t1.transform.height, r = i * (2 / 3), s = o * (2 / 3), n = .5 * (i - r), a = .5 * (o - s);
                return [
                    new e.P(n, a),
                    new e.P(n + r, a + s)
                ];
            }
            _findBuildingAtCenter(e, t1) {
                for (const i of t1)if ("Polygon" === i.geometry.type && this._pointInPolygon(e, i.geometry.coordinates[0])) return i;
                return null;
            }
            _pointInPolygon(e, t1) {
                let i = !1;
                for(let o = 0, r = t1.length - 1; o < t1.length; r = o++){
                    const s = t1[o][0], n = t1[o][1], a = t1[r][1];
                    n > e[1] != a > e[1] && e[0] < (t1[r][0] - s) * (e[1] - n) / (a - n) + s && (i = !i);
                }
                return i;
            }
        }
        class _o {
            constructor(){
                this._selectedFloorId = null, this._selectedBuildingId = null, this._floors = [];
            }
            setBuildingId(e) {
                this._selectedBuildingId = e;
            }
            setFloors(e) {
                if (this._floors = e.filter((e)=>e.properties.building_id === this._selectedBuildingId), !this._selectedFloorId || !this._floors.map((e)=>e.properties.id).includes(this._selectedFloorId)) {
                    const e = this._floors.map((e)=>({
                            id: e.properties.id,
                            level: e.properties.floor_level
                        })).reduce((e, t1)=>{
                        const i = Math.abs(e.level - 1), o = Math.abs(t1.level - 1);
                        return o < i || o === i && t1.level > e.level ? t1 : e;
                    });
                    this._selectedFloorId = e.id;
                }
            }
            setFloorId(e) {
                this._selectedFloorId = e;
            }
            getSelectedFloorId() {
                return this._selectedFloorId;
            }
            getCurrentBuildingFloors() {
                return this._floors;
            }
            reset() {
                this._selectedFloorId = null, this._selectedBuildingId = null, this._floors = [];
            }
        }
        const po = {
            "mbx-indoor-level-selected": {
                default: [
                    "literal",
                    []
                ]
            }
        };
        function fo(e) {
            return e = e || {}, Object.assign(e, po);
        }
        class mo extends e.E {
            constructor(t1){
                super(), e.aV([
                    "_onLoad",
                    "_onMove"
                ], this), this._map = t1, this._floorSelectionState = new _o, this._queryIndoor(), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
            }
            destroy() {
                this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = null, this._floorSelectionState = null;
            }
            _onLoad() {
                this._map.style.forEachFragmentStyle((t1)=>{
                    t1.stylesheet.indoor && (this._indoorDataQuery ? this.fire(new e.z(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._scope = t1.scope, this._indoorDataQuery = new uo(this._scope)));
                }), this._map._addIndoorControl(), this._queryIndoor();
            }
            _onMove() {
                this._queryIndoor();
            }
            _queryIndoor() {
                if (!this._indoorDataQuery || !this._map.isStyleLoaded()) return;
                if (this._map.transform.zoom < 16) return void this._clearIndoorData();
                const e = this._indoorDataQuery.execute(this._map);
                e && 0 !== e.floors.length ? (this._floorSelectionState.getSelectedFloorId() || this._map._addIndoorControl(), this._selectFloors(e)) : this._clearIndoorData();
            }
            _selectFloors(e) {
                if (e.building) this._floorSelectionState.setBuildingId(e.building.properties.id), this._floorSelectionState.setFloors(e.floors), this._updateUI();
                else {
                    const t1 = this._floorSelectionState.getSelectedFloorId();
                    if (t1 && e.floors.some((e)=>e.properties.id === t1)) return;
                    this._clearIndoorData();
                }
            }
            _clearIndoorData() {
                this._floorSelectionState.reset(), this._map._removeIndoorControl(), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", [
                    "literal",
                    []
                ]);
            }
            _updateUI() {
                const t1 = this._floorSelectionState.getCurrentBuildingFloors().map((e)=>({
                        id: e.properties.id,
                        name: e.properties.name,
                        shortName: e.properties.floor_level,
                        levelOrder: e.properties.floor_level
                    })), i = this._floorSelectionState.getSelectedFloorId();
                i ? (this._updateIndoorConfig(), this.fire(new e.A("indoorupdate", {
                    selectedFloorId: i,
                    floors: t1
                }))) : console.warn("IndoorManager: Selected floor is not set");
            }
            _updateIndoorConfig() {
                const e = this._floorSelectionState.getSelectedFloorId();
                e ? this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", [
                    "literal",
                    [
                        e
                    ]
                ]) : console.warn("IndoorManager: Selected floor is not set");
            }
            selectFloor(e) {
                this._floorSelectionState.setFloorId(e), this._updateIndoorConfig();
            }
        }
        function go(t1) {
            if (!t1.metadata || !t1.metadata.content_area) return;
            const i = e.q.devicePixelRatio, { left: o, top: r, width: s, height: n } = t1.metadata.content_area, a = o * i, l = r * i;
            return [
                a,
                l,
                a + s * i,
                l + n * i
            ];
        }
        function vo(t1) {
            if (t1) return t1.map(([t1, i])=>[
                    t1 * e.q.devicePixelRatio,
                    i * e.q.devicePixelRatio
                ]);
        }
        class yo {
            constructor(e, t1, i){
                this.id = e, this.scope = t1, this.sourceCache = i, this.pendingRequests = new Set, this.missingRequests = new Set;
            }
            addPendingRequest(e) {
                this.missingRequests.has(e.name) || this.pendingRequests.has(e.name) || this.pendingRequests.add(e.name);
            }
            hasPendingRequests() {
                return this.pendingRequests.size > 0;
            }
            resolvePendingRequests() {
                const t1 = new Map;
                if (!this.sourceCache.loaded()) return t1;
                const i = this.sourceCache.getVisibleCoordinates();
                if (0 === i.length) return t1;
                const o = this.sourceCache.getSource();
                if (!(o instanceof rt)) return t1;
                const r = i.map((e)=>this.sourceCache.getTile(e)), s = o.getImages(r, Array.from(this.pendingRequests));
                for (const [i, o] of s)t1.set(e.I.from({
                    name: i,
                    iconsetId: this.id
                }), o), this.pendingRequests.delete(i);
                for (const e of this.pendingRequests)this.missingRequests.add(e);
                return this.pendingRequests.clear(), t1;
            }
        }
        const xo = (e, t1)=>De(e, t1 && t1.filter((e)=>"source.canvas" !== e.identifier)), bo = e.aF(zt, [
            "addLayer",
            "removeLayer",
            "setLights",
            "setPaintProperty",
            "setLayoutProperty",
            "setSlot",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setSnow",
            "setRain",
            "setProjection",
            "setCamera",
            "addImport",
            "removeImport",
            "updateImport",
            "addIconset",
            "removeIconset"
        ]), wo = e.aF(zt, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), To = new Set([
            "background",
            "sky",
            "slot",
            "custom"
        ]), Eo = {
            version: 8,
            layers: [],
            sources: {}
        }, So = {
            duration: 300,
            delay: 0
        };
        class Io extends e.E {
            constructor(t1, i = {}){
                super(), this.map = t1, this.scope = i.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map, this.resolvedImports = i.resolvedImports || new Set, this.transition = e.h({}, So), this._buildingIndex = new Dt(this), this.crossTileSymbolIndex = new Fi, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new G, this.dispatcher = i.dispatcher ? i.dispatcher : new e.D(e.db(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new q(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.dc(t1._requestManager, i.localFontFamily ? e.dd.all : i.localIdeographFontFamily ? e.dd.ideographs : e.dd.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new co(t1._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map, this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set, this._config = i.config, this._styleColorTheme = {
                    lut: null,
                    lutLoading: !1,
                    lutLoadingCorrelationID: 0,
                    colorTheme: null,
                    colorThemeOverride: i.colorThemeOverride
                }, this._styleColorThemeForScope = {}, this._initialConfig = i.initialConfig, this.dispatcher.broadcast("setReferrer", e.de());
                const o = this;
                this._rtlTextPluginCallback = Io.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e.df(t1), i && i.every((e)=>e)) for(const e in o._sourceCaches){
                            const t1 = o._sourceCaches[e], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e)=>{
                    if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
                    const t1 = this.getOwnSource(e.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e in this._layers){
                        const i = this._layers[e];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            load(e) {
                return e ? ("string" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;
            }
            _getGlobalId(t1) {
                if (!t1) return null;
                if ("string" == typeof t1) {
                    if (e.j(t1)) return t1;
                    const i = e.dg(t1);
                    if (!i.startsWith("http")) try {
                        return new URL(i, location.href).toString();
                    } catch (e) {
                        return i;
                    }
                    return i;
                }
                return `json://${e.dh(JSON.stringify(t1))}`;
            }
            _diffStyle(t1, i, o) {
                this.globalId = this._getGlobalId(t1);
                const r = (e, t1)=>{
                    try {
                        t1(null, this.setState(e, o));
                    } catch (e) {
                        t1(e, !1);
                    }
                };
                if ("string" == typeof t1) {
                    const o = this.map._requestManager.normalizeStyleURL(t1), s = this.map._requestManager.transformRequest(o, e.R.Style);
                    e.n(s, (t1, o)=>{
                        t1 ? this.fire(new e.z(t1)) : o && r(o, i);
                    });
                } else "object" == typeof t1 && r(t1, i);
            }
            loadURL(t1, i = {}) {
                this.fire(new e.A("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e.j(t1);
                this.globalId = this._getGlobalId(t1), t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken), this.resolvedImports.add(t1);
                const r = this.importsCache.get(t1);
                if (r) return this._load(r, o);
                const s = this.map._requestManager.transformRequest(t1, e.R.Style);
                this._request = e.n(s, (i, r)=>{
                    if (this._request = null, i) this.fire(new e.z(i));
                    else if (r) return this.importsCache.set(t1, r), this._load(r, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e.A("dataloading", {
                    dataType: "style"
                })), this.globalId = this._getGlobalId(t1), this._request = e.q.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e.A("dataloading", {
                    dataType: "style"
                })), this._load(Eo, !1);
            }
            _loadImports(t1, i, o) {
                if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
                const r = [];
                for (const e of t1){
                    const t1 = this._createFragmentStyle(e), s = new Promise((e)=>{
                        t1.once("style.import.load", e), t1.once("error", e);
                    }).then(()=>this.mergeAll());
                    if (r.push(s), this.resolvedImports.has(e.url)) {
                        t1.loadEmpty();
                        continue;
                    }
                    const n = e.data || this.importsCache.get(e.url);
                    n ? (t1.loadJSON(n, {
                        validate: i
                    }), this._isInternalStyle(n) && (t1.globalId = null)) : e.url ? t1.loadURL(e.url, {
                        validate: i
                    }) : t1.loadEmpty();
                    const a = {
                        style: t1,
                        id: e.id,
                        config: e.config
                    };
                    if (o) {
                        const e = this.fragments.findIndex(({ id: e })=>e === o);
                        this.fragments = this.fragments.slice(0, e).concat(a).concat(this.fragments.slice(e));
                    } else this.fragments.push(a);
                }
                return Promise.allSettled(r);
            }
            getImportGlobalIds(e = this, t1 = new Set) {
                for (const i of e.fragments)i.style.globalId && t1.add(i.style.globalId), this.getImportGlobalIds(i.style, t1);
                return [
                    ...t1.values()
                ];
            }
            _createFragmentStyle(t1) {
                const i = this.scope ? e.C(t1.id, this.scope) : t1.id;
                let o;
                const r = this._initialConfig && this._initialConfig[i];
                (t1.config || r) && (o = e.h({}, t1.config, r));
                const s = new Io(this.map, {
                    scope: i,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                    config: o,
                    configOptions: this.options,
                    colorThemeOverride: t1["color-theme"],
                    configDependentLayers: this._configDependentLayers
                });
                return s.setEventedParent(this.map, {
                    style: s
                }), s;
            }
            _reloadImports() {
                this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
            }
            _isInternalStyle(e) {
                return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);
            }
            _load(t1, i) {
                const o = t1.indoor ? fo(t1.schema) : t1.schema;
                if (this._isInternalStyle(t1)) {
                    const o = e.h({}, Eo, {
                        imports: [
                            {
                                id: "basemap",
                                data: t1,
                                url: ""
                            }
                        ]
                    });
                    return void this._load(o, i);
                }
                if (this.updateConfig(this._config, o), i && xo(this, me(t1))) return;
                this._loaded = !0, this.stylesheet = e.di(t1);
                const r = ()=>{
                    for(const e in t1.sources)this.addSource(e, t1.sources[e], {
                        validate: !1,
                        isInitialLoad: !0
                    });
                    if (t1.iconsets) for(const e in t1.iconsets)this.addIconset(e, t1.iconsets[e]);
                    t1.sprite ? this._loadIconset(t1.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    })), !this.glyphManager.url && t1.glyphs && this.glyphManager.setURL(t1.glyphs);
                    const o = Lt(this.stylesheet.layers);
                    if (this._order = o.map((e)=>e.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                        const e = this.stylesheet.lights[0];
                        this.light = new Le(e.properties, e.id);
                    } else this.setLights(this.stylesheet.lights);
                    this.light || (this.light = new Le(this.stylesheet.light)), this._layers = {};
                    for (const t1 of o){
                        const i = e.dn(t1, this.scope, this._styleColorTheme.lut, this.options);
                        0 !== i.configDependencies.size && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {
                            layer: {
                                id: i.id
                            }
                        }), this._layers[i.id] = i;
                        const o = this.getOwnLayerSourceCache(i), r = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                        o && i.canCastShadows() && r && (o.castsShadows = !0);
                    }
                    this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
                    const r = this.stylesheet.terrain;
                    r && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(r, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.A("data", {
                        dataType: "style"
                    }));
                    const s = this.isRootStyle();
                    t1.imports ? this._loadImports(t1.imports, i).then(()=>{
                        this._reloadImports(), this.fire(new e.A(s ? "style.load" : "style.import.load"));
                    }).catch((t1)=>{
                        this.fire(new e.z(new Error("Failed to load imports", t1))), this.fire(new e.A(s ? "style.load" : "style.import.load"));
                    }) : (this._reloadImports(), this.fire(new e.A(s ? "style.load" : "style.import.load")));
                };
                this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
                const s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (s) {
                    const t1 = this._evaluateColorThemeData(s);
                    this._loadColorTheme(t1).then(()=>{
                        r();
                    }).catch((t1)=>{
                        e.w(`Couldn't load color theme from the stylesheet: ${t1}`), r();
                    });
                } else this._styleColorTheme.lut = null, r();
            }
            isRootStyle() {
                return 0 === this.importDepth;
            }
            mergeAll() {
                let t1, i, o, r, s, n, a, l, c, h;
                const d = {};
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e)=>{
                    if (e.stylesheet) {
                        if (null != e.light && (t1 = e.light), e.stylesheet.lights) for (const t1 of e.stylesheet.lights)"ambient" === t1.type && null != e.ambientLight && (i = e.ambientLight), "directional" === t1.type && null != e.directionalLight && (o = e.directionalLight);
                        r = this._prioritizeTerrain(r, e.terrain, e.stylesheet.terrain), e.stylesheet.fog && null != e.fog && (s = e.fog), e.stylesheet.snow && null != e.snow && (n = e.snow), e.stylesheet.rain && null != e.rain && (a = e.rain), null != e.stylesheet.camera && (h = e.stylesheet.camera), null != e.stylesheet.projection && (l = e.stylesheet.projection), null != e.stylesheet.transition && (c = e.stylesheet.transition), d[e.scope] = e._styleColorTheme;
                    }
                }), this.light = t1, this.ambientLight = i, this.directionalLight = o, this.fog = s, this.snow = n, this.rain = a, this._styleColorThemeForScope = d, null === r ? delete this.terrain : this.terrain = r, this.camera = h || {
                    "camera-projection": "perspective"
                }, this.projection = l || {
                    name: "mercator"
                }, this.transition = e.h({}, So, c), this.mergeSources(), this.mergeLayers();
            }
            forEachFragmentStyle(e) {
                const t1 = (i)=>{
                    for (const e of i.fragments)t1(e.style);
                    e(i);
                };
                t1(this);
            }
            _prioritizeTerrain(e, t1, i) {
                const o = e && 0 === e.drapeRenderMode;
                return null === i ? t1 && 0 === t1.drapeRenderMode ? t1 : o ? e : null : null != t1 && (!e || o || t1 && 1 === t1.drapeRenderMode) ? t1 : e;
            }
            mergeTerrain() {
                let e;
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t1)=>{
                    e = this._prioritizeTerrain(e, t1.terrain, t1.stylesheet.terrain);
                }), null === e ? delete this.terrain : this.terrain = e;
            }
            mergeProjection() {
                let e;
                this.forEachFragmentStyle((t1)=>{
                    null != t1.stylesheet.projection && (e = t1.stylesheet.projection);
                }), this.projection = e || {
                    name: "mercator"
                };
            }
            mergeSources() {
                const t1 = {}, i = {}, o = {};
                this.forEachFragmentStyle((r)=>{
                    for(const i in r._sourceCaches){
                        const o = e.C(i, r.scope);
                        t1[o] = r._sourceCaches[i];
                    }
                    for(const t1 in r._otherSourceCaches){
                        const o = e.C(t1, r.scope);
                        i[o] = r._otherSourceCaches[t1];
                    }
                    for(const t1 in r._symbolSourceCaches){
                        const i = e.C(t1, r.scope);
                        o[i] = r._symbolSourceCaches[t1];
                    }
                }), this._mergedSourceCaches = t1, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;
            }
            mergeLayers() {
                const t1 = {}, i = [], o = {};
                this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((o)=>{
                    for (const r of o._order){
                        const s = o._layers[r];
                        if ("slot" === s.type) {
                            const i = e.dj(r);
                            if (t1[i]) continue;
                            t1[i] = [];
                        }
                        s.slot && t1[s.slot] ? t1[s.slot].push(s) : i.push(s);
                    }
                }), this._mergedOrder = [];
                const r = (i = [])=>{
                    for (const s of i)if ("slot" === s.type) {
                        const i = e.dj(s.id);
                        t1[i] && r(t1[i]), this._mergedSlots.push(i);
                    } else {
                        const t1 = e.C(s.id, s.scope);
                        this._mergedOrder.push(t1), o[t1] = s, s.is3D(!!this.terrain) && (this._has3DLayers = !0), "circle" === s.type && (this._hasCircleLayers = !0), "symbol" === s.type && (this._hasSymbolLayers = !0), "clip" === s.type && (this._clipLayerPresent = !0);
                    }
                };
                r(i), this._mergedOrder.sort((e, t1)=>{
                    const i = o[e], r = o[t1];
                    return i.hasInitialOcclusionOpacityProperties ? r.is3D(!!this.terrain) ? 1 : 0 : i.is3D(!!this.terrain) && r.hasInitialOcclusionOpacityProperties ? -1 : 0;
                }), this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
                return this.stylesheet.camera;
            }
            setCamera(t1) {
                return this.stylesheet.camera = e.h({}, this.stylesheet.camera, t1), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t1) {
                return t1.data ? (function(t1, i, o, r) {
                    const s = e.h({}, i);
                    for (const t1 of Object.keys(e.a5.colorTheme))void 0 === s[t1] && (s[t1] = e.a5.colorTheme[t1].default);
                    const n = new e.a6(ho, t1, new Map(o));
                    return n.setTransitionOrValue(s, o), n.untransitioned().possiblyEvaluate(new e.aa(0, {
                        worldview: void 0
                    }));
                })(this.scope, t1, this.options).get("data") : null;
            }
            _loadColorTheme(t1) {
                this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
                const i = this._styleColorTheme.lutLoadingCorrelationID;
                return new Promise((o, r)=>{
                    const s = "data:image/png;base64,";
                    if (!t1 || 0 === t1.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();
                    let n = t1;
                    n.startsWith(s) || (n = s + n);
                    const a = e.I.from("mapbox-reserved-lut"), l = new Image;
                    l.src = n, l.onerror = ()=>{
                        this._styleColorTheme.lutLoading = !1, r(new Error("Failed to load image data"));
                    }, l.onload = ()=>{
                        if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();
                        this._styleColorTheme.lutLoading = !1;
                        const { width: s, height: n, data: c } = e.q.getImageData(l);
                        if (n > 32) return void r(new Error("The height of the image must be less than or equal to 32 pixels."));
                        if (s !== n * n) return void r(new Error("The width of the image must be equal to the height squared."));
                        this.getImage(a) && this.removeImage(a), this.addImage(a, {
                            data: new e.r({
                                width: s,
                                height: n
                            }, c),
                            pixelRatio: 1,
                            sdf: !1,
                            usvg: !1,
                            version: 0
                        });
                        const h = this.imageManager.getImage(a, this.scope);
                        h ? (this._styleColorTheme.lut = {
                            image: h.data,
                            data: t1
                        }, o()) : r(new Error("Missing LUT image."));
                    };
                });
            }
            getLut(e) {
                const t1 = this._styleColorThemeForScope[e];
                return t1 ? t1.lut : null;
            }
            setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
                this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let r, s, n;
                    const a = e.q.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e.n(i.transformRequest(i.normalizeSpriteURL(t1, a, ".json"), e.R.SpriteJSON), (e, t1)=>{
                        l = null, n || (n = e, r = t1, h());
                    }), c = e.o(i.transformRequest(i.normalizeSpriteURL(t1, a, ".png"), e.R.SpriteImage), (e, t1)=>{
                        c = null, n || (n = e, s = t1, h());
                    });
                    function h() {
                        if (n) o(n);
                        else if (r && s) {
                            const t1 = e.q.getImageData(s), i = {};
                            for(const o in r){
                                const { width: s, height: n, x: a, y: l, sdf: c, pixelRatio: h, stretchX: d, stretchY: u, content: _ } = r[o], p = new e.r({
                                    width: s,
                                    height: n
                                });
                                e.r.copy(t1, p, {
                                    x: a,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: s,
                                    height: n
                                }, null), i[o] = {
                                    data: p,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: d,
                                    stretchY: u,
                                    content: _,
                                    usvg: !1
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e.z(t1));
                    else if (i) {
                        const t1 = new Map;
                        for(const o in i)t1.set(e.I.from(o), i[o]);
                        this.addImages(t1);
                    }
                    this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.A("data", {
                        dataType: "style"
                    }));
                });
            }
            addIconset(t1, i) {
                if ("sprite" === i.type) return void this._loadSprite(i.url);
                const o = this.getOwnSourceCache(i.source);
                if (!o) return void this.fire(new e.z(new Error(`Source "${i.source}" as specified by iconset "${t1}" does not exist and cannot be used as an iconset source`)));
                const r = o.getSource();
                if ("raster-array" !== r.type) return void this.fire(new e.z(new Error(`Source "${i.source}" as specified by iconset "${t1}" is not a "raster-array" source and cannot be used as an iconset source`)));
                r.partial = !1;
                const s = new yo(t1, this.scope, o);
                this.imageManager.addImageProvider(s, this.scope);
            }
            removeIconset(e) {
                this.imageManager.removeImageProvider(e, this.scope);
            }
            _loadIconset(t1) {
                if (!e.j(t1) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t1);
                const i = "auto" === this.map._spriteFormat;
                var o, r;
                this._spriteRequest = (r = (o, r)=>{
                    if (this._spriteRequest = null, o) i ? this._loadSprite(t1) : this.fire(new e.z(o));
                    else if (r) {
                        const t1 = new Map;
                        for(const i in r)t1.set(e.I.from(i), r[i]);
                        this.addImages(t1);
                    }
                    this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.A("data", {
                        dataType: "style"
                    }));
                }, e.br((o = this.map._requestManager).transformRequest(o.normalizeIconsetURL(t1), e.R.Iconset), (t1, i)=>{
                    if (t1) return void r(t1);
                    const o = {}, s = e.da(new e.bq(i));
                    for (const t1 of s.icons){
                        const i = {
                            version: 1,
                            pixelRatio: e.q.devicePixelRatio,
                            content: go(t1),
                            stretchX: t1.metadata ? vo(t1.metadata.stretch_x_areas) : void 0,
                            stretchY: t1.metadata ? vo(t1.metadata.stretch_y_areas) : void 0,
                            sdf: !1,
                            usvg: !0,
                            icon: t1
                        };
                        o[t1.name] = i;
                    }
                    r(null, o);
                }));
            }
            _validateLayer(t1) {
                const i = this.getOwnSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.z(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
                for(const e in this._sourceCaches)if (!this._sourceCaches[e].loaded()) return !1;
                if (!this.imageManager.isLoaded()) return !1;
                if (this.imageManager.hasPatternsInFlight()) return !1;
                if (!this.modelManager.isLoaded()) return !1;
                if (this._styleColorTheme.lutLoading) return !1;
                for (const { style: e } of this.fragments)if (!e.loaded()) return !1;
                return !0;
            }
            _serializeImports() {
                if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t1)=>{
                    const i = this.fragments[t1];
                    return i && i.style && (e.data = i.style.serialize()), e;
                });
            }
            _serializeSources() {
                const e = {};
                for(const t1 in this._sourceCaches){
                    const i = this._sourceCaches[t1].getSource();
                    e[i.id] || (e[i.id] = i.serialize());
                }
                return e;
            }
            _serializeLayers(e) {
                const t1 = [];
                for (const i of e){
                    const e = this._layers[i];
                    e && "custom" !== e.type && t1.push(e.serialize());
                }
                return t1;
            }
            hasLightTransitions() {
                return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
                return !!this.fog && this.fog.hasTransition();
            }
            hasSnowTransition() {
                return !!this.snow && this.snow.hasTransition();
            }
            hasRainTransition() {
                return !!this.rain && this.rain.hasTransition();
            }
            hasTransitions() {
                if (this.hasLightTransitions()) return !0;
                if (this.hasFogTransition()) return !0;
                if (this.hasSnowTransition()) return !0;
                if (this.hasRainTransition()) return !0;
                for(const e in this._sourceCaches)if (this._sourceCaches[e].hasTransition()) return !0;
                for(const e in this._layers)if (this._layers[e].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            _getOrder(e) {
                return e ? this.order : this._mergedOrder;
            }
            isLayerDraped(e) {
                return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            _checkLayer(t1) {
                const i = this.getOwnLayer(t1);
                if (i) return i;
                this.fire(new e.z(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            _checkSource(t1) {
                const i = this.getOwnSource(t1);
                if (i) return i;
                this.fire(new e.z(new Error(`The source '${t1}' does not exist in the map's style.`)));
            }
            precompilePrograms(e, t1) {
                const i = this.map.painter;
                if (i) for(let o = e.minzoom || 0; o < (e.maxzoom || 25.5); o++){
                    const o = e.getProgramIds();
                    if (o) for (const r of o){
                        const o = e.getDefaultProgramParams(r, t1.zoom, this._styleColorTheme.lut);
                        o && (i.style = this, this.fog && (i._fogVisible = !0, o.overrideFog = !0, i.getOrCreateProgram(r, o)), i._fogVisible = !1, o.overrideFog = !1, i.getOrCreateProgram(r, o), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o.overrideRtt = !0, i.getOrCreateProgram(r, o)));
                    }
                }
            }
            update(t1) {
                if (!this._loaded) return;
                this.ambientLight && this.ambientLight.recalculate(t1), this.directionalLight && this.directionalLight.recalculate(t1);
                const i = this.calculateLightsBrightness();
                t1.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast("setBrightness", i)), t1.worldview !== this._worldview && (this._worldview = t1.worldview, this.dispatcher.broadcast("setWorldview", this._worldview));
                const o = this._changes.isDirty();
                let r = !1;
                if (this._changes.isDirty()) {
                    const e = this._changes.getLayerUpdatesByScope();
                    for(const t1 in e){
                        const { updatedIds: i, removedIds: o } = e[t1];
                        (i || o) && (this._updateWorkerLayers(t1, i, o), r = !0);
                    }
                    this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t1), this.light && this.light.updateTransitions(t1), this.ambientLight && this.ambientLight.updateTransitions(t1), this.directionalLight && this.directionalLight.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this.snow && this.snow.updateTransitions(t1), this.rain && this.rain.updateTransitions(t1), this._changes.reset();
                }
                const s = {};
                for(const e in this._mergedSourceCaches){
                    const t1 = this._mergedSourceCaches[e];
                    s[e] = t1.used, t1.used = !1, t1.tileCoverLift = 0;
                }
                for (const e of this._mergedOrder){
                    const i = this._mergedLayers[e];
                    if (i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e = this.getLayerSourceCache(i);
                        e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));
                    }
                    !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(()=>{
                        this.precompilePrograms(i, t1);
                    }) : this.precompilePrograms(i, t1));
                }
                this._shouldPrecompile && (this._precompileDone = !0), this.terrain && r && this.mergeLayers();
                const n = this.imageManager.getPendingImageProviders();
                for (const e of n)e.sourceCache.used = !0;
                for(const t1 in s){
                    const i = this._mergedSourceCaches[t1];
                    s[t1] !== i.used && i.getSource().fire(new e.A("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light && this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.snow && this.snow.recalculate(t1), this.rain && this.rain.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), o && this.fire(new e.A("data", {
                    dataType: "style"
                }));
            }
            updateImageProviders() {
                const e = this.imageManager.getPendingImageProviders();
                for (const t1 of e){
                    const e = t1.resolvePendingRequests(), i = this.getFragmentStyle(t1.scope);
                    i && i.addImages(e);
                }
            }
            _updateTilesForChangedImages() {
                const e = {};
                for(const t1 in this._mergedSourceCaches){
                    const i = this._mergedSourceCaches[t1].getSource().scope;
                    e[i] = e[i] || this._changes.getUpdatedImages(i), 0 !== e[i].length && this._mergedSourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e[i]);
                }
                for(const t1 in e)this._changes.resetUpdatedImages(t1);
            }
            _updateWorkerLayers(e, t1, i) {
                const o = this.getFragmentStyle(e);
                o && this.dispatcher.broadcast("updateLayers", {
                    layers: t1 ? o._serializeLayers(t1) : [],
                    scope: e,
                    removedIds: i || [],
                    options: o.options
                });
            }
            setState(t1, i) {
                if (this._checkLoaded(), xo(this, me(t1))) return !1;
                (t1 = e.di(t1)).layers = Lt(t1.layers);
                const o = (function(t1, i) {
                    if (!t1) return [
                        {
                            command: zt.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!e.bv(t1.version, i.version)) return [
                            {
                                command: zt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        if (e.bv(t1.center, i.center) || o.push({
                            command: zt.setCenter,
                            args: [
                                i.center
                            ]
                        }), e.bv(t1.zoom, i.zoom) || o.push({
                            command: zt.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), e.bv(t1.bearing, i.bearing) || o.push({
                            command: zt.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), e.bv(t1.pitch, i.pitch) || o.push({
                            command: zt.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), e.bv(t1.sprite, i.sprite) || o.push({
                            command: zt.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), e.bv(t1.glyphs, i.glyphs) || o.push({
                            command: zt.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), e.bv(t1.imports, i.imports) || function(t1 = [], i = [], o) {
                            i = i || [];
                            const r = (t1 = t1 || []).map(Nt), s = i.map(Nt), n = t1.reduce(Ut, {}), a = i.reduce(Ut, {}), l = r.slice();
                            let c, h, d, u;
                            for(c = 0, h = 0; c < r.length; c++)d = r[c], a.hasOwnProperty(d) ? h++ : (o.push({
                                command: zt.removeImport,
                                args: [
                                    d
                                ]
                            }), l.splice(l.indexOf(d, h), 1));
                            for(c = 0, h = 0; c < s.length; c++)d = s[s.length - 1 - c], l[l.length - 1 - c] !== d && (n.hasOwnProperty(d) ? (o.push({
                                command: zt.removeImport,
                                args: [
                                    d
                                ]
                            }), l.splice(l.lastIndexOf(d, l.length - h), 1)) : h++, u = l[l.length - c], o.push({
                                command: zt.addImport,
                                args: [
                                    a[d],
                                    u
                                ]
                            }), l.splice(l.length - c, 0, d));
                            for (const t1 of i){
                                const i = n[t1.id];
                                i && (delete i.data, e.bv(i, t1) || o.push({
                                    command: zt.updateImport,
                                    args: [
                                        t1.id,
                                        t1
                                    ]
                                }));
                            }
                        }(t1.imports, i.imports, o), e.bv(t1.transition, i.transition) || o.push({
                            command: zt.setTransition,
                            args: [
                                i.transition
                            ]
                        }), e.bv(t1.light, i.light) || o.push({
                            command: zt.setLight,
                            args: [
                                i.light
                            ]
                        }), e.bv(t1.fog, i.fog) || o.push({
                            command: zt.setFog,
                            args: [
                                i.fog
                            ]
                        }), e.bv(t1.snow, i.snow) || o.push({
                            command: zt.setSnow,
                            args: [
                                i.snow
                            ]
                        }), e.bv(t1.rain, i.rain) || o.push({
                            command: zt.setRain,
                            args: [
                                i.rain
                            ]
                        }), e.bv(t1.projection, i.projection) || o.push({
                            command: zt.setProjection,
                            args: [
                                i.projection
                            ]
                        }), e.bv(t1.lights, i.lights) || o.push({
                            command: zt.setLights,
                            args: [
                                i.lights
                            ]
                        }), e.bv(t1.camera, i.camera) || o.push({
                            command: zt.setCamera,
                            args: [
                                i.camera
                            ]
                        }), e.bv(t1.iconsets, i.iconsets) || function(t1, i, o) {
                            let r;
                            for(r in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(r) && (i.hasOwnProperty(r) || o.push({
                                command: zt.removeIconset,
                                args: [
                                    r
                                ]
                            }));
                            for(r in i){
                                if (!i.hasOwnProperty(r)) continue;
                                const s = i[r];
                                t1.hasOwnProperty(r) ? e.bv(t1[r], s) || (o.push({
                                    command: zt.removeIconset,
                                    args: [
                                        r
                                    ]
                                }), o.push({
                                    command: zt.addIconset,
                                    args: [
                                        r,
                                        s
                                    ]
                                })) : o.push({
                                    command: zt.addIconset,
                                    args: [
                                        r,
                                        s
                                    ]
                                });
                            }
                        }(t1.iconsets, i.iconsets, o), !e.bv(t1["color-theme"], i["color-theme"])) return [
                            {
                                command: zt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        const r = {}, s = [];
                        !function(t1, i, o, r) {
                            let s;
                            for(s in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(s) && (i.hasOwnProperty(s) || Ot(s, o, r));
                            for(s in i){
                                if (!i.hasOwnProperty(s)) continue;
                                const n = i[s];
                                t1.hasOwnProperty(s) ? e.bv(t1[s], n) || ("geojson" === t1[s].type && "geojson" === n.type && Bt(t1, i, s) ? o.push({
                                    command: zt.setGeoJSONSourceData,
                                    args: [
                                        s,
                                        n.data
                                    ]
                                }) : Ft(s, i, o, r)) : Mt(s, i, o);
                            }
                        }(t1.sources, i.sources, s, r);
                        const n = [];
                        t1.layers && t1.layers.forEach((e)=>{
                            e.source && r[e.source] ? o.push({
                                command: zt.removeLayer,
                                args: [
                                    e.id
                                ]
                            }) : n.push(e);
                        });
                        let a = t1.terrain;
                        a && r[a.source] && (o.push({
                            command: zt.setTerrain,
                            args: [
                                void 0
                            ]
                        }), a = void 0), o = o.concat(s), e.bv(a, i.terrain) || o.push({
                            command: zt.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(t1, i, o) {
                            i = i || [];
                            const r = (t1 = t1 || []).map(Nt), s = i.map(Nt), n = t1.reduce(Ut, {}), a = i.reduce(Ut, {}), l = r.slice(), c = Object.create(null);
                            let h, d, u, _, p, f, m;
                            for(h = 0, d = 0; h < r.length; h++)u = r[h], a.hasOwnProperty(u) ? d++ : (o.push({
                                command: zt.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.indexOf(u, d), 1));
                            for(h = 0, d = 0; h < s.length; h++)u = s[s.length - 1 - h], l[l.length - 1 - h] !== u && (n.hasOwnProperty(u) ? (o.push({
                                command: zt.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.lastIndexOf(u, l.length - d), 1)) : d++, f = l[l.length - h], o.push({
                                command: zt.addLayer,
                                args: [
                                    a[u],
                                    f
                                ]
                            }), l.splice(l.length - h, 0, u), c[u] = !0);
                            for(h = 0; h < s.length; h++)if (u = s[h], _ = n[u], p = a[u], !c[u] && !e.bv(_, p)) if (e.bv(_.source, p.source) && e.bv(_["source-layer"], p["source-layer"]) && e.bv(_.type, p.type)) {
                                for(m in kt(_.layout, p.layout, o, u, null, zt.setLayoutProperty), kt(_.paint, p.paint, o, u, null, zt.setPaintProperty), e.bv(_.slot, p.slot) || o.push({
                                    command: zt.setSlot,
                                    args: [
                                        u,
                                        p.slot
                                    ]
                                }), e.bv(_.filter, p.filter) || o.push({
                                    command: zt.setFilter,
                                    args: [
                                        u,
                                        p.filter
                                    ]
                                }), e.bv(_.minzoom, p.minzoom) && e.bv(_.maxzoom, p.maxzoom) || o.push({
                                    command: zt.setLayerZoomRange,
                                    args: [
                                        u,
                                        p.minzoom,
                                        p.maxzoom
                                    ]
                                }), _)_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? kt(_[m], p[m], o, u, m.slice(6), zt.setPaintProperty) : e.bv(_[m], p[m]) || o.push({
                                    command: zt.setLayerProperty,
                                    args: [
                                        u,
                                        m,
                                        p[m]
                                    ]
                                }));
                                for(m in p)p.hasOwnProperty(m) && !_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? kt(_[m], p[m], o, u, m.slice(6), zt.setPaintProperty) : e.bv(_[m], p[m]) || o.push({
                                    command: zt.setLayerProperty,
                                    args: [
                                        u,
                                        m,
                                        p[m]
                                    ]
                                }));
                            } else o.push({
                                command: zt.removeLayer,
                                args: [
                                    u
                                ]
                            }), f = l[l.lastIndexOf(u) + 1], o.push({
                                command: zt.addLayer,
                                args: [
                                    p,
                                    f
                                ]
                            });
                        }(n, i.layers, o);
                    } catch (e) {
                        console.warn("Unable to compute style diff:", e), o = [
                            {
                                command: zt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), t1).filter((e)=>!(e.command in wo));
                if (0 === o.length) return !1;
                const r = o.filter((e)=>!(e.command in bo));
                if (r.length > 0) throw new Error(`Unimplemented: ${r.map((e)=>e.command).join(", ")}.`);
                const s = [];
                return o.forEach((e)=>{
                    s.push(this[e.command](...e.args));
                }), i && Promise.all(s).then(i).catch(i), this.stylesheet = t1, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), !0;
            }
            _updateWorkerImages() {
                this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                    scope: this.scope,
                    images: this._availableImages
                });
            }
            _updateWorkerModels() {
                this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", {
                    scope: this.scope,
                    models: this._availableModels
                });
            }
            addImages(t1) {
                if (0 === t1.size) return this;
                for (const [i, o] of t1.entries()){
                    if (this.getImage(i)) return this.fire(new e.z(new Error(`An image with the name "${i.name}" already exists.`)));
                    this.imageManager.addImage(i, this.scope, o), this._changes.updateImage(i, this.scope);
                }
                return this._updateWorkerImages(), this.fire(new e.A("data", {
                    dataType: "style"
                })), this;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e.z(new Error(`An image with the name "${t1.name}" already exists.`))) : (this.imageManager.addImage(t1, this.scope, i), this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", {
                    dataType: "style"
                })), this);
            }
            updateImage(t1, i, o = !1) {
                this.imageManager.updateImage(t1, this.scope, i), o && (this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", {
                    dataType: "style"
                })));
            }
            getImage(e) {
                return this.imageManager.getImage(e, this.scope);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1, this.scope), this._changes.updateImage(t1, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", {
                    dataType: "style"
                })), this) : this.fire(new e.z(new Error("No image with this name exists.")));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addModelURLs(t1) {
                return this.modelManager.addModelURLs(t1, this.scope), this._updateWorkerModels(), this.fire(new e.A("data", {
                    dataType: "style"
                })), this;
            }
            addModel(t1, i, o = {}) {
                return this._checkLoaded(), this._validate(Re, `models.${t1}`, i, null, o) || (this.modelManager.addModel(t1, i, this.scope), this.fire(new e.A("data", {
                    dataType: "style"
                }))), this;
            }
            hasModel(e) {
                return this.modelManager.hasModel(e, this.scope);
            }
            removeModel(t1) {
                return this.hasModel(t1) ? (this.modelManager.removeModel(t1, this.scope, !1, !0), this.fire(new e.A("data", {
                    dataType: "style"
                })), this) : this.fire(new e.z(new Error("No model with this ID exists.")));
            }
            listModels() {
                return this._checkLoaded(), this.modelManager.listModels(this.scope);
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getOwnSource(t1)) throw new Error(`There is already a source with ID "${t1}".`);
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(ge, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const r = nt(t1, i, this.dispatcher, this);
                r.scope = this.scope, r.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(r.id),
                        source: r.serialize(),
                        sourceId: r.id
                    }));
                const s = (t1)=>{
                    const i = (t1 ? "symbol:" : "other:") + r.id, o = e.C(i, this.scope), s = this._sourceCaches[i] = new It(o, r, t1);
                    (t1 ? this._symbolSourceCaches : this._otherSourceCaches)[r.id] = s, s.onAdd(this.map);
                };
                s(!1), "vector" !== i.type && "geojson" !== i.type || s(!0), r.onAdd && r.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getOwnSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e.z(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t1) return this.fire(new e.z(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                if (this.stylesheet.iconsets) {
                    const i = Object.entries(this.stylesheet.iconsets).find(([e, i])=>"source" === i.type && i.source === t1);
                    if (i) return this.fire(new e.z(new Error(`Source "${t1}" cannot be removed while iconset "${i[0]}" is using it.`)));
                }
                const o = this.getOwnSourceCaches(t1);
                for (const t1 of o){
                    const i = e.dj(t1.id);
                    delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t1.id), t1.fire(new e.A("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: t1.getSource().id
                    })), t1.setEventedParent(null), t1.clearTiles();
                }
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e, t1) {
                this._checkLoaded(), this.getOwnSource(e).setData(t1), this._changes.setDirty();
            }
            getOwnSource(e) {
                const t1 = this.getOwnSourceCache(e);
                return t1 && t1.getSource();
            }
            getOwnSources() {
                const e = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this.getOwnSourceCache(t1);
                    i && e.push(i.getSource());
                }
                return e;
            }
            areTilesLoaded() {
                const e = this._mergedSourceCaches;
                for(const t1 in e){
                    const i = e[t1]._tiles;
                    for(const e in i){
                        const t1 = i[e];
                        if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                    }
                }
                return !0;
            }
            setLights(t1) {
                if (this._checkLoaded(), !t1) return delete this.ambientLight, void delete this.directionalLight;
                const i = this._getTransitionParameters();
                for (const o of t1){
                    if (this._validate(ye, "lights", o)) return;
                    switch(o.type){
                        case "ambient":
                            if (this.ambientLight) {
                                const e = this.ambientLight;
                                e.set(o), e.updateTransitions(i);
                            } else this.ambientLight = new $e(o, qe || (qe = new e.a7({
                                color: new e.a8(e.a5.properties_light_ambient.color),
                                "color-use-theme": new e.a8({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-constant"
                                }),
                                intensity: new e.a8(e.a5.properties_light_ambient.intensity)
                            })), this.scope, this.options);
                            break;
                        case "directional":
                            if (this.directionalLight) {
                                const e = this.directionalLight;
                                e.set(o), e.updateTransitions(i);
                            } else this.directionalLight = new $e(o, He || (He = new e.a7({
                                direction: new e.an(e.a5.properties_light_directional.direction),
                                color: new e.a8(e.a5.properties_light_directional.color),
                                "color-use-theme": new e.a8({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-constant"
                                }),
                                intensity: new e.a8(e.a5.properties_light_directional.intensity),
                                "cast-shadows": new e.a8(e.a5.properties_light_directional["cast-shadows"]),
                                "shadow-quality": new e.a8(e.a5.properties_light_directional["shadow-quality"]),
                                "shadow-intensity": new e.a8(e.a5.properties_light_directional["shadow-intensity"])
                            })), this.scope, this.options);
                    }
                }
                const o = Object.assign(i, {
                    worldview: this.map.getWorldview()
                }), r = new e.aa(this.z || 0, o);
                this.ambientLight && this.ambientLight.recalculate(r), this.directionalLight && this.directionalLight.recalculate(r), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
                const t1 = this.directionalLight, i = this.ambientLight;
                if (!t1 || !i) return;
                const o = (e)=>.2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)), r = t1.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), s = t1.properties.get("intensity"), n = t1.properties.get("direction"), a = 1 - e.d1(n.x, n.y, n.z)[2] / 90, l = o(r) * s * a, c = i.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), h = i.properties.get("intensity"), d = o(c) * h;
                return Number(((l + d) / 2).toFixed(6));
            }
            getBrightness() {
                return this._brightness;
            }
            getLights() {
                if (!this.enable3dLights()) return null;
                const e = [];
                return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;
            }
            enable3dLights() {
                return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t1) {
                if (null == t1 || "" === t1 && this.isRootStyle()) return this;
                if (e.dk(t1)) {
                    const i = e.dl(t1), o = this.fragments.find(({ id: e })=>e === i);
                    if (!o) return;
                    const r = e.dj(t1);
                    return o.style.getFragmentStyle(r);
                }
                {
                    const e = this.fragments.find(({ id: e })=>e === t1);
                    return e ? e.style : void 0;
                }
            }
            setFeaturesetSelectors(t1) {
                if (!t1) return;
                const i = {}, o = (e, t1 = "")=>`${e}::${t1}`;
                this._featuresetSelectors = {};
                for(const r in t1){
                    const s = this._featuresetSelectors[r] = [];
                    for (const n of t1[r].selectors){
                        if (n.featureNamespace) {
                            const t1 = this.getOwnLayer(n.layer);
                            if (!t1) {
                                e.w(`Layer is undefined for selector: ${n.layer}`);
                                continue;
                            }
                            const s = o(t1.source, t1.sourceLayer);
                            if (s in i && i[s] !== n.featureNamespace) {
                                e.w(`"featureNamespace ${n.featureNamespace} of featureset ${r}'s selector is not associated to the same source, skip this selector`);
                                continue;
                            }
                            i[s] = n.featureNamespace;
                        }
                        let t1;
                        if (n.properties) for(const i in n.properties){
                            const o = e.X(n.properties[i]);
                            "success" === o.result && (t1 = t1 || {}, t1[i] = o.value);
                        }
                        s.push({
                            layerId: n.layer,
                            namespace: n.featureNamespace,
                            properties: t1,
                            uniqueFeatureID: n._uniqueFeatureID
                        });
                    }
                }
            }
            getFeaturesetDescriptors(e) {
                const t1 = this.getFragmentStyle(e);
                if (!t1 || !t1.stylesheet.featuresets) return [];
                const i = [];
                for(const e in t1.stylesheet.featuresets)i.push({
                    featuresetId: e,
                    importId: t1.scope ? t1.scope : void 0
                });
                return i;
            }
            getFeaturesetLayers(t1, i) {
                const o = this.getFragmentStyle(i), r = o.stylesheet.featuresets;
                if (!r || !r[t1]) return this.fire(new e.z(new Error(`The featureset '${t1}' does not exist in the map's style and cannot be queried.`))), [];
                const s = [];
                for (const e of r[t1].selectors){
                    const t1 = o.getOwnLayer(e.layer);
                    t1 && s.push(t1);
                }
                return s;
            }
            getConfigProperty(t1, i) {
                const o = this.getFragmentStyle(t1);
                if (!o) return null;
                const r = e.C(i, o.scope), s = o.options.get(r), n = s ? s.value || s.default : null;
                return n ? n.serialize() : null;
            }
            setConfigProperty(t1, i, o) {
                const r = this.getFragmentStyle(t1);
                if (!r) return;
                const s = r.stylesheet.indoor ? fo(r.stylesheet.schema) : r.stylesheet.schema;
                if (!s || !s[i]) return;
                const n = e.X(o);
                if ("success" !== n.result) return void xo(this, n.value);
                const a = n.value.expression, l = e.C(i, r.scope), c = r.options.get(l);
                if (!c) return;
                let h;
                const { minValue: d, maxValue: u, stepValue: _, type: p, values: f } = s[i], m = e.X(s[i].default);
                "success" === m.result && (h = m.value.expression), h ? (this.options.set(l, Object.assign({}, c, {
                    value: a,
                    default: h,
                    minValue: d,
                    maxValue: u,
                    stepValue: _,
                    type: p,
                    values: f
                })), this.updateConfigDependencies(i)) : this.fire(new e.z(new Error(`No schema defined for the config option "${i}" in the "${t1}" fragment.`)));
            }
            getConfig(t1) {
                const i = this.getFragmentStyle(t1);
                if (!i) return null;
                const o = i.stylesheet.schema;
                if (!o) return null;
                const r = {};
                for(const t1 in o){
                    const o = e.C(t1, i.scope), s = i.options.get(o), n = s ? s.value || s.default : null;
                    r[t1] = n ? n.serialize() : null;
                }
                return r;
            }
            setConfig(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.updateConfig(t1, i.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e) {
                const t1 = this.getFragmentStyle(e);
                return t1 ? t1.stylesheet.schema : null;
            }
            setSchema(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.stylesheet.schema = t1, i.updateConfig(i._config, t1), this.updateConfigDependencies());
            }
            updateConfig(t1, i) {
                if (this._config = t1, t1 || i) if (i) for(const o in i){
                    let r, s;
                    const n = e.X(i[o].default);
                    if ("success" === n.result && (r = n.value.expression), t1 && void 0 !== t1[o]) {
                        const i = e.X(t1[o]);
                        "success" === i.result && (s = i.value.expression);
                    }
                    const { minValue: a, maxValue: l, stepValue: c, type: h, values: d } = i[o];
                    if (r) {
                        const t1 = e.C(o, this.scope);
                        this.options.set(t1, {
                            default: r,
                            value: s,
                            minValue: a,
                            maxValue: l,
                            stepValue: c,
                            type: h,
                            values: d
                        });
                    } else this.fire(new e.z(new Error(`No schema defined for config option "${o}".`)));
                }
                else this.fire(new e.z(new Error("Attempting to set config for a style without schema.")));
            }
            updateConfigDependencies(e) {
                for (const t1 of this._configDependentLayers){
                    const i = this.getLayer(t1);
                    if (i) {
                        if (e && !i.configDependencies.has(e)) continue;
                        i.possiblyEvaluateVisibility(), this._updateLayer(i);
                    }
                }
                this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e)=>{
                    const t1 = e._styleColorTheme.colorThemeOverride ? e._styleColorTheme.colorThemeOverride : e._styleColorTheme.colorTheme;
                    if (t1) {
                        const i = e._evaluateColorThemeData(t1);
                        (!e._styleColorTheme.lut && "" !== i || e._styleColorTheme.lut && i !== e._styleColorTheme.lut.data) && e.setColorTheme(t1);
                    }
                }), this._changes.setDirty();
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const r = t1.id;
                if (this._layers[r]) return void this.fire(new e.z(new Error(`Layer with id "${r}" already exists on this map`)));
                let s;
                if ("custom" === t1.type) {
                    if (xo(this, e.dm(t1))) return;
                    s = e.dn(t1, this.scope, this._styleColorTheme.lut, this.options);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(r, t1.source), t1 = e.di(t1), t1 = e.h(t1, {
                        source: r
                    })), this._validate(Ee, `layers.${r}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    s = e.dn(t1, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(s), s.setEventedParent(this, {
                        layer: {
                            id: r
                        }
                    });
                }
                0 !== s.configDependencies.size && this._configDependentLayers.add(s.fqid);
                let n = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.z(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    s.slot === this._layers[i].slot ? n = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = s;
                const a = this.getOwnLayerSourceCache(s), l = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                a && s.canCastShadows() && l && (a.castsShadows = !0);
                const c = this._changes.getRemovedLayer(s);
                if (c && s.source && a && "custom" !== s.type) {
                    this._changes.discardLayerRemoval(s);
                    const t1 = e.C(s.source, s.scope);
                    c.type !== s.type ? this._changes.updateSourceCache(t1, "clear") : (this._changes.updateSourceCache(t1, "reload"), a.pause());
                }
                this._updateLayer(s), s.onAdd && s.onAdd(this.map), s.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(t1);
                if (!o) return;
                if (t1 === i) return;
                const r = this._order.indexOf(t1);
                this._order.splice(r, 1);
                let s = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.z(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    o.slot === this._layers[i].slot ? s = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(s, 0, t1), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
            }
            removeLayer(e) {
                this._checkLoaded();
                const t1 = this._checkLayer(e);
                if (!t1) return;
                t1.setEventedParent(null);
                const i = this._order.indexOf(e);
                this._order.splice(i, 1), delete this._layers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t1.fqid), this._changes.removeLayer(t1);
                const o = this.getOwnLayerSourceCache(t1);
                if (o && o.castsShadows) {
                    let e = !1;
                    for(const i in this._layers)if (this._layers[i].source === t1.source && this._layers[i].canCastShadows()) {
                        e = !0;
                        break;
                    }
                    o.castsShadows = e;
                }
                t1.onRemove && t1.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e) {
                return this._layers[e];
            }
            hasLayer(e) {
                return e in this._mergedLayers;
            }
            hasLayerType(e) {
                for(const t1 in this._layers)if (this._layers[t1].type === e) return !0;
                return !1;
            }
            setLayerZoomRange(e, t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(e);
                o && (o.minzoom === t1 && o.maxzoom === i || (null != t1 && (o.minzoom = t1), null != i && (o.maxzoom = i), this._updateLayer(o)));
            }
            getSlots() {
                return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e, t1) {
                this._checkLoaded();
                const i = this._checkLayer(e);
                i && i.slot !== t1 && (i.slot = t1, this._updateLayer(i));
            }
            setFilter(t1, i, o = {}) {
                this._checkLoaded();
                const r = this._checkLayer(t1);
                if (r && !e.bv(r.filter, i)) return null == i ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(Se, `layers.${r.id}.filter`, i, {
                    layerType: r.type
                }, o) || (r.filter = e.di(i), this._updateLayer(r)));
            }
            getFilter(t1) {
                const i = this._checkLayer(t1);
                if (i) return e.di(i.filter);
            }
            setLayoutProperty(t1, i, o, r = {}) {
                this._checkLoaded();
                const s = this._checkLayer(t1);
                if (s && !e.bv(s.getLayoutProperty(i), o)) {
                    if (null != o && (!r || !1 !== r.validate) && xo(s, Ce.call(me, {
                        key: `layers.${t1}.layout.${i}`,
                        layerType: s.type,
                        objectKey: i,
                        value: o,
                        styleSpec: e.a5,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))) return;
                    s.setLayoutProperty(i, o), 0 !== s.configDependencies.size && this._configDependentLayers.add(s.fqid), this._updateLayer(s);
                }
            }
            getLayoutProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getLayoutProperty(t1);
            }
            setPaintProperty(t1, i, o, r = {}) {
                this._checkLoaded();
                const s = this._checkLayer(t1);
                if (!s) return;
                if (e.bv(s.getPaintProperty(i), o)) return;
                if (null != o && (!r || !1 !== r.validate) && xo(s, Ie.call(me, {
                    key: `layers.${t1}.paint.${i}`,
                    layerType: s.type,
                    objectKey: i,
                    value: o,
                    styleSpec: e.a5
                }))) return;
                const n = s.setPaintProperty(i, o);
                0 !== s.configDependencies.size && this._configDependentLayers.add(s.fqid), n && this._updateLayer(s), this._changes.updatePaintProperties(s);
            }
            getPaintProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, r = this.getFragmentStyle(o), s = r.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of s)r.setFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.setFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, r = t1.sourceLayer, s = this._checkSource(o);
                if (!s) return;
                const n = s.type;
                if ("geojson" === n && r) return void this.fire(new e.z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === n && !r) return void this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e.z(new Error("The feature id parameter must be provided.")));
                const a = this.getOwnSourceCaches(o);
                for (const e of a)e.setFeatureState(r, t1.id, i);
            }
            removeFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, r = this.getFragmentStyle(o), s = r.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of s)r.removeFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.removeFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, r = this._checkSource(o);
                if (!r) return;
                const s = r.type, n = "vector" === s ? t1.sourceLayer : void 0;
                if ("vector" === s && !n) return void this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e.z(new Error("A feature id is required to remove its specific state property.")));
                const a = this.getOwnSourceCaches(o);
                for (const e of a)e.removeFeatureState(n, t1.id, i);
            }
            getFeatureState(t1) {
                if (this._checkLoaded(), "target" in t1) {
                    let i;
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: o, importId: r } = t1.target, s = this.getFragmentStyle(r), n = s.getFeaturesetLayers(o);
                        for (const { source: o, sourceLayer: r } of n){
                            const n = s.getFeatureState({
                                id: t1.id,
                                source: o,
                                sourceLayer: r
                            });
                            if (n && !i) i = n;
                            else if (!e.bv(i, n)) return void this.fire(new e.z(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                        }
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        i = this.getFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        });
                    }
                    return i;
                }
                const i = t1.source, o = t1.sourceLayer, r = this._checkSource(i);
                if (r) {
                    if ("vector" !== r.type || o) return void 0 === t1.id && this.fire(new e.z(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                }
            }
            setTransition(t1) {
                return this.stylesheet.transition = e.h({}, this.stylesheet.transition, t1), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
                return e.h({}, this.stylesheet.transition);
            }
            serialize() {
                this._checkLoaded();
                const t1 = this.getTerrain(), i = t1 && this.terrain && this.terrain.scope === this.scope ? t1 : this.stylesheet.terrain;
                return e.dp({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    fragment: this.stylesheet.fragment,
                    iconsets: this.stylesheet.iconsets,
                    imports: this._serializeImports(),
                    schema: this.stylesheet.schema,
                    camera: this.stylesheet.camera,
                    light: this.stylesheet.light,
                    lights: this.stylesheet.lights,
                    terrain: i,
                    fog: this.stylesheet.fog,
                    snow: this.stylesheet.snow,
                    rain: this.stylesheet.rain,
                    center: this.stylesheet.center,
                    "color-theme": this.stylesheet["color-theme"],
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: this._serializeSources(),
                    layers: this._serializeLayers(this._order)
                }, (e)=>void 0 !== e);
            }
            _updateFilteredLayers(e) {
                for (const t1 of Object.values(this._mergedLayers))e(t1) && this._updateLayer(t1);
            }
            _updateLayer(t1) {
                this._changes.updateLayer(t1);
                const i = this.getLayerSourceCache(t1), o = e.C(t1.source, t1.scope), r = this._changes.getUpdatedSourceCaches();
                t1.source && !r[o] && i && "raster" !== i.getSource().type && (this._changes.updateSourceCache(o, "reload"), i.pause()), t1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e) {
                const t1 = (e)=>this._mergedLayers[e].is3D(!!this.terrain), i = this.order, o = {}, r = [];
                for(let s = i.length - 1; s >= 0; s--){
                    const n = i[s];
                    if (t1(n)) {
                        o[n] = s;
                        for (const t1 of e){
                            const e = t1[n];
                            if (e) for (const t1 of e)r.push(t1);
                        }
                    }
                }
                r.sort((e, t1)=>t1.intersectionZ - e.intersectionZ);
                const s = [];
                for(let n = i.length - 1; n >= 0; n--){
                    const a = i[n];
                    if (t1(a)) for(let e = r.length - 1; e >= 0; e--){
                        const t1 = r[e].feature;
                        if (t1.layer && o[t1.layer.id] < n) break;
                        s.push(t1), r.pop();
                    }
                    else for (const t1 of e){
                        const e = t1[a];
                        if (e) for (const t1 of e)s.push(t1.feature);
                    }
                }
                return s;
            }
            queryRenderedFeatures(t1, i, o) {
                let r;
                i && !Array.isArray(i) && i.filter && (this._validate(Se, "queryRenderedFeatures.filter", i.filter, null, i), r = e.b3(i.filter));
                const s = {}, n = (e)=>{
                    if (To.has(e.type)) return;
                    const t1 = this.getOwnLayerSourceCache(e), i = s[t1.id] = s[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    e.is3D(!!this.terrain) && (i.has3DLayers = !0), i.layers[e.fqid] = i.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, i.layers[e.fqid].targets.push({
                        filter: r
                    });
                };
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e.z(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._layers[t1];
                        if (!i) return this.fire(new e.z(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        n(i);
                    }
                } else for(const e in this._layers)n(this._layers[e]);
                const a = this._queryRenderedFeatures(t1, s, o), l = this._flattenAndSortRenderedFeatures(a), c = [];
                for (const t1 of l)e.dq(t1.layer.id) === this.scope && c.push(t1);
                return c;
            }
            queryRenderedFeatureset(t1, i, o) {
                let r;
                i && !Array.isArray(i) && i.filter && (this._validate(Se, "queryRenderedFeatures.filter", i.filter, null, i), r = e.b3(i.filter));
                const s = "mock", n = [];
                if (i && i.target) n.push(Object.assign({}, i, {
                    targetId: s,
                    filter: r
                }));
                else {
                    const e = this.getFeaturesetDescriptors();
                    for (const t1 of e)n.push({
                        targetId: s,
                        filter: r,
                        target: t1
                    });
                    for (const { style: e } of this.fragments){
                        const t1 = e.getFeaturesetDescriptors();
                        for (const e of t1)n.push({
                            targetId: s,
                            filter: r,
                            target: e
                        });
                    }
                }
                const a = this.queryRenderedTargets(t1, n, o), l = [], c = new Set;
                for (const t1 of a)for (const i of t1.variants[s])lt(i, t1, c) || l.push(new e.dr(t1, i));
                return l;
            }
            queryRenderedTargets(t1, i, o) {
                const r = {}, s = (e, t1, i, o)=>{
                    const s = r[t1.id] = r[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    if (s.layers[e.fqid] = s.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, e.is3D(!!this.terrain) && (s.has3DLayers = !0), !o) return i.uniqueFeatureID = !1, void s.layers[e.fqid].targets.push(i);
                    s.layers[e.fqid].targets.push(Object.assign({}, i, {
                        namespace: o.namespace,
                        properties: o.properties,
                        uniqueFeatureID: o.uniqueFeatureID
                    }));
                };
                for (const t1 of i)if ("featuresetId" in t1.target) {
                    const { featuresetId: i, importId: o } = t1.target, r = this.getFragmentStyle(o);
                    if (!r || !r._featuresetSelectors) continue;
                    const n = r._featuresetSelectors[i];
                    if (!n) {
                        this.fire(new e.z(new Error(`The featureset '${i}' does not exist in the map's style and cannot be queried for features.`)));
                        continue;
                    }
                    for (const e of n){
                        const i = r.getOwnLayer(e.layerId);
                        i && !To.has(i.type) && s(i, r.getOwnLayerSourceCache(i), t1, e);
                    }
                } else if ("layerId" in t1.target) {
                    const { layerId: e } = t1.target, i = this.getLayer(e);
                    if (!i || To.has(i.type)) continue;
                    s(i, this.getLayerSourceCache(i), t1);
                }
                const n = this._queryRenderedFeatures(t1, r, o);
                return this._flattenAndSortRenderedFeatures(n);
            }
            _queryRenderedFeatures(e, t1, i) {
                const o = [], r = !!this.map._showQueryGeometry, s = Xe.createFromScreenPoints(e, i);
                for(const e in t1){
                    const n = ct(s, t1[e], this._availableImages, i, r);
                    Object.keys(n).length && o.push(n);
                }
                if (this.placement) for(const e in t1){
                    if (!t1[e].sourceCache._onlySymbols) continue;
                    const i = ht(s.screenGeometry, t1[e], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());
                    Object.keys(i).length && o.push(i);
                }
                return o;
            }
            querySourceFeatures(e, t1) {
                const i = t1 && t1.filter;
                i && this._validate(Se, "querySourceFeatures.filter", i, null, t1);
                let o = [];
                const r = this.getOwnSourceCaches(e);
                for (const e of r)o = o.concat(dt(e, t1));
                return o;
            }
            addSourceType(e, t1, i) {
                return Io.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Io.setSourceType(e, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getFlatLight() {
                return this.light.getLight();
            }
            setFlatLight(t1, i, o = {}) {
                this._checkLoaded();
                const r = this.light.getLight();
                let s = !1;
                for(const i in t1)if (!e.bv(t1[i], r[i])) {
                    s = !0;
                    break;
                }
                if (!s) return;
                const n = this._getTransitionParameters();
                this.light.setLight(t1, i, o), this.light.updateTransitions(n);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            checkCanvasFingerprintNoise() {
                void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(t1, i = 1) {
                if (this._checkLoaded(), !t1) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i && delete this.terrain, null === t1 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                this.checkCanvasFingerprintNoise();
                let o = t1;
                const r = null == t1.source;
                if (1 === i) {
                    if (this.disableElevatedTerrain) return;
                    if ("object" == typeof o.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, o.source), o = e.di(o), o = e.h(o, {
                            source: t1
                        });
                    }
                    const t1 = e.h({}, o), i = {};
                    if (this.terrain && r) {
                        t1.source = this.terrain.get().source;
                        const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                        e && (i.style = e.serialize());
                    }
                    if (this._validate(xe, "terrain", t1, i)) return;
                }
                if (!this.terrain || this.terrain.scope !== this.scope && !r || this.terrain && i !== this.terrain.drapeRenderMode) {
                    if (!o) return;
                    this._createTerrain(o, i), this.fire(new e.A("data", {
                        dataType: "style"
                    }));
                } else {
                    const i = this.terrain, r = i.get();
                    for (const t1 of Object.keys(e.a5.terrain))!o.hasOwnProperty(t1) && e.a5.terrain[t1].default && (o[t1] = e.a5.terrain[t1].default);
                    for(const o in t1)if (!e.bv(t1[o], r[o])) {
                        i.set(t1, this.options), this.stylesheet.terrain = t1;
                        const o = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(o), this.fire(new e.A("data", {
                            dataType: "style"
                        }));
                        break;
                    }
                }
                this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e) {
                const t1 = this.fog = new je(e, this.map.transform, this.scope, this.options);
                this.stylesheet.fog = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createSnow(e) {
                const t1 = this.snow = new Ze(e, this.map.transform, this.scope, this.options);
                this.stylesheet.snow = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createRain(e) {
                const t1 = this.rain = new We(e, this.map.transform, this.scope, this.options);
                this.stylesheet.rain = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e of this.map._markers)e._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(t1) {
                if (this._checkLoaded(), !t1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog;
                    if (!e.bv(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.fog = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createFog(t1);
                this._markersNeedUpdate = !0;
            }
            getSnow() {
                return this.snow ? this.snow.get() : null;
            }
            setSnow(t1) {
                if (this._checkLoaded(), !t1) return delete this.snow, void delete this.stylesheet.snow;
                if (this.snow) {
                    const i = this.snow;
                    if (!e.bv(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.snow = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createSnow(t1);
                this._markersNeedUpdate = !0;
            }
            getRain() {
                return this.rain ? this.rain.get() : null;
            }
            setRain(t1) {
                if (this._checkLoaded(), !t1) return delete this.rain, void delete this.stylesheet.rain;
                if (this.rain) {
                    const i = this.rain;
                    if (!e.bv(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.rain = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createRain(t1);
                this._markersNeedUpdate = !0;
            }
            _reloadColorTheme() {
                const t1 = ()=>{
                    for(const e in this._layers)this._layers[e].lut = this._styleColorTheme.lut;
                    for(const e in this._sourceCaches)this._sourceCaches[e].clearTiles();
                }, i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (!i) return this._styleColorTheme.lut = null, void t1();
                const o = this._evaluateColorThemeData(i);
                this._loadColorTheme(o).then(()=>{
                    this.fire(new e.A("colorthemeset")), t1();
                }).catch((t1)=>{
                    e.w(`Couldn't set color theme: ${t1}`);
                });
            }
            setColorTheme(t1) {
                this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t1, this._reloadColorTheme();
            }
            setImportColorTheme(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i._styleColorTheme.colorThemeOverride = t1, i._reloadColorTheme());
            }
            _getTransitionParameters(t1) {
                return {
                    now: e.q.now(),
                    transition: e.h(this.transition, t1)
                };
            }
            updateDrapeFirstLayers() {
                if (!this.terrain) return;
                const e = [], t1 = [];
                for (const i of this._mergedOrder)this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t1.push(i);
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e, t1) {
                const i = this.terrain = new ze(e, t1, this.scope, this.options, this.map.getWorldview());
                1 === t1 && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
                const o = this._getTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, r, s = {}) {
                if (s && !1 === s.validate) return !1;
                const n = e.h({}, this.serialize());
                return xo(this, t1.call(me, e.h({
                    key: i,
                    style: n,
                    value: o,
                    styleSpec: e.a5
                }, r)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.ds.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e in this._mergedLayers)this._mergedLayers[e].setEventedParent(null);
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);
                this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
            }
            clearSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.clearTiles();
            }
            clearSources() {
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles();
            }
            clearLayers() {
                for(const e in this._mergedLayers){
                    const t1 = this._mergedLayers[e];
                    t1._clear && t1._clear();
                }
            }
            reloadSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.resume(), e.reload();
            }
            reloadSources() {
                for (const e of this.getSources())e.reload && e.reload();
            }
            reloadModels() {
                this.modelManager.reloadModels(""), this.forEachFragmentStyle((e)=>{
                    e.modelManager.reloadModels(e.scope);
                });
            }
            updateSources(e) {
                let t1;
                this.directionalLight && (t1 = no(this.directionalLight));
                const i = new Set;
                for(const e in this._mergedLayers){
                    const t1 = this._mergedLayers[e];
                    t1.hasElevation() && !i.has(t1.source) && i.add(t1.source);
                }
                for(const o in this._mergedSourceCaches){
                    const r = this._mergedSourceCaches[o], s = i.has(r._source.id);
                    r.update(e, void 0, void 0, t1, s);
                }
            }
            _generateCollisionBoxes() {
                for(const e in this._sourceCaches){
                    const t1 = this._sourceCaches[e];
                    t1.resume(), t1.reload();
                }
            }
            _updatePlacement(t1, i, o, r, s, n, a = !1) {
                let l = !1, c = !1;
                const h = {}, d = {};
                for (const t1 of this._mergedOrder){
                    const o = this._mergedLayers[t1];
                    if ("symbol" !== o.type) continue;
                    const r = e.C(o.source, o.scope);
                    let s = h[r];
                    if (!s) {
                        const e = this.getLayerSourceCache(o);
                        if (!e) continue;
                        const t1 = e.getRenderableIds(!0).map((t1)=>e.getTileByID(t1));
                        d[r] = t1.slice(), s = h[r] = t1.sort((e, t1)=>t1.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const n = this.crossTileSymbolIndex.addLayer(o, s, i.center.lng, i.projection);
                    l = l || n;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a = a || this._layerOrderChanged || 0 === r, this._layerOrderChanged && this.fire(new e.A("neworder")), (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.q.now(), i.zoom)) && (this.pauseablePlacement = new Pi(i, this._mergedOrder, a, o, r, s, this.placement, this.fog && i.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h, d, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.q.now()), c = !0), l && this.pauseablePlacement.placement.setStale()), c || l) {
                    this._buildingIndex.onNewFrame(i.zoom);
                    for(let t1 = 0; t1 < this._mergedOrder.length; t1++){
                        const i = this._mergedLayers[this._mergedOrder[t1]];
                        if ("symbol" !== i.type) continue;
                        const o = this.isLayerClipped(i);
                        this.placement.updateLayerOpacities(i, h[e.C(i.source, i.scope)], t1, o ? n : null);
                    }
                }
                return {
                    needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.q.now())
                };
            }
            _releaseSymbolFadeTiles() {
                for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();
            }
            addImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports = this.stylesheet.imports || [];
                if (-1 !== o.findIndex(({ id: e })=>e === t1.id)) return void this.fire(new e.z(new Error(`Import with id '${t1.id}' already exists in the map's style.`)));
                if (!i) return o.push(t1), this._loadImports([
                    t1
                ], !0);
                const r = o.findIndex(({ id: e })=>e === i);
                return -1 === r && this.fire(new e.z(new Error(`Import with id "${i}" does not exist on this map.`))), this.stylesheet.imports = o.slice(0, r).concat(t1).concat(o.slice(r)), this._loadImports([
                    t1
                ], !0, i);
            }
            updateImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports || [], r = this.getImportIndex(t1);
                return -1 === r ? this : "string" == typeof i ? (this.setImportUrl(t1, i), this) : (i.url && i.url !== o[r].url && this.setImportUrl(t1, i.url), e.bv(i.config, o[r].config) || this.setImportConfig(t1, i.config, i.data.schema), e.bv(i.data, o[r].data) || this.setImportData(t1, i.data), this);
            }
            moveImport(e, t1) {
                this._checkLoaded();
                let i = this.stylesheet.imports || [];
                const o = this.getImportIndex(e);
                if (-1 === o) return this;
                const r = this.getImportIndex(t1);
                if (-1 === r) return this;
                const s = i[o], n = this.fragments[o];
                return i = i.filter(({ id: t1 })=>t1 !== e), this.fragments = this.fragments.filter(({ id: t1 })=>t1 !== e), this.stylesheet.imports = i.slice(0, r).concat(s).concat(i.slice(r)), this.fragments = this.fragments.slice(0, r).concat(n).concat(this.fragments.slice(r)), this.mergeLayers(), this;
            }
            setImportUrl(e, t1) {
                this._checkLoaded();
                const i = this.stylesheet.imports || [], o = this.getImportIndex(e);
                if (-1 === o) return this;
                i[o].url = t1;
                const r = this.fragments[o];
                return r.style = this._createFragmentStyle(i[o]), r.style.on("style.import.load", ()=>this.mergeAll()), r.style.loadURL(t1), this;
            }
            setImportData(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                return -1 === i ? this : t1 ? (this.fragments[i].style.setState(t1), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));
            }
            setImportConfig(e, t1, i) {
                this._checkLoaded();
                const o = this.getImportIndex(e), r = this.stylesheet.imports || [];
                if (-1 === o) return this;
                t1 ? r[o].config = t1 : delete r[o].config;
                const s = this.fragments[o];
                i && s.style.stylesheet && (s.style.stylesheet.schema = i);
                const n = s.style.stylesheet && s.style.stylesheet.schema;
                return s.config = t1, s.style.updateConfig(t1, n), this.updateConfigDependencies(), this;
            }
            removeImport(e) {
                this._checkLoaded();
                const t1 = this.stylesheet.imports || [], i = this.getImportIndex(e);
                -1 !== i && (t1.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());
            }
            getImportIndex(t1) {
                const i = (this.stylesheet.imports || []).findIndex((e)=>e.id === t1);
                return -1 === i && this.fire(new e.z(new Error(`Import '${t1}' does not exist in the map's style and cannot be updated.`))), i;
            }
            getLayer(e) {
                return this._mergedLayers[e];
            }
            getSources() {
                const e = [];
                for(const t1 in this._mergedOtherSourceCaches){
                    const i = this._mergedOtherSourceCaches[t1];
                    i && e.push(i.getSource());
                }
                return e;
            }
            getSource(e, t1) {
                const i = this.getSourceCache(e, t1);
                return i && i.getSource();
            }
            getLayerSource(e) {
                const t1 = this.getLayerSourceCache(e);
                return t1 && t1.getSource();
            }
            getSourceCache(t1, i) {
                const o = e.C(t1, i);
                return this._mergedOtherSourceCaches[o];
            }
            getLayerSourceCache(t1) {
                const i = e.C(t1.source, t1.scope);
                return "symbol" === t1.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];
            }
            getSourceCaches(e) {
                if (null == e) return Object.values(this._mergedSourceCaches);
                const t1 = [];
                return this._mergedOtherSourceCaches[e] && t1.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t1.push(this._mergedSymbolSourceCaches[e]), t1;
            }
            updateSourceCaches() {
                const e = this._changes.getUpdatedSourceCaches();
                for(const t1 in e){
                    const i = e[t1];
                    "reload" === i ? this.reloadSource(t1) : "clear" === i && this.clearSource(t1);
                }
            }
            updateLayers(e) {
                const t1 = this._changes.getUpdatedPaintProperties();
                for (const i of t1){
                    const t1 = this.getLayer(i);
                    t1 && t1.updateTransitions(e);
                }
            }
            getGlyphsUrl() {
                return this.stylesheet.glyphs;
            }
            setGlyphsUrl(e) {
                this.stylesheet.glyphs = e, this.glyphManager.setURL(e);
            }
            getImages(t1, i, o) {
                this.imageManager.getImages(i.images, i.scope, o), this._updateTilesForChangedImages();
                const r = (t1)=>{
                    if (t1) {
                        const o = i.images.map((t1)=>e.I.toString(t1));
                        t1.setDependencies(i.tileID.key, i.type, o);
                    }
                }, s = e.C(i.source, i.scope);
                r(this._mergedOtherSourceCaches[s]), r(this._mergedSymbolSourceCaches[s]), i.images.some((e)=>e.iconsetId) && this.fire(new e.A("data", {
                    dataType: "style"
                }));
            }
            rasterizeImages(e, t1, i) {
                this.imageManager.rasterizeImages(t1, i);
            }
            getGlyphs(e, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, i);
            }
            getResource(t1, i, o) {
                return e.dt(i, o);
            }
            getOwnSourceCache(e) {
                return this._otherSourceCaches[e];
            }
            getOwnLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }
            getOwnSourceCaches(e) {
                const t1 = [];
                return this._otherSourceCaches[e] && t1.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t1.push(this._symbolSourceCaches[e]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this.getOwnSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e.z(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e)=>e.loaded());
            }
            has3DLayers() {
                return this._has3DLayers;
            }
            hasSymbolLayers() {
                return this._hasSymbolLayers;
            }
            hasCircleLayers() {
                return this._hasCircleLayers;
            }
            isLayerClipped(e, t1) {
                if (!this._clipLayerPresent && "fill-extrusion" !== e.type && "building" !== e.type) return !1;
                const i = "fill-extrusion" === e.type && ("building" === e.sourceLayer || "procedural_buildings" === e.sourceLayer), o = "building" === e.type;
                if (e.is3D(!!this.terrain)) {
                    if (i || o || t1 && "batched-model" === t1.type) return !0;
                    if ("model" === e.type) return !0;
                } else if ("symbol" === e.type) return !0;
                return !1;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.fragments.forEach((e)=>{
                    e.style._remove();
                }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        Io.getSourceType = function(e) {
            return st[e];
        }, Io.setSourceType = function(e, t1) {
            st[e] = t1;
        }, Io.registerForPluginStateChange = e.du;
        var Co = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Ro = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Ao = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", Do = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Po = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", Lo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", zo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", Mo = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", Oo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Fo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", Bo = "#ifdef RENDER_SHADOWS\nprecision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {\n#ifdef CLIP_ZERO_TO_ONE\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);\n#else\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);\n#endif\nreturn texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;\n#ifdef SHADOWS_SINGLE_CASCADE\nvec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);\n#else\nlight_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const ko = [];
        qo(Co, ko), qo(Ao, ko), qo(Ro, ko);
        const No = {
            "_prelude_fog.vertex.glsl": Lo,
            "_prelude_terrain.vertex.glsl": Po,
            "_prelude_shadow.vertex.glsl": Fo,
            "_prelude_fog.fragment.glsl": zo,
            "_prelude_shadow.fragment.glsl": Bo,
            "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE",
            "_prelude_raster_array.glsl": Mo,
            "_prelude_raster_particle.glsl": Oo
        }, Uo = {};
        Ho("", Po), Ho(zo, Lo), Ho(Bo, Fo), Ho(Mo, ""), Ho(Oo, "");
        const jo = Ho(Ro, Ao), Go = Co;
        var Vo = {
            background: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            backgroundPattern: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            building: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nconst float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nin lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;\n#endif\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\nuniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}\n#ifdef BUILDING_FAUX_FACADE\nfloat hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;\n#if 0\nif (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;\n#else\nif (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;\n#endif\nreturn out_color;}\n#endif\nvec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;\n#ifdef BUILDING_FAUX_FACADE\nif (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}\n#endif\nvec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nshadowed_lighting_factor=dot(normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,base_color.rgb,emissive);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));\n#endif\ncolor.rgb=linearTosRGB(color.rgb);color*=u_opacity;\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_pos.z);\n#endif\nglFragColor=color; \n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nout lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nconst float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#ifdef BUILDING_FAUX_FACADE\nmat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}\n#endif\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;\n#ifdef BUILDING_FAUX_FACADE\nv_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);}\n#endif\nv_pos=a_pos_3f;\n#ifdef RENDER_CUTOFF\nvec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=v_pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(v_pos);\n#endif\ngl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);}'),
            buildingBloom: Ho("in vec4 v_color_emissive;\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\nfloat saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;\n#ifdef HAS_ATTRIBUTE_a_bloom_attenuation\nfloat distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);\n#endif\nglFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}", "in vec3 a_pos_3f;\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\nout vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\n#ifdef HAS_ATTRIBUTE_a_part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);\n#else\nv_color_emissive=vec4(1.0);\n#endif\ngl_Position=u_matrix*vec4(a_pos_3f,1.0);}"),
            buildingDepth: Ho("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            circle: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),
            clippingMask: Ho("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: Ho('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            heatmapTexture: Ho("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: Ho("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;\n#endif\nout float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);\n#ifdef PROJECTION_GLOBE_VIEW\n#ifndef PROJECTED_POS_ON_VIEWPORT\nvec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);\n#endif\n#endif\nvec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),
            collisionCircle: Ho("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: Ho("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),
            elevatedStructuresDepth: Ho("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"),
            elevatedStructuresDepthReconstruct: Ho("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"),
            elevatedStructures: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)\n{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nvec3 color=structure_color.xyz;\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,transformed_normal);\n#endif\ncolor=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nv_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fill: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'),
            fillOutline: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FLIP_Y\nv_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillOutlinePattern: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FLIP_Y\nv_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillPattern: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillExtrusion: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);\n#ifdef CLIP_ZERO_TO_ONE\ncutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);\n#else\ncutoff=cutoff_opacity(u_cutoff_params,ground.z);\n#endif\nif (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            fillExtrusionDepth: Ho("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),
            fillExtrusionPattern: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),
            groundShadow: Ho('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),
            fillExtrusionGroundEffect: Ho("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),
            hillshadePrepare: Ho("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            line: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nfloat left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            linePattern: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nuniform float u_emissive_strength;\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            raster: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),
            rasterParticle: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),
            rasterParticleDraw: Ho("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),
            rasterParticleTexture: Ho("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
            rasterParticleUpdate: Ho('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
            symbol: Ho('#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef TERRAIN\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#else\nout_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n}'),
            terrainRaster: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),
            terrainDepth: Ho("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),
            skybox: Ho('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Do),
            skyboxGradient: Ho('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Do),
            skyboxCapture: Ho("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),
            globeAtmosphere: Ho('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
            model: Ho('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;\n#ifdef FLIP_Y\nT=-T;B=-B;\n#endif\nhighp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));\n#ifdef FLIP_Y\nn=normalize(cross(fdx,fdy));\n#else\nn=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\n#ifdef FEATURE_CUTOUT\nfinalColor=apply_feature_cutout(finalColor,gl_FragCoord);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'),
            modelDepth: Ho("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
            stars: Ho("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
            snowParticle: Ho("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"),
            rainParticle: Ho("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"),
            vignette: Ho("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
            occlusion: Ho("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')
        };
        function qo(e, t1) {
            const i = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e of i)if (e = e.trim(), "#" === e[0] && e.includes("if") && !e.includes("endif")) {
                e = e.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i = e.split(" ");
                for (const e of i)t1.includes(e) || t1.push(e);
            }
        }
        function Ho(e, t1) {
            const i = /#include\s+"([^"]+)"/g, o = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
            let r = t1.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
            r && (r = r.map((e)=>{
                const t1 = e.split(" ");
                return t1[t1.length - 1];
            }), r = [
                ...new Set(r)
            ]);
            const s = {}, n = [], a = [];
            if (e = e.replace(i, (e, t1)=>(a.push(t1), "")), (t1 = t1.replace(i, (e, t1)=>(n.push(t1), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
            let l = [
                ...ko
            ];
            qo(e, l), qo(t1, l);
            for (const e of [
                ...n,
                ...a
            ])No[e] || console.error(`Undefined include: ${e}`), Uo[e] || (Uo[e] = [], qo(No[e], Uo[e])), l = [
                ...l,
                ...Uo[e]
            ];
            return {
                fragmentSource: e = e.replace(o, (e, t1, i, o, r)=>(s[r] = !0, "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nin ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize" === t1 ? `\n#ifdef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} ${r};\n#endif\n` : "initialize-attribute" === t1 ? "" : void 0)),
                vertexSource: t1 = t1.replace(o, (e, t1, i, o, r)=>{
                    const n = "float" === o ? "vec2" : o, a = r.match(/color/) ? "color" : n;
                    return "define-attribute-vertex-shader-only" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\nin ${i} ${o} a_${r};\n#endif\n` : s[r] ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\nout ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize" === t1 ? "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} a_${r};\n    out ${i} ${o} ${r};\n#endif\n` : "initialize-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${r} = a_${r};\n#endif\n` : void 0 : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "define-instanced" === t1 ? "mat4" === a ? `\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${r}0;\nin vec4 a_${r}1;\nin vec4 a_${r}2;\nin vec4 a_${r}3;\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : `\n#ifdef INSTANCED_ARRAYS\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize-attribute-custom" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${i} ${o} ${r} = a_${r};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`;
                }),
                staticAttributes: r,
                usedDefines: l,
                vertexIncludes: n,
                fragmentIncludes: a
            };
        }
        class Zo {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e, t1, i, o, r, s, n, a) {
                this.context = e;
                let l = this.boundPaintVertexBuffers.length !== o.length;
                for(let e = 0; !l && e < o.length; e++)this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);
                let c = this.boundDynamicVertexBuffers.length !== n.length;
                for(let e = 0; !c && e < n.length; e++)this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);
                if (!this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== r || this.boundVertexOffset !== s) this.freshBind(t1, i, o, r, s, n, a);
                else {
                    e.bindVertexArrayOES.set(this.vao);
                    for (const i of n)i && (i.bind(), a && i.instanceCount && i.setVertexAttribDivisor(e.gl, t1, a));
                    r && r.dynamicDraw && r.bind();
                }
            }
            freshBind(e, t1, i, o, r, s, n) {
                const a = e.numAttributes, l = this.context, c = l.gl;
                this.vao && this.destroy(), this.vao = l.gl.createVertexArray(), l.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = s, t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r);
                for (const t1 of i)t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r);
                for (const t1 of s)t1 && (t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r), n && t1.instanceCount && t1.setVertexAttribDivisor(c, e, n));
                o && o.bind(), l.currentNumAttributes = a;
            }
            destroy() {
                this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
        }
        function Wo(t1, i) {
            const o = Math.pow(2, i.canonical.z), r = i.canonical.y;
            return [
                new e.ac(0, r / o).toLngLat().lat,
                new e.ac(0, (r + 1) / o).toLngLat().lat
            ];
        }
        function $o(t1, i, o, r, s, n, a) {
            const l = t1.context, c = l.gl, h = o.hillshadeFBO;
            if (!h) return;
            t1.prepareDrawTile();
            const d = t1.isTileAffectedByFog(i), u = t1.getOrCreateProgram("hillshade", {
                overrideFog: d
            });
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const _ = ((t1, i, o, r)=>{
                const s = o.paint.get("hillshade-shadow-color"), n = "none" === o.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a = o.paint.get("hillshade-highlight-color"), l = "none" === o.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c = o.paint.get("hillshade-accent-color"), h = "none" === o.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d = o.paint.get("hillshade-emissive-strength");
                let u = e.al(o.paint.get("hillshade-illumination-direction"));
                if ("viewport" === o.paint.get("hillshade-illumination-anchor")) u -= t1.transform.angle;
                else if (t1.style && t1.style.enable3dLights() && t1.style.directionalLight) {
                    const i = t1.style.directionalLight.properties.get("direction"), o = e.d1(i.x, i.y, i.z);
                    u = e.al(o[1]);
                }
                const _ = !t1.options.moving;
                return {
                    u_matrix: r || t1.transform.calculateProjMatrix(i.tileID.toUnwrapped(), _),
                    u_image: 0,
                    u_latrange: Wo(0, i.tileID),
                    u_light: [
                        o.paint.get("hillshade-exaggeration"),
                        u
                    ],
                    u_shadow: s.toPremultipliedRenderColor(n ? null : o.lut),
                    u_highlight: a.toPremultipliedRenderColor(l ? null : o.lut),
                    u_emissive_strength: d,
                    u_accent: c.toPremultipliedRenderColor(h ? null : o.lut)
                };
            })(t1, o, r, t1.terrain ? i.projMatrix : null);
            t1.uploadCommonUniforms(l, u, i.toUnwrapped());
            const { tileBoundsBuffer: p, tileBoundsIndexBuffer: f, tileBoundsSegments: m } = t1.getTileBoundsBuffers(o);
            u.draw(t1, c.TRIANGLES, s, n, a, qi.disabled, _, r.id, p, f, m);
        }
        function Xo(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const r = t1.context, s = r.gl;
            r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const n = o.getPixels();
            i.demTexture ? i.demTexture.update(n, {
                premultiply: !1
            }) : i.demTexture = new e.T(r, n, s.R32F, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function Yo(t1, i, o) {
            const r = t1.context, s = r.gl;
            if (!i.dem) return;
            const n = i.dem;
            if (r.activeTexture.set(s.TEXTURE1), Xo(t1, i, n), !i.demTexture) return;
            i.demTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE);
            const a = n.dim;
            r.activeTexture.set(s.TEXTURE0);
            let l = i.hillshadeFBO;
            if (!l) {
                const t1 = new e.T(r, {
                    width: a,
                    height: a,
                    data: null
                }, s.RGBA8);
                t1.bind(s.LINEAR, s.CLAMP_TO_EDGE), l = i.hillshadeFBO = r.createFramebuffer(a, a, !0, "renderbuffer"), l.colorAttachment.set(t1.texture);
            }
            r.bindFramebuffer.set(l.framebuffer), r.viewport.set([
                0,
                0,
                a,
                a
            ]);
            const { tileBoundsBuffer: c, tileBoundsIndexBuffer: h, tileBoundsSegments: d } = t1.getMercatorTileBoundsBuffers(), u = [];
            t1.linearFloatFilteringSupported() && u.push("TERRAIN_DEM_FLOAT_FORMAT"), t1.getOrCreateProgram("hillshadePrepare", {
                defines: u
            }).draw(t1, s.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, ((t1, i)=>{
                const o = i.stride, r = e.bz();
                return e.ca(r, 0, e.aj, -e.aj, 0, 0, 1), e.bo(r, r, [
                    0,
                    -e.aj,
                    0
                ]), {
                    u_matrix: r,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ
                };
            })(i.tileID, n), o.id, c, h, d), i.needsHillshadePrepare = !1;
        }
        class Ko {
            constructor(e){
                this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class Jo extends Ko {
            getDefault() {
                return e.am.transparent.toNonPremultipliedRenderColor(null);
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class Qo extends Ko {
            getDefault() {
                return 1;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }
        class er extends Ko {
            getDefault() {
                return 0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }
        class tr extends Ko {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class ir extends Ko {
            getDefault() {
                return !0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }
        class or extends Ko {
            getDefault() {
                return 255;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }
        class rr extends Ko {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e) {
                const t1 = this.current;
                (e.func !== t1.func || e.ref !== t1.ref || e.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }
        class sr extends Ko {
            getDefault() {
                const e = this.gl;
                return [
                    e.KEEP,
                    e.KEEP,
                    e.KEEP
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }
        class nr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }
        class ar extends Ko {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class lr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }
        class cr extends Ko {
            getDefault() {
                return this.gl.LESS;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }
        class hr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e, this.dirty = !1;
            }
        }
        class dr extends Ko {
            getDefault() {
                const e = this.gl;
                return [
                    e.ONE,
                    e.ZERO,
                    e.ONE,
                    e.ZERO
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class ur extends Ko {
            getDefault() {
                return e.am.transparent.toNonPremultipliedRenderColor(null);
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class _r extends Ko {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);
            }
        }
        class pr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }
        class fr extends Ko {
            getDefault() {
                return this.gl.BACK;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }
        class mr extends Ko {
            getDefault() {
                return this.gl.CCW;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }
        let gr = class extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        };
        class vr extends Ko {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }
        class yr extends Ko {
            getDefault() {
                const e = this.gl;
                return [
                    0,
                    0,
                    e.drawingBufferWidth,
                    e.drawingBufferHeight
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class xr extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class br extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class wr extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }
        class Tr extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Er extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Sr extends Ko {
            getDefault() {
                return null;
            }
            set(e) {
                this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);
            }
        }
        class Ir extends Ko {
            getDefault() {
                return 4;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }
        class Cr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Rr extends Ko {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Ar extends Ko {
            constructor(e, t1){
                super(e), this.context = e, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class Dr extends Ar {
            setDirty() {
                this.dirty = !0;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Pr extends Ar {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Lr extends Ar {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, this.attachment(), t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class zr extends Pr {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        const Mr = (e, t1, i)=>({
                u_matrix: e,
                u_image0: 0,
                u_skirt_height: t1,
                u_ground_shadow_factor: i
            }), Or = (e, t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f)=>({
                u_proj_matrix: Float32Array.from(e),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: r,
                u_merc_center: s,
                u_image0: 0,
                u_frustum_tl: n,
                u_frustum_tr: a,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: d,
                u_viewport: u,
                u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),
                u_skirt_height: _,
                u_far_z_cutoff: p
            });
        function Fr(e, t1) {
            return null != e && null != t1 && !(!e.hasData() || !t1.hasData()) && null != e.demTexture && null != t1.demTexture && e.tileID.key !== t1.tileID.key;
        }
        const Br = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e, t1, i, o, r) {
                if (e in this.operations) {
                    const t1 = this.operations[e];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e] = {
                    startTime: o,
                    phase: 0,
                    duration: r,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;
                const t1 = this.operations[e];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e, t1) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t1, !0);
            }
            _validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }, kr = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING"
        };
        function Nr(e, t1, i) {
            if (0 === t1) return 0;
            const o = t1 < 1 && 514 === i ? .25 / t1 : 1;
            return 6 * Math.pow(1.5, 22 - e) * Math.max(t1, 1) * o;
        }
        function Ur(e, t1) {
            const i = 1 << e.z;
            return !t1 && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
        }
        const jr = (e)=>({
                u_matrix: e
            });
        function Gr(t1, i, o, r, s) {
            if (s > 0) {
                const n = e.q.now(), a = (n - t1.timeAdded) / s, l = i ? (n - i.timeAdded) / s : -1, c = o.getSource(), h = r.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), d = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), u = d && t1.refreshedUponExpiration ? 1 : e.ay(d ? a : 1 - l, 0, 1);
                return t1.refreshedUponExpiration && a >= 1 && (t1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - u
                } : {
                    opacity: u,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Vr extends It {
            constructor(e){
                const t1 = nt("mock-dem", {
                    type: "raster-dem",
                    maxzoom: e.transform.maxZoom
                }, e.style.dispatcher, e.style);
                super("mock-dem", t1, !1), t1.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e, t1) {
                e.state = "loaded", t1(null);
            }
        }
        class qr extends It {
            constructor(e){
                const t1 = nt("proxy", {
                    type: "geojson",
                    maxzoom: e.transform.maxZoom
                }, e.style.dispatcher, e.style);
                super("proxy", t1, !1), t1.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e, t1, i) {
                if (e.freezeTileCoverage) return;
                this.transform = e;
                const o = e.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((t1, i)=>{
                    if (t1[i.key] = "", !this._tiles[i.key]) {
                        const t1 = new wt(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom, void 0, void 0, this._source.worldview);
                        t1.state = "loaded", this._tiles[i.key] = t1;
                    }
                    return t1;
                }, {});
                for(const e in this._tiles)e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
            }
            freeFBO(e) {
                const t1 = this.proxyCachedFBO[e];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e)=>e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class Hr extends e.aM {
            constructor(e, t1, i){
                super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class Zr extends e.dF {
            constructor(t1, i){
                super(), this._debugParams = {
                    sortTilesHiZFirst: !0,
                    disableRenderCache: !1
                }, t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "sortTilesHiZFirst", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "disableRenderCache", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerButton([
                    "Terrain"
                ], "Invalidate Render Cache", ()=>{
                    this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
                }), this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, r, s] = function(t1) {
                    const i = new e.ba, o = new e.a_, r = 131;
                    i.reserve(17161), o.reserve(33800);
                    const s = e.aj / 128, n = e.aj + s / 2, a = n + s;
                    for(let t1 = -s; t1 < a; t1 += s)for(let o = -s; o < a; o += s){
                        const r = o < 0 || o > n || t1 < 0 || t1 > n ? 24575 : 0, s = e.ay(Math.round(o), 0, e.aj), a = e.ay(Math.round(t1), 0, e.aj);
                        i.emplaceBack(s + r, a);
                    }
                    const l = (e, t1)=>{
                        const i = t1 * r + e;
                        o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
                    };
                    for(let e = 1; e < 129; e++)for(let t1 = 1; t1 < 129; t1++)l(t1, e);
                    return [
                        0,
                        129
                    ].forEach((e)=>{
                        for(let t1 = 0; t1 < 130; t1++)l(t1, e), l(e, t1);
                    }), [
                        i,
                        o,
                        32768
                    ];
                }(), n = t1.context;
                this.gridBuffer = n.createVertexBuffer(o, e.bc.members), this.gridIndexBuffer = n.createIndexBuffer(r), this.gridSegments = e.bd.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.bd.simpleSegment(0, 0, o.length, s), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new qr(i.map), this.orthoMatrix = e.bz(), e.ca(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.aj, 0, e.aj, 0, 1);
                const a = n.gl;
                this._overlapStencilMode = new ji({
                    func: a.GEQUAL,
                    mask: 255
                }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Vr(i.map), this._pendingGroundEffectLayers = [];
            }
            set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1, this._evaluationZoom = void 0);
                    const r = t1.terrain.properties, s = 0 === t1.terrain.drapeRenderMode, n = t1.terrain.isZoomDependent();
                    this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.q.now();
                    const a = t1.terrain && t1.terrain.scope, l = r.get("source"), c = s ? this._mockSourceCache : t1.getSourceCache(l, a);
                    if (!c) return void e.w(`Couldn't find terrain source "${l}".`);
                    if (this.sourceCache = c, this._attenuationRange = t1.terrain.getAttenuationRange(), this._exaggeration = n ? this.calculateExaggeration(i) : r.get("exaggeration"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();
                    this.enabled = !0;
                    const h = ()=>{
                        this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;
                } else this._disable();
            }
            calculateExaggeration(t1) {
                if (this._attenuationRange && t1.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t1.zoom);
                const i = this._previousCameraAltitude, o = t1.getFreeCameraOptions().position.z / t1.pixelsPerMeter * t1.worldSize;
                this._previousCameraAltitude = o;
                const r = null != i ? o - i : Number.MAX_VALUE;
                if (Math.abs(r) < 2) return this._exaggeration;
                const s = t1.zoom, n = this._style.terrain;
                if (!this._previousUpdateTimestamp) return n.getExaggeration(s);
                let a = s - this._previousZoom;
                const l = this._previousUpdateTimestamp;
                let c = s;
                null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(s - c) > .5 && (a = .5 * (s - c + a)), a * r < 0 && (c += a)), this._evaluationZoom = c;
                const h = n.getExaggeration(c), d = h === n.getExaggeration(Math.max(0, c - .1));
                if (d && Math.abs(h - this._exaggeration) < .01) return h;
                let u = Math.min(.1, .00375 * (this._updateTimestamp - l));
                return (d || h < .1 || Math.abs(a) < 1e-4) && (u = Math.min(.2, 4 * u)), e.ai(this._exaggeration, h, u);
            }
            resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {};
            }
            attenuationRange() {
                return this._attenuationRange;
            }
            getDemUpscale() {
                return this.proxySourceCache.getSource().tileSize / 128;
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e) {
                e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e in this._style._mergedSourceCaches)this._style._mergedSourceCaches[e].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e)=>e.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e,
                    e
                ];
            }
            set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.ac.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const r = this.proxyCoords = i.getIds().map((e)=>{
                    const t1 = i.getTileByID(e).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), r = new e.P(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e.P(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), s = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), n = r.mult(1 << t1.canonical.z);
                        return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(s);
                    });
                }(r, this.painter);
                const s = this.proxyToSource || {};
                this.proxyToSource = {}, r.forEach((e)=>{
                    this.proxyToSource[e.key] = {};
                }), this.terrainTileForTile = {};
                const n = this._style._mergedSourceCaches;
                for(const e in n){
                    const i = n[e];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e], s), i.usedForTerrain) continue;
                    const o = t1[e];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = r.map((e)=>new Hr(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s), this.renderingToTexture = !1;
                const a = {};
                this._visibleDemTiles = [];
                for (const e of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in a || (this._visibleDemTiles.push(t1), a[i] = i);
                }
            }
            _assignTerrainTiles(e) {
                this._initializing || e.forEach((e)=>{
                    if (this.terrainTileForTile[e.key]) return;
                    const t1 = this._findTileCoveringTileID(e, this.sourceCache);
                    t1 && (this.terrainTileForTile[e.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e = this.painter.context, t1 = e.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], r = o.dem;
                    !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t1.TEXTURE1), Xo(this.painter, o, r));
                }
            }
            _prepareDemTileUniforms(e, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const r = e.tileID.canonical, s = Math.pow(2, t1.tileID.canonical.z - r.z), n = o || "";
                return i[`u_dem_tl${n}`] = [
                    r.x * s % 1,
                    r.y * s % 1
                ], i[`u_dem_scale${n}`] = s, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
                if (!this.enabled) return 0;
                let e = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e++, t1 + o;
                }, 0);
                return e ? t1 / e : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), r = new e.dG({
                    width: 1,
                    height: 1
                }, new Float32Array([
                    o
                ]));
                this._emptyDEMTextureDirty = !1;
                let s = this._emptyDEMTexture;
                return s ? s.update(r, {
                    premultiply: !1
                }) : s = this._emptyDEMTexture = new e.T(t1, r, i.R32F, {
                    premultiply: !1
                }), s;
            }
            setupElevationDraw(t1, i, o) {
                const r = this.painter.context, s = r.gl, n = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                };
                n.u_exaggeration = this.exaggeration();
                let a = null, l = null, c = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t1, e, n, "_prev") && (l = e), this._prepareDemTileUniforms(t1, i, n) && (a = i));
                }
                const h = (e)=>e && e.demTexture && this.painter.linearFloatFilteringSupported() ? s.LINEAR : s.NEAREST;
                let d = null;
                var u;
                if (this.enabled ? l && a ? (d = a.demTexture, r.activeTexture.set(s.TEXTURE4), l.demTexture.bind(h(l), s.CLAMP_TO_EDGE), n.u_dem_lerp = c) : (a = this.terrainTileForTile[t1.tileID.key], d = this._prepareDemTileUniforms(t1, a, n) ? a.demTexture : this.emptyDEMTexture) : d = this.emptyDEMTexture, r.activeTexture.set(s.TEXTURE2), d && (n.u_dem_size = 1 === (u = d).size[0] ? 1 : u.size[0] - 2, d.bind(h(a), s.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o && o.useDepthForOcclusion, i, n), o && o.useMeterToDem && a) {
                    const t1 = (1 << a.tileID.canonical.z) * e.cb(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    n.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, n), "globe" === this.painter.transform.projection.name) {
                    const e = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(r, e);
                }
            }
            globeUniformValues(t1, i, o) {
                const r = t1.projection;
                return {
                    u_tile_tl_up: r.upVector(i, 0, 0),
                    u_tile_tr_up: r.upVector(i, e.aj, 0),
                    u_tile_br_up: r.upVector(i, e.aj, e.aj),
                    u_tile_bl_up: r.upVector(i, 0, e.aj),
                    u_tile_up_scale: o ? e.dH(1) : r.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, r, s) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, r, s) {
                        const n = t1.context, a = n.gl;
                        let l, c;
                        const h = t1.transform, d = e.dy(t1, n, h), u = (e, i)=>{
                            if (c === i) return;
                            const o = [
                                kr[i],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            d && o.push("CUSTOM_ANTIALIASING");
                            const r = t1.isTileAffectedByFog(e);
                            l = t1.getOrCreateProgram("globeRaster", {
                                defines: o,
                                overrideFog: r
                            }), c = i;
                        }, _ = t1.colorModeForRenderPass(), p = new Ni(a.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D);
                        Br.update(s);
                        const f = e.dz(h), m = [
                            e.aD(h.center.lng),
                            e.aH(h.center.lat)
                        ], g = t1.globeSharedBuffers, v = [
                            h.width * e.q.devicePixelRatio,
                            h.height * e.q.devicePixelRatio
                        ], y = Float32Array.from(h.globeMatrix), x = {
                            useDenormalizedUpVectorScale: !0
                        };
                        {
                            const h = t1.transform, d = Nr(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                            c = -1;
                            const b = a.TRIANGLES;
                            for (const c of r){
                                const r = o.getTile(c), w = ji.disabled, T = i.prevTerrainTileForTile[c.key], E = i.terrainTileForTile[c.key];
                                Fr(T, E) && Br.newMorphing(c.key, T, E, s, 250), n.activeTexture.set(a.TEXTURE0), r.texture && r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const S = Br.getMorphValuesForProxy(c.key), I = S ? 1 : 0;
                                S && e.L(x, {
                                    morphing: {
                                        srcDemTile: S.from,
                                        dstDemTile: S.to,
                                        phase: e.dx(S.phase)
                                    }
                                });
                                const C = e.dA(c.canonical), R = e.dB(C.getCenter().lat), A = e.dC(c.canonical, C, R, h.worldSize / h._pixelsPerMercatorPixel), D = e.bh(e.dD(c.canonical)), P = Or(h.expandedFarZProjMatrix, y, f, D, e.ah(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, d, h._farZ, A);
                                if (u(c, I), l && (i.setupElevationDraw(r, l, x), t1.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {
                                    const [e, i, o] = g.getGridBuffers(R, 0 !== d);
                                    l.draw(t1, b, p, w, _, qi.backCCW, P, "globe_raster", e, i, o);
                                }
                            }
                        }
                        if (g && (t1.renderDefaultNorthPole || t1.renderDefaultSouthPole)) {
                            const s = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            d && s.push("CUSTOM_ANTIALIASING"), l = t1.getOrCreateProgram("globeRaster", {
                                defines: s
                            });
                            for (const s of r){
                                const { x: r, y: c, z: d } = s.canonical, u = 0 === c, f = c === (1 << d) - 1, [y, b, w, T] = g.getPoleBuffers(d, !1);
                                if (T && (u || f)) {
                                    const c = o.getTile(s);
                                    n.activeTexture.set(a.TEXTURE0), c.texture && c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    let g = e.dE(d, r, h);
                                    const E = e.bh(e.dD(s.canonical)), S = (e, i)=>e.draw(t1, a.TRIANGLES, p, ji.disabled, _, qi.disabled, Or(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), "globe_pole_raster", i, w, T);
                                    i.setupElevationDraw(c, l, x), t1.uploadCommonUniforms(n, l, s.toUnwrapped()), u && t1.renderDefaultNorthPole && S(l, y), f && t1.renderDefaultSouthPole && (g = e.cP(e.bz(), g, [
                                        1,
                                        -1,
                                        1
                                    ]), S(l, b));
                                }
                            }
                        }
                    }(t1, i, o, r, s);
                    else {
                        const n = t1.context, a = n.gl;
                        let l, c;
                        const h = t1.shadowRenderer, d = eo(t1, t1.longestCutoffRange), u = (e)=>{
                            if (c === e) return;
                            const i = [];
                            i.push(kr[e]), d.shouldRenderCutoff && i.push("RENDER_CUTOFF"), h && (i.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h.useNormalOffset && i.push("NORMAL_OFFSET")), l = t1.getOrCreateProgram("terrainRaster", {
                                defines: i
                            }), c = e;
                        }, _ = t1.colorModeForRenderPass(), p = new Ni(a.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D);
                        Br.update(s);
                        const f = t1.transform, m = Nr(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                        let g = [
                            0,
                            0,
                            0
                        ];
                        if (h) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (g = ao(t1.style, e, i));
                        }
                        {
                            c = -1;
                            const v = a.TRIANGLES, [y, x] = [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of r){
                                const r = o.getTile(c), b = ji.disabled, w = i.prevTerrainTileForTile[c.key], T = i.terrainTileForTile[c.key];
                                Fr(w, T) && Br.newMorphing(c.key, w, T, s, 250), n.activeTexture.set(a.TEXTURE0), r.texture && r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const E = Br.getMorphValuesForProxy(c.key), S = E ? 1 : 0;
                                let I;
                                E && (I = {
                                    morphing: {
                                        srcDemTile: E.from,
                                        dstDemTile: E.to,
                                        phase: e.dx(E.phase)
                                    }
                                });
                                const C = Mr(c.projMatrix, Ur(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);
                                if (u(S), !l) continue;
                                i.setupElevationDraw(r, l, I);
                                const R = c.toUnwrapped();
                                h && h.setupShadows(R, l), t1.uploadCommonUniforms(n, l, R, null, d), l.draw(t1, v, p, b, _, qi.backCCW, C, "terrain_raster", i.gridBuffer, y, x);
                            }
                        }
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, r = this.proxySourceCache, s = this.proxiedCoords[r.id], n = this._drapedRenderBatches.shift(), a = i.style.order, l = [];
                let c = 0;
                for (const h of s){
                    const s = r.getTileByID(h.proxyTileKey), d = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t1] : void 0, u = void 0 !== d ? r.renderCache[d] : this.pool[c++], _ = void 0 !== d;
                    if (s.texture = u.tex, _ && !u.dirty) {
                        l.push(s.tileID);
                        continue;
                    }
                    let p;
                    o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({
                        color: e.am.transparent,
                        stencil: 0
                    }), u.dirty = !1);
                    for(let e = n.start; e <= n.end; ++e){
                        const t1 = i.style._mergedLayers[a[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style.getLayerSourceCache(t1), s = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!s) continue;
                        const n = s;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(u, s, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, n);
                    }
                    if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers){
                        const t1 = i.style._mergedLayers[a[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style.getLayerSourceCache(t1), s = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!s) continue;
                        const n = s;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(u, s, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, n);
                    }
                    this.renderedToTile ? (u.dirty = !0, l.push(s.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));
                }
                return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), n.end + 1;
            }
            postRender() {}
            isLayerOrderingCorrect(e) {
                const t1 = e.order.length;
                let i = -1, o = t1;
                for(let r = 0; r < t1; ++r)this._style.isLayerDraped(e._mergedLayers[e.order[r]]) ? i = Math.max(i, r) : o = Math.min(o, r);
                return o > i;
            }
            getMinElevationBelowMSL() {
                let e = 0;
                return this._visibleDemTiles.filter((e)=>e.dem).forEach((t1)=>{
                    e = Math.min(e, t1.dem.tree.minimums[0]);
                }), 0 === e ? e : (e - 30) * this._exaggeration;
            }
            raycast(e, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e)=>e.dem).map((o)=>{
                    const r = o.tileID, s = 1 << r.overscaledZ, { x: n, y: a } = r.canonical, l = n / s, c = (n + 1) / s, h = a / s, d = (a + 1) / s;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: d,
                        t: o.dem.tree.raycastRoot(l, h, c, d, e, t1, i),
                        tile: o
                    };
                });
                o.sort((e, t1)=>(null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const r of o){
                    if (null == r.t) return null;
                    const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const r = new e.T(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA8);
                r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const s = t1.createFramebuffer(o[0], o[1], !0, null);
                return s.colorAttachment.set(r.texture), s.depthAttachment = new zr(t1, s.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, s.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : s.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: s,
                    tex: r,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._debugParams.disableRenderCache) return !0;
                if (this._style.hasLightTransitions()) return !0;
                for(const e in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[e].hasTransition()) return !0;
                return this._style.order.some((e)=>{
                    const t1 = this._style._mergedLayers[e], i = t1.isHidden(this.painter.transform.zoom);
                    return "hillshade" === t1.type || "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e of this._style.getSources())if (e instanceof it) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._mergedLayers[this._style.order[t1]], r = this._style.getLayerSourceCache(o);
                    if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e.ab) {
                        i[r.id] = !0;
                        for (const e of this.proxyCoords){
                            const t1 = this.proxyToSource[e.key][r.id];
                            if (t1) for (const e of t1)this._clearRenderCacheForTile(r.id, e);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e = !1;
                for(const t1 in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[t1]._source instanceof ot) {
                    e = !0;
                    break;
                }
                if (!e) return;
                const t1 = {};
                for(let e = 0; e < this._style.order.length; ++e){
                    const i = this._style._mergedLayers[this._style.order[e]], o = this._style.getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const r = i.paint.get("raster-fade-duration");
                    for (const e of this.proxyCoords){
                        const t1 = this.proxyToSource[e.key][o.id];
                        if (t1) for (const e of t1){
                            const t1 = Gr(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                this._style.updateDrapeFirstLayers();
                const t1 = this._style.order, i = t1.length;
                if (0 === i) return;
                const o = [];
                this._pendingGroundEffectLayers = [];
                let r, s = 0, n = this._style._mergedLayers[t1[s]];
                for(; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++s < i;)n = this._style._mergedLayers[t1[s]];
                for(; s < i; ++s){
                    const e = this._style._mergedLayers[t1[s]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === r && (r = s) : ("fill-extrusion" === e.type && this._pendingGroundEffectLayers.push(s), void 0 !== r && (o.push({
                        start: r,
                        end: s - 1
                    }), r = void 0)));
                }
                if (void 0 !== r && o.push({
                    start: r,
                    end: s - 1
                }), 0 !== o.length) {
                    const t1 = o[o.length - 1];
                    this._pendingGroundEffectLayers.every((e)=>e > t1.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
                }
                this._drapedRenderBatches = o;
            }
            _setupRenderCache(e) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                    if (this.invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e.length; ++i){
                            const o = Object.values(e[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let r = i.length - 1; r >= 0; r--){
                    const s = i[r];
                    if (t1.getTileByID(s.key), void 0 !== t1.proxyCachedFBO[s.key]) {
                        const i = e[s.key], r = this.proxyToSource[s.key];
                        let n = 0;
                        for(const e in r){
                            const t1 = r[e], s = i[e];
                            if (!s || s.length !== t1.length || t1.some((t1, i)=>t1 !== s[i] || o[e] && o[e].hasOwnProperty(t1.key))) {
                                n = -1;
                                break;
                            }
                            ++n;
                        }
                        for(const e in t1.proxyCachedFBO[s.key])t1.renderCache[t1.proxyCachedFBO[s.key][e]].dirty = n < 0 || n !== Object.values(i).length;
                    }
                }
                const r = [
                    ...this._drapedRenderBatches
                ];
                r.sort((e, t1)=>t1.end - t1.start - (e.end - e.start));
                for (const e of r)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const r = this.painter.context, s = r.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let n;
                if (i.isTileClipped()) n = t1.length, this._overlapStencilMode.test = {
                    func: s.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    n = 1, this._overlapStencilMode.test = {
                        func: s.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + n > 255 && (r.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : ji.disabled;
            }
            _renderTileClippingMasks(e, t1) {
                const i = this.painter, o = this.painter.context, r = o.gl;
                i._tileClippingMaskIDs = {}, o.setColorMode(ki.disabled), o.setDepthMode(Ni.disabled);
                const s = i.getOrCreateProgram("clippingMask");
                for (const o of e){
                    const e = i._tileClippingMaskIDs[o.key] = --t1;
                    s.draw(i, r.TRIANGLES, Ni.disabled, new ji({
                        func: r.ALWAYS,
                        mask: 0
                    }, e, 255, r.KEEP, r.KEEP, r.REPLACE), ki.disabled, qi.disabled, jr(o.projMatrix), "$clipping", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aA(o, o, i.pixelMatrixInverse), e.cH(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const r = i._camera.position, s = e.cb(1, i.center.lat), n = [
                    r[0],
                    r[1],
                    r[2] / s,
                    0
                ], a = e.d7([], o.slice(0, 3), n);
                e.au(a, a);
                const l = this.raycast(n, a, this._exaggeration);
                return null !== l && l ? (e.bE(n, n, a, l), n[3] = n[2], n[2] *= s, n) : null;
            }
            _setupProxiedCoordsForOrtho(t1, i, o) {
                if (t1.getSource() instanceof e.aP) return this._setupProxiedCoordsForImageSource(t1, i, o);
                this._findCoveringTileCache[t1.id] = this._findCoveringTileCache[t1.id] || {};
                const r = this.proxiedCoords[t1.id] = [], s = this.proxyCoords;
                for(let e = 0; e < s.length; e++){
                    const i = s[e], n = this._findTileCoveringTileID(i, t1);
                    if (n) {
                        const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t1.id]);
                        r.push(e), this.proxyToSource[i.key][t1.id] = [
                            e
                        ];
                    }
                }
                let n = !1;
                const a = new Set;
                for(let e = 0; e < i.length; e++){
                    const s = t1.getTile(i[e]);
                    if (!s || !s.hasData()) continue;
                    const l = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
                    if (l && l.tileID.canonical.z !== s.tileID.canonical.z) {
                        const e = this.proxyToSource[l.tileID.key][t1.id], i = this._createProxiedId(l.tileID, s, o[l.tileID.key] && o[l.tileID.key][t1.id]);
                        e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t1.id] = [
                            i
                        ];
                        const c = this.proxyToSource[l.tileID.key][t1.id];
                        a.has(c) || a.add(c), r.push(i), n = !0;
                    }
                }
                if (this._sourceTilesOverlap[t1.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of a)e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const r = this.proxiedCoords[t1.id] = [], s = this.proxyCoords, n = t1.getSource(), a = n.tileID;
                if (!a) return;
                const l = new e.P(a.x, a.y)._div(1 << a.z), c = n.coordinates.map(e.ac.fromLngLat).reduce((e, t1)=>(e.min.x = Math.min(e.min.x, t1.x - l.x), e.min.y = Math.min(e.min.y, t1.y - l.y), e.max.x = Math.max(e.max.x, t1.x - l.x), e.max.y = Math.max(e.max.y, t1.y - l.y), e), {
                    min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), h = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), r = t1.canonical.y / (1 << t1.canonical.z), s = e.aj / (1 << t1.canonical.z), n = i.wrap + i.canonical.x / (1 << i.canonical.z), a = i.canonical.y / (1 << i.canonical.z);
                    return o + s < n + c.min.x || o > n + c.max.x || r + s < a + c.min.y || r > a + c.max.y;
                };
                for(let e = 0; e < s.length; e++){
                    const n = s[e];
                    for(let e = 0; e < i.length; e++){
                        const s = t1.getTile(i[e]);
                        if (!s || !s.hasData()) continue;
                        if (h(n, s.tileID)) continue;
                        const a = this._createProxiedId(n, s, o[n.key] && o[n.key][t1.id]), l = this.proxyToSource[n.key][t1.id];
                        l ? l.push(a) : this.proxyToSource[n.key][t1.id] = [
                            a
                        ], r.push(a);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let r = this.orthoMatrix;
                if (o) {
                    const e = o.find((e)=>e.key === i.tileID.key);
                    if (e) return e;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let s, n, a;
                    r = e.bz();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (s = e.aj >> o, n = s * ((i.tileID.canonical.x << o) - t1.canonical.x + l), a = s * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (s = e.aj << -o, n = e.aj * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), a = e.aj * (i.tileID.canonical.y - (t1.canonical.y << -o))), e.ca(r, 0, s, 0, s, 0, 1), e.bo(r, r, [
                        n,
                        a,
                        0
                    ]);
                }
                return new Hr(i.tileID, t1.key, r);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const r = this._findCoveringTileCache[i.id], s = r[t1.key];
                if (o = s ? i.getTileByID(s) : null, o && o.hasData() || null === s) return o;
                let n = o ? o.tileID : t1, a = n.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!s) {
                    const r = i.getSource().maxzoom;
                    if (t1.canonical.z >= r) {
                        const o = t1.canonical.z - r;
                        i.getSource().reparseOverscaled ? (a = Math.max(t1.canonical.z + 2, i.transform.tileZoom), n = new e.aM(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (a = r, n = new e.aM(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    n.key !== t1.key && (c.push(n.key), o = i.getTile(n));
                }
                const h = (e)=>{
                    c.forEach((t1)=>{
                        r[t1] = e;
                    }), c.length = 0;
                };
                for(a -= 1; a >= l && (!o || !o.hasData()); a--){
                    o && h(o.tileID.key);
                    const e = n.calculateScaledKey(a);
                    if (o = i.getTileByID(e), o && o.hasData()) break;
                    const t1 = r[e];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e, t1) {
                let i = this._tilesDirty[e];
                i || (i = this._tilesDirty[e] = {}), i[t1.key] = !0;
            }
        }
        function Wr(t1, i, o) {
            const r = function(t1, i, o) {
                const r = e.bG(i, t1), s = e.bG(o, [
                    .2126,
                    .7152,
                    .0722
                ]), n = (e, t1, i)=>(1 - i) * e + i * t1, a = n(1 - .3 * Math.min(s, 1), 1, Math.min(r + 1, 1));
                return n(.92, 1, Math.asin(e.ay(i[2], -1, 1)) / Math.PI + .5) * a;
            }(t1, [
                0,
                0,
                1
            ], i), s = [
                0,
                0,
                0
            ];
            e.c1(s, o.slice(0, 3), r);
            const n = [
                0,
                0,
                0
            ];
            e.c1(n, i.slice(0, 3), t1[2]);
            const a = [
                0,
                0,
                0
            ];
            return e.d5(a, s, n), e.d8(a);
        }
        const $r = [
            "fill",
            "fillOutline",
            "fillPattern",
            "line",
            "linePattern",
            "background",
            "backgroundPattern",
            "hillshade",
            "raster"
        ], Xr = [
            "stars",
            "rainParticle",
            "snowParticle",
            "fillExtrusion",
            "fillExtrusionGroundEffect",
            "elevatedStructures",
            "model",
            "symbol"
        ];
        class Yr {
            static cacheKey(e, t1, i, o) {
                let r = `${t1}${o ? o.cacheKey : ""}`;
                for (const t1 of i)e.usedDefines.includes(t1) && (r += `/${t1}`);
                return r;
            }
            constructor(t1, i, o, r, s, n){
                const a = t1.gl;
                this.program = a.createProgram(), this.configuration = r, this.name = i, this.fixedDefines = [
                    ...n
                ];
                const l = r ? r.getBinderAttributes() : [], c = (o.staticAttributes || []).concat(l);
                let h = r ? r.defines() : [];
                h = h.concat(n.map((e)=>`#define ${e}`));
                const d = "#version 300 es\n";
                let u = d + h.concat("precision mediump float;", Go, jo.fragmentSource).join("\n");
                for (const e of o.fragmentIncludes)u += `\n${No[e]}`;
                u += `\n${o.fragmentSource}`;
                let _ = d + h.concat("precision highp float;", Go, jo.vertexSource).join("\n");
                for (const e of o.vertexIncludes)_ += `\n${No[e]}`;
                this.forceManualRenderingForInstanceIDShaders = t1.forceManualRenderingForInstanceIDShaders && -1 !== o.vertexSource.indexOf("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && (_ += "\nuniform int u_instanceID;\n"), _ += `\n${o.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (_ = _.replaceAll("gl_InstanceID", "u_instanceID"));
                const p = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(p, u), a.compileShader(p), a.attachShader(this.program, p);
                const f = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost()) this.failedToCreate = !0;
                else {
                    a.shaderSource(f, _), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = c.length;
                    for(let e = 0; e < this.numAttributes; e++)if (c[e]) {
                        const t1 = c[e].startsWith("a_") ? c[e] : `a_${c[e]}`;
                        a.bindAttribLocation(this.program, e, t1), this.attributes[t1] = e;
                    }
                    a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(p), this.fixedUniforms = s(t1), this.binderUniforms = r ? r.getUniforms(t1) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t1)=>({
                            u_instanceID: new e.cd(t1)
                        }))(t1)), (n.includes("TERRAIN") || -1 !== i.indexOf("symbol") || -1 !== i.indexOf("circle")) && (this.terrainUniforms = ((t1)=>({
                            u_dem: new e.cd(t1),
                            u_dem_prev: new e.cd(t1),
                            u_dem_tl: new e.cg(t1),
                            u_dem_scale: new e.cf(t1),
                            u_dem_tl_prev: new e.cg(t1),
                            u_dem_scale_prev: new e.cf(t1),
                            u_dem_size: new e.cf(t1),
                            u_dem_lerp: new e.cf(t1),
                            u_exaggeration: new e.cf(t1),
                            u_depth: new e.cd(t1),
                            u_depth_size_inv: new e.cg(t1),
                            u_depth_range_unpack: new e.cg(t1),
                            u_occluder_half_size: new e.cf(t1),
                            u_occlusion_depth_offset: new e.cf(t1),
                            u_meter_to_dem: new e.cf(t1),
                            u_label_plane_matrix_inv: new e.ch(t1)
                        }))(t1)), n.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                            u_tile_tl_up: new e.ce(t1),
                            u_tile_tr_up: new e.ce(t1),
                            u_tile_br_up: new e.ce(t1),
                            u_tile_bl_up: new e.ce(t1),
                            u_tile_up_scale: new e.cf(t1)
                        }))(t1)), n.includes("FOG") && (this.fogUniforms = ((t1)=>({
                            u_fog_matrix: new e.ch(t1),
                            u_fog_range: new e.cg(t1),
                            u_fog_color: new e.d0(t1),
                            u_fog_horizon_blend: new e.cf(t1),
                            u_fog_vertical_limit: new e.cg(t1),
                            u_fog_temporal_offset: new e.cf(t1),
                            u_frustum_tl: new e.ce(t1),
                            u_frustum_tr: new e.ce(t1),
                            u_frustum_br: new e.ce(t1),
                            u_frustum_bl: new e.ce(t1),
                            u_globe_pos: new e.ce(t1),
                            u_globe_radius: new e.cf(t1),
                            u_globe_transition: new e.cf(t1),
                            u_is_globe: new e.cd(t1),
                            u_viewport: new e.cg(t1)
                        }))(t1)), n.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t1)=>({
                            u_cutoff_params: new e.d0(t1)
                        }))(t1)), n.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t1)=>({
                            u_lighting_ambient_color: new e.ce(t1),
                            u_lighting_directional_dir: new e.ce(t1),
                            u_lighting_directional_color: new e.ce(t1),
                            u_ground_radiance: new e.ce(t1)
                        }))(t1)), n.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t1)=>({
                            u_light_matrix_0: new e.ch(t1),
                            u_light_matrix_1: new e.ch(t1),
                            u_fade_range: new e.cg(t1),
                            u_shadow_normal_offset: new e.ce(t1),
                            u_shadow_intensity: new e.cf(t1),
                            u_shadow_texel_size: new e.cf(t1),
                            u_shadow_map_resolution: new e.cf(t1),
                            u_shadow_direction: new e.ce(t1),
                            u_shadow_bias: new e.ce(t1),
                            u_shadowmap_0: new e.cd(t1),
                            u_shadowmap_1: new e.cd(t1)
                        }))(t1));
                }
            }
            setTerrainUniformValues(e, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setGlobeUniformValues(e, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setFogUniformValues(e, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setCutoffUniformValues(e, t1) {
                if (!this.cutoffUniforms) return;
                const i = this.cutoffUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setLightsUniformValues(e, t1) {
                if (!this.lightsUniforms) return;
                const i = this.lightsUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setShadowUniformValues(e, t1) {
                if (this.failedToCreate || !this.shadowUniforms) return;
                const i = this.shadowUniforms;
                e.program.set(this.program);
                for(const e in t1)i[e].set(this.program, e, t1[e]);
            }
            _drawDebugWireframe(t1, i, o, r, s, n, a, l, c, h) {
                const d = t1.options.wireframe;
                if (!1 === d.terrain && !1 === d.layers2D && !1 === d.layers3D) return;
                const u = t1.context;
                if (!(()=>!(!d.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d.layers2D || t1._terrain && t1._terrain.renderingToTexture || !$r.includes(this.name)) || !(!d.layers3D || !Xr.includes(this.name)))()) return;
                const _ = u.gl, p = t1.wireframeDebugCache.getLinesFromTrianglesBuffer(t1.frameCounter, s, u);
                if (!p) return;
                const f = [
                    ...this.fixedDefines
                ];
                f.push("DEBUG_WIREFRAME");
                const m = t1.getOrCreateProgram(this.name, {
                    config: this.configuration,
                    defines: f
                });
                u.program.set(m.program);
                const g = (e, t1, i)=>{
                    if (t1[e] && i[e]) for(const o in t1[e])i[e][o] && i[e][o].set(i.program, o, t1[e][o].current);
                };
                c && c.setUniforms(m.program, u, m.binderUniforms, a, {
                    zoom: l
                }), g("fixedUniforms", this, m), g("terrainUniforms", this, m), g("globeUniforms", this, m), g("fogUniforms", this, m), g("lightsUniforms", this, m), g("shadowUniforms", this, m), p.bind(), u.setColorMode(new ki([
                    _.ONE,
                    _.ONE_MINUS_SRC_ALPHA,
                    _.ZERO,
                    _.ONE
                ], e.am.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ])), u.setDepthMode(new Ni(i.func === _.LESS ? _.LEQUAL : i.func, Ni.ReadOnly, i.range)), u.setStencilMode(ji.disabled);
                const v = 3 * n.primitiveLength * 2, y = 3 * n.primitiveOffset * 2 * 2;
                if (this.forceManualRenderingForInstanceIDShaders) {
                    const e = h || 1;
                    for(let t1 = 0; t1 < e; ++t1)m.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t1), _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                } else h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, y, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                s.bind(), u.program.set(this.program), u.setDepthMode(i), u.setStencilMode(o), u.setColorMode(r);
            }
            checkUniforms(e, t1, i) {
                if (this.fixedDefines.includes(t1)) {
                    for (const o of Object.keys(i))if (!i[o].initialized) throw new Error(`Program '${this.name}', from draw '${e}': uniform ${o} not set but required by ${t1} being defined`);
                }
            }
            draw(e, t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f) {
                const m = e.context, g = m.gl;
                if (this.failedToCreate) return;
                m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(r), m.setCullFace(s);
                for (const e of Object.keys(this.fixedUniforms))this.fixedUniforms[e].set(this.program, e, n[e]);
                _ && _.setUniforms(this.program, m, this.binderUniforms, d, {
                    zoom: u
                });
                const v = {
                    [g.POINTS]: 1,
                    [g.LINES]: 2,
                    [g.TRIANGLES]: 3,
                    [g.LINE_STRIP]: 1
                }[t1];
                this.checkUniforms(a, "RENDER_SHADOWS", this.shadowUniforms);
                const y = f && f > 0 ? 1 : void 0;
                for (const s of h.get()){
                    const n = s.vaos || (s.vaos = {});
                    if ((n[a] || (n[a] = new Zo)).bind(m, this, l, _ ? _.getPaintVertexBuffers() : [], c, s.vertexOffset, p || [], y), this.forceManualRenderingForInstanceIDShaders) {
                        const e = f || 1;
                        for(let i = 0; i < e; ++i)this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i), c ? g.drawElements(t1, s.primitiveLength * v, g.UNSIGNED_SHORT, s.primitiveOffset * v * 2) : g.drawArrays(t1, s.vertexOffset, s.vertexLength);
                    } else f && f > 1 ? g.drawElementsInstanced(t1, s.primitiveLength * v, g.UNSIGNED_SHORT, s.primitiveOffset * v * 2, f) : c ? g.drawElements(t1, s.primitiveLength * v, g.UNSIGNED_SHORT, s.primitiveOffset * v * 2) : g.drawArrays(t1, s.vertexOffset, s.vertexLength);
                    t1 === g.TRIANGLES && c && this._drawDebugWireframe(e, i, o, r, c, s, d, u, _, f);
                }
            }
        }
        function Kr(t1, i, o = 0) {
            const r = Math.pow(2, i.tileID.overscaledZ), s = i.tileSize * Math.pow(2, t1.transform.tileZoom) / r, n = s * (i.tileID.canonical.x + i.tileID.wrap * r), a = s * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: 1 / e.aw(i, 1, t1.transform.tileZoom),
                u_pixel_coord_upper: [
                    n >> 16,
                    a >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & n,
                    65535 & a
                ],
                u_pattern_transition: o
            };
        }
        const Jr = {
            terrain: 0,
            flat: 1
        }, Qr = e.bz(), es = (t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v)=>{
            const y = i.style.light, x = y.properties.get("position"), b = [
                x.x,
                x.y,
                x.z
            ], w = e.dJ();
            "viewport" === y.properties.get("anchor") && (e.dK(w, -i.transform.angle), e.dL(b, b, w));
            const T = y.properties.get("color").toPremultipliedRenderColor(null), E = i.transform, S = {
                u_matrix: t1,
                u_lightpos: b,
                u_lightintensity: y.properties.get("intensity"),
                u_lightcolor: [
                    T.r,
                    T.g,
                    T.b
                ],
                u_vertical_gradient: +o,
                u_opacity: r,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Qr,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_height_type: Jr[h],
                u_base_type: Jr[d],
                u_ao: s,
                u_edge_radius: n,
                u_width_scale: a,
                u_flood_light_color: f,
                u_vertical_scale: m,
                u_flood_light_intensity: g,
                u_ground_shadow_factor: v
            };
            return "globe" === E.projection.name && (S.u_tile_id = [
                l.canonical.x,
                l.canonical.y,
                1 << l.canonical.z
            ], S.u_zoom_transition = u, S.u_inv_rot_matrix = p, S.u_merc_center = _, S.u_up_dir = E.projection.upVector(new e.cA(0, 0, 0), _[0] * e.aj, _[1] * e.aj), S.u_height_lift = c), S;
        }, ts = (e, t1, i, o, r, s)=>({
                u_matrix: e,
                u_edge_radius: t1,
                u_width_scale: i,
                u_vertical_scale: o,
                u_height_type: Jr[r],
                u_base_type: Jr[s]
            }), is = (t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v)=>{
            const y = es(t1, i, o, r, s, n, a, l, h, d, u, _, p, f, m, g, 1, [
                0,
                0,
                0
            ]), x = {
                u_height_factor: -Math.pow(2, l.overscaledZ) / c.tileSize / 8
            };
            return e.h(y, Kr(i, c, v), x);
        }, os = (e, t1, i)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_ground_shadow_factor: i
            }), rs = (t1, i, o, r, s, n = 0)=>e.h(os(t1, i, s), Kr(o, r, n)), ss = (e, t1, i, o)=>({
                u_matrix: e,
                u_world: i,
                u_emissive_strength: t1,
                u_ground_shadow_factor: o
            }), ns = (t1, i, o, r, s, n, a = 0)=>e.h(rs(t1, i, o, r, n, a), {
                u_world: s
            }), as = (e, t1)=>({
                u_matrix: e,
                u_ground_shadow_factor: t1
            }), ls = (e, t1, i, o, r)=>({
                u_matrix: e,
                u_camera_pos: [
                    t1[0],
                    t1[1],
                    t1[2]
                ],
                u_depth_bias: i,
                u_height_scale: o,
                u_reset_depth: r
            }), cs = (e, t1)=>({
                u_matrix: e,
                u_normal_matrix: t1,
                u_opacity: 1
            }), hs = (e)=>({
                u_matrix: e
            }), ds = (e)=>({
                u_matrix: e
            }), us = (t1, i, o, r, s, n, a, l)=>{
            const c = e.aj / n.tileSize;
            return {
                u_matrix: t1,
                u_inv_rot_matrix: i,
                u_camera_to_center_distance: o.getCameraToCenterDistance(l),
                u_extrude_scale: [
                    o.pixelsToGLUnits[0] / c,
                    o.pixelsToGLUnits[1] / c
                ],
                u_zoom_transition: r,
                u_tile_id: a,
                u_merc_center: s
            };
        }, _s = (e, t1, i = 1)=>({
                u_matrix: e,
                u_color: t1,
                u_overlay: 0,
                u_overlay_scale: i
            }), ps = e.bz(), fs = (t1, i, o, r, s, n, a)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e.dM(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.aw(o, 1, n), d = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: a,
                u_inv_rot_matrix: ps,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                d.u_inv_rot_matrix = r, d.u_merc_center = s, d.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], d.u_zoom_transition = e.ah(l.zoom);
                const t1 = s[0] * e.aj, o = s[1] * e.aj;
                d.u_up_dir = l.projection.upVector(new e.cA(0, 0, 0), t1, o);
            }
            return d;
        };
        function ms(e, [t1, i, o, r], [s, n]) {
            if (s === n) return [
                0,
                0,
                0,
                0
            ];
            const a = 255 * (e - 1) / (e * (n - s));
            return [
                t1 * a,
                i * a,
                o * a,
                r * a
            ];
        }
        function gs(e, t1, [i, o]) {
            return i === o ? 0 : .5 / e + (t1 - i) * (e - 1) / (e * (o - i));
        }
        const vs = (t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b)=>({
                u_matrix: t1,
                u_normalize_matrix: i,
                u_globe_matrix: o,
                u_merc_matrix: r,
                u_grid_matrix: s,
                u_tl_parent: n,
                u_scale_parent: h,
                u_fade_t: d.mix,
                u_opacity: d.opacity * u.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: u.paint.get("raster-brightness-min"),
                u_brightness_high: u.paint.get("raster-brightness-max"),
                u_saturation_factor: e.dO(u.paint.get("raster-saturation")),
                u_contrast_factor: e.dN(u.paint.get("raster-contrast")),
                u_spin_weights: ys(u.paint.get("raster-hue-rotate")),
                u_perspective_transform: _,
                u_raster_elevation: p,
                u_zoom_transition: a,
                u_merc_center: l,
                u_cutoff_params: c,
                u_colorization_mix: ms(e.dP, m, v),
                u_colorization_offset: gs(e.dP, g, v),
                u_color_ramp: f,
                u_texture_offset: [
                    x / (y + 2 * x),
                    y / (y + 2 * x)
                ],
                u_texture_res: [
                    y + 2 * x,
                    y + 2 * x
                ],
                u_emissive_strength: b
            });
        function ys(e) {
            e *= Math.PI / 180;
            const t1 = Math.sin(e), i = Math.cos(e);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const xs = .05, bs = (e, t1, i, o, r, s, n, a, l, c, h, d)=>({
                u_matrix: e,
                u_normalize_matrix: t1,
                u_globe_matrix: i,
                u_merc_matrix: o,
                u_grid_matrix: r,
                u_tl_parent: s,
                u_scale_parent: c,
                u_fade_t: h.mix,
                u_opacity: h.opacity,
                u_image0: 0,
                u_image1: 1,
                u_raster_elevation: d,
                u_zoom_transition: n,
                u_merc_center: a,
                u_cutoff_params: l
            }), ws = (e, t1, i, o, r, s, n, a, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_tile_offset: i,
                u_velocity: o,
                u_color_ramp: s,
                u_velocity_res: r,
                u_max_speed: n,
                u_uv_offset: a,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    xs,
                    xs
                ]
            }), Ts = (e, t1, i, o, r, s, n, a, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_velocity: i,
                u_velocity_res: o,
                u_max_speed: r,
                u_speed_factor: s,
                u_reset_rate: n,
                u_rand_seed: Math.random(),
                u_uv_offset: a,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    xs,
                    xs
                ]
            }), Es = e.bz(), Ss = (t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b, w, T, E)=>{
            const S = s.transform, I = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: S.getCameraToCenterDistance(y),
                u_rotate_symbol: +o,
                u_aspect_ratio: S.width / S.height,
                u_fade_change: s.options.fadeDuration ? s.symbolFadeChange : 1,
                u_matrix: n,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +h,
                u_elevation_from_sea: c ? 1 : 0,
                u_pitch_with_map: +r,
                u_texsize: d,
                u_texsize_icon: u,
                u_texture: 0,
                u_texture_icon: 1,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Es,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: Es,
                u_up_vector: [
                    0,
                    -1,
                    0
                ],
                u_color_adj_mat: w,
                u_icon_transition: T || 0,
                u_gamma_scale: r ? s.transform.getCameraToCenterDistance(y) * Math.cos(s.terrain ? 0 : s.transform._pitch) : 1,
                u_device_pixel_ratio: e.q.devicePixelRatio,
                u_is_halo: 1,
                u_scale_factor: E || 1,
                u_ground_shadow_factor: x,
                u_inv_matrix: e.bi(e.bz(), a),
                u_normal_scale: b
            };
            return "globe" === y.name && (I.u_tile_id = [
                p.canonical.x,
                p.canonical.y,
                1 << p.canonical.z
            ], I.u_zoom_transition = f, I.u_inv_rot_matrix = g, I.u_merc_center = m, I.u_camera_forward = S._camera.forward(), I.u_ecef_origin = e.dQ(S.globeMatrix, p.toUnwrapped()), I.u_tile_matrix = Float32Array.from(S.globeMatrix), I.u_up_vector = v), I;
        }, Is = (e, t1, i, o)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_opacity: i,
                u_color: o
            }), Cs = (t1, i, o, r, s, n, a, l, c)=>e.h(function(t1, i, o, r, s, n) {
                const { width: a, height: l } = r.imageManager.getPixelSize(i), c = Math.pow(2, n.tileID.overscaledZ), h = n.tileSize * Math.pow(2, r.transform.tileZoom) / c, d = h * (n.tileID.canonical.x + n.tileID.wrap * c), u = h * n.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        a,
                        l
                    ],
                    u_pattern_size: o.displaySize,
                    u_pattern_units_to_pixels: s ? [
                        r.transform.width,
                        -1 * r.transform.height
                    ] : [
                        1 / e.aw(n, 1, r.transform.tileZoom),
                        1 / e.aw(n, 1, r.transform.tileZoom)
                    ],
                    u_pixel_coord_upper: [
                        d >> 16,
                        u >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & d,
                        65535 & u
                    ]
                };
            }(0, n, a, r, l, c), {
                u_matrix: t1,
                u_emissive_strength: i,
                u_opacity: o
            }), Rs = new Float32Array(e.bx([])), As = (t1, i, o, r, s, n, a, l, c, h, d, u, _, p = [
            0,
            0,
            0
        ], f)=>{
            const m = s.style.light, g = m.properties.get("position"), v = [
                -g.x,
                -g.y,
                g.z
            ], y = e.dJ();
            "viewport" === m.properties.get("anchor") && (e.dK(y, -s.transform.angle), e.dL(v, v, y));
            const x = "MASK" === d.alphaMode, b = m.properties.get("color").toNonPremultipliedRenderColor(null), w = _.paint.get("model-ambient-occlusion-intensity"), T = _.paint.get("model-color").constantOr(e.am.white).toNonPremultipliedRenderColor(null);
            return T.a = _.paint.get("model-color-mix-intensity").constantOr(0), {
                u_matrix: t1,
                u_lighting_matrix: i,
                u_normal_matrix: o,
                u_node_matrix: r || Rs,
                u_lightpos: v,
                u_lightintensity: m.properties.get("intensity"),
                u_lightcolor: [
                    b.r,
                    b.g,
                    b.b
                ],
                u_camera_pos: p,
                u_opacity: n,
                u_baseTextureIsAlpha: 0,
                u_alphaMask: +x,
                u_alphaCutoff: d.alphaCutoff,
                u_baseColorFactor: a.toNonPremultipliedRenderColor(null).toArray01(),
                u_emissiveFactor: l.toNonPremultipliedRenderColor(null).toArray01(),
                u_metallicFactor: c,
                u_roughnessFactor: h,
                u_baseColorTexture: Yi.BaseColor,
                u_metallicRoughnessTexture: Yi.MetallicRoughness,
                u_normalTexture: Yi.Normal,
                u_occlusionTexture: Yi.Occlusion,
                u_emissionTexture: Yi.Emission,
                u_lutTexture: Yi.LUT,
                u_color_mix: T.toArray01(),
                u_aoIntensity: w,
                u_emissive_strength: u,
                u_occlusionTextureTransform: f || [
                    0,
                    0,
                    0,
                    0
                ]
            };
        }, Ds = (e, t1 = Rs, i = Rs)=>({
                u_matrix: e,
                u_instance: t1,
                u_node_matrix: i
            }), Ps = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_lightpos: new e.ce(t1),
                    u_lightintensity: new e.cf(t1),
                    u_lightcolor: new e.ce(t1),
                    u_vertical_gradient: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_edge_radius: new e.cf(t1),
                    u_width_scale: new e.cf(t1),
                    u_ao: new e.cg(t1),
                    u_height_type: new e.cd(t1),
                    u_base_type: new e.cd(t1),
                    u_tile_id: new e.ce(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_inv_rot_matrix: new e.ch(t1),
                    u_merc_center: new e.cg(t1),
                    u_up_dir: new e.ce(t1),
                    u_height_lift: new e.cf(t1),
                    u_flood_light_color: new e.ce(t1),
                    u_vertical_scale: new e.cf(t1),
                    u_flood_light_intensity: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            fillExtrusionDepth: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_edge_radius: new e.cf(t1),
                    u_width_scale: new e.cf(t1),
                    u_vertical_scale: new e.cf(t1),
                    u_height_type: new e.cd(t1),
                    u_base_type: new e.cd(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_lightpos: new e.ce(t1),
                    u_lightintensity: new e.cf(t1),
                    u_lightcolor: new e.ce(t1),
                    u_vertical_gradient: new e.cf(t1),
                    u_height_factor: new e.cf(t1),
                    u_edge_radius: new e.cf(t1),
                    u_width_scale: new e.cf(t1),
                    u_ao: new e.cg(t1),
                    u_height_type: new e.cd(t1),
                    u_base_type: new e.cd(t1),
                    u_tile_id: new e.ce(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_inv_rot_matrix: new e.ch(t1),
                    u_merc_center: new e.cg(t1),
                    u_up_dir: new e.ce(t1),
                    u_height_lift: new e.cf(t1),
                    u_image: new e.cd(t1),
                    u_texsize: new e.cg(t1),
                    u_pixel_coord_upper: new e.cg(t1),
                    u_pixel_coord_lower: new e.cg(t1),
                    u_tile_units_to_pixels: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_pattern_transition: new e.cf(t1)
                }),
            fillExtrusionGroundEffect: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_opacity: new e.cf(t1),
                    u_ao_pass: new e.cf(t1),
                    u_meter_to_tile: new e.cf(t1),
                    u_ao: new e.cg(t1),
                    u_flood_light_intensity: new e.cf(t1),
                    u_flood_light_color: new e.ce(t1),
                    u_attenuation: new e.cf(t1),
                    u_edge_radius: new e.cf(t1),
                    u_fb: new e.cd(t1),
                    u_fb_size: new e.cf(t1),
                    u_dynamic_offset: new e.cf(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_image: new e.cd(t1),
                    u_texsize: new e.cg(t1),
                    u_pixel_coord_upper: new e.cg(t1),
                    u_pixel_coord_lower: new e.cg(t1),
                    u_tile_units_to_pixels: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1),
                    u_pattern_transition: new e.cf(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_world: new e.cg(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_world: new e.cg(t1),
                    u_image: new e.cd(t1),
                    u_texsize: new e.cg(t1),
                    u_pixel_coord_upper: new e.cg(t1),
                    u_pixel_coord_lower: new e.cg(t1),
                    u_tile_units_to_pixels: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1),
                    u_pattern_transition: new e.cf(t1)
                }),
            building: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_normal_matrix: new e.ch(t1),
                    u_opacity: new e.cf(t1)
                }),
            buildingBloom: (t1)=>({
                    u_matrix: new e.ch(t1)
                }),
            buildingDepth: (t1)=>({
                    u_matrix: new e.ch(t1)
                }),
            elevatedStructuresDepth: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_depth_bias: new e.cf(t1)
                }),
            elevatedStructures: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            elevatedStructuresDepthReconstruct: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_camera_pos: new e.ce(t1),
                    u_depth_bias: new e.cf(t1),
                    u_height_scale: new e.cf(t1),
                    u_reset_depth: new e.cf(t1)
                }),
            circle: e.dT,
            collisionBox: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_inv_rot_matrix: new e.ch(t1),
                    u_camera_to_center_distance: new e.cf(t1),
                    u_extrude_scale: new e.cg(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_merc_center: new e.cg(t1),
                    u_tile_id: new e.ce(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_inv_matrix: new e.ch(t1),
                    u_camera_to_center_distance: new e.cf(t1),
                    u_viewport_size: new e.cg(t1)
                }),
            debug: (t1)=>({
                    u_color: new e.dv(t1),
                    u_matrix: new e.ch(t1),
                    u_overlay: new e.cd(t1),
                    u_overlay_scale: new e.cf(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e.ch(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e.cf(t1),
                    u_intensity: new e.cf(t1),
                    u_matrix: new e.ch(t1),
                    u_inv_rot_matrix: new e.ch(t1),
                    u_merc_center: new e.cg(t1),
                    u_tile_id: new e.ce(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_up_dir: new e.ce(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e.cd(t1),
                    u_color_ramp: new e.cd(t1),
                    u_opacity: new e.cf(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_image: new e.cd(t1),
                    u_latrange: new e.cg(t1),
                    u_light: new e.cg(t1),
                    u_shadow: new e.dv(t1),
                    u_highlight: new e.dv(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_accent: new e.dv(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_image: new e.cd(t1),
                    u_dimension: new e.cg(t1),
                    u_zoom: new e.cf(t1)
                }),
            line: e.dS,
            linePattern: e.dR,
            raster: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_normalize_matrix: new e.ch(t1),
                    u_globe_matrix: new e.ch(t1),
                    u_merc_matrix: new e.ch(t1),
                    u_grid_matrix: new e.dw(t1),
                    u_tl_parent: new e.cg(t1),
                    u_scale_parent: new e.cf(t1),
                    u_fade_t: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_image0: new e.cd(t1),
                    u_image1: new e.cd(t1),
                    u_brightness_low: new e.cf(t1),
                    u_brightness_high: new e.cf(t1),
                    u_saturation_factor: new e.cf(t1),
                    u_contrast_factor: new e.cf(t1),
                    u_spin_weights: new e.ce(t1),
                    u_perspective_transform: new e.cg(t1),
                    u_raster_elevation: new e.cf(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_merc_center: new e.cg(t1),
                    u_cutoff_params: new e.d0(t1),
                    u_colorization_mix: new e.d0(t1),
                    u_colorization_offset: new e.cf(t1),
                    u_color_ramp: new e.cd(t1),
                    u_texture_offset: new e.cg(t1),
                    u_texture_res: new e.cg(t1),
                    u_emissive_strength: new e.cf(t1)
                }),
            rasterParticle: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_normalize_matrix: new e.ch(t1),
                    u_globe_matrix: new e.ch(t1),
                    u_merc_matrix: new e.ch(t1),
                    u_grid_matrix: new e.dw(t1),
                    u_tl_parent: new e.cg(t1),
                    u_scale_parent: new e.cf(t1),
                    u_fade_t: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_image0: new e.cd(t1),
                    u_image1: new e.cd(t1),
                    u_raster_elevation: new e.cf(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_merc_center: new e.cg(t1),
                    u_cutoff_params: new e.d0(t1)
                }),
            rasterParticleTexture: (t1)=>({
                    u_texture: new e.cd(t1),
                    u_opacity: new e.cf(t1)
                }),
            rasterParticleDraw: (t1)=>({
                    u_particle_texture: new e.cd(t1),
                    u_particle_texture_side_len: new e.cf(t1),
                    u_tile_offset: new e.cg(t1),
                    u_velocity: new e.cd(t1),
                    u_color_ramp: new e.cd(t1),
                    u_velocity_res: new e.cg(t1),
                    u_max_speed: new e.cf(t1),
                    u_uv_offset: new e.cg(t1),
                    u_data_scale: new e.cg(t1),
                    u_data_offset: new e.cf(t1),
                    u_particle_pos_scale: new e.cf(t1),
                    u_particle_pos_offset: new e.cg(t1)
                }),
            rasterParticleUpdate: (t1)=>({
                    u_particle_texture: new e.cd(t1),
                    u_particle_texture_side_len: new e.cf(t1),
                    u_velocity: new e.cd(t1),
                    u_velocity_res: new e.cg(t1),
                    u_max_speed: new e.cf(t1),
                    u_speed_factor: new e.cf(t1),
                    u_reset_rate: new e.cf(t1),
                    u_rand_seed: new e.cf(t1),
                    u_uv_offset: new e.cg(t1),
                    u_data_scale: new e.cg(t1),
                    u_data_offset: new e.cf(t1),
                    u_particle_pos_scale: new e.cf(t1),
                    u_particle_pos_offset: new e.cg(t1)
                }),
            symbol: (t1)=>({
                    u_is_size_zoom_constant: new e.cd(t1),
                    u_is_size_feature_constant: new e.cd(t1),
                    u_size_t: new e.cf(t1),
                    u_size: new e.cf(t1),
                    u_camera_to_center_distance: new e.cf(t1),
                    u_rotate_symbol: new e.cd(t1),
                    u_aspect_ratio: new e.cf(t1),
                    u_fade_change: new e.cf(t1),
                    u_matrix: new e.ch(t1),
                    u_label_plane_matrix: new e.ch(t1),
                    u_coord_matrix: new e.ch(t1),
                    u_is_text: new e.cd(t1),
                    u_elevation_from_sea: new e.cd(t1),
                    u_pitch_with_map: new e.cd(t1),
                    u_texsize: new e.cg(t1),
                    u_texsize_icon: new e.cg(t1),
                    u_texture: new e.cd(t1),
                    u_texture_icon: new e.cd(t1),
                    u_gamma_scale: new e.cf(t1),
                    u_device_pixel_ratio: new e.cf(t1),
                    u_tile_id: new e.ce(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_inv_rot_matrix: new e.ch(t1),
                    u_merc_center: new e.cg(t1),
                    u_camera_forward: new e.ce(t1),
                    u_tile_matrix: new e.ch(t1),
                    u_up_vector: new e.ce(t1),
                    u_ecef_origin: new e.ce(t1),
                    u_is_halo: new e.cd(t1),
                    u_icon_transition: new e.cf(t1),
                    u_color_adj_mat: new e.ch(t1),
                    u_scale_factor: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1),
                    u_inv_matrix: new e.ch(t1),
                    u_normal_scale: new e.cf(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_color: new e.dv(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_image: new e.cd(t1),
                    u_pattern_tl: new e.cg(t1),
                    u_pattern_br: new e.cg(t1),
                    u_texsize: new e.cg(t1),
                    u_pattern_size: new e.cg(t1),
                    u_pixel_coord_upper: new e.cg(t1),
                    u_pixel_coord_lower: new e.cg(t1),
                    u_pattern_units_to_pixels: new e.cg(t1)
                }),
            terrainRaster: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_image0: new e.cd(t1),
                    u_skirt_height: new e.cf(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            skybox: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_sun_direction: new e.ce(t1),
                    u_cubemap: new e.cd(t1),
                    u_opacity: new e.cf(t1),
                    u_temporal_offset: new e.cf(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_color_ramp: new e.cd(t1),
                    u_center_direction: new e.ce(t1),
                    u_radius: new e.cf(t1),
                    u_opacity: new e.cf(t1),
                    u_temporal_offset: new e.cf(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e.dw(t1),
                    u_sun_direction: new e.ce(t1),
                    u_sun_intensity: new e.cf(t1),
                    u_color_tint_r: new e.d0(t1),
                    u_color_tint_m: new e.d0(t1),
                    u_luminance: new e.cf(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e.ch(t1),
                    u_globe_matrix: new e.ch(t1),
                    u_normalize_matrix: new e.ch(t1),
                    u_merc_matrix: new e.ch(t1),
                    u_zoom_transition: new e.cf(t1),
                    u_merc_center: new e.cg(t1),
                    u_image0: new e.cd(t1),
                    u_grid_matrix: new e.dw(t1),
                    u_skirt_height: new e.cf(t1),
                    u_far_z_cutoff: new e.cf(t1),
                    u_frustum_tl: new e.ce(t1),
                    u_frustum_tr: new e.ce(t1),
                    u_frustum_br: new e.ce(t1),
                    u_frustum_bl: new e.ce(t1),
                    u_globe_pos: new e.ce(t1),
                    u_globe_radius: new e.cf(t1),
                    u_viewport: new e.cg(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e.ce(t1),
                    u_frustum_tr: new e.ce(t1),
                    u_frustum_br: new e.ce(t1),
                    u_frustum_bl: new e.ce(t1),
                    u_horizon: new e.cf(t1),
                    u_transition: new e.cf(t1),
                    u_fadeout_range: new e.cf(t1),
                    u_color: new e.d0(t1),
                    u_high_color: new e.d0(t1),
                    u_space_color: new e.d0(t1),
                    u_temporal_offset: new e.cf(t1),
                    u_horizon_angle: new e.cf(t1)
                }),
            model: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_lighting_matrix: new e.ch(t1),
                    u_normal_matrix: new e.ch(t1),
                    u_node_matrix: new e.ch(t1),
                    u_lightpos: new e.ce(t1),
                    u_lightintensity: new e.cf(t1),
                    u_lightcolor: new e.ce(t1),
                    u_camera_pos: new e.ce(t1),
                    u_opacity: new e.cf(t1),
                    u_baseColorFactor: new e.d0(t1),
                    u_emissiveFactor: new e.d0(t1),
                    u_metallicFactor: new e.cf(t1),
                    u_roughnessFactor: new e.cf(t1),
                    u_baseTextureIsAlpha: new e.cd(t1),
                    u_alphaMask: new e.cd(t1),
                    u_alphaCutoff: new e.cf(t1),
                    u_baseColorTexture: new e.cd(t1),
                    u_metallicRoughnessTexture: new e.cd(t1),
                    u_normalTexture: new e.cd(t1),
                    u_occlusionTexture: new e.cd(t1),
                    u_emissionTexture: new e.cd(t1),
                    u_lutTexture: new e.cd(t1),
                    u_color_mix: new e.d0(t1),
                    u_aoIntensity: new e.cf(t1),
                    u_emissive_strength: new e.cf(t1),
                    u_occlusionTextureTransform: new e.d0(t1)
                }),
            modelDepth: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_instance: new e.ch(t1),
                    u_node_matrix: new e.ch(t1)
                }),
            groundShadow: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_ground_shadow_factor: new e.ce(t1)
                }),
            stars: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_up: new e.ce(t1),
                    u_right: new e.ce(t1),
                    u_intensity_multiplier: new e.cf(t1)
                }),
            snowParticle: (t1)=>({
                    u_modelview: new e.ch(t1),
                    u_projection: new e.ch(t1),
                    u_time: new e.cf(t1),
                    u_cam_pos: new e.ce(t1),
                    u_velocityConeAperture: new e.cf(t1),
                    u_velocity: new e.cf(t1),
                    u_horizontalOscillationRadius: new e.cf(t1),
                    u_horizontalOscillationRate: new e.cf(t1),
                    u_boxSize: new e.cf(t1),
                    u_billboardSize: new e.cf(t1),
                    u_simpleShapeParameters: new e.cg(t1),
                    u_screenSize: new e.cg(t1),
                    u_thinningCenterPos: new e.cg(t1),
                    u_thinningShape: new e.ce(t1),
                    u_thinningAffectedRatio: new e.cf(t1),
                    u_thinningParticleOffset: new e.cf(t1),
                    u_particleColor: new e.d0(t1),
                    u_direction: new e.ce(t1)
                }),
            rainParticle: (t1)=>({
                    u_modelview: new e.ch(t1),
                    u_projection: new e.ch(t1),
                    u_time: new e.cf(t1),
                    u_cam_pos: new e.ce(t1),
                    u_texScreen: new e.cd(t1),
                    u_velocityConeAperture: new e.cf(t1),
                    u_velocity: new e.cf(t1),
                    u_boxSize: new e.cf(t1),
                    u_rainDropletSize: new e.cg(t1),
                    u_distortionStrength: new e.cf(t1),
                    u_rainDirection: new e.ce(t1),
                    u_color: new e.d0(t1),
                    u_screenSize: new e.cg(t1),
                    u_thinningCenterPos: new e.cg(t1),
                    u_thinningShape: new e.ce(t1),
                    u_thinningAffectedRatio: new e.cf(t1),
                    u_thinningParticleOffset: new e.cf(t1),
                    u_shapeDirectionalPower: new e.cf(t1),
                    u_shapeNormalPower: new e.cf(t1),
                    u_mode: new e.cf(t1)
                }),
            vignette: (t1)=>({
                    u_vignetteShape: new e.ce(t1),
                    u_vignetteColor: new e.d0(t1)
                }),
            occlusion: (t1)=>({
                    u_matrix: new e.ch(t1),
                    u_anchorPos: new e.ce(t1),
                    u_screenSizePx: new e.cg(t1),
                    u_occluderSizePx: new e.cg(t1),
                    u_color: new e.d0(t1)
                })
        };
        class Ls {
            constructor(e, t1, i, o){
                this.id = Ls.uniqueIdxCounter, Ls.uniqueIdxCounter++, this.context = e;
                const r = e.gl;
                this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || o || t1.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e) {
                this.id = Ls.uniqueIdxCounter, Ls.uniqueIdxCounter++;
                const t1 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t1.bufferSubData(t1.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        Ls.uniqueIdxCounter = 0;
        const zs = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class Ms {
            constructor(e, t1, i, o, r, s){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.instanceCount = s, this.context = e;
                const n = e.gl;
                this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || r || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            enableAttributes(e, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.attributes[this.attributes[i].name];
                    void 0 !== o && e.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = this.attributes[o], s = t1.attributes[r.name];
                    void 0 !== s && e.vertexAttribPointer(s, r.components, e[zs[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
                }
            }
            setVertexAttribDivisor(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = t1.attributes[this.attributes[o].name];
                    void 0 !== r && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(r, i);
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Os {
            constructor(e, t1, i, o, r){
                this.context = e, this.width = t1, this.height = i;
                const s = this.framebuffer = e.gl.createFramebuffer();
                o && (this.colorAttachment = new Dr(e, s)), r && (this.depthAttachmentType = r, this.depthAttachment = "renderbuffer" === r ? new Pr(e, s) : new Lr(e, s));
            }
            destroy() {
                const e = this.context.gl;
                if (this.colorAttachment) {
                    const t1 = this.colorAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteRenderbuffer(t1);
                } else {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                e.deleteFramebuffer(this.framebuffer);
            }
        }
        class Fs {
            constructor(e, t1){
                this.gl = e, this.clearColor = new Jo(this), this.clearDepth = new Qo(this), this.clearStencil = new er(this), this.colorMask = new tr(this), this.depthMask = new ir(this), this.stencilMask = new or(this), this.stencilFunc = new rr(this), this.stencilOp = new sr(this), this.stencilTest = new nr(this), this.depthRange = new ar(this), this.depthTest = new lr(this), this.depthFunc = new cr(this), this.blend = new hr(this), this.blendFunc = new dr(this), this.blendColor = new ur(this), this.blendEquation = new _r(this), this.cullFace = new pr(this), this.cullFaceSide = new fr(this), this.frontFace = new mr(this), this.program = new gr(this), this.activeTexture = new vr(this), this.viewport = new yr(this), this.bindFramebuffer = new xr(this), this.bindRenderbuffer = new br(this), this.bindTexture = new wr(this), this.bindVertexBuffer = new Tr(this), this.bindElementBuffer = new Er(this), this.bindVertexArrayOES = new Sr(this), this.pixelStoreUnpack = new Ir(this), this.pixelStoreUnpackPremultiplyAlpha = new Cr(this), this.pixelStoreUnpackFlipY = new Rr(this), this.options = t1 ? Object.assign({}, t1) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t1 && !!t1.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e, t1, i) {
                return new Ls(this, e, t1, i);
            }
            createVertexBuffer(e, t1, i, o, r) {
                return new Ms(this, e, t1, i, o, r);
            }
            createRenderbuffer(e, t1, i) {
                const o = this.gl, r = o.createRenderbuffer();
                return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t1, i), this.bindRenderbuffer.set(null), r;
            }
            createFramebuffer(e, t1, i, o) {
                return new Os(this, e, t1, i, o);
            }
            clear({ color: e, depth: t1, stencil: i, colorMask: o }) {
                const r = this.gl;
                let s = 0;
                e && (s |= r.COLOR_BUFFER_BIT, this.clearColor.set(e.toNonPremultipliedRenderColor(null)), this.colorMask.set(o || [
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (s |= r.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (s |= r.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), r.clear(s);
            }
            setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }
            setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
                    e.fail,
                    e.depthFail,
                    e.pass
                ]), this.stencilFunc.set({
                    func: e.test.func,
                    ref: e.ref,
                    mask: e.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(t1) {
                e.bv(t1.blendFunction, ki.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t1.blendFunction), this.blendColor.set(t1.blendColor), t1.blendEquation ? this.blendEquation.set(t1.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t1.mask);
            }
            unbindVAO() {
                this.bindVertexArrayOES.set(null);
            }
        }
        let Bs;
        function ks(t1, i, o, r, s, n, a) {
            const l = t1.context, c = l.gl, h = t1.transform, d = [
                e.aD(h.center.lng),
                e.aH(h.center.lat)
            ], u = o.layout.get("symbol-placement"), _ = o.layout.get("text-variable-anchor"), p = "map" === o.layout.get("icon-rotation-alignment"), f = "map" === o.layout.get("text-rotation-alignment"), m = "point" !== u, g = [];
            let v = 0, y = 0;
            for(let l = 0; l < r.length; l++){
                const u = r[l], x = i.getTile(u), b = x.getBucket(o);
                if (!b) continue;
                const w = b.getProjection().createInversionMatrix(h, u.canonical), T = [], E = Gt(u, b, h), S = !a && p && m, I = a && f && m, C = _ && b.hasTextData(), R = b.hasIconTextFit() && C && b.hasIconData(), A = S || I || a && C || R, D = "globe" === b.projection.name, P = D ? e.ah(h.zoom) : 0;
                D && (T.push("PROJECTION_GLOBE_VIEW"), A && T.push("PROJECTED_POS_ON_VIEWPORT"));
                const L = t1.getOrCreateProgram("collisionBox", {
                    defines: T
                });
                let z = E;
                0 === s[0] && 0 === s[1] || (z = t1.translatePosMatrix(E, x, s, n));
                const M = a ? b.textCollisionBox : b.iconCollisionBox, O = b.collisionCircleArray;
                if (O.length > 0) {
                    const t1 = e.bz(), i = z;
                    e.cM(t1, b.placementInvProjMatrix, h.glCoordMatrix), e.cM(t1, t1, b.placementViewportMatrix), g.push({
                        circleArray: O,
                        circleOffset: y,
                        transform: i,
                        invTransform: t1,
                        projection: b.getProjection()
                    }), v += O.length / 4, y = v;
                }
                if (!M) continue;
                t1.terrain && t1.terrain.setupElevationDraw(x, L);
                const F = D ? [
                    u.canonical.x,
                    u.canonical.y,
                    1 << u.canonical.z
                ] : [
                    0,
                    0,
                    0
                ];
                L.draw(t1, c.LINES, Ni.disabled, ji.disabled, t1.colorModeForRenderPass(), qi.disabled, us(z, w, h, P, d, x, F, b.getProjection()), o.id, M.layoutVertexBuffer, M.indexBuffer, M.segments, null, h.zoom, null, [
                    M.collisionVertexBuffer,
                    M.collisionVertexBufferExt
                ]);
            }
            if (!a || !g.length) return;
            const x = t1.getOrCreateProgram("collisionCircle"), b = new e.dU;
            b.resize(4 * v), b._trim();
            let w = 0;
            for (const e of g)for(let t1 = 0; t1 < e.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e.circleArray[i + 0], r = e.circleArray[i + 1], s = e.circleArray[i + 2], n = e.circleArray[i + 3];
                b.emplace(w++, o, r, s, n, 0), b.emplace(w++, o, r, s, n, 1), b.emplace(w++, o, r, s, n, 2), b.emplace(w++, o, r, s, n, 3);
            }
            (!Bs || Bs.length < 2 * v) && (Bs = function(t1) {
                const i = 2 * t1, o = new e.a_;
                o.resize(i), o._trim();
                for(let e = 0; e < i; e++){
                    const t1 = 6 * e;
                    o.uint16[t1 + 0] = 4 * e + 0, o.uint16[t1 + 1] = 4 * e + 1, o.uint16[t1 + 2] = 4 * e + 2, o.uint16[t1 + 3] = 4 * e + 2, o.uint16[t1 + 4] = 4 * e + 3, o.uint16[t1 + 5] = 4 * e + 0;
                }
                return o;
            }(v));
            const T = l.createIndexBuffer(Bs, !0), E = l.createVertexBuffer(b, e.dV.members, !0);
            for (const i of g){
                const r = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (S = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [
                        S.width,
                        S.height
                    ]
                };
                x.draw(t1, c.TRIANGLES, Ni.disabled, ji.disabled, t1.colorModeForRenderPass(), qi.disabled, r, o.id, E, T, e.bd.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var S;
            E.destroy(), T.destroy();
        }
        const Ns = e.bz();
        function Us(t1) {
            const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e.az([], i, t1.globeMatrix);
            e.bi(o, o);
            const r = [
                0,
                0,
                0
            ], s = [
                0,
                1,
                0,
                0
            ];
            return e.aA(s, s, o), r[0] = s[0], r[1] = s[1], r[2] = s[2], e.au(r, r), r;
        }
        function js({ width: t1, height: i, anchor: o, textOffset: r, textScale: s }, n) {
            const { horizontalAlign: a, verticalAlign: l } = e.bZ(o), c = -(a - .5) * t1, h = -(l - .5) * i, d = e.b_(o, r);
            return new e.P((c / s + d[0]) * n, (h / s + d[1]) * n);
        }
        function Gs(t1, i, o, r, s, n, a, l, c, h) {
            const d = t1.text.placedSymbolArray, u = t1.text.dynamicLayoutVertexArray, _ = t1.icon.dynamicLayoutVertexArray, p = {}, f = t1.getProjection(), m = Vt(a, f, s), g = s.elevation, v = f.upVectorScale(a.canonical, s.center.lat, s.worldSize).metersToTile;
            u.clear();
            for(let _ = 0; _ < d.length; _++){
                const y = d.get(_), { tileAnchorX: x, tileAnchorY: b, numGlyphs: w } = y, T = y.hidden || !y.crossTileID || t1.allowVerticalPlacement && !y.placedOrientation ? null : r[y.crossTileID];
                if (T) {
                    let r = 0, d = 0, _ = 0;
                    if (g) {
                        const e = g ? g.getAtTileOffset(a, x, b) : 0, [t1, i, o] = f.upVector(a.canonical, x, b);
                        r = e * t1 * v, d = e * i * v, _ = e * o * v;
                    }
                    let [E, S, I, C] = Kt(y.projectedAnchorX + r, y.projectedAnchorY + d, y.projectedAnchorZ + _, o ? m : n);
                    const R = Jt(s.getCameraToCenterDistance(f), C);
                    let A = e.bJ(t1.textSizeData, c, y) * R / e.bU;
                    o && (A *= t1.tilePixelRatio / l);
                    const D = js(T, A);
                    o ? ({ x: E, y: S, z: I } = f.projectTilePoint(x + D.x, b + D.y, a.canonical), [E, S, I] = Kt(E + r, S + d, I + _, n)) : (i && D._rotate(-s.angle), E += D.x, S += D.y, I = 0);
                    const P = t1.allowVerticalPlacement && y.placedOrientation === e.bI.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < w; t1++)e.bL(u, E, S, I, P);
                    h && y.associatedIconIndex >= 0 && (p[y.associatedIconIndex] = {
                        x: E,
                        y: S,
                        z: I,
                        angle: P
                    });
                } else ai(w, u);
            }
            if (h) {
                _.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: r } = o, s = p[t1];
                    if (o.hidden || !s) ai(r, _);
                    else {
                        const { x: t1, y: i, z: o, angle: n } = s;
                        for(let s = 0; s < r; s++)e.bL(_, t1, i, o, n);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(_);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(u);
        }
        function Vs(t1, i, o, r, s, n, a = {}) {
            const l = o.paint.get("icon-translate"), c = o.paint.get("text-translate"), h = o.paint.get("icon-translate-anchor"), d = o.paint.get("text-translate-anchor"), u = o.layout.get("icon-rotation-alignment"), _ = o.layout.get("text-rotation-alignment"), p = o.layout.get("icon-pitch-alignment"), f = o.layout.get("text-pitch-alignment"), m = o.layout.get("icon-keep-upright"), g = o.layout.get("text-keep-upright"), v = o.paint.get("icon-color-saturation"), y = o.paint.get("icon-color-contrast"), x = o.paint.get("icon-color-brightness-min"), b = o.paint.get("icon-color-brightness-max"), w = "sea" === o.layout.get("symbol-elevation-reference"), T = t1.context, E = T.gl, S = t1.transform, I = "map" === u, C = "map" === _, R = "map" === p, A = "map" === f, D = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let P = !1;
            const L = t1.depthModeForSublayer(0, Ni.ReadOnly), z = new Ni(t1.context.gl.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D), M = [
                e.aD(S.center.lng),
                e.aH(S.center.lat)
            ], O = o.layout.get("text-variable-anchor"), F = "globe" === S.projection.name, B = [], k = [
                0,
                -1,
                0
            ];
            for (const s of r){
                const r = i.getTile(s), n = r.getBucket(o);
                if (!n) continue;
                if ("mercator" === n.projection.name && F) continue;
                if (n.fullyClipped) continue;
                const u = "globe" === n.projection.name, _ = u ? e.ah(S.zoom) : 0, p = Vt(s, n.getProjection(), S), f = S.calculatePixelsToTileUnitsMatrix(r), T = O && n.hasTextData(), N = n.hasIconTextFit() && T && n.hasIconData(), U = n.getProjection().createInversionMatrix(S, s.canonical), j = (1 << r.tileID.canonical.z) * e.aj / t1.transform.worldSize, G = (e)=>{
                    let i = [
                        0,
                        0,
                        0
                    ];
                    if (e) {
                        const e = t1.style.directionalLight, o = t1.style.ambientLight;
                        e && o && (i = ao(t1.style, e, o));
                    }
                    return i;
                }, V = (e)=>{
                    S.depthOcclusionForSymbolsAndCircles && (o.hasInitialOcclusionOpacityProperties || t1.terrain) && (e.push("DEPTH_D24"), e.push("DEPTH_OCCLUSION"));
                }, q = ()=>{
                    const i = I && "point" !== o.layout.get("symbol-placement"), a = [];
                    V(a);
                    const c = i || N, d = "road" === n.elevationType, g = t1.shadowRenderer, T = d && R && !!g && g.enabled, C = G(T), A = d && R && !t1.terrain ? z : L, D = o.paint.get("icon-image-cross-fade");
                    t1.terrainRenderModeElevated() && R && a.push("PITCH_WITH_MAP_TERRAIN"), u && (a.push("PROJECTION_GLOBE_VIEW"), c && a.push("PROJECTED_POS_ON_VIEWPORT")), D > 0 && n.hasAnySecondaryIcon && a.push("ICON_TRANSITION"), !n.icon.zOffsetVertexBuffer || d && t1.terrain || a.push("Z_OFFSET"), 0 === v && 0 === y && 0 === x && 1 === b || a.push("COLOR_ADJUSTMENT"), n.sdfIcons && a.push("RENDER_SDF"), T && a.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), d && R && !t1.terrain && n.icon.orientationVertexBuffer && a.push("ELEVATED_ROADS");
                    const P = n.icon.programConfigurations.get(o.id), O = t1.getOrCreateProgram("symbol", {
                        config: P,
                        defines: a
                    }), B = r.imageAtlasTexture ? r.imageAtlasTexture.size : [
                        0,
                        0
                    ], q = n.iconSizeData, H = e.bH(q, S.zoom), Z = R || !S.isOrthographic, W = $t(p, r.tileID.canonical, R, I, S, n.getProjection(), f), $ = Yt(p, r.tileID.canonical, R, I, S, n.getProjection(), f), X = t1.translatePosMatrix($, r, l, h, !0), Y = t1.translatePosMatrix(p, r, l, h), K = c ? Ns : W, J = I && !R && !i;
                    let Q = k;
                    !F && !S.mercatorFromTransition || I || (Q = Us(S));
                    const ee = u ? Q : k, te = o.getColorAdjustmentMatrix(v, y, x, b), ie = Ss(q.kind, H, J, R, t1, Y, K, X, w, !1, B, [
                        0,
                        0
                    ], 0, s, _, M, U, ee, n.getProjection(), C, j, te, D, null), oe = r.imageAtlasTexture ? r.imageAtlasTexture : null, re = 1 !== o.layout.get("icon-size").constantOr(0) || n.iconsNeedLinear, se = n.sdfIcons || t1.options.rotating || t1.options.zooming || re || Z ? E.LINEAR : E.NEAREST, ne = n.sdfIcons && 0 !== o.paint.get("icon-halo-width").constantOr(1), ae = t1.terrain && R && i ? e.bi(e.bz(), W) : Ns;
                    if (i && n.icon) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(s, S.center.lat, S.worldSize, n.getProjection()) : null, o = Xt(p, r.tileID.canonical, R, I, S, n.getProjection(), f);
                        ei(n, p, t1, !1, o, $, R, m, i, s);
                    }
                    return {
                        program: O,
                        buffers: n.icon,
                        uniformValues: ie,
                        atlasTexture: oe,
                        atlasTextureIcon: null,
                        atlasInterpolation: se,
                        atlasInterpolationIcon: null,
                        isSDF: n.sdfIcons,
                        hasHalo: ne,
                        depthMode: A,
                        tile: r,
                        renderWithShadows: T,
                        labelPlaneMatrixInv: ae
                    };
                }, H = ()=>{
                    const i = C && "point" !== o.layout.get("symbol-placement"), a = [], l = i || O || N, h = "road" === n.elevationType, m = t1.shadowRenderer, v = h && A && !!m && m.enabled, y = G(v), x = h && A && !t1.terrain ? z : L;
                    t1.terrainRenderModeElevated() && A && a.push("PITCH_WITH_MAP_TERRAIN"), u && (a.push("PROJECTION_GLOBE_VIEW"), l && a.push("PROJECTED_POS_ON_VIEWPORT")), !n.text.zOffsetVertexBuffer || h && t1.terrain || a.push("Z_OFFSET"), n.iconsInText && a.push("RENDER_TEXT_AND_SYMBOL"), a.push("RENDER_SDF"), v && a.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), h && A && !t1.terrain && n.text.orientationVertexBuffer && a.push("ELEVATED_ROADS"), V(a);
                    const b = n.text.programConfigurations.get(o.id), T = t1.getOrCreateProgram("symbol", {
                        config: b,
                        defines: a
                    });
                    let I, R = [
                        0,
                        0
                    ], D = null;
                    const P = n.textSizeData;
                    n.iconsInText && (R = r.imageAtlasTexture ? r.imageAtlasTexture.size : [
                        0,
                        0
                    ], D = r.imageAtlasTexture ? r.imageAtlasTexture : null, I = A || !S.isOrthographic || t1.options.rotating || t1.options.zooming || "composite" === P.kind || "camera" === P.kind ? E.LINEAR : E.NEAREST);
                    const B = r.glyphAtlasTexture ? r.glyphAtlasTexture.size : [
                        0,
                        0
                    ], q = o.layout.get("text-size-scale-range"), H = e.ay(t1.scaleFactor, q[0], q[1]), Z = e.bH(P, S.zoom, H), W = $t(p, r.tileID.canonical, A, C, S, n.getProjection(), f), $ = Yt(p, r.tileID.canonical, A, C, S, n.getProjection(), f), X = t1.translatePosMatrix($, r, c, d, !0), Y = t1.translatePosMatrix(p, r, c, d), K = l ? Ns : W, J = C && !A && !i;
                    let Q = k;
                    !F && !S.mercatorFromTransition || C || (Q = Us(S));
                    const ee = Ss(P.kind, Z, J, A, t1, Y, K, X, w, !0, B, R, 0, s, _, M, U, u ? Q : k, n.getProjection(), y, j, null, null, H), te = r.glyphAtlasTexture ? r.glyphAtlasTexture : null, ie = E.LINEAR, oe = 0 !== o.paint.get("text-halo-width").constantOr(1), re = t1.terrain && A && i ? e.bi(e.bz(), W) : Ns;
                    if (i && n.text) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(s, S.center.lat, S.worldSize, n.getProjection()) : null, o = Xt(p, r.tileID.canonical, A, C, S, n.getProjection(), f);
                        ei(n, p, t1, !0, o, $, A, g, i, s);
                    }
                    return {
                        program: T,
                        buffers: n.text,
                        uniformValues: ee,
                        atlasTexture: te,
                        atlasTextureIcon: D,
                        atlasInterpolation: ie,
                        atlasInterpolationIcon: I,
                        isSDF: !0,
                        hasHalo: oe,
                        depthMode: x,
                        tile: r,
                        renderWithShadows: v,
                        labelPlaneMatrixInv: re
                    };
                }, Z = n.icon.segments.get().length, W = n.text.segments.get().length, $ = Z && !a.onlyText ? q() : null, X = W && !a.onlyIcons ? H() : null, Y = o.paint.get("icon-opacity").constantOr(1), K = o.paint.get("text-opacity").constantOr(1);
                if (D && n.canOverlap) {
                    P = !0;
                    const t1 = Y && !a.onlyText ? n.icon.segments.get() : [], i = K && !a.onlyIcons ? n.text.segments.get() : [];
                    for (const i of t1)B.push({
                        segments: new e.bd([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: $
                    });
                    for (const t1 of i)B.push({
                        segments: new e.bd([
                            t1
                        ]),
                        sortKey: t1.sortKey,
                        state: X
                    });
                } else a.onlyText || B.push({
                    segments: Y ? n.icon.segments : new e.bd([]),
                    sortKey: 0,
                    state: $
                }), a.onlyIcons || B.push({
                    segments: K ? n.text.segments : new e.bd([]),
                    sortKey: 0,
                    state: X
                });
            }
            P && B.sort((e, t1)=>e.sortKey - t1.sortKey);
            for (const e of B){
                const i = e.state;
                if (i) if (t1.terrain ? t1.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: S.depthOcclusionForSymbolsAndCircles,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }) : t1.setupDepthForOcclusion(S.depthOcclusionForSymbolsAndCircles, i.program), T.activeTexture.set(E.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, E.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (T.activeTexture.set(E.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, E.CLAMP_TO_EDGE, !0)), i.renderWithShadows && t1.shadowRenderer.setupShadows(i.tile.tileID.toUnwrapped(), i.program, "vector-tile"), t1.uploadCommonLightUniforms(t1.context, i.program), i.hasHalo) {
                    const r = i.uniformValues;
                    r.u_is_halo = 1, qs(i.buffers, e.segments, o, t1, i.program, i.depthMode, s, n, r, 2), r.u_is_halo = 0;
                } else {
                    if (i.isSDF) {
                        const r = i.uniformValues;
                        i.hasHalo && (r.u_is_halo = 1, qs(i.buffers, e.segments, o, t1, i.program, i.depthMode, s, n, r, 1)), r.u_is_halo = 0;
                    }
                    qs(i.buffers, e.segments, o, t1, i.program, i.depthMode, s, n, i.uniformValues, 1);
                }
            }
        }
        function qs(e, t1, i, o, r, s, n, a, l, c) {
            const h = [
                e.dynamicLayoutVertexBuffer,
                e.opacityVertexBuffer,
                e.iconTransitioningVertexBuffer,
                e.globeExtVertexBuffer,
                e.zOffsetVertexBuffer,
                e.orientationVertexBuffer
            ];
            r.draw(o, o.context.gl.TRIANGLES, s, n, a, qi.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t1, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);
        }
        function Hs(t1, i) {
            const o = 1 << t1.canonical.z, r = (i.x * o - t1.canonical.x - t1.wrap * o) * e.aj, s = (i.y * o - t1.canonical.y) * e.aj, n = e.e2(i.z, i.y);
            return e.d2(r, s, n);
        }
        function Zs(t1, i, o, r, s) {
            if (!o.layout || "none" === o.layout.get("fill-elevation-reference")) return;
            const n = t1.context.gl, a = new Ni(t1.context.gl.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D), l = new Ni(t1.context.gl.GREATER, Ni.ReadWrite, t1.depthRangeFor3D), c = function(t1) {
                const i = e.cU(t1.pitch);
                let o = .01;
                return t1.isOrthographic && (o = e.ai(1e-4, o, e.cZ(i >= Ji ? 1 : i / Ji))), 2 * o;
            }(t1.transform), h = t1.transform.getFreeCameraOptions().position, d = "elevatedStructuresDepthReconstruct", u = t1.getOrCreateProgram(d, {
                defines: [
                    "DEPTH_RECONSTRUCTION"
                ]
            }), _ = t1.getOrCreateProgram(d);
            for (const e of r){
                const r = i.getTile(e), d = r.getBucket(o);
                if (!d) continue;
                const p = d.elevatedStructures;
                if (!p) continue;
                const f = d.elevationBufferData.heightRange, m = Hs(e.toUnwrapped(), h), g = t1.translatePosMatrix(e.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                let v, y, x, b;
                if ("initialize" === s) {
                    if (!f || f.min >= 1 || 0 === p.depthSegments.segments[0].primitiveLength) continue;
                    v = ls(g, m, c, 1, 0), y = a, x = p.depthSegments, b = u;
                } else if ("reset" === s) {
                    if (!f || f.min >= 0 || 0 === p.maskSegments.segments[0].primitiveLength) continue;
                    v = ls(g, m, 0, 0, 1), y = l, x = p.maskSegments, b = u;
                } else if ("geometry" === s) {
                    if (0 === p.depthSegments.segments[0].primitiveLength) continue;
                    v = ls(g, m, c, 1, 0), y = a, x = p.depthSegments, b = _;
                }
                b.draw(t1, n.TRIANGLES, y, ji.disabled, ki.disabled, qi.disabled, v, o.id, p.vertexBuffer, p.indexBuffer, x, o.paint, t1.transform.zoom);
            }
        }
        function Ws(t1, i, o) {
            const { painter: r, sourceCache: s, layer: n, coords: a, colorMode: l, elevationType: c, terrainEnabled: h, pass: d } = t1, u = r.context.gl, _ = n.paint.get("fill-pattern"), p = n.paint.get("fill-pattern-cross-fade"), f = _.constantOr(null);
            let m = c;
            "road" !== c || i && !h || (m = "none");
            const g = "road" === m, v = t1.painter.shadowRenderer, y = g && !!v && v.enabled, x = new Ni(r.context.gl.LEQUAL, Ni.ReadOnly, r.depthRangeFor3D);
            let b = [
                0,
                0,
                0
            ];
            if (y) {
                const e = r.style.directionalLight, t1 = r.style.ambientLight;
                e && t1 && (b = ao(r.style, e, t1));
            }
            const w = _ && _.constantOr(1), T = (t1, d)=>{
                let _, m, T, E, S;
                d ? (_ = w && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", T = u.LINES) : (_ = w ? "fillPattern" : "fill", T = u.TRIANGLES);
                for (const I of a){
                    const a = s.getTile(I);
                    if (w && !a.patternsLoaded()) continue;
                    const C = a.getBucket(n);
                    if (!C) continue;
                    const R = i ? C.elevationBufferData : C.bufferData;
                    if (R.isEmpty()) continue;
                    r.prepareDrawTile();
                    const A = R.programConfigurations.get(n.id), D = r.isTileAffectedByFog(I), P = [], L = [];
                    g && (P.push("ELEVATED_ROADS"), L.push(R.elevatedLayoutVertexBuffer)), y && P.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), w && (r.context.activeTexture.set(u.TEXTURE0), a.imageAtlasTexture && a.imageAtlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE), A.updatePaintBuffers());
                    let z = !1;
                    if (f && a.imageAtlas) {
                        const t1 = a.imageAtlas, i = e.dZ.from(f), o = i.getPrimary().scaleSelf(e.q.devicePixelRatio).toString(), r = i.getSecondary(), s = t1.patternPositions.get(o), n = r ? t1.patternPositions.get(r.scaleSelf(e.q.devicePixelRatio).toString()) : null;
                        z = !!s && !!n, s && A.setConstantPatternPositions(s, n);
                    }
                    p > 0 && (z || A.getPatternTransitionVertexBuffer("fill-pattern")) && P.push("FILL_PATTERN_TRANSITION");
                    const M = r.getOrCreateProgram(_, {
                        config: A,
                        overrideFog: D,
                        defines: P
                    }), O = r.translatePosMatrix(I.projMatrix, a, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor"));
                    y && v.setupShadows(a.tileID.toUnwrapped(), M, "vector-tile");
                    const F = n.paint.get("fill-emissive-strength");
                    if (d) {
                        E = R.lineIndexBuffer, S = R.lineSegments;
                        const e = r.terrain && r.terrain.renderingToTexture ? r.terrain.drapeBufferSize : [
                            u.drawingBufferWidth,
                            u.drawingBufferHeight
                        ];
                        m = "fillOutlinePattern" === _ && w ? ns(O, F, r, a, e, b, p) : ss(O, F, e, b);
                    } else E = R.indexBuffer, S = R.triangleSegments, m = w ? rs(O, F, r, a, b, p) : os(O, F, b);
                    r.uploadCommonUniforms(r.context, M, I.toUnwrapped());
                    let B = t1;
                    ("road" === c && !h || "offset" === c) && (B = x), M.draw(r, T, B, o || r.stencilModeForClipping(I), l, qi.disabled, m, n.id, R.layoutVertexBuffer, E, S, n.paint, r.transform.zoom, A, L);
                }
            };
            r.renderPass === d && T(r.depthModeForSublayer(1, "opaque" === r.renderPass ? Ni.ReadWrite : Ni.ReadOnly), !1), "none" === m && "translucent" === r.renderPass && n.paint.get("fill-antialias") && T(r.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, Ni.ReadOnly), !0);
        }
        function $s(t1, i, o, r, s, n, a, l) {
            o.resetLayerRenderingStats(t1);
            const c = t1.context, h = c.gl, d = t1.transform, u = o.paint.get("fill-extrusion-pattern"), _ = o.paint.get("fill-extrusion-pattern-cross-fade"), p = u.constantOr(null), f = u.constantOr(1), m = o.paint.get("fill-extrusion-opacity"), g = t1.style.enable3dLights(), v = o.paint.get(g && !f ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                v
            ], x = o.layout.get("fill-extrusion-edge-radius"), b = x > 0 && !o.paint.get("fill-extrusion-rounded-roof"), w = b ? 0 : x, T = "globe" === d.projection.name ? e.e5() : 0, E = "globe" === d.projection.name, S = E ? e.ah(d.zoom) : 0, I = [
                e.aD(d.center.lng),
                e.aH(d.center.lat)
            ], C = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R = o.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(C ? null : o.lut).toArray01().slice(0, 3), A = o.paint.get("fill-extrusion-flood-light-intensity"), D = o.paint.get("fill-extrusion-vertical-scale"), P = 0 !== o.paint.get("fill-extrusion-line-width").constantOr(1), L = o.paint.get("fill-extrusion-height-alignment"), z = o.paint.get("fill-extrusion-base-alignment"), M = eo(t1, o.paint.get("fill-extrusion-cutoff-fade-range")), O = [];
            let F;
            E && O.push("PROJECTION_GLOBE_VIEW"), y[0] > 0 && O.push("FAUX_AO"), b && O.push("ZERO_ROOF_RADIUS"), l && O.push("HAS_CENTROID"), A > 0 && O.push("FLOOD_LIGHT"), M.shouldRenderCutoff && O.push("RENDER_CUTOFF"), P && O.push("RENDER_WALL_MODE");
            const B = "shadow" === t1.renderPass, k = t1.shadowRenderer, N = B && !!k, U = B ? qi.disabled : qi.backCCW;
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !0);
            let j = [
                0,
                0,
                0
            ];
            if (k) {
                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                e && i && (j = ao(t1.style, e, i)), B || (O.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k.useNormalOffset && O.push("NORMAL_OFFSET")), F = O.concat([
                    "SHADOWS_SINGLE_CASCADE"
                ]);
            }
            const G = N ? "fillExtrusionDepth" : f ? "fillExtrusionPattern" : "fillExtrusion", V = o.getLayerRenderingStats();
            for (const u of r){
                const r = i.getTile(u), g = r.getBucket(o);
                if (!g || g.projection.name !== d.projection.name) continue;
                let v = !1;
                k && (v = 0 === k.getMaxCascadeForTile(u.toUnwrapped()));
                const x = t1.isTileAffectedByFog(u), b = g.programConfigurations.get(o.id);
                let C = !1;
                if (p && r.imageAtlas) {
                    const t1 = r.imageAtlas, i = e.dZ.from(p), o = i.getPrimary().scaleSelf(e.q.devicePixelRatio).toString(), s = i.getSecondary(), n = t1.patternPositions.get(o), a = s ? t1.patternPositions.get(s.scaleSelf(e.q.devicePixelRatio).toString()) : null;
                    C = !!n && !!a, n && b.setConstantPatternPositions(n, a);
                }
                _ > 0 && (C || b.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && O.push("FILL_EXTRUSION_PATTERN_TRANSITION");
                const N = t1.getOrCreateProgram(G, {
                    config: b,
                    defines: v ? F : O,
                    overrideFog: x
                });
                if (t1.terrain && t1.terrain.setupElevationDraw(r, N, {
                    useMeterToDem: !0
                }), !g.centroidVertexBuffer) {
                    const e = N.attributes.a_centroid_pos;
                    void 0 !== e && h.vertexAttrib2f(e, 0, 0);
                }
                !B && k && k.setupShadows(r.tileID.toUnwrapped(), N, "vector-tile"), f && (t1.context.activeTexture.set(h.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), b.updatePaintBuffers());
                const q = o.paint.get("fill-extrusion-vertical-gradient"), H = 1 / g.tileToMeter;
                let Z;
                if (B && k) {
                    if (tn(r.tileID, g.maxHeight, t1)) continue;
                    const e = k.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());
                    Z = ts(e, w, H, D, L, z);
                } else {
                    const e = t1.translatePosMatrix(u.expandedProjMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = d.projection.createInversionMatrix(d, u.canonical);
                    Z = f ? is(e, t1, q, m, y, w, H, u, r, T, L, z, S, I, i, R, D, _) : es(e, t1, q, m, y, w, H, u, T, L, z, S, I, i, R, D, A, j);
                }
                t1.uploadCommonUniforms(c, N, u.toUnwrapped(), null, M);
                let W = g.segments;
                if ("mercator" === d.projection.name && !B && (W = g.getVisibleSegments(r.tileID, t1.terrain, t1.transform.getFrustum(0)), !W.get().length)) continue;
                if (V) if (B) for (const e of W.get())V.numRenderedVerticesInShadowPass += e.primitiveLength;
                else for (const e of W.get())V.numRenderedVerticesInTransparentPass += e.primitiveLength;
                const $ = [];
                (t1.terrain || l) && $.push(g.centroidVertexBuffer), E && $.push(g.layoutVertexExtBuffer), P && $.push(g.wallVertexBuffer), N.draw(t1, c.gl.TRIANGLES, s, n, a, U, Z, o.id, g.layoutVertexBuffer, g.indexBuffer, W, o.paint, t1.transform.zoom, b, $);
            }
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !1);
        }
        class Xs {
            constructor(){
                this.translate = [
                    0,
                    0
                ], this.translateAnchor = "map", this.edgeRadius = 0, this.cutoffFadeRange = 0;
            }
        }
        function Ys(t1, i, o, r, s, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {
            const b = i.context, w = b.gl, T = i.transform, E = i.transform.zoom, S = [], I = t1.translate, C = t1.translateAnchor, R = t1.edgeRadius, A = eo(i, t1.cutoffFadeRange);
            "clear" === d ? (S.push("CLEAR_SUBPASS"), x && (S.push("CLEAR_FROM_TEXTURE"), b.activeTexture.set(w.TEXTURE0), x.bind(w.LINEAR, w.CLAMP_TO_EDGE))) : "sdf" === d && S.push("SDF_SUBPASS"), v && S.push("HAS_CENTROID"), A.shouldRenderCutoff && S.push("RENDER_CUTOFF");
            const D = (e, t1, o, s, d)=>{
                const y = t1.programConfigurations.get(r.id), w = i.isTileAffectedByFog(e), T = i.getOrCreateProgram("fillExtrusionGroundEffect", {
                    config: y,
                    defines: S,
                    overrideFog: w
                }), I = ((e, t1, i, o, r, s, n, a, l, c, h)=>({
                        u_matrix: t1,
                        u_opacity: i,
                        u_ao_pass: o ? 1 : 0,
                        u_meter_to_tile: r,
                        u_ao: s,
                        u_flood_light_intensity: n,
                        u_flood_light_color: a,
                        u_attenuation: l,
                        u_edge_radius: c,
                        u_fb: 0,
                        u_fb_size: h,
                        u_dynamic_offset: 1
                    }))(0, s, u, h, d, [
                    _,
                    p * d
                ], f, m, g, E >= 17 ? 0 : R * d, x ? x.size[0] : 0), C = [];
                v && C.push(t1.hiddenByLandmarkVertexBuffer), i.uploadCommonUniforms(b, T, e.toUnwrapped(), null, A), T.draw(i, b.gl.TRIANGLES, n, a, l, c, I, r.id, t1.vertexBuffer, t1.indexBuffer, o, r.paint, E, y, C);
            };
            for (const t1 of s){
                const s = o.getTile(t1), n = s.getBucket(r);
                if (!n || n.projection.name !== T.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;
                const a = n.groundEffect, l = 1 / n.tileToMeter;
                {
                    const e = i.translatePosMatrix(t1.projMatrix, s, I, C), o = a.getDefaultSegment();
                    D(t1, a, o, e, l);
                }
                if (y) for(let n = 0; n < 4; n++){
                    const a = e.e3[n](t1), c = o.getTile(a);
                    if (!c) continue;
                    const h = c.getBucket(r);
                    if (!h || h.projection.name !== T.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;
                    const d = h.groundEffect;
                    let u, _;
                    0 === n ? (u = [
                        -e.aj,
                        0,
                        0
                    ], _ = 1) : 1 === n ? (u = [
                        e.aj,
                        0,
                        0
                    ], _ = 0) : 2 === n ? (u = [
                        0,
                        -e.aj,
                        0
                    ], _ = 3) : (u = [
                        0,
                        e.aj,
                        0
                    ], _ = 2);
                    const p = d.regionSegments[_];
                    if (!p) continue;
                    const f = new Float32Array(16);
                    e.bo(f, t1.projMatrix, u), D(t1, d, p, i.translatePosMatrix(f, s, I, C), l);
                }
            }
        }
        function Ks(t1, i, o, r, s, n, a) {
            0 === r.centroidVertexArray.length && r.createCentroidsBuffer();
            const l = n ? n.findDEMTileFor(o) : null;
            if (!(l && l.dem || a)) return;
            n && l && l.dem && r.selfDEMTileTimestamp !== l.dem._timestamp && (r.borderDoneWithNeighborZ = [
                -1,
                -1,
                -1,
                -1
            ], r.selfDEMTileTimestamp = l.dem._timestamp);
            const c = (t1)=>new e.P(Math.ceil((t1 + e.e7) * e.e8), 0), h = (e)=>{
                const t1 = i.getSource().minzoom, o = (e)=>{
                    const t1 = i.getTileByID(e);
                    if (t1 && t1.hasData()) return t1.getBucket(s);
                }, r = [
                    0,
                    -1,
                    1
                ];
                for (const i of r){
                    if (e.overscaledZ + i < t1) continue;
                    const r = o(e.calculateScaledKey(e.overscaledZ + i));
                    if (r) return r;
                }
            }, d = [
                0,
                0,
                0
            ], u = (t1, i)=>(d[0] = Math.min(t1.min.y, i.min.y), d[1] = Math.max(t1.max.y, i.max.y), d[2] = e.aj - i.min.x > t1.max.x ? i.min.x - e.aj : t1.max.x, d), _ = (t1, i)=>(d[0] = Math.min(t1.min.x, i.min.x), d[1] = Math.max(t1.max.x, i.max.x), d[2] = e.aj - i.min.y > t1.max.y ? i.min.y - e.aj : t1.max.y, d), p = [
                (e, t1)=>u(e, t1),
                (e, t1)=>u(t1, e),
                (e, t1)=>_(e, t1),
                (e, t1)=>_(t1, e)
            ], f = (t1, i, r, s, a, c, h)=>{
                if (!n) return 0;
                const d = [
                    [
                        c ? r : t1,
                        c ? t1 : r,
                        0
                    ],
                    [
                        c ? r : i,
                        c ? i : r,
                        0
                    ]
                ], u = h < 0 ? e.aj + h : h, _ = [
                    c ? u : (t1 + i) / 2,
                    c ? (t1 + i) / 2 : u,
                    0
                ];
                return 0 === r && h < 0 || 0 !== r && h > 0 ? n.getForTilePoints(a, [
                    _
                ], !0, s) : d.push(_), n.getForTilePoints(o, d, !0, l), Math.max(d[0][2], d[1][2], _[2]) / n.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = r.borderFeatureIndices[t1];
                if (0 === i.length) continue;
                const s = e.e3[t1](o), l = h(s);
                if (!(l && l instanceof e.e4)) continue;
                const d = n ? n.findDEMTileFor(s) : null;
                if (!(d && d.dem || a)) continue;
                if (n && d && d.dem && r.borderDEMTileTimestamp[t1] !== d.dem._timestamp && (r.borderDoneWithNeighborZ[t1] = -1, r.borderDEMTileTimestamp[t1] = d.dem._timestamp), r.borderDoneWithNeighborZ[t1] === l.canonical.z) continue;
                0 === l.centroidVertexArray.length && l.createCentroidsBuffer();
                const u = (t1 < 2 ? 1 : 5) - t1, _ = l.borderDoneWithNeighborZ[u] !== r.canonical.z, v = l.borderFeatureIndices[u];
                let y = 0;
                if (r.canonical.z !== l.canonical.z) {
                    for (const e of i)r.showCentroid(r.featuresOnBorder[e]);
                    if (_) for (const e of v)l.showCentroid(l.featuresOnBorder[e]);
                    r.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[u] = r.canonical.z;
                }
                for (const o of i){
                    const i = r.featuresOnBorder[o], n = r.centroidData[i.centroidDataIndex], h = i.borders[t1];
                    let _;
                    for(; y < v.length;){
                        _ = l.featuresOnBorder[v[y]];
                        const e = _.borders[u];
                        if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;
                        l.showCentroid(_), y++;
                    }
                    if (_ && y < v.length) {
                        const o = y;
                        let x = 0;
                        for(; !(_.borders[u][0] > h[1] - 3) && (x++, ++y !== v.length);)_ = l.featuresOnBorder[v[y]];
                        _ = l.featuresOnBorder[v[o]];
                        let b = !1;
                        if (x >= 1) {
                            const e = _.borders[u];
                            Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (x = 1, b = !0, y = o + 1);
                        } else if (0 === x) {
                            r.showCentroid(i);
                            continue;
                        }
                        const w = l.centroidData[_.centroidDataIndex];
                        a && b && (((m = n).flags | (g = w).flags) & e.e6 ? (m.flags |= e.e6, g.flags |= e.e6) : (m.flags &= ~e.e6, g.flags &= ~e.e6));
                        const T = i.intersectsCount() > 1 || _.intersectsCount() > 1;
                        if (x > 1) y = o, n.centroidXY = w.centroidXY = new e.P(0, 0);
                        else if (d && d.dem && !T) {
                            const i = p[t1](n, w), o = t1 % 2 ? e.aj - 1 : 0, r = f(i[0], Math.min(e.aj - 1, i[1]), o, d, s, t1 < 2, i[2]);
                            n.centroidXY = w.centroidXY = c(r);
                        } else T ? n.centroidXY = w.centroidXY = new e.P(0, 0) : (n.centroidXY = r.encodeBorderCentroid(i), w.centroidXY = l.encodeBorderCentroid(_));
                        r.writeCentroidToBuffer(n), l.writeCentroidToBuffer(w);
                    } else r.showCentroid(i);
                }
                r.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[u] = r.canonical.z;
            }
            var m, g;
            (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t1);
        }
        const Js = [
            1,
            0,
            0
        ], Qs = [
            0,
            1,
            0
        ], en = [
            0,
            0,
            1
        ];
        function tn(t1, i, o) {
            const r = o.transform, s = o.shadowRenderer;
            if (!s) return !0;
            const n = t1.toUnwrapped(), a = r.tileSize * s._cascades[o.currentShadowCascade].scale;
            let l = i;
            if (r.elevation) {
                const e = r.elevation.getMinMaxForTile(t1);
                e && (l += e.max);
            }
            const c = [
                ...s.shadowDirection
            ];
            c[2] = -c[2];
            const h = s.computeSimplifiedTileShadowVolume(n, l, a, c);
            if (!h) return !1;
            const d = [
                Js,
                Qs,
                en,
                c,
                [
                    c[0],
                    0,
                    c[2]
                ],
                [
                    0,
                    c[1],
                    c[2]
                ]
            ], u = "globe" === r.projection.name, _ = r.scaleZoom(a), p = e.cy.fromInvProjectionMatrix(r.invProjMatrix, r.worldSize, _, !u), f = s.getCurrentCascadeFrustum();
            return 0 === p.intersectsPrecise(h.vertices, h.planes, d) || 0 === f.intersectsPrecise(h.vertices, h.planes, d);
        }
        function on(t1) {
            const { painter: i, source: o, layer: r, coords: s } = t1, n = t1.defines, a = i.context, l = "shadow" === i.renderPass, c = "light-beam" === i.renderPass, h = i.shadowRenderer;
            let d;
            h && (d = n.concat([
                "SHADOWS_SINGLE_CASCADE"
            ]));
            const u = e.e9(i.transform.center.lat, i.transform.zoom);
            for (const _ of s){
                const s = o.getTile(_), p = s.getBucket(r);
                if (!p) continue;
                let f = !1;
                h && (f = 0 === h.getMaxCascadeForTile(_.toUnwrapped()));
                const m = p.programConfigurations.get(r.id);
                let g, v, y = i.translatePosMatrix(_.expandedProjMatrix, s, [
                    0,
                    0
                ], "map");
                if (y = e.cP(e.bz(), y, [
                    1,
                    1,
                    t1.verticalScale
                ]), l && h) {
                    if (tn(s.tileID, p.maxHeight * u, i)) continue;
                    let o = h.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());
                    o = e.cP(e.bz(), o, [
                        1,
                        1,
                        t1.verticalScale
                    ]), v = ds(o), g = i.getOrCreateProgram("buildingDepth", {
                        config: m,
                        defines: f ? d : n,
                        overrideFog: !1
                    });
                } else if (c) g = i.getOrCreateProgram("buildingBloom", {
                    config: m,
                    defines: f ? d : n,
                    overrideFog: !1
                }), v = hs(y);
                else {
                    const o = i.transform.calculatePosMatrix(_.toUnwrapped(), i.transform.worldSize);
                    e.cP(o, o, [
                        1,
                        1,
                        t1.verticalScale
                    ]);
                    const r = e.bz();
                    e.cP(r, o, [
                        1,
                        -1,
                        1 / u
                    ]), e.bi(r, r), e.ea(r, r), v = cs(y, r), g = i.getOrCreateProgram("building", {
                        config: m,
                        defines: f ? d : n,
                        overrideFog: !1
                    }), h && h.setupShadowsFromMatrix(o, g, !0);
                }
                if (i.uploadCommonUniforms(a, g, _.toUnwrapped(), null, null), c) {
                    const e = p.bloomGeometry;
                    g.draw(i, a.gl.TRIANGLES, t1.depthMode, ji.disabled, t1.blendMode, qi.disabled, v, r.id, e.layoutVertexBuffer, e.indexBuffer, e.segmentsBucket, r.paint, i.transform.zoom, m, [
                        e.layoutAttenuationBuffer,
                        e.layoutColorBuffer
                    ]);
                } else g.draw(i, a.gl.TRIANGLES, t1.depthMode, ji.disabled, t1.blendMode, l ? qi.disabled : qi.backCW, v, r.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, r.paint, i.transform.zoom, m, [
                    p.layoutNormalBuffer,
                    p.layoutColorBuffer
                ]);
            }
        }
        function rn(t1) {
            return [
                t1[0] * e.eb,
                t1[1] * e.eb,
                t1[2] * e.eb,
                0
            ];
        }
        function sn(t1, i, o, r, s, n, a, l, c) {
            const h = r.getSource(), d = o.globeSharedBuffers;
            if (!d) return;
            let u, _, p;
            if (i && (u = r.getTile(i)), h instanceof e.aP ? (_ = h.texture, p = e.dE(0, 0, o.transform)) : u && i && (_ = u.texture, p = e.dE(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;
            t1 || (p = e.cP(e.bz(), p, [
                1,
                -1,
                1
            ]));
            const f = o.context, m = f.gl, g = "nearest" === s.paint.get("raster-resampling") ? m.NEAREST : m.LINEAR, v = o.colorModeForDrapableLayerRenderPass(n), y = a.defines;
            y.push("GLOBE_POLES");
            const x = new Ni(m.LEQUAL, Ni.ReadWrite, o.depthRangeFor3D), b = Float32Array.from(o.transform.expandedFarZProjMatrix), w = Float32Array.from(e.bh(e.dD(new e.cA(0, 0, 0))));
            o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), "useMipmap" in _ && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);
            const [T, E, S, I] = i ? d.getPoleBuffers(i.canonical.z, !1) : d.getPoleBuffers(0, !0), C = s.paint.get("raster-elevation");
            let R;
            t1 ? (R = T, o.renderDefaultNorthPole = 0 !== C) : (R = E, o.renderDefaultSouthPole = 0 !== C);
            const A = rn(a.mix), D = ((e, t1, i, o, r, s, n, a, l, c, h, d, u)=>vs(e, t1, i, new Float32Array(16), new Float32Array(9), [
                    0,
                    0
                ], o, [
                    0,
                    0
                ], [
                    0,
                    0,
                    0,
                    0
                ], 1, {
                    opacity: 1,
                    mix: 0
                }, s, [
                    0,
                    0
                ] || [
                    0,
                    0
                ], a, 2, c, h, d, 1, 0, u))(b, w, p, e.ah(o.transform.zoom), 0, s, 0, C, 0, A, a.offset, a.range, n), P = o.getOrCreateProgram("raster", {
                defines: y
            });
            o.uploadCommonUniforms(f, P, null), P.draw(o, m.TRIANGLES, x, c, v, l, D, s.id, R, S, I);
        }
        function nn(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, r = .2 * e.height, s = t1 + r;
            return [
                t1,
                i,
                (s - r - t1) / o,
                (s - t1) / o
            ];
        }
        function an(e, t1, i, o) {
            if (e) return t1 instanceof rt && e instanceof Tt ? t1.getTextureDescriptor(e, i, !0) : {
                texture: e.texture,
                mix: rn(o.mix),
                offset: o.offset,
                buffer: 0,
                tileSize: 1
            };
        }
        var ln = e.ec([
            {
                name: "a_index",
                type: "Int16",
                components: 1
            }
        ]);
        class cn {
            constructor(t1, i, o, r){
                const s = {
                    width: o[0],
                    height: o[1],
                    data: null
                }, n = t1.gl;
                this.targetColorTexture = new e.T(t1, s, n.RGBA8, {
                    useMipmap: !1
                }), this.backgroundColorTexture = new e.T(t1, s, n.RGBA8, {
                    useMipmap: !1
                }), this.context = t1, this.updateParticleTexture(i, r), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t1, i) {
                if (this.particleTextureDimension === i.width) return;
                (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
                const o = this.context.gl, r = i.width * i.height;
                this.particleTexture0 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                }), this.particleTexture1 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                });
                const s = new e.ed;
                s.reserve(r);
                for(let e = 0; e < r; e++)s.emplaceBack(e);
                this.particleIndexBuffer = this.context.createVertexBuffer(s, ln.members, !0), this.particleSegment = e.bd.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;
            }
            update(t1) {
                return !(this.lastInvalidatedAt < t1 && (this.lastInvalidatedAt = e.q.now(), 1));
            }
            destroy() {
                this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
        }
        function hn(t1, i, o) {
            if (!t1) return null;
            const r = i.getTextureDescriptor(t1, o, !0);
            if (!r) return null;
            let { texture: s, mix: n, offset: a, tileSize: l, buffer: c, format: h } = r;
            if (!s || !h) return null;
            let d = !1;
            return "uint32" === h && (d = !0, n[3] = 0, n = ms(e.ee, n, [
                0,
                o.paint.get("raster-particle-max-speed")
            ]), a = gs(e.ee, a, [
                0,
                o.paint.get("raster-particle-max-speed")
            ])), {
                texture: s,
                textureOffset: [
                    c / (l + 2 * c),
                    l / (l + 2 * c)
                ],
                tileSize: l,
                scalarData: d,
                scale: n,
                offset: a,
                defines: [
                    "RASTER_ARRAY",
                    {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32"
                    }[h]
                ]
            };
        }
        function dn(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, r = .2 * e.height, s = t1 + r;
            return [
                t1,
                i,
                (s - r - t1) / o,
                (s - t1) / o
            ];
        }
        const un = new e.am(1, 0, 0, 1), _n = new e.am(0, 1, 0, 1), pn = new e.am(0, 0, 1, 1), fn = new e.am(1, 0, 1, 1), mn = new e.am(0, 1, 1, 1);
        function gn(t1, i, o, r, s, n) {
            for(let a = 0; a < o.length; a++)if (s) {
                const s = 1, l = .8, c = new e.am(r.r * l, r.g * l, r.b * l, 1);
                vn(t1, i, o[a], r, -s, -s, n), vn(t1, i, o[a], r, -s, s, n), vn(t1, i, o[a], r, s, s, n), vn(t1, i, o[a], r, s, -s, n), vn(t1, i, o[a], c, 0, 0, n);
            } else vn(t1, i, o[a], r, 0, 0, n);
        }
        function vn(t1, i, o, r, s, n, a) {
            const l = t1.context, c = t1.transform, h = l.gl, d = "globe" === c.projection.name, u = d ? [
                "PROJECTION_GLOBE_VIEW"
            ] : [];
            let _ = e.bw(o.projMatrix);
            if (d && e.ah(c.zoom) > 0) {
                const t1 = e.bg(o.canonical, c), i = e.ef(t1);
                _ = e.az(new Float32Array(16), c.globeMatrix, i), e.az(_, c.projMatrix, _);
            }
            const p = e.bz();
            p[12] += 2 * s / (e.q.devicePixelRatio * c.width), p[13] += 2 * n / (e.q.devicePixelRatio * c.height), e.az(_, p, _);
            const f = t1.getOrCreateProgram("debug", {
                defines: u
            }), m = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(m, f);
            const g = Ni.disabled, v = ji.disabled, y = t1.colorModeForRenderPass(), x = "$debug";
            l.activeTexture.set(h.TEXTURE0), t1.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), d ? m._makeGlobeTileDebugBuffers(t1.context, c) : m._makeDebugTileBoundsBuffers(t1.context, c.projection);
            const b = m._tileDebugBuffer || t1.debugBuffer, w = m._tileDebugIndexBuffer || t1.debugIndexBuffer, T = m._tileDebugSegments || t1.debugSegments;
            if (f.draw(t1, h.LINE_STRIP, g, v, y, qi.disabled, _s(_, r.toPremultipliedRenderColor(null)), x, b, w, T, null, null, null, [
                m._globeTileDebugBorderBuffer
            ]), a) {
                const e = m.latestRawTileData, i = Math.floor((e && e.byteLength || 0) / 1024);
                let r = o.canonical.toString();
                o.overscaledZ !== o.canonical.z && (r += ` => ${o.overscaledZ}`), r += ` ${m.state}`, r += ` ${i}kb`, function(e, t1) {
                    e.initDebugOverlayCanvas();
                    const i = e.debugOverlayCanvas, o = e.context.gl, r = e.debugOverlayCanvas.getContext("2d");
                    r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t1, 5, 5), r.strokeText(t1, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
                }(t1, r);
            }
            const E = i.getTile(o).tileSize, S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5, I = m._tileDebugTextBuffer || t1.debugBuffer, C = m._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, R = m._tileDebugTextSegments || t1.debugSegments;
            f.draw(t1, h.TRIANGLES, g, v, ki.alphaBlended, qi.disabled, _s(_, e.am.transparent.toPremultipliedRenderColor(null), S), x, I, C, R, null, null, null, [
                m._globeTileDebugTextBuffer
            ]);
        }
        function yn(e, t1, i, o) {
            bn(e, 0, t1 + i / 2, e.transform.width, i, o);
        }
        function xn(e, t1, i, o) {
            bn(e, t1 - i / 2, 0, i, e.transform.height, o);
        }
        function bn(t1, i, o, r, s, n) {
            const a = t1.context, l = a.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e.q.devicePixelRatio, o * e.q.devicePixelRatio, r * e.q.devicePixelRatio, s * e.q.devicePixelRatio), a.clear({
                color: n
            }), l.disable(l.SCISSOR_TEST);
        }
        const wn = e.ec([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: Tn } = wn;
        function En(e, t1, i, o) {
            e.emplaceBack(t1, i, o);
        }
        class Sn {
            constructor(t1){
                this.vertexArray = new e.eg, this.indices = new e.a_, En(this.vertexArray, -1, -1, 1), En(this.vertexArray, 1, -1, 1), En(this.vertexArray, -1, 1, 1), En(this.vertexArray, 1, 1, 1), En(this.vertexArray, -1, -1, -1), En(this.vertexArray, 1, -1, -1), En(this.vertexArray, -1, 1, -1), En(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, Tn), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e.bd.simpleSegment(0, 0, 36, 12);
            }
        }
        function In(t1, i, o, r, s, n) {
            const a = t1.context.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), d = ((e, t1, i, o, r)=>({
                    u_matrix_3f: e,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        r.r,
                        r.g,
                        r.b,
                        r.a
                    ],
                    u_luminance: 5e-5
                }))(e.ei(e.dJ(), r), s, h, l.toPremultipliedRenderColor(null), c.toPremultipliedRenderColor(null));
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t1, a.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.frontCW, d, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const Cn = e.ec([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class Rn {
            constructor(t1){
                const i = new e.ej;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e.a_;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, Cn.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e.bd.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const An = e.ec([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_size_scale",
                components: 1
            },
            {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1
            }
        ]);
        class Dn {
            constructor(){
                this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;
            }
        }
        class Pn {
            constructor(t1){
                this.colorModeAlphaBlendedWriteRGB = new ki([
                    1,
                    Bi,
                    1,
                    Bi
                ], e.am.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ]), this.colorModeWriteAlpha = new ki([
                    1,
                    0,
                    1,
                    0
                ], e.am.transparent, [
                    !1,
                    !1,
                    !1,
                    !0
                ]), this.params = new Dn, this.updateNeeded = !0, t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "starsCount", {
                    min: 100,
                    max: 16e3,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeMultiplier", {
                    min: .01,
                    max: 2,
                    step: .01
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "intensityRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                });
            }
            update(t1) {
                const i = t1.context;
                if (!this.atmosphereBuffer || this.updateNeeded) {
                    this.updateNeeded = !1, this.atmosphereBuffer = new Rn(i);
                    const t1 = this.params.sizeRange, o = this.params.intensityRange, r = function(t1) {
                        const i = e.el(30), o = [];
                        for(let r = 0; r < t1; ++r){
                            const t1 = 2 * Math.PI * i(), r = Math.acos(1 - 2 * i()) - .5 * Math.PI;
                            o.push(e.d2(Math.cos(r) * Math.cos(t1), Math.cos(r) * Math.sin(t1), Math.sin(r)));
                        }
                        return o;
                    }(this.params.starsCount), s = e.el(300), n = new e.ek, a = new e.a_;
                    let l = 0;
                    for(let i = 0; i < r.length; ++i){
                        const c = e.c1([], r[i], 200), h = Math.max(0, 1 + .01 * t1 * (1 * s() - .5)), d = Math.max(0, 1 + .01 * o * (1 * s() - .5));
                        n.emplaceBack(c[0], c[1], c[2], -1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, d), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, d), a.emplaceBack(l + 0, l + 1, l + 2), a.emplaceBack(l + 0, l + 2, l + 3), l += 4;
                    }
                    this.starsVx = i.createVertexBuffer(n, An.members), this.starsIdx = i.createIndexBuffer(a), this.starsSegments = e.bd.simpleSegment(0, 0, n.length, a.length);
                }
            }
            destroy() {
                this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t1, i) {
                const o = t1.context, r = o.gl, s = t1.transform, n = new Ni(r.LEQUAL, Ni.ReadOnly, [
                    0,
                    1
                ]), a = e.ah(s.zoom), l = t1.style.getLut(i.scope), c = "none" === i.properties.get("color-use-theme"), h = i.properties.get("color").toNonPremultipliedRenderColor(c ? null : l).toArray01(), d = "none" === i.properties.get("high-color-use-theme"), u = i.properties.get("high-color").toNonPremultipliedRenderColor(d ? null : l).toArray01(), _ = "none" === i.properties.get("space-color-use-theme"), p = i.properties.get("space-color").toNonPremultipliedRenderColor(_ ? null : l).toArray01(), f = 5e-4, m = e.em(i.properties.get("horizon-blend"), 0, 1, f, .25), g = e.dy(t1, o, s) && m === f ? s.worldSize / (2 * Math.PI * 1.025) - 1 : s.globeRadius, v = t1.frameCounter / 1e3 % 1, y = e.ae(s.globeCenterInViewSpace), x = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2)), b = Math.acos(x / y), w = (e)=>{
                    const i = "globe" === s.projection.name ? [
                        "PROJECTION_GLOBE_VIEW",
                        "FOG"
                    ] : [
                        "FOG"
                    ];
                    e && i.push("ALPHA_PASS");
                    const l = t1.getOrCreateProgram("globeAtmosphere", {
                        defines: i
                    }), c = ((e, t1, i, o, r, s, n, a, l, c, h, d)=>({
                            u_frustum_tl: e,
                            u_frustum_tr: t1,
                            u_frustum_br: i,
                            u_frustum_bl: o,
                            u_horizon: r,
                            u_transition: s,
                            u_fadeout_range: n,
                            u_color: a,
                            u_high_color: l,
                            u_space_color: c,
                            u_temporal_offset: h,
                            u_horizon_angle: d
                        }))(s.frustumCorners.TL, s.frustumCorners.TR, s.frustumCorners.BR, s.frustumCorners.BL, s.frustumCorners.horizon, a, m, h, u, p, v, b);
                    t1.uploadCommonUniforms(o, l);
                    const d = this.atmosphereBuffer;
                    d && l.draw(t1, r.TRIANGLES, n, ji.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, qi.backCW, c, e ? "atmosphere_glow_alpha" : "atmosphere_glow", d.vertexBuffer, d.indexBuffer, d.segments);
                };
                w(!1), w(!0);
            }
            drawStars(t1, i) {
                const o = e.ay(i.properties.get("star-intensity"), 0, 1);
                if (0 === o) return;
                const r = t1.context, s = r.gl, n = t1.transform, a = t1.getOrCreateProgram("stars"), l = e.c3([]);
                e.c5(l, l, -n._pitch), e.c4(l, l, -n.angle), e.c5(l, l, e.al(n._center.lat)), e.en(l, l, -e.al(n._center.lng));
                const c = e.c8(new Float32Array(16), l), h = e.az([], n.starsProjMatrix, c), d = e.ei([], c), u = e.eo([], d), _ = [
                    0,
                    1,
                    0
                ];
                e.dL(_, _, u), e.c1(_, _, this.params.sizeMultiplier);
                const p = [
                    1,
                    0,
                    0
                ];
                e.dL(p, p, u), e.c1(p, p, this.params.sizeMultiplier);
                const f = (m = _, g = p, v = o, {
                    u_matrix: Float32Array.from(h),
                    u_up: m,
                    u_right: g,
                    u_intensity_multiplier: v
                });
                var m, g, v;
                t1.uploadCommonUniforms(r, a), this.starsVx && this.starsIdx && a.draw(t1, s.TRIANGLES, Ni.disabled, ji.disabled, this.colorModeAlphaBlendedWriteRGB, qi.disabled, f, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
        }
        class Ln {
            constructor(){
                this.visibleTiles = [];
            }
            updateBorders(t1, i) {
                const o = [], r = [], s = t1._getRenderableCoordinates(!1, !0);
                for (const e of s){
                    const s = t1.getTile(e);
                    if (!s.hasData()) continue;
                    const n = s.getBucket(i);
                    n && (n.isEmpty() || (o.push(e.key), r.push({
                        bucket: n,
                        tileID: e.canonical
                    })));
                }
                let n = o.length !== this.visibleTiles.length;
                if (!n) {
                    o.sort();
                    for(let e = 0; e < o.length; e++)if (o[e] !== this.visibleTiles[e]) {
                        n = !0;
                        break;
                    }
                }
                if (!n) return;
                const a = new Set;
                this.visibleTiles = o, r.sort((e, t1)=>e.tileID.z - t1.tileID.z || e.tileID.x - t1.tileID.x || e.tileID.y - t1.tileID.y);
                for (const t1 of r){
                    const i = new Array, o = new Array, r = t1.bucket;
                    for (const e of r.featuresOnBorder)a.has(e.featureId) ? o.push(e.footprintIndex) : (a.add(e.featureId), i.push(e.footprintIndex));
                    r.updateFootprintHiddenFlags(i, e.ep, !1), r.updateFootprintHiddenFlags(o, e.ep, !0);
                }
            }
        }
        function zn(t1, i) {
            const o = [
                ...t1
            ], r = i.cameraWorldSizeForFog / i.worldSize, s = e.bx([]);
            return e.cP(s, s, [
                r,
                r,
                1
            ]), e.az(o, s, o), e.az(o, i.worldToFogMatrix, o), o;
        }
        function Mn(t1, i, o, r, s) {
            const n = o.material, a = r.context, { baseColorTexture: l, metallicRoughnessTexture: c } = n.pbrMetallicRoughness, { normalTexture: h, occlusionTexture: d, emissionTexture: u } = n;
            function _(e, i, o) {
                if (e && (t1.push(i), a.activeTexture.set(a.gl.TEXTURE0 + o), e.gfxTexture)) {
                    const { minFilter: t1, magFilter: i, wrapS: o, wrapT: r } = e.sampler;
                    e.gfxTexture.bindExtraParam(t1, i, o, r);
                }
            }
            _(l, "HAS_TEXTURE_u_baseColorTexture", Yi.BaseColor), _(c, "HAS_TEXTURE_u_metallicRoughnessTexture", Yi.MetallicRoughness), _(h, "HAS_TEXTURE_u_normalTexture", Yi.Normal), _(d, "HAS_TEXTURE_u_occlusionTexture", Yi.Occlusion), _(u, "HAS_TEXTURE_u_emissionTexture", Yi.Emission), s && (s.texture || (s.texture = new e.et(r.context, s.image, [
                s.image.height,
                s.image.height,
                s.image.height
            ], a.gl.RGBA8)), a.activeTexture.set(a.gl.TEXTURE0 + Yi.LUT), s.texture && s.texture.bind(a.gl.LINEAR, a.gl.CLAMP_TO_EDGE), t1.push("APPLY_LUT_ON_GPU")), o.texcoordBuffer && (t1.push("HAS_ATTRIBUTE_a_uv_2f"), i.push(o.texcoordBuffer)), o.colorBuffer && (t1.push(12 === o.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i.push(o.colorBuffer)), o.normalBuffer && (t1.push("HAS_ATTRIBUTE_a_normal_3f"), i.push(o.normalBuffer)), o.pbrBuffer && (t1.push("HAS_ATTRIBUTE_a_pbr"), t1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i.push(o.pbrBuffer)), "OPAQUE" !== n.alphaMode && "MASK" !== n.alphaMode || t1.push("UNPREMULT_TEXTURE_IN_SHADER"), n.defined || t1.push("DIFFUSE_SHADED");
            const p = r.shadowRenderer;
            p && (t1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p.useNormalOffset && t1.push("NORMAL_OFFSET"));
        }
        function On(t1, i, o, r, s, n) {
            const a = o.paint.get("model-opacity").constantOr(1), l = i.context, c = new Ni(i.context.gl.LEQUAL, Ni.ReadWrite, i.depthRangeFor3D), h = i.transform, d = t1.mesh, u = d.material, _ = u.pbrMetallicRoughness, p = i.style.fog;
            let f;
            f = "pixels" === i.transform.projection.zAxisUnit ? [
                ...t1.nodeModelMatrix
            ] : e.az([], r.zScaleMatrix, t1.nodeModelMatrix), e.az(f, r.negCameraPosMatrix, f);
            const m = e.bi([], f);
            e.ea(m, m);
            const g = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = o.paint.get("model-emissive-strength").constantOr(0), y = As(new Float32Array(t1.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, a, _.baseColorFactor, u.emissiveFactor, _.metallicFactor, _.roughnessFactor, u, v, o), x = {
                defines: []
            }, b = [], w = i.shadowRenderer;
            w && (w.useNormalOffset = !1), Mn(x.defines, b, d, i, g ? null : o.lut);
            let T = null;
            if (p) {
                const e = zn(t1.nodeModelMatrix, i.transform);
                if (T = new Float32Array(e), "globe" !== h.projection.name) {
                    const t1 = d.aabb.min, i = d.aabb.max, [o, r] = p.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                    x.overrideFog = o >= Fe || r >= Fe;
                }
            }
            const E = eo(i, o.paint.get("model-cutoff-fade-range"));
            E.shouldRenderCutoff && x.defines.push("RENDER_CUTOFF");
            const S = i.getOrCreateProgram("model", x);
            i.uploadCommonUniforms(l, S, null, T, E), "shadow" !== i.renderPass && w && w.setupShadowsFromMatrix(t1.nodeModelMatrix, S), S.draw(i, l.gl.TRIANGLES, c, s, n, d.material.doubleSided ? qi.disabled : qi.backCCW, y, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, i.transform.zoom, void 0, b);
        }
        function Fn(t1, i, o, r, s, n, a) {
            let l;
            l = "globe" === t1.projection.name ? e.er(o, t1) : [
                ...o
            ], e.az(l, l, i.matrix);
            const c = e.az([], r, l);
            if (i.meshes) for (const o of i.meshes){
                if ("BLEND" !== o.material.alphaMode) {
                    a.push({
                        mesh: o,
                        depth: 0,
                        modelIndex: s,
                        worldViewProjection: c,
                        nodeModelMatrix: l
                    });
                    continue;
                }
                const i = e.ad([], o.centroid, c);
                !t1.isOrthographic && i[2] <= 0 || n.push({
                    mesh: o,
                    depth: i[2],
                    modelIndex: s,
                    worldViewProjection: c,
                    nodeModelMatrix: l
                });
            }
            if (i.children) for (const e of i.children)Fn(t1, e, o, r, s, n, a);
        }
        function Bn(e, t1, i, o) {
            const r = i.shadowRenderer;
            if (!r) return;
            const s = r.getShadowPassDepthMode(), n = r.getShadowPassColorMode(), a = r.calculateShadowPassMatrixFromMatrix(t1), l = Ds(a);
            i.getOrCreateProgram("modelDepth", {
                defines: i._shadowMapDebug ? [] : [
                    "DEPTH_TEXTURE"
                ]
            }).draw(i, i.context.gl.TRIANGLES, s, ji.disabled, n, qi.backCCW, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);
        }
        function kn(t1, i, o) {
            const r = i.updateZoomBasedPaintProperties(), s = function(t1, i, o) {
                let r, s, n, a = t1.terrain ? t1.terrain.exaggeration() : 0;
                if (t1.terrain && a > 0) {
                    const i = t1.terrain, s = i.findDEMTileFor(o);
                    s && s.dem ? r = e.eu.create(i, o, s) : a = 0;
                }
                if (0 === a && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), a === i.validForExaggeration && (0 === a || r && r._demTile && r._demTile.tileID === i.validForDEMTile.id && r._dem._timestamp === i.validForDEMTile.timestamp)) return !1;
                for(const e in i.instancesPerModel){
                    const t1 = i.instancesPerModel[e];
                    for(let e = 0; e < t1.instancedDataArray.length; ++e){
                        const o = (r ? a * r.getElevationAt(0 | t1.instancedDataArray.float32[16 * e], 0 | t1.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t1.instancesEvaluatedElevation[e];
                        t1.instancedDataArray.float32[16 * e + 6] = o, s = s ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;
                    }
                }
                return i.terrainElevationMin = s || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = a, i.validForDEMTile = r && r._demTile ? {
                    id: r._demTile.tileID,
                    timestamp: r._dem._timestamp
                } : {
                    id: void 0,
                    timestamp: 0
                }, !0;
            }(t1, i, o);
            (r || s) && (i.uploaded = !1, i.upload(t1.context));
        }
        const Nn = {
            shadowUniformsInitialized: !1,
            useSingleShadowCascade: !1,
            tileMatrix: new Float64Array(16),
            shadowTileMatrix: new Float32Array(16),
            aabb: new e.d6([
                0,
                0,
                0
            ], [
                e.aj,
                e.aj,
                0
            ])
        };
        function Un(t1, i) {
            const o = 1 << t1.canonical.z, r = i.getFreeCameraOptions().position, s = i.elevation, n = t1.canonical.x / o, a = (t1.canonical.x + 1) / o, l = t1.canonical.y / o, c = (t1.canonical.y + 1) / o;
            let h = i._centerAltitude;
            if (s) {
                const e = s.getMinMaxForTile(t1);
                e && e.max > h && (h = e.max);
            }
            const d = e.ay(r.x, n, a) - r.x, u = e.ay(r.y, l, c) - r.y, _ = e.cb(h, i.center.lat) - r.z;
            return i._zoomFromMercatorZ(Math.sqrt(d * d + u * u + _ * _));
        }
        function jn(e, t1, i, o, r, s, n) {
            const a = e.context, l = "shadow" === e.renderPass, c = e.shadowRenderer, h = l && c ? c.getShadowPassDepthMode() : new Ni(a.gl.LEQUAL, Ni.ReadWrite, e.depthRangeFor3D), d = e.isTileAffectedByFog(s);
            if (i.meshes) for (const u of i.meshes){
                const _ = [
                    "MODEL_POSITION_ON_GPU"
                ], p = [];
                let f, m, g;
                o.instancedDataArray.length > 20 && _.push("INSTANCED_ARRAYS");
                const v = eo(e, t1.paint.get("model-cutoff-fade-range"));
                if (v.shouldRenderCutoff && _.push("RENDER_CUTOFF"), l && c) f = e.getOrCreateProgram("modelDepth", {
                    defines: _
                }), m = Ds(n.shadowTileMatrix, n.shadowTileMatrix, Float32Array.from(i.matrix)), g = c.getShadowPassColorMode();
                else {
                    Mn(_, p, u, e, "none" === t1.paint.get("model-color-use-theme").constantOr("default") ? null : t1.lut), f = e.getOrCreateProgram("model", {
                        defines: _,
                        overrideFog: d
                    });
                    const o = u.material, l = o.pbrMetallicRoughness, h = t1.paint.get("model-opacity").constantOr(1), y = t1.paint.get("model-emissive-strength").constantOr(0);
                    m = As(s.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), null, e, h, l.baseColorFactor, o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, y, t1, r), c && (n.shadowUniformsInitialized ? f.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(s.toUnwrapped(), f, "model-tile"), n.shadowUniformsInitialized = !0)), g = v.shouldRenderCutoff || h < 1 || "OPAQUE" !== o.alphaMode ? ki.alphaBlended : ki.unblended;
                }
                e.uploadCommonUniforms(a, f, s.toUnwrapped(), null, v);
                const y = u.material.doubleSided ? qi.disabled : qi.backCCW;
                if (o.instancedDataArray.length > 20) p.push(o.instancedDataBuffer), f.draw(e, a.gl.TRIANGLES, h, ji.disabled, g, y, m, t1.id, u.vertexBuffer, u.indexBuffer, u.segments, t1.paint, e.transform.zoom, void 0, p, o.instancedDataArray.length);
                else {
                    const i = l ? "u_instance" : "u_normal_matrix";
                    for(let r = 0; r < o.instancedDataArray.length; ++r)m[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * r, 16), f.draw(e, a.gl.TRIANGLES, h, ji.disabled, g, y, m, t1.id, u.vertexBuffer, u.indexBuffer, u.segments, t1.paint, e.transform.zoom, void 0, p);
                }
            }
            if (i.children) for (const a of i.children)jn(e, t1, a, o, r, s, n);
        }
        const Gn = [
            1,
            -1,
            1
        ];
        function Vn(t1, i, o, r) {
            if (!o.modelManager) return !0;
            const s = o.modelManager;
            if (!o.shadowRenderer) return !0;
            const n = o.shadowRenderer, a = i.aabb;
            let l = !0, c = t1.maxHeight;
            if (0 === c) {
                let e = 0;
                for(const i in t1.instancesPerModel){
                    const t1 = s.getModel(i, r);
                    t1 ? e = Math.max(e, Math.max(Math.max(t1.aabb.max[0], t1.aabb.max[1]), t1.aabb.max[2])) : l = !1;
                }
                c = t1.maxScale * e * 1.41 + t1.maxVerticalOffset, l && (t1.maxHeight = c);
            }
            a.max[2] = c, a.min[2] += t1.terrainElevationMin, a.max[2] += t1.terrainElevationMax, e.ad(a.min, a.min, i.tileMatrix), e.ad(a.max, a.max, i.tileMatrix);
            const h = a.intersects(n.getCurrentCascadeFrustum());
            return 0 === o.currentShadowCascade && (t1.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;
        }
        function qn(t1, i) {
            const o = t1.uniformValues.u_cutoff_params[0], r = t1.uniformValues.u_cutoff_params[1], s = t1.uniformValues.u_cutoff_params[2], n = t1.uniformValues.u_cutoff_params[3];
            return r === o || n === s ? 1 : e.ay(((i - o) / (r - o) - s) / (n - s), 0, 1);
        }
        function Hn(t1, i, o, r) {
            if (i.pitch < 20) return 1;
            const s = i.getWorldToCameraMatrix();
            e.az(s, s, t1);
            const n = e.bR(o.min[0], o.min[1], o.min[2], 1);
            let a = e.aA(e.ev(), n, s), l = a, c = a;
            n[1] = o.max[1], a = e.aA(e.ev(), n, s), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[0] = o.max[0], a = e.aA(e.ev(), n, s), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[1] = o.min[1], a = e.aA(e.ev(), n, s), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c;
            const h = e.ay(r[0], 0, 1), d = 100 * i.pixelsPerMeter * e.ay(r[1], 0, 1), u = e.ay(r[2], 0, 1), _ = e.ew(e.ev(), l, c, h), p = Math.tan(.5 * i.fovX), f = -_[2] * p;
            if (0 === d) return _[1] < -Math.abs(f) ? u : 1;
            const m = (-Math.abs(f) - _[1]) / d, g = (e, t1, i)=>(1 - i) * e + i * t1, v = e.ay(g(1, u, m), u, 1);
            return g(1, v, e.ay((i.pitch - 20) / 20, 0, 1));
        }
        class Zn {
        }
        class Wn {
            constructor(){
                this._storage = new Map;
            }
            getLinesFromTrianglesBuffer(t1, i, o) {
                {
                    const e = this._storage.get(i.id);
                    if (e) return e.lastUsedFrameIdx = t1, e.buf;
                }
                const r = o.gl, s = r.getBufferParameter(r.ELEMENT_ARRAY_BUFFER, r.BUFFER_SIZE), n = new ArrayBuffer(s), a = new Int16Array(n);
                r.getBufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));
                const l = new e.ey;
                for(let e = 0; e < s / 2; e += 3){
                    const t1 = a[e], i = a[e + 1], o = a[e + 2];
                    l.emplaceBack(t1, i), l.emplaceBack(i, o), l.emplaceBack(o, t1);
                }
                const c = o.bindVertexArrayOES.current, h = new Zn;
                return h.buf = new Ls(o, l), h.lastUsedFrameIdx = t1, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;
            }
            update(e) {
                for (const [t1, i] of this._storage)e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t1));
            }
            destroy() {
                for (const [e, t1] of this._storage)t1.buf.destroy(), this._storage.delete(e);
            }
        }
        class $n {
            constructor(e){
                this.occluderSize = 30, this.depthOffset = -1e-4, e.registerParameter(this, [
                    "Occlusion"
                ], "occluderSize", {
                    min: 1,
                    max: 100,
                    step: 1
                }), e.registerParameter(this, [
                    "Occlusion"
                ], "depthOffset", {
                    min: -.05,
                    max: 0,
                    step: 1e-5
                });
            }
        }
        const Xn = e.ec([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_rainParticleData",
                components: 4
            }
        ]);
        class Yn {
            registerParameter() {}
            registerButton() {}
            registerBinding() {}
            refreshUI() {}
        }
        class Kn {
            constructor(e, t1){
                this.revealStart = 11, this.revealRange = 2, e.registerParameter(this, [
                    ...t1,
                    "Reveal"
                ], "revealStart", {
                    min: 0,
                    max: 17,
                    step: .05
                }), e.registerParameter(this, [
                    ...t1,
                    "Reveal"
                ], "revealRange", {
                    min: .1,
                    max: 5.1,
                    step: .05
                });
            }
        }
        const Jn = e.ec([
            {
                type: "Float32",
                name: "a_pos_2f",
                components: 2
            }
        ]);
        class Qn {
            destroy() {
                this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
            }
            draw(t1, i) {
                const o = t1.getOrCreateProgram("vignette");
                if (!this.vignetteVx || !this.vignetteIdx) {
                    const i = new e.ez, o = new e.a_;
                    i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.vignetteVx = t1.context.createVertexBuffer(i, Jn.members), this.vignetteIdx = t1.context.createIndexBuffer(o);
                }
                const r = e.bd.simpleSegment(0, 0, 4, 6);
                if (this.vignetteVx && this.vignetteIdx) {
                    t1.uploadCommonUniforms(t1.context, o);
                    const e = {
                        u_vignetteShape: (s = {
                            vignetteShape: [
                                i.start,
                                i.range,
                                Math.pow(10, i.fadePower)
                            ],
                            vignetteColor: [
                                i.color.r,
                                i.color.g,
                                i.color.b,
                                i.color.a * i.strength
                            ]
                        }).vignetteShape,
                        u_vignetteColor: s.vignetteColor
                    };
                    o.draw(t1, t1.context.gl.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, e, "vignette", this.vignetteVx, this.vignetteIdx, r);
                }
                var s;
            }
        }
        class ea {
            constructor(){
                this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            }
            update(t1, i) {
                const o = t1.getFreeCameraOptions().position, r = o.toAltitude(), s = o.toLngLat(), n = e.al(s.lng), a = e.al(s.lat), l = t1.pixelsPerMeter / i, c = n * e.eB, h = e.eB * Math.log(Math.tan(Math.PI / 4 + a / 2));
                if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
                else {
                    const e = -this._offsetYPrev + h, t1 = -this._elevationPrev + r;
                    this._accumulatedOffsetX += (-this._offsetXPrev + c) * l, this._accumulatedOffsetY += e * l, this._accumulatedElevation += t1 * l, this._offsetXPrev = c, this._offsetYPrev = h, this._elevationPrev = r;
                }
            }
            getPosition() {
                return [
                    this._accumulatedOffsetX,
                    this._accumulatedOffsetY,
                    this._accumulatedElevation
                ];
            }
        }
        function ta(e, t1) {
            return [
                -(e[0] - Math.floor(e[0] / t1) * t1),
                -(e[1] - Math.floor(e[1] / t1) * t1),
                -(e[2] - Math.floor(e[2] / t1) * t1)
            ];
        }
        function ia(t1) {
            const i = e.el(1323123451230), o = [];
            for(let r = 0; r < t1; ++r){
                const t1 = 2 * i() - 1, r = 2 * i() - 1, s = 2 * i() - 1;
                o.push(e.d2(t1, r, s));
            }
            return o;
        }
        function oa(t1, i, o, r, s) {
            const n = e.ay((s - o) / (r - o), 0, 1);
            return (1 - n) * t1 + n * i;
        }
        class ra {
            constructor(e){
                this._movement = new ea, this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Qn, this._ppmScaleFactor = e;
            }
            destroy() {
                this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
            }
            updateOnRender(t1, i) {
                const o = t1.transform;
                this._movement.update(o, this._ppmScaleFactor);
                const r = o.starsProjMatrix, s = e.c3([]);
                e.c5(s, s, e.al(90) - o._pitch), e.c4(s, s, -o.angle);
                const n = e.c8(new Float32Array(16), s), a = e.eA(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l = e.ea([], a), c = e.az([], l, n), h = Date.now() / 1e3;
                return this._accumulatedTimeFromStart += (h - this._prevTime) * i, this._prevTime = h, {
                    projectionMatrix: r,
                    modelviewMatrix: c
                };
            }
        }
        class sa extends ra {
            constructor(e){
                super(4.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .5,
                    timeFactor: 1,
                    velocityConeAperture: 0,
                    velocity: 300,
                    boxSize: 2500,
                    dropletSizeX: 1,
                    dropletSizeYScale: 10,
                    distortionStrength: 70,
                    screenThinning: {
                        intensity: .57,
                        start: .46,
                        range: 1.17,
                        fadePower: .17,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: .66,
                        g: .68,
                        b: .74,
                        a: .7
                    },
                    direction: {
                        x: -50,
                        y: -35
                    },
                    shapeDirPower: 2,
                    shapeNormalPower: 1
                }, this._revealParams = new Kn(e.tp, [
                    "Precipitation",
                    "Rain"
                ]), this._vignetteParams = {
                    strength: 1,
                    start: .7,
                    range: 1,
                    fadePower: .4,
                    color: {
                        r: .27,
                        g: .27,
                        b: .27,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = ia(this.particlesCount), o = new e.eC, r = new e.a_;
                    let s = 0;
                    const n = e.el(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], a = [
                            2 * n() - 1,
                            n(),
                            n(),
                            n()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...a), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...a), r.emplaceBack(s + 0, s + 1, s + 2), r.emplaceBack(s + 0, s + 2, s + 3), s += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, Xn.members), this.particlesIdx = i.createIndexBuffer(r);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.rain) return;
                const i = this._params.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, o = t1.transform.zoom;
                if (i.revealStart > o) return;
                const r = oa(0, 1, i.revealStart, i.revealStart + i.revealRange, o);
                if (!this.particlesVx || !this.particlesIdx) return;
                const s = structuredClone(this._params);
                let n = [
                    -s.direction.x,
                    s.direction.y,
                    -100
                ];
                e.au(n, n);
                const a = structuredClone(this._vignetteParams);
                a.strength *= r, s.overrideStyleParameters || (s.intensity = t1.style.rain.state.density, s.timeFactor = t1.style.rain.state.intensity, s.color = structuredClone(t1.style.rain.state.color), n = structuredClone(t1.style.rain.state.direction), s.screenThinning.intensity = t1.style.rain.state.centerThinning, s.dropletSizeX = t1.style.rain.state.dropletSize[0], s.dropletSizeYScale = t1.style.rain.state.dropletSize[1] / t1.style.rain.state.dropletSize[0], s.distortionStrength = 100 * t1.style.rain.state.distortionStrength, a.strength = 1, a.color = structuredClone(t1.style.rain.state.vignetteColor));
                const l = this.updateOnRender(t1, s.timeFactor), c = t1.context, h = c.gl, d = t1.transform;
                this.screenTexture && this.screenTexture.size[0] === t1.width && this.screenTexture.size[1] === t1.height || (this.screenTexture = new e.T(c, {
                    width: t1.width,
                    height: t1.height,
                    data: null
                }, h.RGBA8)), s.distortionStrength > 0 && (c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, 0, 0, t1.width, t1.height));
                const u = t1.getOrCreateProgram("rainParticle");
                t1.uploadCommonUniforms(c, u), c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
                const _ = [
                    s.color.r,
                    s.color.g,
                    s.color.b,
                    s.color.a
                ], p = (i, o)=>{
                    const r = ta(this._movement.getPosition(), i), a = s.dropletSizeX, c = s.dropletSizeX * s.dropletSizeYScale, p = t1.width / 2, f = t1.height / 2, m = oa(0, s.screenThinning.start, 0, 1, s.screenThinning.intensity), g = oa(.001, s.screenThinning.range, 0, 1, s.screenThinning.intensity), v = oa(0, s.screenThinning.particleOffset, 0, 1, s.screenThinning.intensity), y = (x = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: r,
                        velocityConeAperture: s.velocityConeAperture,
                        velocity: s.velocity,
                        boxSize: i,
                        rainDropletSize: [
                            a,
                            c
                        ],
                        distortionStrength: s.distortionStrength,
                        rainDirection: n,
                        color: _,
                        screenSize: [
                            d.width,
                            d.height
                        ],
                        thinningCenterPos: [
                            p,
                            f
                        ],
                        thinningShape: [
                            m,
                            g,
                            Math.pow(10, s.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: s.screenThinning.affectedRatio,
                        thinningParticleOffset: v,
                        shapeDirectionalPower: s.shapeDirPower,
                        shapeNormalPower: s.shapeNormalPower,
                        mode: o ? 0 : 1
                    }, {
                        u_modelview: Float32Array.from(x.modelview),
                        u_projection: Float32Array.from(x.projection),
                        u_time: x.time,
                        u_cam_pos: x.camPos,
                        u_texScreen: 0,
                        u_velocityConeAperture: x.velocityConeAperture,
                        u_velocity: x.velocity,
                        u_boxSize: x.boxSize,
                        u_rainDropletSize: x.rainDropletSize,
                        u_distortionStrength: x.distortionStrength,
                        u_rainDirection: x.rainDirection,
                        u_color: x.color,
                        u_screenSize: x.screenSize,
                        u_thinningCenterPos: x.thinningCenterPos,
                        u_thinningShape: x.thinningShape,
                        u_thinningAffectedRatio: x.thinningAffectedRatio,
                        u_thinningParticleOffset: x.thinningParticleOffset,
                        u_shapeDirectionalPower: x.shapeDirectionalPower,
                        u_shapeNormalPower: x.shapeNormalPower,
                        u_mode: x.mode
                    });
                    var x;
                    const b = Math.round(s.intensity * this.particlesCount), w = e.bd.simpleSegment(0, 0, 4 * b, 2 * b);
                    u.draw(t1, h.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, y, "rain_particles", this.particlesVx, this.particlesIdx, w);
                };
                s.distortionStrength > 0 && p(s.boxSize, !0), p(s.boxSize, !1), this._vignette.draw(t1, a);
            }
        }
        const na = e.ec([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_snowParticleData",
                components: 4
            },
            {
                type: "Float32",
                name: "a_snowParticleDataHorizontalOscillation",
                components: 2
            }
        ]);
        class aa extends ra {
            constructor(e){
                super(2.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .85,
                    timeFactor: .75,
                    velocityConeAperture: 70,
                    velocity: 40,
                    horizontalOscillationRadius: 4,
                    horizontalOscillationRate: 1.5,
                    boxSize: 2e3,
                    billboardSize: 2,
                    shapeFadeStart: .27,
                    shapeFadePower: .21,
                    screenThinning: {
                        intensity: .4,
                        start: .15,
                        range: 1.4,
                        fadePower: .24,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    },
                    direction: {
                        x: -50,
                        y: -35
                    }
                }, this._revealParams = new Kn(e.tp, [
                    "Precipitation",
                    "Snow"
                ]), this._vignetteParams = {
                    strength: .3,
                    start: .78,
                    range: .46,
                    fadePower: .2,
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = ia(this.particlesCount), o = new e.eD, r = new e.a_;
                    let s = 0;
                    const n = e.el(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], a = n(), l = n(), c = n(), h = [
                            e / t1.length,
                            a,
                            l,
                            c
                        ], d = [
                            n(),
                            n()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...h, ...d), r.emplaceBack(s + 0, s + 1, s + 2), r.emplaceBack(s + 0, s + 2, s + 3), s += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, na.members), this.particlesIdx = i.createIndexBuffer(r);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.snow) return;
                const i = structuredClone(this._params);
                let o = [
                    -i.direction.x,
                    i.direction.y,
                    -100
                ];
                e.au(o, o);
                const r = structuredClone(this._vignetteParams), s = i.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, n = t1.transform.zoom;
                if (s.revealStart > n) return;
                const a = oa(0, 1, s.revealStart, s.revealStart + s.revealRange, n);
                r.strength *= a, i.overrideStyleParameters || (i.intensity = t1.style.snow.state.density, i.timeFactor = t1.style.snow.state.intensity, i.color = structuredClone(t1.style.snow.state.color), o = structuredClone(t1.style.snow.state.direction), i.screenThinning.intensity = t1.style.snow.state.centerThinning, i.billboardSize = 2.79 * t1.style.snow.state.flakeSize, r.strength = 1, r.color = structuredClone(t1.style.snow.state.vignetteColor));
                const l = this.updateOnRender(t1, i.timeFactor);
                if (!this.particlesVx || !this.particlesIdx) return;
                const c = t1.context, h = c.gl, d = t1.transform, u = t1.getOrCreateProgram("snowParticle");
                t1.uploadCommonUniforms(c, u), ((i, r, s)=>{
                    const n = ta(this._movement.getPosition(), i), a = d.width / 2, c = d.height / 2, _ = oa(0, s.screenThinning.start, 0, 1, s.screenThinning.intensity), p = oa(.001, s.screenThinning.range, 0, 1, s.screenThinning.intensity), f = oa(0, s.screenThinning.particleOffset, 0, 1, s.screenThinning.intensity), m = (g = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: n,
                        velocityConeAperture: s.velocityConeAperture,
                        velocity: s.velocity,
                        horizontalOscillationRadius: s.horizontalOscillationRadius,
                        horizontalOscillationRate: s.horizontalOscillationRate,
                        boxSize: i,
                        billboardSize: 1 * s.billboardSize,
                        simpleShapeParameters: [
                            s.shapeFadeStart,
                            s.shapeFadePower
                        ],
                        screenSize: [
                            d.width,
                            d.height
                        ],
                        thinningCenterPos: [
                            a,
                            c
                        ],
                        thinningShape: [
                            _,
                            p,
                            Math.pow(10, s.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: s.screenThinning.affectedRatio,
                        thinningParticleOffset: f,
                        color: [
                            s.color.r,
                            s.color.g,
                            s.color.b,
                            s.color.a
                        ],
                        direction: o
                    }, {
                        u_modelview: Float32Array.from(g.modelview),
                        u_projection: Float32Array.from(g.projection),
                        u_time: g.time,
                        u_cam_pos: g.camPos,
                        u_velocityConeAperture: g.velocityConeAperture,
                        u_velocity: g.velocity,
                        u_horizontalOscillationRadius: g.horizontalOscillationRadius,
                        u_horizontalOscillationRate: g.horizontalOscillationRate,
                        u_boxSize: g.boxSize,
                        u_billboardSize: g.billboardSize,
                        u_simpleShapeParameters: g.simpleShapeParameters,
                        u_screenSize: g.screenSize,
                        u_thinningCenterPos: g.thinningCenterPos,
                        u_thinningShape: g.thinningShape,
                        u_thinningAffectedRatio: g.thinningAffectedRatio,
                        u_thinningParticleOffset: g.thinningParticleOffset,
                        u_particleColor: g.color,
                        u_direction: g.direction
                    });
                    var g;
                    const v = Math.round(s.intensity * this.particlesCount), y = e.bd.simpleSegment(0, 0, 4 * v, 2 * v);
                    this.particlesVx && this.particlesIdx && u.draw(t1, h.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, m, "snow_particles", this.particlesVx, this.particlesIdx, y);
                })(i.boxSize, 0, i), this._vignette.draw(t1, r);
            }
        }
        const la = {
            symbol: function(t1, i, o, r, s) {
                if ("translucent" !== t1.renderPass) return;
                const n = ji.disabled, a = t1.colorModeForRenderPass(), l = o.layout.get("text-variable-anchor"), c = o.layout.get("text-size-scale-range"), h = e.ay(t1.scaleFactor, c[0], c[1]);
                l && function(t1, i, o, r, s, n, a, l) {
                    const c = i.transform, h = "map" === s, d = "map" === n;
                    for (const i of t1){
                        const t1 = r.getTile(i), s = t1.getBucket(o);
                        if (!s || !s.text || !s.text.segments.get().length) continue;
                        const n = e.bH(s.textSizeData, c.zoom, l), u = Vt(i, s.getProjection(), c), _ = c.calculatePixelsToTileUnitsMatrix(t1), p = $t(u, t1.tileID.canonical, d, h, c, s.getProjection(), _), f = s.hasIconTextFit() && s.hasIconData();
                        n && Gs(s, h, d, a, c, p, i, Math.pow(2, c.zoom - t1.tileID.overscaledZ), n, f);
                    }
                }(r, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), s, h);
                const d = 0 !== o.paint.get("icon-opacity").constantOr(1), u = 0 !== o.paint.get("text-opacity").constantOr(1);
                void 0 !== o.layout.get("symbol-sort-key").constantOr(1) && (d || u) ? Vs(t1, i, o, r, n, a) : (d && Vs(t1, i, o, r, n, a, {
                    onlyIcons: !0
                }), u && Vs(t1, i, o, r, n, a, {
                    onlyText: !0
                })), i.map.showCollisionBoxes && (ks(t1, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), ks(t1, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const s = o.paint.get("circle-opacity"), n = o.paint.get("circle-stroke-width"), a = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1), c = o.paint.get("circle-emissive-strength");
                if (0 === s.constantOr(1) && (0 === n.constantOr(1) || 0 === a.constantOr(1))) return;
                const h = t1.context, d = h.gl, u = t1.transform, _ = !(!t1.terrain || !t1.terrain.enabled), p = o.layout.get("circle-elevation-reference"), f = t1.depthModeForSublayer(0, Ni.ReadOnly), m = new Ni(t1.context.gl.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D), g = "none" === p || _ ? f : m, v = ji.disabled, y = t1.colorModeForDrapableLayerRenderPass(c), x = "globe" === u.projection.name, b = [
                    e.aD(u.center.lng),
                    e.aH(u.center.lat)
                ], w = [];
                for(let s = 0; s < r.length; s++){
                    const n = r[s], a = i.getTile(n), c = a.getBucket(o);
                    if (!c || c.projection.name !== u.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), d = c.layoutVertexBuffer, _ = c.globeExtVertexBuffer, p = c.indexBuffer, f = e.dW(o), m = [
                        _
                    ], g = t1.isTileAffectedByFog(n);
                    x && f.push("PROJECTION_GLOBE_VIEW"), f.push("DEPTH_D24"), t1.terrain && u.depthOcclusionForSymbolsAndCircles && f.push("DEPTH_OCCLUSION"), c.hasElevation && !t1.terrain && (f.push("ELEVATED_ROADS"), m.push(c.elevatedLayoutVertexBuffer));
                    const v = t1.getOrCreateProgram("circle", {
                        config: h,
                        defines: f,
                        overrideFog: g
                    }), y = u.projection.createInversionMatrix(u, n.canonical), T = {
                        programConfiguration: h,
                        program: v,
                        layoutVertexBuffer: d,
                        dynamicBuffers: m,
                        indexBuffer: p,
                        uniformValues: e.dX(t1, n, a, y, b, o),
                        tile: a
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)w.push({
                            segments: new e.bd([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: T
                        });
                    } else w.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: T
                    });
                }
                l && w.sort((e, t1)=>e.sortKey - t1.sortKey);
                const T = {
                    useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles
                };
                for (const e of w){
                    const { programConfiguration: i, program: r, layoutVertexBuffer: s, dynamicBuffers: n, indexBuffer: a, uniformValues: l, tile: c } = e.state, _ = e.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(c, r, T), t1.uploadCommonUniforms(h, r, c.tileID.toUnwrapped()), r.draw(t1, d.TRIANGLES, g, v, y, qi.disabled, l, o.id, s, a, _, o.paint, u.zoom, i, n);
                }
            },
            heatmap: function(t1, i, o, r) {
                if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t1.renderPass) {
                    const s = t1.context, n = s.gl, a = ji.disabled, l = new ki([
                        n.ONE,
                        n.ONE,
                        n.ONE,
                        n.ONE
                    ], e.am.transparent, [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                    !function(e, t1, i, o) {
                        const r = e.gl, s = t1.width * o, n = t1.height * o;
                        e.activeTexture.set(r.TEXTURE1), e.viewport.set([
                            0,
                            0,
                            s,
                            n
                        ]);
                        let a = i.heatmapFbo;
                        if (!a || a && (a.width !== s || a.height !== n)) {
                            a && a.destroy();
                            const t1 = r.createTexture();
                            r.bindTexture(r.TEXTURE_2D, t1), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e.createFramebuffer(s, n, !0, null), function(e, t1, i, o, r, s) {
                                const n = e.gl;
                                n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, r, s, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                            }(e, 0, t1, a, s, n);
                        } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);
                    }(s, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), s.clear({
                        color: e.am.transparent
                    });
                    const c = t1.transform, h = "globe" === c.projection.name, d = h ? [
                        "PROJECTION_GLOBE_VIEW"
                    ] : [], u = h ? qi.frontCCW : qi.disabled, _ = [
                        e.aD(c.center.lng),
                        e.aH(c.center.lat)
                    ];
                    for(let e = 0; e < r.length; e++){
                        const p = r[e];
                        if (i.hasRenderableParent(p)) continue;
                        const f = i.getTile(p), m = f.getBucket(o);
                        if (!m || m.projection.name !== c.projection.name) continue;
                        const g = t1.isTileAffectedByFog(p), v = m.programConfigurations.get(o.id), y = t1.getOrCreateProgram("heatmap", {
                            config: v,
                            defines: d,
                            overrideFog: g
                        }), { zoom: x } = t1.transform;
                        t1.terrain && t1.terrain.setupElevationDraw(f, y), t1.uploadCommonUniforms(s, y, p.toUnwrapped());
                        const b = c.projection.createInversionMatrix(c, p.canonical);
                        y.draw(t1, n.TRIANGLES, Ni.disabled, a, l, u, fs(t1, p, f, b, _, x, o.paint.get("heatmap-intensity")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t1.transform.zoom, v, h ? [
                            m.globeExtVertexBuffer
                        ] : null);
                    }
                    s.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                    const o = t1.context, r = o.gl, s = i.heatmapFbo;
                    if (!s) return;
                    o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, s.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
                    let n = i.colorRampTexture;
                    n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA8)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), t1.getOrCreateProgram("heatmapTexture").draw(t1, r.TRIANGLES, Ni.disabled, ji.disabled, t1.colorModeForRenderPass(), qi.disabled, ((e, t1, i, o)=>({
                            u_image: 0,
                            u_color_ramp: 1,
                            u_opacity: t1.paint.get("heatmap-opacity")
                        }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                }(t1, o));
            },
            line: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const s = o.paint.get("line-opacity"), n = o.paint.get("line-width");
                if (0 === s.constantOr(1) || 0 === n.constantOr(1)) return;
                const a = o.paint.get("line-emissive-strength"), l = o.paint.get("line-occlusion-opacity"), c = o.layout.get("line-elevation-reference"), h = "meters" === o.layout.get("line-width-unit"), d = "sea" === c, u = !(!t1.terrain || !t1.terrain.enabled), _ = t1.context, p = _.gl;
                if (o.hasElevatedBuckets && "globe" === t1.transform.projection.name) return;
                const f = o.layout.get("line-cross-slope"), m = void 0 !== f, g = f < 1, v = t1.colorModeForDrapableLayerRenderPass(a), y = t1.terrain && t1.terrain.renderingToTexture, x = y ? 1 : e.q.devicePixelRatio, b = o.paint.get("line-dasharray"), w = b.constantOr(1), T = o.layout.get("line-cap"), E = b.constantOr(null), S = T.constantOr(null), I = o.paint.get("line-pattern"), C = I.constantOr(1), R = o.paint.get("line-pattern-cross-fade"), A = I.constantOr(null), D = o.paint.get("line-opacity").constantOr(1);
                let P = !C && 1 !== D || t1.depthOcclusion && l > 0 && l < 1;
                const L = o.paint.get("line-gradient"), z = C ? "linePattern" : "line", M = e.dY(o);
                let O;
                if (y && t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (P = !1), 0 !== l && t1.depthOcclusion) {
                    const t1 = o.paint._values["line-opacity"];
                    t1 && t1.value && "constant" === t1.value.kind ? O = t1.value : e.w(`Occlusion opacity for layer ${o.id} is supported only when line-opacity isn't data-driven.`);
                }
                "constant" !== n.value.kind && !1 === n.value.isLineProgressConstant && M.push("VARIABLE_LINE_WIDTH");
                const F = (r, s, n, a, c, u)=>{
                    for (const f of r){
                        const r = i.getTile(f);
                        if (C && !r.patternsLoaded()) continue;
                        const m = r.getBucket(o);
                        if (!m) continue;
                        if ("none" !== m.elevationType && !c || "none" === m.elevationType && c) continue;
                        t1.prepareDrawTile();
                        const g = [
                            ...s
                        ], b = t1.shadowRenderer, T = "road" === m.elevationType && !!b && b.enabled;
                        let I = [
                            0,
                            0,
                            0
                        ];
                        if (T) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (I = ao(t1.style, e, i)), g.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                        }
                        const M = m.programConfigurations.get(o.id);
                        let F = !1;
                        if (A && r.imageAtlas) {
                            const t1 = e.dZ.from(A), i = t1.getPrimary().scaleSelf(x).toString(), o = r.imageAtlas.patternPositions.get(i), s = t1.getSecondary(), n = s ? r.imageAtlas.patternPositions.get(s.scaleSelf(x).toString()) : null;
                            F = !!o && !!n, o && M.setConstantPatternPositions(o, n);
                        }
                        R > 0 && (F || M.getPatternTransitionVertexBuffer("line-pattern")) && g.push("LINE_PATTERN_TRANSITION");
                        const B = t1.isTileAffectedByFog(f), k = t1.getOrCreateProgram(z, {
                            config: M,
                            defines: g,
                            overrideFog: B
                        });
                        if (!C && E && S && r.lineAtlas) {
                            const e = r.lineAtlas.getDash(E, S);
                            e && M.setConstantPatternPositions(e);
                        }
                        T && b.setupShadows(r.tileID.toUnwrapped(), k, "vector-tile");
                        let [N, U] = o.paint.get("line-trim-offset");
                        if ("round" === S || "square" === S) {
                            const e = 1;
                            N !== U && (0 === N && (N -= e), 1 === U && (U += e));
                        }
                        const j = y ? f.projMatrix : null, G = h ? 1 / m.tileToMeter / e.aw(r, 1, t1.transform.zoom) : 1, V = h ? 1 / m.tileToMeter / e.aw(r, 1, Math.floor(t1.transform.zoom)) : 1, q = C ? e.d_(t1, r, o, j, x, G, V, [
                            N,
                            U
                        ], I, R) : e.d$(t1, r, o, j, m.lineClipsArray.length, x, G, V, [
                            N,
                            U
                        ], I);
                        if (L) {
                            const r = m.gradients[o.id];
                            let s = r.texture;
                            if (o.gradientVersion !== r.version) {
                                let n = 256;
                                if (o.stepInterpolant) {
                                    const o = i.getSource().maxzoom, r = f.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - f.canonical.z) : 1;
                                    n = e.ay(e.e0(m.maxLineLength / e.aj * 1024 * r), 256, _.maxTextureSize);
                                }
                                r.gradient = e.e1({
                                    expression: o.gradientExpression(),
                                    evaluationKey: "lineProgress",
                                    resolution: n,
                                    image: r.gradient || void 0,
                                    clips: m.lineClipsArray
                                }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.T(_, r.gradient, p.RGBA8), r.version = o.gradientVersion, s = r.texture;
                            }
                            _.activeTexture.set(p.TEXTURE1), s.bind(o.stepInterpolant ? p.NEAREST : p.LINEAR, p.CLAMP_TO_EDGE);
                        }
                        w && (_.activeTexture.set(p.TEXTURE0), r.lineAtlasTexture && r.lineAtlasTexture.bind(p.LINEAR, p.REPEAT), M.updatePaintBuffers()), C && (_.activeTexture.set(p.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), M.updatePaintBuffers()), c && !d && t1.terrain.setupElevationDraw(r, k), t1.uploadCommonUniforms(_, k, f.toUnwrapped());
                        const H = (e)=>{
                            null != O && (O.value = D * l), k.draw(t1, p.TRIANGLES, n, e, v, qi.disabled, q, o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t1.transform.zoom, M, [
                                m.layoutVertexBuffer2,
                                m.patternVertexBuffer,
                                m.zOffsetVertexBuffer
                            ]), null != O && (O.value = D);
                        };
                        if (P && !c) {
                            const e = t1.stencilModeForClipping(f).ref;
                            0 === e && y && _.clear({
                                stencil: 0
                            });
                            const i = {
                                func: p.EQUAL,
                                mask: 255
                            };
                            q.u_alpha_discard_threshold = .8, H(new ji(i, e, 255, p.KEEP, p.KEEP, p.INVERT)), q.u_alpha_discard_threshold = 0, H(new ji(i, e, 255, p.KEEP, p.KEEP, p.KEEP));
                        } else q.u_alpha_discard_threshold = P && c && u ? .8 : 0, H(c ? a : t1.stencilModeForClipping(f));
                    }
                };
                let B = t1.depthModeForSublayer(0, Ni.ReadOnly);
                const k = new Ni(t1.depthOcclusion ? p.GREATER : p.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D);
                if (o.hasNonElevatedBuckets) {
                    const i = !y && t1.terrain;
                    0 !== l && i ? e.w(`Occlusion opacity for layer ${o.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o.id}.`) : F(r, M, B, ji.disabled, !1, !0);
                }
                if (o.hasElevatedBuckets) {
                    "hd-road-markup" === c ? u || (B = k, M.push("ELEVATED_ROADS")) : (M.push("ELEVATED"), B = k, m && M.push(g ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), d && M.push("ELEVATION_REFERENCE_SEA"));
                    const e = P ? t1.stencilModeFor3D() : ji.disabled;
                    t1.forceTerrainMode = !0, F(r, M, B, e, !0, !0), P && F(r, M, B, e, !0, !1), t1.forceTerrainMode = !1;
                }
                P && (t1.resetStencilClippingMasks(), y && _.clear({
                    stencil: 0
                })), 0 === l || t1.depthOcclusion || y || t1.layersWithOcclusionOpacity.push(t1.currentLayer);
            },
            fill: function(t1, i, o, r) {
                const s = o.paint.get("fill-color"), n = o.paint.get("fill-opacity");
                if (0 === n.constantOr(1)) return;
                const a = o.paint.get("fill-emissive-strength"), l = t1.colorModeForDrapableLayerRenderPass(a), c = o.paint.get("fill-pattern"), h = t1.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === s.constantOr(e.am.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";
                let d = "none";
                "none" !== o.layout.get("fill-elevation-reference") ? d = "road" : 0 !== o.paint.get("fill-z-offset").constantOr(1) && (d = "offset");
                const u = !(!t1.terrain || !t1.terrain.enabled), _ = {
                    painter: t1,
                    sourceCache: i,
                    layer: o,
                    coords: r,
                    colorMode: l,
                    elevationType: d,
                    terrainEnabled: u,
                    pass: h
                };
                if ("shadow" !== t1.renderPass) if ("offset" !== d) {
                    if (Ws(_, !1), "road" === d) {
                        const e = !u && "translucent" === t1.renderPass;
                        e && Zs(t1, i, o, r, "geometry"), Ws(_, !0, ji.disabled), e && function(e) {
                            const { painter: t1, sourceCache: i, layer: o, coords: r, colorMode: s } = e, n = t1.context.gl, a = e.painter.shadowRenderer, l = !!a && a.enabled, c = new Ni(t1.context.gl.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D);
                            let h = [
                                0,
                                0,
                                0
                            ];
                            if (l) {
                                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                                e && i && (h = ao(t1.style, e, i));
                            }
                            const d = (e)=>{
                                for (const d of r){
                                    const r = i.getTile(d), u = r.getBucket(o);
                                    if (!u) continue;
                                    const _ = u.elevatedStructures;
                                    if (!_) continue;
                                    let p, f;
                                    if (e ? (p = _.renderableBridgeSegments, f = _.bridgeProgramConfigurations.get(o.id)) : (p = _.renderableTunnelSegments, f = _.tunnelProgramConfigurations.get(o.id)), !p || 0 === p.segments[0].primitiveLength) continue;
                                    f.updatePaintBuffers(), t1.prepareDrawTile();
                                    const m = t1.isTileAffectedByFog(d), g = [];
                                    l && g.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                                    const v = t1.getOrCreateProgram("elevatedStructures", {
                                        config: f,
                                        overrideFog: m,
                                        defines: g
                                    }), y = t1.translatePosMatrix(d.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                                    l && a.setupShadows(r.tileID.toUnwrapped(), v, "vector-tile");
                                    const x = as(y, h);
                                    t1.uploadCommonUniforms(t1.context, v, d.toUnwrapped()), v.draw(t1, n.TRIANGLES, c, ji.disabled, s, qi.backCCW, x, o.id, _.vertexBuffer, _.indexBuffer, p, o.paint, t1.transform.zoom, f, [
                                        _.vertexBufferNormal
                                    ]);
                                }
                            };
                            d(!0), d(!1);
                        }(_);
                    }
                } else Ws(_, !1, t1.stencilModeFor3D());
                else t1.shadowRenderer && "road" === d && !u && function(e) {
                    const { painter: t1, sourceCache: i, layer: o, coords: r } = e, s = t1.context.gl, n = e.painter.shadowRenderer;
                    for (const e of r){
                        const r = i.getTile(e), a = r.getBucket(o);
                        if (!a) continue;
                        const l = a.elevatedStructures;
                        if (!l) continue;
                        if (!l.shadowCasterSegments || 0 === l.shadowCasterSegments.segments[0].primitiveLength) continue;
                        t1.prepareDrawTile();
                        const c = a.bufferData.programConfigurations.get(o.id), h = t1.isTileAffectedByFog(e), d = t1.getOrCreateProgram("elevatedStructuresDepth", {
                            config: c,
                            overrideFog: h
                        }), u = n.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());
                        t1.uploadCommonUniforms(t1.context, d, e.toUnwrapped());
                        const _ = {
                            u_matrix: u,
                            u_depth_bias: 0
                        };
                        d.draw(t1, s.TRIANGLES, n.getShadowPassDepthMode(), ji.disabled, n.getShadowPassColorMode(), qi.disabled, _, o.id, l.vertexBuffer, l.indexBuffer, l.shadowCasterSegments, o.paint, t1.transform.zoom, c);
                    }
                }(_);
            },
            "fill-extrusion": function(t1, i, o, r) {
                const s = o.paint.get("fill-extrusion-opacity"), n = t1.context, a = n.gl, l = t1.terrain, c = l && l.renderingToTexture;
                if (0 === s) return;
                const h = t1.conflationActive && t1.style.isLayerClipped(o, i.getSource()), d = t1.style.order.indexOf(o.fqid);
                if (h && function(e, t1, i, o, r) {
                    for (const s of o){
                        const o = t1.getTile(s).getBucket(i);
                        o && (o.updateReplacement(s, e.replacementSource, r), o.uploadCentroid(e.context));
                    }
                }(t1, i, o, r, d), l || h) for (const e of r){
                    const r = i.getTile(e).getBucket(o);
                    r && Ks(t1.context, i, e, r, o, l, h);
                }
                if ("shadow" === t1.renderPass && t1.shadowRenderer) {
                    const n = t1.shadowRenderer;
                    if (l && s < .65 && o._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.ab) return;
                    const a = n.getShadowPassDepthMode(), c = n.getShadowPassColorMode();
                    $s(t1, i, o, r, a, ji.disabled, c, h);
                } else if ("translucent" === t1.renderPass) {
                    const d = !o.paint.get("fill-extrusion-pattern").constantOr(1), u = o.paint.get("fill-extrusion-color").constantOr(e.am.white);
                    if (!c && 0 !== u.a) {
                        const e = new Ni(t1.context.gl.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D);
                        1 === s && d ? $s(t1, i, o, r, e, ji.disabled, ki.unblended, h) : ($s(t1, i, o, r, e, ji.disabled, ki.disabled, h), $s(t1, i, o, r, e, t1.stencilModeFor3D(), t1.colorModeForRenderPass(), h), t1.resetStencilClippingMasks());
                    }
                    if (t1.style.enable3dLights() && d && (!l && "globe" !== t1.transform.projection.name || c)) {
                        const s = o.paint.get("fill-extrusion-opacity"), d = o.paint.get("fill-extrusion-ambient-occlusion-intensity"), u = o.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _ = o.paint.get("fill-extrusion-flood-light-intensity"), p = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), f = o.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(p ? null : o.lut).toArray01().slice(0, 3), m = d > 0 && u > 0, g = _ > 0, v = (e, t1, i)=>(1 - i) * e + i * t1, y = new Xs;
                        y.translate = o.paint.get("fill-extrusion-translate"), y.translateAnchor = o.paint.get("fill-extrusion-translate-anchor"), y.edgeRadius = o.layout.get("fill-extrusion-edge-radius"), y.cutoffFadeRange = o.paint.get("fill-extrusion-cutoff-fade-range");
                        const x = (n)=>{
                            const l = t1.depthModeForSublayer(1, Ni.ReadOnly, a.LEQUAL, !0), c = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), p = v(.1, 3, c), m = t1._showOverdrawInspector;
                            if (!m) {
                                const c = new ji({
                                    func: a.ALWAYS,
                                    mask: 255
                                }, 255, 255, a.KEEP, a.KEEP, a.REPLACE), m = new ki([
                                    a.ONE,
                                    a.ONE,
                                    a.ONE,
                                    a.ONE
                                ], e.am.transparent, [
                                    !1,
                                    !1,
                                    !1,
                                    !0
                                ], a.MIN);
                                Ys(y, t1, i, o, r, l, c, m, qi.disabled, n, "sdf", s, d, u, _, f, p, h, !1);
                            }
                            {
                                const c = m ? ji.disabled : new ji({
                                    func: a.EQUAL,
                                    mask: 255
                                }, 255, 255, a.KEEP, a.DECR, a.DECR), g = m ? t1.colorModeForRenderPass() : new ki([
                                    a.ONE_MINUS_DST_ALPHA,
                                    a.DST_ALPHA,
                                    a.ONE,
                                    a.ONE
                                ], e.am.transparent, [
                                    !0,
                                    !0,
                                    !0,
                                    !0
                                ]);
                                Ys(y, t1, i, o, r, l, c, g, qi.disabled, n, "color", s, d, u, _, f, p, h, !1);
                            }
                        };
                        if (c) {
                            const c = (n, l, c)=>{
                                const p = t1.depthModeForSublayer(1, Ni.ReadOnly, a.LEQUAL, !1), m = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), g = v(.1, 3, m);
                                {
                                    const c = new ki([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        a.ONE
                                    ], e.am.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ]);
                                    Ys(y, t1, i, o, r, p, ji.disabled, c, qi.disabled, n, "clear", s, d, u, _, f, g, h, l);
                                }
                                {
                                    const c = new ji({
                                        func: a.ALWAYS,
                                        mask: 255
                                    }, 255, 255, a.KEEP, a.KEEP, a.REPLACE), m = new ki([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        a.ONE
                                    ], e.am.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], a.MIN);
                                    Ys(y, t1, i, o, r, p, c, m, qi.disabled, n, "sdf", s, d, u, _, f, g, h, l);
                                }
                                {
                                    const c = n ? a.ZERO : a.ONE_MINUS_DST_ALPHA, m = new ji({
                                        func: a.EQUAL,
                                        mask: 255
                                    }, 255, 255, a.KEEP, a.DECR, a.DECR), v = new ki([
                                        c,
                                        a.DST_ALPHA,
                                        a.ONE_MINUS_DST_ALPHA,
                                        a.ZERO
                                    ], e.am.transparent, [
                                        !0,
                                        !0,
                                        !0,
                                        !0
                                    ]);
                                    Ys(y, t1, i, o, r, p, m, v, qi.disabled, n, "color", s, d, u, _, f, g, h, l);
                                }
                                {
                                    const m = new ki([
                                        a.ONE,
                                        a.ONE,
                                        a.ONE,
                                        n ? a.ZERO : a.ONE
                                    ], e.am.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], n ? a.FUNC_ADD : a.MAX);
                                    Ys(y, t1, i, o, r, p, ji.disabled, m, qi.disabled, n, "clear", s, d, u, _, f, g, h, l, c);
                                }
                            };
                            if (m || g) {
                                let i;
                                if (t1.prepareDrawTile(), l) {
                                    const t1 = l.drapeBufferSize[0], o = l.drapeBufferSize[1];
                                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t1 && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(n, new e.r({
                                        width: t1,
                                        height: o
                                    }), a.RGBA8)), i.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.copyTexSubImage2D(a.TEXTURE_2D, 0, 0, 0, 0, 0, t1, o);
                                }
                                m && c(!0, !1, i), g && c(!1, !0, i);
                            }
                        } else m && x(!0), g && x(!1), (m || g) && t1.resetStencilClippingMasks();
                    }
                }
            },
            building: function(t1, i, o, r) {
                t1.currentLayer < t1.firstLightBeamLayer && (t1.firstLightBeamLayer = t1.currentLayer);
                const s = o.paint.get("building-ambient-occlusion-ground-intensity"), n = o.paint.get("building-ambient-occlusion-ground-radius"), a = o.paint.get("building-ambient-occlusion-ground-attenuation");
                let l = s > 0 && n > 0, c = !0;
                const h = o.paint.get("building-vertical-scale");
                h < 1 && (c = !1);
                const d = t1.conflationActive && t1.style.isLayerClipped(o, i.getSource()), u = t1.style.order.indexOf(o.fqid);
                if (function(e, t1, i, o, r, s) {
                    for (const n of s){
                        const s = t1.getTile(n).getBucket(i);
                        s && (r && s.updateReplacement(n, e.replacementSource, o), s.uploadUpdatedIndexBuffer(e.context));
                    }
                }(t1, i, o, u, d, r), function(e, t1, i, o) {
                    for (const r of o){
                        const o = t1.getTile(r).getBucket(i);
                        o && o.needsEvaluation(e, i) && (o.evaluate(i), o.uploadUpdatedColorBuffer(e.context));
                    }
                }(t1, i, o, r), o.resetLayerRenderingStats(t1), t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !0), "shadow" === t1.renderPass && t1.shadowRenderer) {
                    const e = t1.shadowRenderer, s = [], n = e.getShadowPassDepthMode();
                    on({
                        painter: t1,
                        source: i,
                        layer: o,
                        coords: r,
                        defines: s,
                        blendMode: e.getShadowPassColorMode(),
                        depthMode: n,
                        verticalScale: h
                    });
                } else if ("translucent" === t1.renderPass) {
                    l && function(t1, i, o, r, s, n, a, l, c, h, d, u, _) {
                        const p = t1.context.gl, f = t1.depthModeForSublayer(1, Ni.ReadOnly, p.LEQUAL, !0), m = .1 * (1 - (g = d)) + 3 * g;
                        var g;
                        const v = t1._showOverdrawInspector, y = u, x = new Xs;
                        v || Ys(x, t1, i, o, r, f, new ji({
                            func: p.ALWAYS,
                            mask: 255
                        }, 255, 255, p.KEEP, p.KEEP, p.REPLACE), new ki([
                            p.ONE,
                            p.ONE,
                            p.ONE,
                            p.ONE
                        ], e.am.transparent, [
                            !1,
                            !1,
                            !1,
                            !0
                        ], p.MIN), qi.disabled, s, "sdf", 1, a, l, 0, h, m, y, !1);
                        {
                            const n = v ? ji.disabled : new ji({
                                func: p.EQUAL,
                                mask: 255
                            }, 255, 255, p.KEEP, p.DECR, p.DECR), c = v ? t1.colorModeForRenderPass() : new ki([
                                p.ONE_MINUS_DST_ALPHA,
                                p.DST_ALPHA,
                                p.ONE,
                                p.ONE
                            ], e.am.transparent, [
                                !0,
                                !0,
                                !0,
                                !0
                            ]);
                            Ys(x, t1, i, o, r, f, n, c, qi.disabled, s, "color", 1, a, l, 0, h, m, y, !1);
                        }
                    }(t1, i, o, r, !0, 0, s, n, 0, [
                        0,
                        0,
                        0
                    ], a, d);
                    let u = [
                        "HAS_ATTRIBUTE_a_part_color_emissive",
                        "LIGHTING_3D_MODE"
                    ];
                    c && (u = u.concat("RENDER_SHADOWS", "DEPTH_TEXTURE")), t1.shadowRenderer.useNormalOffset && (u = u.concat("NORMAL_OFFSET"));
                    const _ = new Ni(t1.context.gl.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D), p = t1.colorModeForRenderPass();
                    on({
                        painter: t1,
                        source: i,
                        layer: o,
                        coords: r,
                        defines: u,
                        blendMode: p,
                        depthMode: _,
                        verticalScale: h
                    });
                } else if ("light-beam" === t1.renderPass) {
                    const e = [
                        "HAS_ATTRIBUTE_a_part_color_emissive",
                        "HAS_ATTRIBUTE_a_bloom_attenuation"
                    ], s = new Ni(t1.context.gl.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D);
                    on({
                        painter: t1,
                        source: i,
                        layer: o,
                        coords: r,
                        defines: e,
                        blendMode: ki.alphaBlended,
                        depthMode: s,
                        verticalScale: h
                    });
                }
                t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !1), t1.resetStencilClippingMasks();
            },
            hillshade: function(e, t1, i, o) {
                if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass) return;
                if (e.style.disableElevatedTerrain) return;
                const r = e.context, s = e.terrain && e.terrain.renderingToTexture, [n, a] = "translucent" !== e.renderPass || s ? [
                    {},
                    o
                ] : e.stencilConfigForOverlap(o);
                for (const o of a){
                    const r = t1.getTile(o);
                    if (r.needsHillshadePrepare && "offscreen" === e.renderPass) Yo(e, r, i);
                    else if ("translucent" === e.renderPass) {
                        const t1 = e.depthModeForSublayer(0, Ni.ReadOnly), a = i.paint.get("hillshade-emissive-strength"), l = e.colorModeForDrapableLayerRenderPass(a), c = s && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : n[o.overscaledZ];
                        $o(e, o, r, i, t1, c, l);
                    }
                }
                r.viewport.set([
                    0,
                    0,
                    e.width,
                    e.height
                ]), e.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, r, s, n) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                const a = "globe" === t1.transform.projection.name, l = 0 !== o.paint.get("raster-elevation"), c = l && a;
                if (t1.renderElevatedRasterBackface && !c) return;
                const h = t1.context, d = h.gl, u = i.getSource(), _ = function(t1, i, o, r) {
                    const s = i.paint.get("raster-color"), n = "raster-array" === t1.type, a = [], l = i.paint.get("raster-resampling"), c = i.paint.get("raster-color-mix");
                    let h = i.paint.get("raster-color-range");
                    const d = [
                        c[0],
                        c[1],
                        c[2],
                        0
                    ], u = c[3];
                    let _ = "nearest" === l ? r.NEAREST : r.LINEAR;
                    if (n && (a.push("RASTER_ARRAY"), s || a.push("RASTER_COLOR"), "linear" === l && a.push("RASTER_ARRAY_LINEAR"), _ = r.NEAREST, !h && t1.rasterLayers)) {
                        const e = t1.rasterLayers.find(({ id: e })=>e === i.sourceLayer);
                        e && e.fields && e.fields.range && (h = e.fields.range);
                    }
                    if (h = h || [
                        0,
                        1
                    ], s) {
                        a.push("RASTER_COLOR"), o.activeTexture.set(r.TEXTURE2), i.updateColorRamp(h);
                        let t1 = i.colorRampTexture;
                        t1 || (t1 = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA8)), t1.bind(r.LINEAR, r.CLAMP_TO_EDGE);
                    }
                    return {
                        mix: d,
                        range: h,
                        offset: u,
                        defines: a,
                        resampling: _
                    };
                }(u, o, h, d);
                if (u instanceof e.aP && !r.length && !a) return;
                const p = o.paint.get("raster-emissive-strength"), f = t1.colorModeForDrapableLayerRenderPass(p), m = t1.terrain && t1.terrain.renderingToTexture, g = !t1.options.moving, v = "nearest" === o.paint.get("raster-resampling") ? d.NEAREST : d.LINEAR;
                if (u instanceof e.aP && !r.length && (u.onNorthPole || u.onSouthPole)) {
                    const e = l ? t1.stencilModeFor3D() : ji.disabled;
                    return void sn(!!u.onNorthPole, null, t1, i, o, p, _, qi.disabled, e);
                }
                if (!r.length) return;
                const [y, x] = u instanceof e.aP || m ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r), b = x[x.length - 1].overscaledZ;
                c && _.defines.push("PROJECTION_GLOBE_VIEW"), l && _.defines.push("RENDER_CUTOFF");
                const w = (r, s, x)=>{
                    for (const w of r){
                        const r = w.toUnwrapped(), T = i.getTile(w);
                        if (m && (!T || !T.hasData())) continue;
                        h.activeTexture.set(d.TEXTURE0);
                        const E = an(T, u, o, _);
                        if (!E || !E.texture) continue;
                        const { texture: S, mix: I, offset: C, tileSize: R, buffer: A } = E;
                        let D, P;
                        m ? (D = Ni.disabled, P = w.projMatrix) : l ? (D = new Ni(d.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D), P = a ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(r, g)) : (D = t1.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get("raster-opacity") ? Ni.ReadWrite : Ni.ReadOnly, d.LESS), P = t1.transform.calculateProjMatrix(r, g));
                        const L = t1.terrain && m ? t1.terrain.stencilModeForRTTOverlap(w) : y[w.overscaledZ], z = n ? 0 : o.paint.get("raster-fade-duration");
                        T.registerFadeDuration(z);
                        const M = i.findLoadedParent(w, 0), O = Gr(T, M, i, t1.transform, z);
                        let F, B;
                        t1.terrain && t1.terrain.prepareDrawTile(), h.activeTexture.set(d.TEXTURE0), S.bind(v, d.CLAMP_TO_EDGE), h.activeTexture.set(d.TEXTURE1), M ? (M.texture && M.texture.bind(v, d.CLAMP_TO_EDGE), F = Math.pow(2, M.tileID.overscaledZ - T.tileID.overscaledZ), B = [
                            T.tileID.canonical.x * F % 1,
                            T.tileID.canonical.y * F % 1
                        ]) : S.bind(v, d.CLAMP_TO_EDGE), "useMipmap" in S && h.extTextureFilterAnisotropic && t1.transform.pitch > 20 && d.texParameterf(d.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);
                        const k = t1.transform;
                        let N;
                        const U = l ? nn(k) : [
                            0,
                            0,
                            0,
                            0
                        ];
                        let j, G, V, q, H, Z = 0;
                        if (c && u instanceof e.aP && u.coordinates.length > 3) j = Float32Array.from(e.bh(e.dD(new e.cA(0, 0, 0)))), G = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.dz(k)), q = [
                            e.aD(k.center.lng),
                            e.aH(k.center.lat)
                        ], N = u.elevatedGlobePerspectiveTransform, H = u.elevatedGlobeGridMatrix || new Float32Array(9);
                        else if (c) {
                            const t1 = e.dA(w.canonical);
                            Z = e.dB(t1.getCenter().lat), j = Float32Array.from(e.bh(e.dD(w.canonical))), G = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.dz(k)), q = [
                                e.aD(k.center.lng),
                                e.aH(k.center.lat)
                            ], N = [
                                0,
                                0
                            ], H = Float32Array.from(e.dC(w.canonical, t1, Z, k.worldSize / k._pixelsPerMercatorPixel));
                        } else N = u instanceof e.aP ? u.perspectiveTransform : [
                            0,
                            0
                        ], j = new Float32Array(16), G = new Float32Array(9), V = new Float32Array(16), q = [
                            0,
                            0
                        ], H = new Float32Array(9);
                        const W = vs(P, j, G, V, H, B || [
                            0,
                            0
                        ], e.ah(t1.transform.zoom), q, U, F || 1, O, o, N, l ? o.paint.get("raster-elevation") : 0, 2, I, C, _.range, R, A, p), $ = t1.isTileAffectedByFog(w), X = t1.getOrCreateProgram("raster", {
                            defines: _.defines,
                            overrideFog: $
                        });
                        if (t1.uploadCommonUniforms(h, X, r), u instanceof e.aP) {
                            const i = u.elevatedGlobeVertexBuffer, r = u.elevatedGlobeIndexBuffer;
                            if (m || !a) u.boundsBuffer && u.boundsSegments && X.draw(t1, d.TRIANGLES, D, ji.disabled, f, qi.disabled, W, o.id, u.boundsBuffer, t1.quadTriangleIndexBuffer, u.boundsSegments);
                            else if (i && r) {
                                const n = k.zoom <= e.cX ? u.elevatedGlobeSegments : u.getSegmentsForLongitude(k.center.lng);
                                n && X.draw(t1, d.TRIANGLES, D, ji.disabled, f, s, W, o.id, i, r, n);
                            }
                        } else if (c) {
                            D = new Ni(d.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D);
                            const e = t1.globeSharedBuffers;
                            if (e) {
                                const [i, r, n] = e.getGridBuffers(Z, !1);
                                X.draw(t1, d.TRIANGLES, D, x || L, t1.colorModeForRenderPass(), s, W, o.id, i, r, n);
                            }
                        } else {
                            const { tileBoundsBuffer: e, tileBoundsIndexBuffer: i, tileBoundsSegments: r } = t1.getTileBoundsBuffers(T);
                            X.draw(t1, d.TRIANGLES, D, L, f, qi.disabled, W, o.id, e, i, r);
                        }
                    }
                    if (!(u instanceof e.aP) && c) for (const e of r){
                        const r = e.canonical.y === (1 << e.canonical.z) - 1;
                        0 === e.canonical.y && sn(!0, e, t1, i, o, p, _, s, x || ji.disabled), r && sn(!1, e, t1, i, o, p, _, s === qi.frontCW ? qi.backCW : qi.frontCW, x || ji.disabled);
                    }
                };
                c ? w(x, t1.renderElevatedRasterBackface ? qi.backCW : qi.frontCW, t1.stencilModeFor3D()) : w(x, qi.disabled, void 0), t1.resetStencilClippingMasks();
            },
            "raster-particle": function(t1, i, o, r, s, n) {
                "offscreen" === t1.renderPass && function(t1, i, o, r) {
                    if (!r.length) return;
                    const s = t1.context, n = s.gl, a = i.getSource();
                    if (!(a instanceof rt)) return;
                    const l = Math.ceil(Math.sqrt(o.paint.get("raster-particle-count")));
                    let c = o.particlePositionRGBAImage;
                    if (!c || c.width !== l) {
                        const t1 = function(e) {
                            const t1 = e * e, i = new Uint8Array(4 * t1), o = function(e) {
                                return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;
                            }, r = 1 / 1.1;
                            for(let e = 0; e < t1; e++){
                                const t1 = r * (o(2 * e + 0) + xs), s = r * (o(2 * e + 1) + xs), n = 255 * t1 % 1, a = 255 * s % 1, l = n, c = s - a / 255, h = a;
                                i[4 * e + 0] = 255 * (t1 - n / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;
                            }
                            return i;
                        }(l);
                        c = o.particlePositionRGBAImage = new e.r({
                            width: l,
                            height: l
                        }, t1);
                    }
                    let h = o.particleFramebuffer;
                    h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = s.createFramebuffer(l, l, !0, null)) : h = o.particleFramebuffer = s.createFramebuffer(l, l, !0, null);
                    const d = [];
                    for (const e of r){
                        const t1 = i.getTile(e);
                        if (!(t1 instanceof Tt)) continue;
                        const r = hn(t1, a, o);
                        if (!r) continue;
                        const n = [
                            t1.tileSize,
                            t1.tileSize
                        ];
                        let h = o.tileFramebuffer;
                        h || (h = o.tileFramebuffer = s.createFramebuffer(n[0], n[1], !0, null));
                        let u = t1.rasterParticleState;
                        u || (u = t1.rasterParticleState = new cn(s, e, n, c));
                        const _ = u.update(o.lastInvalidatedAt);
                        u.particleTextureDimension !== l && u.updateParticleTexture(e, c);
                        const p = u.targetColorTexture;
                        u.targetColorTexture = u.backgroundColorTexture, u.backgroundColorTexture = p;
                        const f = u.particleTexture0;
                        u.particleTexture0 = u.particleTexture1, u.particleTexture1 = f, d.push([
                            e,
                            r,
                            u,
                            _
                        ]);
                    }
                    if (0 === d.length) return;
                    const u = e.q.now(), _ = o.previousDrawTimestamp ? .001 * (u - o.previousDrawTimestamp) : .0167;
                    if (o.previousDrawTimestamp = u, o.hasColorMap()) {
                        s.activeTexture.set(n.TEXTURE0 + 2);
                        let t1 = o.colorRampTexture;
                        t1 || (t1 = o.colorRampTexture = new e.T(s, o.colorRamp, n.RGBA8)), t1.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                    }
                    s.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function(t1, i, o) {
                        const r = t1.context, s = r.gl, n = i.tileFramebuffer;
                        r.activeTexture.set(s.TEXTURE0);
                        const a = {
                            u_texture: 0,
                            u_opacity: 1.05 * (c = i.paint.get("raster-particle-fade-opacity-factor")) / (c + .05)
                        }, l = t1.getOrCreateProgram("rasterParticleTexture", {
                            defines: [],
                            overrideFog: !1
                        });
                        var c;
                        for (const c of o){
                            const [, , o, h] = c;
                            n.colorAttachment.set(o.targetColorTexture.texture), r.viewport.set([
                                0,
                                0,
                                n.width,
                                n.height
                            ]), r.clear({
                                color: e.am.transparent
                            }), h && (o.backgroundColorTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), l.draw(t1, s.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, a, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments));
                        }
                    }(t1, o, d), function(t1, i, o, r) {
                        const s = t1.context, n = s.gl, a = o.tileFramebuffer, l = "globe" === t1.transform.projection.name, c = o.paint.get("raster-particle-max-speed");
                        for (const h of r){
                            const [r, d, u] = h;
                            s.activeTexture.set(n.TEXTURE0 + 0), d.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.colorAttachment.set(u.targetColorTexture.texture);
                            const _ = t1.getOrCreateProgram("rasterParticleDraw", {
                                defines: d.defines,
                                overrideFog: !1
                            });
                            s.activeTexture.set(n.TEXTURE0 + 1);
                            const p = d.scalarData ? [] : [
                                0,
                                1,
                                2,
                                3
                            ].map((t1)=>e.e3[t1](r));
                            p.push(r);
                            const f = r.canonical.x, m = r.canonical.y;
                            for (const e of p){
                                const s = i.getTile(l ? e.wrapped() : e);
                                if (!s) continue;
                                const a = s.rasterParticleState;
                                if (!a) continue;
                                const h = e.canonical.x + (1 << e.canonical.z) * (e.wrap - r.wrap), u = e.canonical.y;
                                a.particleTexture0.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                                const p = ws(1, a.particleTexture0.size[0], [
                                    h - f,
                                    u - m
                                ], 0, d.texture.size, 2, c, d.textureOffset, d.scale, d.offset);
                                _.draw(t1, n.POINTS, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, p, o.id, a.particleIndexBuffer, void 0, a.particleSegment);
                            }
                        }
                    }(t1, i, o, d), s.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function(t1, i, o, r) {
                        const s = t1.context, n = s.gl, a = i.paint.get("raster-particle-max-speed"), l = r * i.paint.get("raster-particle-speed-factor") * .15, c = function(e) {
                            return Math.pow(e, 6);
                        }(.01 + 1 * i.paint.get("raster-particle-reset-rate-factor")), h = i.particleFramebuffer;
                        s.viewport.set([
                            0,
                            0,
                            h.width,
                            h.height
                        ]);
                        for (const r of o){
                            const [, o, d] = r;
                            s.activeTexture.set(n.TEXTURE0 + 0), o.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), s.activeTexture.set(n.TEXTURE0 + 1);
                            const u = d.particleTexture0;
                            u.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                            const _ = Ts(1, u.size[0], 0, o.texture.size, a, l, c, o.textureOffset, o.scale, o.offset);
                            h.colorAttachment.set(d.particleTexture1.texture), s.clear({
                                color: e.am.transparent
                            }), t1.getOrCreateProgram("rasterParticleUpdate", {
                                defines: o.defines
                            }).draw(t1, n.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, _, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                        }
                    }(t1, o, d, _);
                }(t1, i, o, r), "translucent" === t1.renderPass && (function(t1, i, o, r, s) {
                    const n = t1.context, a = n.gl, l = i.getSource().tileSize, c = 5 * (1 - e.af(e.cI, e.cI + 1, t1.transform.zoom)) * l + o.paint.get("raster-particle-elevation"), h = !t1.options.moving, d = "globe" === t1.transform.projection.name;
                    if (!r.length) return;
                    const [u, _] = t1.stencilConfigForOverlap(r), p = [];
                    d && p.push("PROJECTION_GLOBE_VIEW");
                    const f = t1.stencilModeFor3D();
                    for (const r of _){
                        const s = r.toUnwrapped(), l = i.getTile(r);
                        if (!l.rasterParticleState) continue;
                        const _ = l.rasterParticleState, m = 100;
                        l.registerFadeDuration(m);
                        const g = i.findLoadedParent(r, 0), v = Gr(l, g, i, t1.transform, m);
                        let y, x;
                        t1.terrain && t1.terrain.prepareDrawTile(), n.activeTexture.set(a.TEXTURE0), _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.activeTexture.set(a.TEXTURE1), g && g.rasterParticleState ? (g.rasterParticleState.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), y = Math.pow(2, g.tileID.overscaledZ - l.tileID.overscaledZ), x = [
                            l.tileID.canonical.x * y % 1,
                            l.tileID.canonical.y * y % 1
                        ]) : _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                        const b = d ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(s, h), w = t1.transform, T = dn(w), E = e.dA(r.canonical), S = e.dB(E.getCenter().lat);
                        let I, C, R, A, D;
                        d ? (I = Float32Array.from(e.bh(e.dD(r.canonical))), C = Float32Array.from(w.globeMatrix), R = Float32Array.from(e.dz(w)), A = [
                            e.aD(w.center.lng),
                            e.aH(w.center.lat)
                        ], D = Float32Array.from(e.dC(r.canonical, E, S, w.worldSize / w._pixelsPerMercatorPixel))) : (I = new Float32Array(16), C = new Float32Array(9), R = new Float32Array(16), A = [
                            0,
                            0
                        ], D = new Float32Array(9));
                        const P = bs(b, I, C, R, D, x || [
                            0,
                            0
                        ], e.ah(t1.transform.zoom), A, T, y || 1, v, c), L = t1.isTileAffectedByFog(r), z = t1.getOrCreateProgram("rasterParticle", {
                            defines: p,
                            overrideFog: L
                        });
                        if (t1.uploadCommonUniforms(n, z, s), d) {
                            const e = new Ni(a.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D), i = 0, r = t1.globeSharedBuffers;
                            if (r) {
                                const [s, n, l] = r.getGridBuffers(S, 0 !== i);
                                z.draw(t1, a.TRIANGLES, e, f, ki.alphaBlended, t1.renderElevatedRasterBackface ? qi.frontCCW : qi.backCCW, P, o.id, s, n, l);
                            }
                        } else {
                            const e = t1.depthModeForSublayer(0, Ni.ReadOnly), i = u[r.overscaledZ], { tileBoundsBuffer: s, tileBoundsIndexBuffer: n, tileBoundsSegments: c } = t1.getTileBoundsBuffers(l);
                            z.draw(t1, a.TRIANGLES, e, i, ki.alphaBlended, qi.disabled, P, o.id, s, n, c);
                        }
                    }
                    t1.resetStencilClippingMasks();
                }(t1, i, o, r), t1.style.map.triggerRepaint());
            },
            background: function(t1, i, o, r) {
                const s = o.paint.get("background-color"), n = "none" === o.paint.get("background-color-use-theme").constantOr("default"), a = o.paint.get("background-opacity"), l = o.paint.get("background-emissive-strength"), c = "viewport" === o.paint.get("background-pitch-alignment");
                if (0 === a) return;
                const h = t1.context, d = h.gl, u = t1.transform, _ = u.tileSize, p = o.paint.get("background-pattern");
                let f;
                if (void 0 !== p) {
                    if (null === p) return;
                    if (f = t1.imageManager.getPattern(e.I.from(p.toString()), o.scope, t1.style.getLut(o.scope)), !f) return;
                }
                const m = !p && 1 === s.a && 1 === a && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== m) return;
                const g = ji.disabled, v = t1.depthModeForSublayer(0, "opaque" === m ? Ni.ReadWrite : Ni.ReadOnly), y = t1.colorModeForDrapableLayerRenderPass(l), x = p ? "backgroundPattern" : "background";
                let b, w = r;
                if (w || (b = t1.getBackgroundTiles(), w = Object.values(b).map((e)=>e.tileID)), p && (h.activeTexture.set(d.TEXTURE0), t1.imageManager.bind(t1.context, o.scope)), c) {
                    const i = t1.getOrCreateProgram(x, {
                        overrideFog: !1,
                        overrideRtt: !0
                    }), r = new Float32Array(e.bx([])), h = new e.aM(0, 0, 0, 0, 0), u = p ? Cs(r, l, a, t1, 0, o.scope, f, c, {
                        tileID: h,
                        tileSize: _
                    }) : Is(r, l, a, s.toPremultipliedRenderColor(n ? null : o.lut));
                    i.draw(t1, d.TRIANGLES, v, g, y, qi.disabled, u, o.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                } else for (const e of w){
                    const m = t1.isTileAffectedByFog(e), w = t1.getOrCreateProgram(x, {
                        overrideFog: m
                    }), T = e.toUnwrapped(), E = r ? e.projMatrix : t1.transform.calculateProjMatrix(T);
                    t1.prepareDrawTile();
                    const S = i ? i.getTile(e) : b ? b[e.key] : new wt(e, _, u.zoom, t1), I = p ? Cs(E, l, a, t1, 0, o.scope, f, c, {
                        tileID: e,
                        tileSize: _
                    }) : Is(E, l, a, s.toPremultipliedRenderColor(n ? null : o.lut));
                    t1.uploadCommonUniforms(h, w, T);
                    const { tileBoundsBuffer: C, tileBoundsIndexBuffer: R, tileBoundsSegments: A } = t1.getTileBoundsBuffers(S);
                    w.draw(t1, d.TRIANGLES, v, g, y, qi.disabled, I, o.id, C, R, A);
                }
            },
            sky: function(t1, i, o) {
                const r = t1._atmosphere ? e.ah(t1.transform.zoom) : 1, s = o.paint.get("sky-opacity") * r;
                if (0 === s) return;
                const n = t1.context, a = o.paint.get("sky-type"), l = new Ni(n.gl.LEQUAL, Ni.ReadOnly, [
                    0,
                    1
                ]), c = t1.frameCounter / 1e3 % 1;
                "atmosphere" === a ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i, o, r) {
                    const s = t1.context, n = s.gl;
                    let a = i.skyboxFbo;
                    if (!a) {
                        a = i.skyboxFbo = s.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new Sn(s), i.skyboxTexture = s.gl.createTexture(), n.bindTexture(n.TEXTURE_CUBE_MAP, i.skyboxTexture), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, n.LINEAR);
                        for(let e = 0; e < 6; ++e)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, n.RGBA, 32, 32, 0, n.RGBA, n.UNSIGNED_BYTE, null);
                    }
                    s.bindFramebuffer.set(a.framebuffer), s.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l = i.getCenter(t1, !0), c = t1.getOrCreateProgram("skyboxCapture"), h = new Float64Array(16);
                    e.bx(h), e.eh(h, h, .5 * -Math.PI), In(t1, i, c, h, l, 0), e.bx(h), e.eh(h, h, .5 * Math.PI), In(t1, i, c, h, l, 1), e.bx(h), e.cR(h, h, .5 * -Math.PI), In(t1, i, c, h, l, 2), e.bx(h), e.cR(h, h, .5 * Math.PI), In(t1, i, c, h, l, 3), e.bx(h), In(t1, i, c, h, l, 4), e.bx(h), e.eh(h, h, Math.PI), In(t1, i, c, h, l, 5), s.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(e, t1, i, o, r) {
                    const s = e.context, n = s.gl, a = e.transform, l = e.getOrCreateProgram("skybox");
                    s.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_CUBE_MAP, t1.skyboxTexture);
                    const c = ((e, t1, i, o, r)=>({
                            u_matrix: e,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: r
                        }))(a.skyboxMatrix, t1.getCenter(e, !1), 0, o, r);
                    e.uploadCommonUniforms(s, l), l.draw(e, n.TRIANGLES, i, ji.disabled, e.colorModeForRenderPass(), qi.backCW, c, "skybox", t1.skyboxGeometry.vertexBuffer, t1.skyboxGeometry.indexBuffer, t1.skyboxGeometry.segment);
                }(t1, o, l, s, c) : "gradient" === a && "sky" === t1.renderPass && function(t1, i, o, r, s) {
                    const n = t1.context, a = n.gl, l = t1.transform, c = t1.getOrCreateProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new Sn(n)), n.activeTexture.set(a.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, a.RGBA8)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const d = ((t1, i, o, r, s)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e.al(o),
                            u_opacity: r,
                            u_temporal_offset: s
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), r, s);
                    t1.uploadCommonUniforms(n, c), c.draw(t1, a.TRIANGLES, o, ji.disabled, t1.colorModeForRenderPass(), qi.backCW, d, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, l, s, c);
            },
            custom: function(t1, i, o, r) {
                const s = t1.context, n = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isDraped(i)) {
                    if ("offscreen" === t1.renderPass) {
                        const i = n.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), s.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(n, s.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.ah(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(n, s.gl, t1.transform.customLayerMatrix());
                            s.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const e = n.renderToTile;
                            if (e) {
                                const i = r[0].canonical, o = {
                                    x: i.x + r[0].wrap * (n.wrapTileId ? 0 : 1 << i.z),
                                    y: i.y,
                                    z: i.z
                                };
                                s.setDepthMode(Ni.disabled), s.setStencilMode(ji.disabled), s.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), e.call(n, s.gl, o), s.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), s.setColorMode(t1.colorModeForRenderPass()), s.setStencilMode(ji.disabled);
                        const i = "3d" === n.renderingMode ? new Ni(t1.context.gl.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, Ni.ReadOnly);
                        if (s.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            n.render(s.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.ah(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else n.render(s.gl, t1.transform.customLayerMatrix());
                        s.setDirty(), t1.setBaseState(), s.bindFramebuffer.set(null);
                    }
                } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            },
            model: function(t1, i, o, r) {
                if ("opaque" === t1.renderPass) return;
                const s = o.paint.get("model-opacity").constantOr(1);
                if (0 === s) return;
                const n = o.paint.get("model-cast-shadows");
                if ("shadow" === t1.renderPass) {
                    if (!n) return;
                    if (t1.terrain && s < .65 && o._transitionablePaint._values["model-opacity"].value.expression instanceof e.ab) return;
                }
                const a = t1.shadowRenderer, l = o.paint.get("model-receive-shadows");
                a && (a.useNormalOffset = !0, l || (a.enabled = !1));
                const c = ()=>{
                    a && (a.useNormalOffset = !0, l || (a.enabled = !0));
                }, h = i.getSource();
                if ("light-beam" === t1.renderPass && "batched-model" !== h.type) return;
                if ("vector" === h.type || "geojson" === h.type) return function(t1, i, o, r, s) {
                    const n = t1.transform;
                    if ("mercator" !== n.projection.name) return void e.w(`Drawing 3D models for ${n.projection.name} projection is not yet implemented`);
                    const a = n.getFreeCameraOptions().position;
                    if (!t1.modelManager) return;
                    const l = t1.modelManager;
                    o.modelManager = l;
                    const c = t1.shadowRenderer;
                    if (!o._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
                    const h = o._unevaluatedLayout._values["model-id"], d = Object.assign({}, o.layout.get("model-id").parameters), u = t1.style.order.indexOf(o.fqid);
                    for (const _ of r){
                        const r = i.getTile(_).getBucket(o);
                        if (!r || r.projection.name !== n.projection.name) continue;
                        const p = r.getModelUris();
                        p && !r.modelsRequested && (l.addModelsFromBucket(p, s), r.modelsRequested = !0);
                        const f = Un(_, n);
                        d.zoom = f;
                        const m = h.possiblyEvaluate(d);
                        if (kn(t1, r, _), Nn.shadowUniformsInitialized = !1, Nn.useSingleShadowCascade = !!c && 0 === c.getMaxCascadeForTile(_.toUnwrapped()), "shadow" === t1.renderPass && c) {
                            if (1 === t1.currentShadowCascade && r.isInsideFirstShadowMapFrustum) continue;
                            const i = n.calculatePosMatrix(_.toUnwrapped(), n.worldSize);
                            if (Nn.tileMatrix.set(i), Nn.shadowTileMatrix = Float32Array.from(c.calculateShadowPassMatrixFromMatrix(i)), Nn.aabb.min.fill(0), Nn.aabb.max[0] = Nn.aabb.max[1] = e.aj, Nn.aabb.max[2] = 0, Vn(r, Nn, t1, o.scope)) continue;
                        }
                        const g = 1 << _.canonical.z, v = [
                            ((a.x - _.wrap) * g - _.canonical.x) * e.aj,
                            (a.y * g - _.canonical.y) * e.aj,
                            a.z * g * e.aj
                        ];
                        t1.conflationActive && Object.keys(r.instancesPerModel).length > 0 && t1.style.isLayerClipped(o, i.getSource()) && r.updateReplacement(_, t1.replacementSource, u, s) && (r.uploaded = !1, r.upload(t1.context));
                        for(let e in r.instancesPerModel){
                            const i = r.instancesPerModel[e];
                            i.features.length > 0 && (e = m.evaluate(i.features[0].feature, {}));
                            const n = l.getModel(e, s);
                            if (n || l.hasURLBeenRequested(e) || r.modelUris.includes(e) || (r.modelUris.push(e), r.modelsRequested = !1), n && n.uploaded) for (const e of n.nodes)jn(t1, o, e, i, v, _, Nn);
                        }
                    }
                }(t1, i, o, r, "vector" === h.type ? o.scope : ""), void c();
                if (!h.loaded()) return;
                if ("batched-model" === h.type) return function(t1, i, o, r) {
                    o.resetLayerRenderingStats(t1);
                    const s = t1.context, n = t1.transform, a = t1.style.fog, l = t1.shadowRenderer;
                    if ("mercator" !== n.projection.name) return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);
                    const c = t1.transform.getFreeCameraOptions().position, h = e.c1([], [
                        c.x,
                        c.y,
                        c.z
                    ], t1.transform.worldSize), d = e.eq([], h), u = e.bx([]), _ = e.e9(n.center.lat, n.zoom), p = e.bn([], [
                        1,
                        1,
                        1 / _
                    ]);
                    e.bo(u, u, d);
                    const f = o.paint.get("model-opacity").constantOr(1), m = new Ni(s.gl.LEQUAL, Ni.ReadWrite, t1.depthRangeFor3D), g = new Ni(s.gl.LEQUAL, Ni.ReadOnly, t1.depthRangeFor3D), v = new e.d6([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]), y = "shadow" === t1.renderPass, x = y && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)), b = o.paint.get("model-front-cutoff"), w = b[2] < 1, T = eo(t1, o.paint.get("model-cutoff-fade-range")), E = o.getLayerRenderingStats();
                    (function(e, t1, i, o) {
                        const r = e.terrain ? e.terrain.exaggeration() : 0, s = e.transform.zoom;
                        for (const n of o){
                            const o = t1.getTile(n).getBucket(i);
                            o && (o.setFilter(i.filter), e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateTransform(e, i), e.terrain && r > 0 && o.elevationUpdate(e.terrain, r, n, i.source), o.needsReEvaluation(e, s, i) && o.evaluate(i));
                        }
                    })(t1, i, o, r), function() {
                        let c, d, S;
                        w ? (c = r.length - 1, d = -1, S = -1) : (c = 0, d = r.length, S = 1);
                        const I = new Float64Array(16), C = e.cx(), R = new e.P(0, 0);
                        for(let A = c; A !== d; A += S){
                            const c = r[A], d = i.getTile(c).getBucket(o);
                            if (!d || !d.uploaded) continue;
                            let S = !1;
                            l && (S = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));
                            const D = n.calculatePosMatrix(c.toUnwrapped(), n.worldSize), P = d.modelTraits;
                            !y && w && (e.bi(I, D), e.ad(C, h, I), R.x = C[0], R.y = C[1]);
                            const L = [];
                            d.setFilter(o.filter);
                            for (const i of d.getNodesInfo()){
                                if (i.hiddenByReplacement) continue;
                                if (!i.node.meshes) continue;
                                const o = i.node;
                                let r = 0;
                                t1.terrain && o.elevation && (r = o.elevation * t1.terrain.exaggeration());
                                const s = (()=>{
                                    const t1 = i.aabb;
                                    return v.min = [
                                        ...t1.min
                                    ], v.max = [
                                        ...t1.max
                                    ], v.min[2] += r, v.max[2] += r, e.ad(v.min, v.min, D), e.ad(v.max, v.max, D), v;
                                })(), a = i.evaluatedScale;
                                if (a[0] <= 1 && a[1] <= 1 && a[2] <= 1 && 0 === s.intersects(x)) continue;
                                if (!y && w) {
                                    const t1 = 1 / 6;
                                    i.cameraCollisionOpacity = h[0] > s.min[0] && h[0] < s.max[0] && h[1] > s.min[1] && h[1] < s.max[1] && h[2] * _ < s.max[2] && o.footprint && e.bY(R, o.footprint) ? Math.max(i.cameraCollisionOpacity - t1, 0) : Math.min(1, i.cameraCollisionOpacity + t1);
                                }
                                const l = [
                                    ...D
                                ], d = 1 / e.d4(c.canonical), u = o.anchor ? o.anchor[0] : 0, p = o.anchor ? o.anchor[1] : 0;
                                e.bo(l, l, [
                                    u * (a[0] - 1) + i.evaluatedTranslation[0] * d,
                                    p * (a[1] - 1) + i.evaluatedTranslation[1] * d,
                                    r + i.evaluatedTranslation[2]
                                ]), e.cn(a, e.es) || e.cP(l, l, a);
                                const m = e.az([], l, o.matrix), g = e.az([], n.expandedFarZProjMatrix, m), E = e.az([], n.expandedFarZProjMatrix, l), S = e.aA([], [
                                    u,
                                    p,
                                    r,
                                    1
                                ], g)[2];
                                o.hidden = !1;
                                let I = f;
                                y || (w && (I *= i.cameraCollisionOpacity, I *= Hn(l, n, i.aabb, b)), I *= qn(T, S)), 0 !== I ? L.push({
                                    nodeInfo: i,
                                    depth: S,
                                    opacity: I,
                                    wvpForNode: g,
                                    wvpForTile: E,
                                    nodeModelMatrix: m,
                                    tileModelMatrix: l
                                }) : o.hidden = !0;
                            }
                            y || L.sort((e, t1)=>!w || 1 === e.opacity && 1 === t1.opacity ? e.depth < t1.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t1.opacity ? 1 : e.depth > t1.depth ? -1 : 1);
                            for (const i of L){
                                const r = i.nodeInfo, c = r.node;
                                let h = e.az([], p, i.tileModelMatrix);
                                e.az(h, u, h);
                                const d = e.bi([], h);
                                e.ea(d, d), e.cP(d, d, Gn), h = e.az(h, h, c.matrix);
                                const _ = "light-beam" === t1.renderPass, f = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = P & e.ex.HasMapboxMeshFeatures, x = v ? 0 : r.evaluatedRMEA[0][2];
                                for(let e = 0; e < c.meshes.length; ++e){
                                    const u = c.meshes[e], p = e === c.lightMeshIndex;
                                    let b = i.wvpForNode;
                                    if (p) {
                                        if (!_ && !t1.terrain && t1.shadowRenderer) {
                                            t1.currentLayer < t1.firstLightBeamLayer && (t1.firstLightBeamLayer = t1.currentLayer);
                                            continue;
                                        }
                                        b = i.wvpForTile;
                                    } else if (_) continue;
                                    const w = {
                                        defines: []
                                    }, T = [];
                                    if (!y && l && (l.useNormalOffset = !!u.normalBuffer), Mn(w.defines, T, u, t1, f ? null : o.lut), v || w.defines.push("DIFFUSE_SHADED"), S && w.defines.push("SHADOWS_SINGLE_CASCADE"), E && (y ? E.numRenderedVerticesInShadowPass += u.vertexArray.length : E.numRenderedVerticesInTransparentPass += u.vertexArray.length), y) {
                                        Bn(u, i.nodeModelMatrix, t1, o);
                                        continue;
                                    }
                                    let I = null;
                                    if (a) {
                                        const e = zn(i.nodeModelMatrix, t1.transform);
                                        if (I = new Float32Array(e), "globe" !== n.projection.name) {
                                            const t1 = u.aabb.min, i = u.aabb.max, [o, r] = a.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                                            w.overrideFog = o >= Fe || r >= Fe;
                                        }
                                    }
                                    const C = u.material;
                                    let R;
                                    C.occlusionTexture && C.occlusionTexture.offsetScale && (R = C.occlusionTexture.offsetScale, w.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                    const A = t1.getOrCreateProgram("model", w);
                                    !y && l && l.setupShadowsFromMatrix(i.tileModelMatrix, A, l.useNormalOffset), t1.uploadCommonUniforms(s, A, null, I);
                                    const D = C.pbrMetallicRoughness;
                                    D.metallicFactor = .9, D.roughnessFactor = .5;
                                    const P = As(new Float32Array(b), new Float32Array(h), new Float32Array(d), new Float32Array(c.matrix), t1, i.opacity, D.baseColorFactor, C.emissiveFactor, D.metallicFactor, D.roughnessFactor, C, x, o, [
                                        0,
                                        0,
                                        0
                                    ], R);
                                    !p && (r.hasTranslucentParts || i.opacity < 1) && A.draw(t1, s.gl.TRIANGLES, m, ji.disabled, ki.disabled, qi.backCCW, P, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t1.transform.zoom, void 0, T), A.draw(t1, s.gl.TRIANGLES, p ? g : m, ji.disabled, p || i.opacity < 1 || r.hasTranslucentParts ? ki.alphaBlended : ki.unblended, qi.backCCW, P, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t1.transform.zoom, void 0, T);
                                }
                            }
                        }
                    }();
                }(t1, i, o, r), void c();
                if ("model" !== h.type) return;
                const d = h.getModels(), u = [], _ = t1.transform.getFreeCameraOptions().position, p = e.c1([], [
                    _.x,
                    _.y,
                    _.z
                ], t1.transform.worldSize);
                e.eq(p, p);
                const f = [], m = [];
                let g = 0;
                for (const i of d){
                    const r = o.paint.get("model-rotation").constantOr(null), s = o.paint.get("model-scale").constantOr(null), n = o.paint.get("model-translation").constantOr(null);
                    i.computeModelMatrix(t1, r, s, n, !0, !0, !1);
                    const a = e.bx([]), l = e.e9(i.position.lat, t1.transform.zoom), c = e.bn([], [
                        1,
                        1,
                        1 / l
                    ]);
                    e.bo(a, a, p), u.push({
                        zScaleMatrix: c,
                        negCameraPosMatrix: a
                    });
                    for (const e of i.nodes)Fn(t1.transform, e, i.matrix, t1.transform.expandedFarZProjMatrix, g, f, m);
                    g++;
                }
                if (f.sort((e, t1)=>t1.depth - e.depth), "shadow" !== t1.renderPass) {
                    if (1 === s) for (const e of m)On(e, t1, o, u[e.modelIndex], ji.disabled, t1.colorModeForRenderPass());
                    else {
                        for (const e of m)On(e, t1, o, u[e.modelIndex], ji.disabled, ki.disabled);
                        for (const e of m)On(e, t1, o, u[e.modelIndex], t1.stencilModeFor3D(), t1.colorModeForRenderPass());
                        t1.resetStencilClippingMasks();
                    }
                    for (const e of f)On(e, t1, o, u[e.modelIndex], ji.disabled, t1.colorModeForRenderPass());
                    c();
                } else {
                    for (const e of m)Bn(e.mesh, e.nodeModelMatrix, t1, o);
                    for (const e of f)Bn(e.mesh, e.nodeModelMatrix, t1, o);
                    c();
                }
            }
        }, ca = {
            line: function(e, t1, i) {
                if (e.hasElevatedBuckets = !1, e.hasNonElevatedBuckets = !1, void 0 !== e._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e._unevaluatedLayout.getValue("line-z-offset")) {
                    if (t1) {
                        const i = t1.getVisibleCoordinates();
                        for (const o of i){
                            const i = t1.getTile(o).getBucket(e);
                            if (i && ("none" !== i.elevationType ? e.hasElevatedBuckets = !0 : e.hasNonElevatedBuckets = !0, e.hasElevatedBuckets && e.hasNonElevatedBuckets)) break;
                        }
                    }
                } else e.hasNonElevatedBuckets = !0;
            },
            model: function(e, t1, i) {
                const o = t1.getSource();
                if (!o.loaded()) return;
                if ("vector" === o.type || "geojson" === o.type) return void (i.modelManager && i.modelManager.upload(i, "vector" === o.type ? e.scope : ""));
                if ("batched-model" === o.type) return;
                if ("model" !== o.type) return;
                const r = o.getModels();
                for (const e of r)e.upload(i.context);
            },
            raster: function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof rt && o.loaded())) return;
                const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!r) return;
                const s = e.paint.get("raster-array-band") || o.getInitialBand(r);
                if (null == s) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const t1 of n)t1.updateNeeded(e.id, s) && o.prepareTile(t1, r, e.id, s);
            },
            "raster-particle": function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof rt && o.loaded())) return;
                const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!r) return;
                const s = e.paint.get("raster-particle-array-band") || o.getInitialBand(r);
                if (null == s) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const t1 of n)t1.updateNeeded(e.id, s) && o.prepareTile(t1, r, e.id, s);
            }
        }, ha = {
            fill: Zs
        }, da = {
            fill: function(e, t1, i, o) {
                if (!i.layout || "none" === i.layout.get("fill-elevation-reference")) return;
                const r = e.context.gl, s = new Ni(r.LEQUAL, Ni.ReadOnly, e.depthRangeFor3D), n = new ji({
                    func: r.ALWAYS,
                    mask: 255
                }, 255, 255, r.KEEP, r.KEEP, r.REPLACE), a = e.transform.getFreeCameraOptions().position, l = e.getOrCreateProgram("elevatedStructuresDepthReconstruct");
                for (const c of o){
                    const o = t1.getTile(c), h = o.getBucket(i);
                    if (!h) continue;
                    const d = h.elevatedStructures;
                    if (!d || 0 === d.depthSegments.segments[0].primitiveLength) continue;
                    const u = Hs(c.toUnwrapped(), a), _ = e.translatePosMatrix(c.projMatrix, o, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor")), p = ls(_, u, 0, 1, 0);
                    l.draw(e, r.TRIANGLES, s, n, ki.disabled, qi.disabled, p, i.id, d.vertexBuffer, d.indexBuffer, d.depthSegments, i.paint, e.transform.zoom);
                }
            }
        };
        class ua {
            constructor(t1, i, o, r, s, n){
                this.context = new Fs(t1, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = s, this._timeStamp = e.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
                    forceEnablePrecipitation: !1,
                    showTerrainProxyTiles: !1,
                    fpsWindow: 30,
                    continousRedraw: !1,
                    enabledLayers: {}
                };
                const a = [
                    "fill",
                    "line",
                    "symbol",
                    "circle",
                    "heatmap",
                    "fill-extrusion",
                    "building",
                    "raster",
                    "raster-particle",
                    "hillshade",
                    "model",
                    "background",
                    "sky"
                ];
                for (const e of a)this._debugParams.enabledLayers[e] = !0;
                s.registerParameter(this._debugParams, [
                    "Terrain"
                ], "showTerrainProxyTiles", {}, ()=>{
                    this.style.map.triggerRepaint();
                }), s.registerParameter(this._debugParams, [
                    "Precipitation"
                ], "forceEnablePrecipitation"), s.registerParameter(this._debugParams, [
                    "FPS"
                ], "fpsWindow", {
                    min: 1,
                    max: 100,
                    step: 1
                }), s.registerBinding(this._debugParams, [
                    "FPS"
                ], "continousRedraw", {
                    readonly: !0,
                    label: "continuous redraw"
                }), s.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "value"
                }), s.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "graph",
                    view: "graph",
                    min: 0,
                    max: 200
                });
                for (const e of a)s.registerParameter(this._debugParams.enabledLayers, [
                    "Debug",
                    "Layers"
                ], e);
                this.occlusionParams = new $n(s), this.setup(), this.numSublayers = It.maxUnderzooming + It.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.eE, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new ro(this), this._wireframeDebugCache = new Wn, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
                const l = new e.r({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0));
                this.emptyDepthTexture = new e.T(this.context, l, t1.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = r, this.worldview = n;
            }
            updateTerrain(e, t1) {
                const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new Zr(this, e));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e, this.transform, t1), this.transform.elevation && !o.enabled && (this.transform.elevation = null);
            }
            _updateFog(e) {
                const t1 = e.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const r = i + .78 * (o - i);
                this.transform.fogCullDistSq = r * r;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
                return this._forceTerrainMode;
            }
            set forceTerrainMode(e) {
                e && !this._terrain && (this._terrain = new Zr(this, this.style)), this._forceTerrainMode = e;
            }
            get shadowRenderer() {
                return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
                return this._wireframeDebugCache;
            }
            resize(t1, i) {
                if (this.width = t1 * e.q.devicePixelRatio, this.height = i * e.q.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e of this.style.order)this.style._mergedLayers[e].resize();
            }
            setup() {
                const t1 = this.context, i = new e.ba;
                i.emplaceBack(0, 0), i.emplaceBack(e.aj, 0), i.emplaceBack(0, e.aj), i.emplaceBack(e.aj, e.aj), this.tileExtentBuffer = t1.createVertexBuffer(i, e.bc.members), this.tileExtentSegments = e.bd.simpleSegment(0, 0, 4, 2);
                const o = new e.ba;
                o.emplaceBack(0, 0), o.emplaceBack(e.aj, 0), o.emplaceBack(0, e.aj), o.emplaceBack(e.aj, e.aj), this.debugBuffer = t1.createVertexBuffer(o, e.bc.members), this.debugSegments = e.bd.simpleSegment(0, 0, 4, 5);
                const r = new e.ba;
                r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(r, e.bc.members), this.viewportSegments = e.bd.simpleSegment(0, 0, 4, 2);
                const s = new e.aZ;
                s.emplaceBack(0, 0, 0, 0), s.emplaceBack(e.aj, 0, e.aj, 0), s.emplaceBack(0, e.aj, 0, e.aj), s.emplaceBack(e.aj, e.aj, e.aj, e.aj), this.mercatorBoundsBuffer = t1.createVertexBuffer(s, e.bf.members), this.mercatorBoundsSegments = e.bd.simpleSegment(0, 0, 4, 2);
                const n = new e.a_;
                n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(n);
                const a = new e.bb;
                for (const e of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])a.emplaceBack(e);
                this.debugIndexBuffer = t1.createIndexBuffer(a), this.emptyTexture = new e.T(t1, new e.r({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA8), this.identityMat = e.bz();
                const l = this.context.gl;
                this.stencilClearMode = new ji({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                    tileBoundsBuffer: e._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                    tileBoundsSegments: e._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const e = this.context.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e.TRIANGLES, Ni.disabled, this.stencilClearMode, ki.disabled, qi.disabled, jr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e, t1, i) {
                if (!t1 || this.currentStencilSource === t1.id || !e.isTileClipped() || !i || 0 === i.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e = !1;
                    for (const t1 of i)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e = !0;
                        break;
                    }
                    if (!e) return;
                }
                this.currentStencilSource = t1.id;
                const o = this.context, r = o.gl;
                this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(ki.disabled), o.setDepthMode(Ni.disabled);
                const s = this.getOrCreateProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e of i){
                    const i = t1.getTile(e), o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++, { tileBoundsBuffer: n, tileBoundsIndexBuffer: a, tileBoundsSegments: l } = this.getTileBoundsBuffers(i);
                    s.draw(this, r.TRIANGLES, Ni.disabled, new ji({
                        func: r.ALWAYS,
                        mask: 0
                    }, o, 255, r.KEEP, r.KEEP, r.REPLACE), ki.disabled, qi.disabled, jr(e.projMatrix), "$clipping", n, a, l);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++, t1 = this.context.gl;
                return new ji({
                    func: t1.NOTEQUAL,
                    mask: 255
                }, e, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilModeForClipping(e) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);
                const t1 = this.context.gl;
                return new ji({
                    func: t1.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[e.key], 0, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilConfigForOverlap(e) {
                const t1 = this.context.gl, i = e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ), o = i[i.length - 1].overscaledZ, r = i[0].overscaledZ - o + 1;
                if (r > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + r > 256 && this.clearStencil();
                    const e = {};
                    for(let i = 0; i < r; i++)e[i + o] = new ji({
                        func: t1.GEQUAL,
                        mask: 255
                    }, i + this.nextStencilID, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
                    return this.nextStencilID += r, [
                        e,
                        i
                    ];
                }
                return [
                    {
                        [o]: ji.disabled
                    },
                    i
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new ki([
                        t1.CONSTANT_COLOR,
                        t1.ONE,
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e.am(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? ki.unblended : ki.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t1) {
                const i = this.context.gl;
                return (()=>this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new ki([
                    i.ONE,
                    i.ONE_MINUS_SRC_ALPHA,
                    i.CONSTANT_ALPHA,
                    i.ONE_MINUS_SRC_ALPHA
                ], new e.am(0, 0, 0, void 0 === t1 ? 0 : t1), [
                    !0,
                    !0,
                    !0,
                    !0
                ]) : this.colorModeForRenderPass();
            }
            depthModeForSublayer(e, t1, i, o = !1) {
                if (this.depthOcclusion) return new Ni(this.context.gl.GREATER, Ni.ReadOnly, this.depthRangeFor3D);
                if (!this.opaquePassEnabledForLayer() && !o) return Ni.disabled;
                const r = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                return new Ni(i || this.context.gl.LEQUAL, t1, [
                    r,
                    r
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
                const t1 = this.context.gl, i = Math.ceil(this.width), o = Math.ceil(this.height), r = this.context.bindFramebuffer.get(), s = t1.getParameter(t1.TEXTURE_BINDING_2D);
                this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === o || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i && 0 !== o && (this.depthFBO = new Os(this.context, i, o, !1, "texture"), this.depthTexture = new e.T(this.context, {
                    width: i,
                    height: o,
                    data: null
                }, t1.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(r), t1.bindTexture(t1.TEXTURE_2D, s), this.depthFBO && (t1.bindFramebuffer(t1.READ_FRAMEBUFFER, null), t1.bindFramebuffer(t1.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t1.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t1.DEPTH_BUFFER_BIT, t1.NEAREST), t1.bindFramebuffer(t1.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
                this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t1)=>e + t1 / this._fpsHistory.length, 0));
            }
            render(t1, i) {
                const o = e.q.now();
                this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t1.map.repaint, this.style = t1, this.options = i;
                const r = this.style._mergedLayers, s = !(!this.terrain || !this.terrain.enabled), n = ()=>this.style._getOrder(s).filter((e)=>{
                        const t1 = r[e];
                        return !(t1.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t1.type];
                    });
                let a = n(), l = !1, c = !1, h = null;
                for (const e of a){
                    const t1 = r[e];
                    "circle" === t1.type ? l = !0 : "building" === t1.type ? h = t1 : "symbol" === t1.type && (t1.hasInitialOcclusionOpacityProperties ? c = !0 : l = !0);
                }
                let d = a.map((e)=>r[e]);
                const u = this.style._mergedSourceCaches;
                this.imageManager = t1.imageManager, this.modelManager = t1.modelManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e.q.now()), this.imageManager.beginFrame();
                let _ = 0, p = !1;
                for(const e in u){
                    const t1 = u[e];
                    t1.used && (t1.prepare(this.context), t1.getSource().usedInConflation && ++_);
                }
                let f = !1;
                for (const e of d)e.isHidden(this.transform.zoom) || ("clip" === e.type && (f = !0), this.prepareLayer(e));
                const m = {}, g = {}, v = {}, y = {}, x = {};
                for(const e in u){
                    const t1 = u[e];
                    m[e] = t1.getVisibleCoordinates(), g[e] = m[e].slice().reverse(), v[e] = t1.getVisibleCoordinates(!0).reverse(), y[e] = t1.getShadowCasterCoordinates(), x[e] = t1.sortCoordinatesByDistance(m[e]);
                }
                const b = (e)=>{
                    const t1 = this.style.getLayerSourceCache(e);
                    return t1 && t1.used ? t1.getSource() : null;
                };
                if (_ || f || this._clippingActiveLastFrame) {
                    const t1 = [], i = [];
                    let o = 0;
                    for (const e of d)this.isSourceForClippingOrConflation(e, b(e)) && (t1.push(e), i.push(o)), o++;
                    if (t1 && (f || t1.length > 1) || this._clippingActiveLastFrame) {
                        f = !1;
                        const o = [];
                        for(let r = 0; r < t1.length; r++){
                            const s = t1[r], n = i[r], a = this.style.getLayerSourceCache(s);
                            if (!a || !a.used || !a.getSource().usedInConflation && "clip" !== s.type && "building" !== s.type) continue;
                            let l = e.eF, c = e.bW.None;
                            const h = [];
                            let d = !0;
                            if ("building" === s.type) l = e.eH;
                            else if ("clip" === s.type) {
                                l = n;
                                for (const t1 of s.layout.get("clip-layer-types"))c |= "model" === t1 ? e.bW.Model : "symbol" === t1 ? e.bW.Symbol : e.bW.FillExtrusion;
                                for (const e of s.layout.get("clip-layer-scope"))h.push(e);
                                s.isHidden(this.transform.zoom) ? d = !1 : f = !0;
                            }
                            d && o.push({
                                layer: s.fqid,
                                cache: a,
                                order: l,
                                clipMask: c,
                                clipScope: h
                            });
                        }
                        this.replacementSource.setSources(o), p = !0;
                    }
                }
                this._clippingActiveLastFrame = f, p || this.replacementSource.clear(), this.conflationActive = p, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
                for(let e = 0; e < d.length; e++){
                    const t1 = d[e], i = t1.cutoffRange();
                    if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {
                        const e = b(t1);
                        e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t1.minzoom && (this.minCutoffZoom = Math.max(t1.minzoom, this.minCutoffZoom));
                    }
                    t1.is3D(s) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);
                }
                const w = this.style && this.style.fog;
                w ? (this._fogVisible = 0 !== w.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = w.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(v), this.opaquePassCutoff = 0, a = n(), d = a.map((e)=>r[e]));
                const T = this._shadowRenderer;
                if (T) {
                    T.updateShadowParameters(this.transform, this.style.directionalLight);
                    for(const e in u)for (const t1 of m[e]){
                        let e = {
                            min: 0,
                            max: 0
                        };
                        this.terrain && (e = this.terrain.getMinMaxForTile(t1) || e), T.addShadowReceiver(t1.toUnwrapped(), e.min, e.max);
                    }
                }
                "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eG(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Pn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
                const E = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), S = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
                if (E && !this._snow && (this._snow = new aa(this)), !E && this._snow && (this._snow.destroy(), delete this._snow), S && !this._rain && (this._rain = new sa(this)), !S && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), h) {
                    this.buildingTileBorderManager || (this.buildingTileBorderManager = new Ln);
                    const e = this.style.getLayerSourceCache(h);
                    this.buildingTileBorderManager.updateBorders(e, h);
                }
                if (!U.has(this.context.gl)) return;
                this.renderPass = "offscreen";
                for (const e of d){
                    const i = t1.getLayerSourceCache(e);
                    if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;
                    const o = i ? g[i.id] : void 0;
                    ("custom" === e.type || "raster" === e.type || "raster-particle" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);
                }
                this.depthRangeFor3D = [
                    0,
                    1 - (d.length + 2) * this.numSublayers * this.depthEpsilon
                ], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, y)), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]);
                const I = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), C = (()=>{
                    if (i.showOverdrawInspector) return e.am.black;
                    const t1 = this.style.fog;
                    if (t1 && this.transform.projection.supportsFog) {
                        const i = this.style.getLut(t1.scope);
                        if (!I) {
                            const o = "none" === t1.properties.get("color-use-theme"), r = t1.properties.get("color").toNonPremultipliedRenderColor(o ? null : i).toArray01();
                            return new e.am(...r);
                        }
                        if (I) {
                            const o = "none" === t1.properties.get("space-color-use-theme"), r = t1.properties.get("space-color").toNonPremultipliedRenderColor(o ? null : i).toArray01();
                            return new e.am(...r);
                        }
                    }
                    return e.am.transparent;
                })();
                if (this.context.clear({
                    color: C,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for(this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const e = d[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) continue;
                    const o = i ? (e.is3D(s) ? x : g)[i.id] : void 0;
                    this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);
                }
                if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.ah(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for(this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++){
                    const e = d[this.currentLayer], i = t1.getLayerSourceCache(e);
                    e.isSky() && this.renderLayer(this, i, e, i ? g[i.id] : void 0);
                }
                function R(e, t1) {
                    let i;
                    return t1 && (i = ("symbol" === e.type ? v : e.is3D(s) ? x : g)[t1.id]), i;
                }
                if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                    for(this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a.length;){
                        const e = d[this.currentLayer];
                        if ("raster" === e.type || "raster-particle" === e.type) {
                            const i = t1.getLayerSourceCache(e);
                            this.renderLayer(this, i, e, R(e, i));
                        }
                        ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                }
                this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                let A = 0;
                T && (A = T.getShadowCastingLayerCount());
                let D = !1, P = -1;
                for(let e = 0; e < a.length; ++e){
                    const t1 = d[e];
                    t1.isHidden(this.transform.zoom) || t1.is3D(s) && (P = e);
                }
                c && -1 === P && (l = !0);
                let L = !1;
                for(; this.currentLayer < a.length;){
                    const e = d[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(e)) {
                        if (e.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                    } else {
                        if (!L && e.is3D(s) && !s) {
                            const e = this.currentLayer, t1 = (e)=>{
                                for(this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++){
                                    const t1 = d[this.currentLayer];
                                    if (ha[t1.type]) {
                                        const i = this.style.getLayerSourceCache(t1);
                                        ha[t1.type](this, i, t1, R(t1, i), e);
                                    }
                                }
                            };
                            t1("initialize"), t1("reset"), this.currentLayer = e, L = !0;
                        }
                        if (l && !D && this.terrain && !this.transform.isOrthographic && (D = !0, this.blitDepth()), c && -1 !== P && this.currentLayer === P + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e, i, i ? m[i.id] : void 0), this.renderLayer(this, i, e, R(e, i)), !this.terrain && T && A > 0 && e.hasShadowPass() && 0 == --A) {
                            {
                                this.clearStencil(), this.resetStencilClippingMasks();
                                const e = this.currentLayer;
                                for(this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++){
                                    const e = d[this.currentLayer];
                                    if (da[e.type]) {
                                        const t1 = this.style.getLayerSourceCache(e);
                                        da[e.type](this, t1, e, R(e, t1));
                                    }
                                }
                                this.currentLayer = e;
                            }
                            if (T.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {
                                const e = this.currentLayer;
                                for(this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++){
                                    const e = d[this.currentLayer];
                                    if (!e.hasLightBeamPass()) continue;
                                    const i = t1.getLayerSourceCache(e);
                                    this.renderLayer(this, i, e, i ? g[i.id] : void 0);
                                }
                                this.currentLayer = e, this.renderPass = "translucent";
                            }
                        }
                        if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                            const e = this.currentLayer;
                            this.depthOcclusion = !0;
                            for (const e of this.layersWithOcclusionOpacity){
                                this.currentLayer = e;
                                const i = d[this.currentLayer], o = t1.getLayerSourceCache(i), r = o ? g[o.id] : void 0;
                                this.terrain || this._renderTileClippingMasks(i, o, o ? m[o.id] : void 0), this.renderLayer(this, o, i, r);
                            }
                            this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                        }
                        ++this.currentLayer;
                    }
                }
                if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let i = null;
                    d.forEach((e)=>{
                        const o = t1.getLayerSourceCache(e);
                        o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                    }), i && this.options.showTileBoundaries && gn(this, i, i.getVisibleCoordinates(), e.am.red, !1, this.options.showParseStatus);
                }
                this.terrain && this._debugParams.showTerrainProxyTiles && gn(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.am(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(e) {
                    const t1 = e.transform.padding;
                    yn(e, e.transform.height - (t1.top || 0), 3, un), yn(e, t1.bottom || 0, 3, _n), xn(e, t1.left || 0, 3, pn), xn(e, e.transform.width - (t1.right || 0), 3, fn);
                    const i = e.transform.centerPoint;
                    !function(e, t1, i, o) {
                        bn(e, t1 - 1, i - 10, 2, 20, o), bn(e, t1 - 10, i - 1, 20, 2, o);
                    }(e, i.x, e.transform.height - i.y, mn);
                }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), p || (this.conflationActive = !1);
            }
            prepareLayer(e) {
                this.gpuTimingStart(e);
                const { unsupportedLayers: t1 } = this.transform.projection, i = !t1 || !t1.includes(e.type);
                if (ca[e.type] && (i || this.terrain && "custom" === e.type)) {
                    const t1 = this.style.getLayerSourceCache(e);
                    ca[e.type](e, t1, this);
                }
                this.gpuTimingEnd();
            }
            renderLayer(e, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || "model" === i.type || "raster" === i.type || "raster-particle" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || "custom" !== i.type) || "clip" === i.type || la[i.type](e, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery, i = this.context.gl;
                let o = this.gpuTimers[e.id];
                o || (o = this.gpuTimers[e.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: i.createQuery()
                }), o.calls++, i.beginQuery(t1.TIME_ELAPSED_EXT, o.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e = this.context.extTimerQuery, t1 = this.context.gl, i = t1.createQuery();
                    this.deferredRenderGpuTimeQueries.push(i), t1.beginQuery(e.TIME_ELAPSED_EXT, i);
                }
            }
            gpuTimingDeferredRenderEnd() {
                this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e = this.gpuTimers;
                return this.gpuTimers = {}, e;
            }
            collectDeferredRenderGpuQueries() {
                const e = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e;
            }
            queryGpuTimers(e) {
                const t1 = {};
                for(const i in e){
                    const o = e[i], r = this.context.extTimerQuery, s = r.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;
                    r.deleteQueryEXT(o.query), t1[i] = s;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.gl;
                let i = 0;
                for (const o of e)i += t1.getQueryParameter(o, t1.QUERY_RESULT) / 1e6, t1.deleteQuery(o);
                return i;
            }
            translatePosMatrix(t1, i, o, r, s) {
                if (!o[0] && !o[1]) return t1;
                const n = s ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                if (n) {
                    const e = Math.sin(n), t1 = Math.cos(n);
                    o = [
                        o[0] * t1 - o[1] * e,
                        o[0] * e + o[1] * t1
                    ];
                }
                const a = [
                    s ? o[0] : e.aw(i, o[0], this.transform.zoom),
                    s ? o[1] : e.aw(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e.bo(l, t1, a), l;
            }
            saveTileTexture(e) {
                if (e.context !== this.context) return;
                const t1 = e.size[0], i = this._tileTextures[t1];
                i ? i.push(e) : this._tileTextures[t1] = [
                    e
                ];
            }
            getTileTexture(e) {
                const t1 = this._tileTextures[e];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
                return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e, t1, i) {
                const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i, r = [];
                return this.style && this.style.enable3dLights() && ("globeRaster" === e || "terrainRaster" === e ? (r.push("LIGHTING_3D_MODE"), r.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o || r.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || r.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (r.push("TERRAIN"), this.linearFloatFilteringSupported() && r.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && r.push("GLOBE"), !this._fogVisible || o || void 0 !== t1 && !t1 || r.push("FOG", "FOG_DITHERING"), o && r.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && r.push("OVERDRAW_INSPECTOR"), r;
            }
            getOrCreateProgram(e, t1) {
                this.cache = this.cache || {};
                const i = t1 && t1.defines || [], o = t1 && t1.config, r = this.currentGlobalDefines(e, t1 && t1.overrideFog, t1 && t1.overrideRtt).concat(i), s = Yr.cacheKey(Vo[e], e, r, o);
                return this.cache[s] || (this.cache[s] = new Yr(this.context, e, Vo[e], o, Ps[e], r)), this.cache[s];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t1, i) {
                if (this.style.enable3dLights()) {
                    const o = this.style.directionalLight, r = this.style.ambientLight;
                    if (o && r) {
                        const s = ((t1, i, o)=>{
                            const r = t1.properties.get("direction"), s = "none" === t1.properties.get("color-use-theme"), n = t1.properties.get("color").toNonPremultipliedRenderColor(s ? null : o.getLut(t1.scope)).toArray01(), a = t1.properties.get("intensity"), l = "none" === i.properties.get("color-use-theme"), c = i.properties.get("color").toNonPremultipliedRenderColor(l ? null : o.getLut(i.scope)).toArray01(), h = i.properties.get("intensity"), d = [
                                r.x,
                                r.y,
                                r.z
                            ], u = e.dI(c, h), _ = e.dI(n, a);
                            return {
                                u_lighting_ambient_color: u,
                                u_lighting_directional_dir: d,
                                u_lighting_directional_color: _,
                                u_ground_radiance: Wr(d, _, u)
                            };
                        })(o, r, this.style);
                        i.setLightsUniformValues(t1, s);
                    }
                }
            }
            uploadCommonUniforms(t1, i, o, r, s) {
                if (this.uploadCommonLightUniforms(t1, i), this.terrain && this.terrain.renderingToTexture) return;
                const n = this.style.fog;
                if (n) {
                    const s = n.getOpacity(this.transform.pitch), a = ((t1, i, o, r, s, n, a, l, c, h, d, u)=>{
                        const _ = t1.transform, p = "none" === i.properties.get("color-use-theme"), f = i.properties.get("color").toNonPremultipliedRenderColor(p ? null : t1.style.getLut(i.scope)).toArray01();
                        f[3] = r;
                        const m = t1.frameCounter / 1e3 % 1, [g, v] = i.properties.get("vertical-range");
                        return {
                            u_fog_matrix: o ? _.calculateFogTileMatrix(o) : u || t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(_._fov),
                            u_fog_color: f,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_vertical_limit: [
                                Math.min(g, v),
                                v
                            ],
                            u_fog_temporal_offset: m,
                            u_frustum_tl: s,
                            u_frustum_tr: n,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: d,
                            u_globe_transition: e.ah(_.zoom),
                            u_is_globe: +("globe" === _.projection.name)
                        };
                    })(this, n, o, s, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e.q.devicePixelRatio,
                        this.transform.height * e.q.devicePixelRatio
                    ], r);
                    i.setFogUniformValues(t1, a);
                }
                s && i.setCutoffUniformValues(t1, s.uniformValues);
            }
            setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }
            saveCanvasCopy() {
                const e = this.canvasCopy();
                e && (this.frameCopies.push(e), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e = this.context.gl, t1 = e.createTexture();
                return e.bindTexture(e.TEXTURE_2D, t1), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e = this.style && this.style.fog;
                return !!e && 0 !== e.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const e = this._backgroundTiles, t1 = this._backgroundTiles = {}, i = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const o of i)t1[o.key] = e[o.key] || new wt(o, 512, this.transform.tileZoom, this, void 0, this.worldview);
                return t1;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e, t1) {
                return !(!e.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e.type && "building" !== e.type && (e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e.sourceLayer && "procedural_buildings" !== e.sourceLayer) && (!t1 || "batched-model" !== t1.type)));
            }
            isTileAffectedByFog(e) {
                if (!this.style || !this.style.fog) return !1;
                if ("globe" === this.transform.projection.name) return !0;
                let t1 = this._cachedTileFogOpacities[e.key];
                return t1 || (this._cachedTileFogOpacities[e.key] = t1 = this.style.fog.getOpacityForTile(e)), t1[0] >= Fe || t1[1] >= Fe;
            }
            setupDepthForOcclusion(e, t1, i) {
                const o = this.context, r = o.gl, s = !!i;
                var n;
                i || (i = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                }), o.activeTexture.set(r.TEXTURE3), e && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), i.u_depth_size_inv = [
                    1 / this.depthFBO.width,
                    1 / this.depthFBO.height
                ], i.u_depth_range_unpack = [
                    2 / ((n = this.depthRangeFor3D)[1] - n[0]),
                    -1 - 2 * n[0] / (n[1] - n[0])
                ], i.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), o.activeTexture.set(r.TEXTURE0), s || t1.setTerrainUniformValues(o, i);
            }
        }
        function _a(e, t1) {
            let i = !1, o = null;
            const r = ()=>{
                o = null, i && (e(), o = setTimeout(r, t1), i = !1);
            };
            return ()=>(i = !0, o || r(), o);
        }
        class pa {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e.aV([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = _a(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e) {
                return this._map = e, window.addEventListener("hashchange", this._onHashChange, !1), e.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const e = this._map;
                if (!e) return "";
                const t1 = fa(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let i = !1;
                    const o = location.hash.slice(1).split("&").map((o)=>{
                        const r = o.split("=")[0];
                        return r === e ? (i = !0, `${r}=${t1}`) : o;
                    }).filter((e)=>e);
                    return i || o.push(`${e}=${t1}`), `#${o.join("&")}`;
                }
                return `#${t1}`;
            }
            _getCurrentHash() {
                const e = location.hash.replace("#", "");
                if (this._hashName) {
                    let t1;
                    return e.split("&").map((e)=>e.split("=")).forEach((e)=>{
                        e[0] === this._hashName && (t1 = e);
                    }), (t1 && t1[1] || "").split("/");
                }
                return e.split("/");
            }
            _onHashChange() {
                const e = this._map;
                if (!e) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e)=>isNaN(Number(e)))) {
                    const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e.getBearing();
                    return e.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
        }
        function fa(e, t1) {
            const i = e.getCenter(), o = Math.round(100 * e.getZoom()) / 100, r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), s = Math.pow(10, r), n = Math.round(i.lng * s) / s, a = Math.round(i.lat * s) / s, l = e.getBearing(), c = e.getPitch();
            let h = t1 ? `/${n}/${a}/${o}` : `${o}/${a}/${n}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const ma = {
            linearity: .3,
            easing: e.eI(0, 0, .3, 1)
        }, ga = e.h({
            deceleration: 2500,
            maxSpeed: 1400
        }, ma), va = e.h({
            deceleration: 20,
            maxSpeed: 1400
        }, ma), ya = e.h({
            deceleration: 1e3,
            maxSpeed: 360
        }, ma), xa = e.h({
            deceleration: 1e3,
            maxSpeed: 90
        }, ma);
        class ba {
            constructor(e){
                this._map = e, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e.q.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e.q.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._map._prefersReducedMotion()) return;
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e.P(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e } of this._inertiaBuffer)i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
                if (i.pan.mag()) {
                    const s = Ta(i.pan.mag(), o, e.h({}, ga, t1 || {}));
                    r.offset = i.pan.mult(s.amount / i.pan.mag()), r.center = this._map.transform.center, wa(r, s);
                }
                if (i.zoom) {
                    const e = Ta(i.zoom, o, va);
                    r.zoom = this._map.transform.zoom + e.amount, wa(r, e);
                }
                if (i.bearing) {
                    const t1 = Ta(i.bearing, o, ya);
                    r.bearing = this._map.transform.bearing + e.ay(t1.amount, -179, 179), wa(r, t1);
                }
                if (i.pitch) {
                    const e = Ta(i.pitch, o, xa);
                    r.pitch = this._map.transform.pitch + e.amount, wa(r, e);
                }
                if (r.zoom || r.bearing) {
                    const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    r.around = e ? this._map.unproject(e) : this._map.getCenter();
                }
                return this.clear(), r.noMoveStart = !0, r;
            }
        }
        function wa(e, t1) {
            (!e.duration || e.duration < t1.duration) && (e.duration = t1.duration, e.easing = t1.easing);
        }
        function Ta(t1, i, o) {
            const { maxSpeed: r, linearity: s, deceleration: n } = o, a = e.ay(t1 * s / (i / 1e3), -r, r), l = Math.abs(a) / (n * s);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            };
        }
        class Ea extends e.A {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o, r = {}){
                const s = g(i.getCanvasContainer(), o), n = i.unproject(s);
                super(t1, e.h({
                    point: s,
                    lngLat: n,
                    originalEvent: o
                }, r)), this._defaultPrevented = !1, this.target = i;
            }
        }
        class Sa extends e.A {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const r = "touchend" === t1 ? o.changedTouches : o.touches, s = v(i.getCanvasContainer(), r), n = s.map((e)=>i.unproject(e)), a = s.reduce((e, t1, i, o)=>e.add(t1.div(o.length)), new e.P(0, 0));
                super(t1, {
                    points: s,
                    point: a,
                    lngLats: n,
                    lngLat: i.unproject(a),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class Ia extends e.A {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e, t1){
                super("wheel", {
                    originalEvent: t1
                }), this._defaultPrevented = !1;
            }
        }
        class Ca {
            constructor(e, t1){
                this._map = e, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e) {
                return this._firePreventable(new Ia(this._map, e));
            }
            mousedown(e, t1) {
                return this._mousedownPos = t1, this._firePreventable(new Ea(e.type, this._map, e));
            }
            mouseup(e) {
                this._map.fire(new Ea(e.type, this._map, e));
            }
            preclick(t1) {
                const i = e.h({}, t1);
                i.type = "preclick", this._map.fire(new Ea(i.type, this._map, i));
            }
            click(e, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Ea(e.type, this._map, e)));
            }
            dblclick(e) {
                return this._firePreventable(new Ea(e.type, this._map, e));
            }
            mouseover(e) {
                this._map.fire(new Ea(e.type, this._map, e));
            }
            mouseout(e) {
                this._map.fire(new Ea(e.type, this._map, e));
            }
            touchstart(e) {
                return this._firePreventable(new Sa(e.type, this._map, e));
            }
            touchmove(e) {
                this._map.fire(new Sa(e.type, this._map, e));
            }
            touchend(e) {
                this._map.fire(new Sa(e.type, this._map, e));
            }
            touchcancel(e) {
                this._map.fire(new Sa(e.type, this._map, e));
            }
            _firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class Ra {
            constructor(e){
                this._map = e;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e) {
                this._map.fire(new Ea(e.type, this._map, e));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ea("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Ea(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class Aa {
            constructor(e, t1){
                this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e, t1) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (_(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, r = this._lastPos;
                if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                const s = Math.min(o.x, i.x), n = Math.max(o.x, i.x), a = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${s}px,${a}px)`, this._box.style.width = n - s + "px", this._box.style.height = c - a + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, r = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), m(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.A("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e)=>e.fitScreenCoordinates(o, r, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e.A(t1, {
                    originalEvent: i
                }));
            }
        }
        function Da(e, t1) {
            const i = {};
            for(let o = 0; o < e.length; o++)i[e[o].identifier] = t1[o];
            return i;
        }
        class Pa {
            constructor(e){
                this.reset(), this.numTouches = e.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e.P(0, 0);
                    for (const e of t1)i._add(e);
                    return i.div(t1.length);
                }(i), this.touches = Da(o, i)));
            }
            touchmove(e, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = Da(i, t1);
                for(const e in this.touches){
                    const t1 = o[e];
                    (!t1 || t1.dist(this.touches[e]) > 30) && (this.aborted = !0);
                }
            }
            touchend(e, t1, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e = !this.aborted && this.centroid;
                    if (this.reset(), e) return e;
                }
            }
        }
        class La {
            constructor(e){
                this.singleTap = new Pa(e), this.numTaps = e.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e, t1, i) {
                this.singleTap.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this.singleTap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this.singleTap.touchend(e, t1, i);
                if (o) {
                    const t1 = e.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class za {
            constructor(){
                this._zoomIn = new La({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new La({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e, t1, i) {
                this._zoomIn.touchstart(e, t1, i), this._zoomOut.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this._zoomIn.touchmove(e, t1, i), this._zoomOut.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this._zoomIn.touchend(e, t1, i), r = this._zoomOut.touchend(e, t1, i);
                return o ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e
                        })
                }) : r ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(r)
                        }, {
                            originalEvent: e
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const Ma = {
            0: 1,
            2: 2
        }, Oa = {
            Control: "ctrlKey",
            Alt: "altKey",
            Shift: "shiftKey",
            Meta: "metaKey"
        };
        class Fa {
            constructor(e){
                this.reset(), this._clickTolerance = e.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e, t1) {
                return !1;
            }
            _move(e, t1) {
                return {};
            }
            mousedown(e, t1) {
                if (this._lastPoint) return;
                const i = y(e);
                this._correctButton(e, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e.preventDefault(), null != this._eventButton && function(e, t1) {
                        const i = Ma[t1];
                        return void 0 === e.buttons || (e.buttons & i) !== i;
                    }(e, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e) {
                this._lastPoint && y(e) === this._eventButton && (this._moved && m(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Ba extends Fa {
            mousedown(e, t1) {
                super.mousedown(e, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e, t1) {
                return 0 === t1 && !e.ctrlKey;
            }
            _move(e, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e)
                };
            }
        }
        class ka extends Fa {
            constructor(e){
                super(e), this._pitchRotateKey = e.pitchRotateKey ? Oa[e.pitchRotateKey] : void 0;
            }
            _correctButton(e, t1) {
                return this._pitchRotateKey ? 0 === t1 && e[this._pitchRotateKey] : 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = .8 * (t1.x - e.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e) {
                this._pitchRotateKey || e.preventDefault();
            }
        }
        class Na extends Fa {
            constructor(e){
                super(e), this._pitchRotateKey = e.pitchRotateKey ? Oa[e.pitchRotateKey] : void 0;
            }
            _correctButton(e, t1) {
                return this._pitchRotateKey ? 0 === t1 && e[this._pitchRotateKey] : 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = -.5 * (t1.y - e.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e) {
                this._pitchRotateKey || e.preventDefault();
            }
        }
        class Ua {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aV([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e, t1, i) {
                return this._calculateTransform(e, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e.eJ()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e, t1, i) {
                this._calculateTransform(e, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const r = Da(o, i), s = new e.P(0, 0), n = new e.P(0, 0);
                let a = 0;
                for(const e in r){
                    const t1 = r[e], i = this._touches[e];
                    i && (s._add(t1), n._add(t1.sub(i)), a++, r[e] = t1);
                }
                if (this._touches = r, a < this._minTouches || !n.mag()) return;
                const l = n.div(a);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: s.div(a),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 500);
            }
        }
        class ja {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e) {}
            _move(e, t1, i) {
                return {};
            }
            touchstart(e, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e.preventDefault();
                const [r, s] = o, n = Ga(i, t1, r), a = Ga(i, t1, s);
                if (!n || !a) return;
                const l = this._aroundCenter ? null : n.add(a).div(2);
                return this._move([
                    n,
                    a
                ], l, e);
            }
            touchend(e, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, r] = this._firstTwoTouches, s = Ga(i, t1, o), n = Ga(i, t1, r);
                s && n || (this._active && m(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Ga(e, t1, i) {
            for(let o = 0; o < e.length; o++)if (e[o].identifier === i) return t1[o];
        }
        function Va(e, t1) {
            return Math.log(e / t1) / Math.LN2;
        }
        class qa extends ja {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._distance;
                if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Va(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: Va(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function Ha(e, t1) {
            return 180 * e.angleWith(t1) / Math.PI;
        }
        class Za extends ja {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._vector;
                if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: Ha(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = Ha(e, i);
                return Math.abs(o) < t1;
            }
        }
        function Wa(e) {
            return Math.abs(e.y) > Math.abs(e.x);
        }
        class $a extends ja {
            constructor(e){
                super(), this._map = e;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e) {
                this._lastPoints = e, Wa(e[0].sub(e[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const r = this._lastPoints;
                if (!r) return;
                const s = t1[0].sub(r[0]), n = t1[1].sub(r[1]);
                return this._map._cooperativeGestures && !e.eJ() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (s.y + n.y) / 2 * -.5
                });
            }
            gestureBeginsVertically(e, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e.mag() >= 2, r = t1.mag() >= 2;
                if (!o && !r) return;
                if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const s = e.y > 0 == t1.y > 0;
                return Wa(e) && Wa(t1) && s;
            }
        }
        const Xa = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class Ya {
            constructor(){
                const e = Xa;
                this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                let t1 = 0, i = 0, o = 0, r = 0, s = 0;
                switch(e.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);
                        break;
                    case 39:
                        e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);
                        break;
                    case 38:
                        e.shiftKey ? o = 1 : (e.preventDefault(), s = -1);
                        break;
                    case 40:
                        e.shiftKey ? o = -1 : (e.preventDefault(), s = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (n)=>{
                        const a = n.getZoom();
                        n.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: Ka,
                            zoom: t1 ? Math.round(a) + t1 * (e.shiftKey ? 2 : 1) : a,
                            bearing: n.getBearing() + i * this._bearingStep,
                            pitch: n.getPitch() + o * this._pitchStep,
                            offset: [
                                -r * this._panStep,
                                -s * this._panStep
                            ],
                            center: n.getCenter()
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function Ka(e) {
            return e * (2 - e);
        }
        const Ja = 4.000244140625, Qa = 1 / 450;
        class el {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Qa, e.aV([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e) {
                this._defaultZoomRate = e;
            }
            setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e.eJ())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e.q.now(), r = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % Ja == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = window.setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }
            _start(e) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = g(this._el, e);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e = "wheel" === this._type && Math.abs(this._delta) > Ja ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const r = i(), s = Math.pow(2, r), n = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : s;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(n * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), r = this._startZoom, s = this._easing;
                let n, a = !1;
                if ("wheel" === this._type && r && s) {
                    const t1 = Math.min((e.q.now() - this._lastWheelEventTime) / 200, 1), i = s(t1);
                    n = e.ai(r, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else n = o, a = !0;
                this._active = !0, a && (this._active = !1, this._finishTimeout = window.setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200));
                let l = n - i();
                return l * this._lastDelta < 0 && (l = 0), {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: l,
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e.eK;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e.q.now() - t1.start) / t1.duration, r = t1.easing(o + .01) - t1.easing(o), s = .27 / Math.sqrt(r * r + 1e-4) * .01, n = Math.sqrt(.0729 - s * s);
                    i = e.eI(s, n, .25, 1);
                }
                return this._prevEase = {
                    start: e.q.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 200);
            }
        }
        class tl {
            constructor(e, t1){
                this._clickZoom = e, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class il {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e, t1) {
                return e.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class ol {
            constructor(){
                this._tap = new La({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e, t1, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t1, i));
            }
            touchmove(e, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], r = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e.preventDefault(), this._active = !0, {
                            zoomDelta: r / 128
                        };
                    }
                } else this._tap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t1, i) && (this._tapTime = e.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class rl {
            constructor(e, t1, i){
                this._el = e, this._mousePan = t1, this._touchPan = i;
            }
            enable(e) {
                this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class sl {
            constructor(e, t1, i){
                this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class nl {
            constructor(e, t1, i, o){
                this._el = e, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const al = (e)=>e.zoom || e.drag || e.pitch || e.rotate;
        class ll extends e.A {
        }
        class cl {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e.at([], i, t1);
                this.radius = e.ae(o[2] < 0 ? e.eM([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e.eM(t1, t1, this.constants), e.au(t1, t1), e.eN(t1, t1, this.constants);
                const i = e.c1([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e.c1([], [
                        0,
                        0,
                        1
                    ], e.bG(i, [
                        0,
                        0,
                        1
                    ])), o = e.c1([], e.au([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), r = e.d5([], i, e.c1([], e.at([], e.d5([], o, t1), i), 2));
                    i[0] = r[0], i[1] = r[1];
                }
                return i;
            }
        }
        function hl(e) {
            return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }
        class dl {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ba(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new cl, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aV([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.addEventListener(t1, o, i);
                }
            }
            destroy() {
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.removeEventListener(t1, o, i);
                }
            }
            _addDefaultHandlers(e) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new Ca(t1, e));
                const o = t1.boxZoom = new Aa(t1, e);
                this._add("boxZoom", o);
                const r = new za, s = new il;
                t1.doubleClickZoom = new tl(s, r), this._add("tapZoom", r), this._add("clickZoom", s);
                const n = new ol;
                this._add("tapDragZoom", n);
                const a = t1.touchPitch = new $a(t1);
                this._add("touchPitch", a);
                const l = new ka(e), c = new Na(e);
                t1.dragRotate = new sl(e, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new Ba(e), d = new Ua(t1, e);
                t1.dragPan = new rl(i, h, d), this._add("mousePan", h), this._add("touchPan", d, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const u = new Za, _ = new qa;
                t1.touchZoomRotate = new nl(i, _, u, n), this._add("touchRotate", u, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", _, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new Ra(t1));
                const p = t1.scrollZoom = new el(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const f = t1.keyboard = new Ya;
                this._add("keyboard", f);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e.interactive && e[i] && t1[i].enable(e[i]);
            }
            _add(e, t1, i) {
                this._handlers.push({
                    handlerName: e,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e] = t1;
            }
            stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e } of this._handlers)e.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;
                }
            }
            isActive() {
                for (const { handler: e } of this._handlers)if (e.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!al(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e, t1, i) {
                for(const o in e)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }
            _getMapTouches(e) {
                const t1 = [];
                for (const i of e)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e.type, o = i ? void 0 : e, r = {
                    needsRenderFrame: !1
                }, s = {}, n = {}, a = e.touches ? this._getMapTouches(e.touches) : void 0, l = a ? v(this._el, a) : i ? void 0 : g(this._el, e);
                for (const { handlerName: i, handler: c, allowed: h } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let d;
                    this._blockedByActive(n, h, i) ? c.reset() : c[t1 || e.type] && (d = c[t1 || e.type](e, l, a), this.mergeHandlerResult(r, s, d, i, o), d && d.needsRenderFrame && this._triggerRenderFrame()), (d || c.isActive()) && (n[i] = c);
                }
                const c = {};
                for(const e in this._previousActiveHandlers)n[e] || (c[e] = o);
                this._previousActiveHandlers = n, (Object.keys(c).length || hl(r)) && (this._changes.push([
                    r,
                    s,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(n).length || hl(r)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h } = r;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(t1, i, o, r, s) {
                if (!o) return;
                e.h(t1, o);
                const n = {
                    handlerName: r,
                    originalEvent: o.originalEvent || s
                };
                void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [r, s, n] of this._changes)r.panDelta && (t1.panDelta = (t1.panDelta || new e.P(0, 0))._add(r.panDelta)), r.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t1.around = r.around), void 0 !== r.aroundCoord && (t1.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t1.pinchAround = r.pinchAround), r.noInertia && (t1.noInertia = r.noInertia), e.h(i, s), e.h(o, n);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const r = this._map, s = r.transform, n = (e)=>[
                        e.x,
                        e.y,
                        e.z
                    ];
                if (((e)=>{
                    const t1 = this._eventsInProgress.drag;
                    return t1 && !this._handlersById[t1.handlerName].isActive();
                })() && !hl(t1)) {
                    const e = s.zoom;
                    s.cameraElevationReference = "sea", null != this._originalZoom && s._orthographicProjectionAtLowPitch && "globe" !== s.projection.name && 0 === s.pitch ? (s.cameraElevationReference = "ground", s.zoom = this._originalZoom) : (s.recenterOnTerrain(), s.cameraElevationReference = "ground"), e !== s.zoom && this._map._update(!0);
                }
                if (s._isCameraConstrained && r._stop(!0), !hl(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: d, aroundCoord: u, pinchAround: _ } = t1;
                s._isCameraConstrained && (l > 0 && (l = 0), s._isCameraConstrained = !1), void 0 !== _ && (d = _), (l || ((e)=>i[e] && !this._eventsInProgress[e])("drag")) && d && (this._dragOrigin = n(s.pointCoordinate3D(d)), this._originalZoom = s.zoom, this._trackingEllipsoid.setup(s._camera.position, this._dragOrigin)), s.cameraElevationReference = "sea", r._stop(!0), d = d || r.transform.centerPoint, c && (s.bearing += c), h && (s.pitch += h), s._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (a) if ("mercator" === s.projection.name) {
                    const e = this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(d).dir), t1 = this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(d.sub(a)).dir);
                    p[0] = t1[0] - e[0], p[1] = t1[1] - e[1];
                } else {
                    const t1 = s.pointCoordinate(d);
                    if ("globe" === s.projection.name) {
                        a = a.rotate(-s.angle);
                        const i = s._pixelsPerMercatorPixel / s.worldSize;
                        p[0] = -a.x * e.eL(e.aY(t1.y)) * i, p[1] = -a.y * e.eL(s.center.lat) * i;
                    } else {
                        const e = s.pointCoordinate(d.sub(a));
                        t1 && e && (p[0] = e.x - t1.x, p[1] = e.y - t1.y);
                    }
                }
                const f = s.zoom, m = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = n(u || s.pointCoordinate3D(d)), i = {
                        dir: e.au([], e.at([], t1, s._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = s.zoomDeltaToMovement(t1, l);
                        e.c1(m, i.dir, o);
                    }
                }
                const g = e.d5(p, p, m);
                s._translateCameraConstrained(g), l && Math.abs(s.zoom - f) > 1e-4 && s.recenterOnTerrain(), s.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const r = al(this._eventsInProgress), s = al(t1), n = {};
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._eventsInProgress[e] || (n[`${e}start`] = i), this._eventsInProgress[e] = t1[e];
                }
                !r && s && this._fireEvent("movestart", s.originalEvent);
                for(const e in n)this._fireEvent(e, n[e]);
                s && this._fireEvent("move", s.originalEvent);
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._fireEvent(e, i);
                }
                const a = {};
                let l;
                for(const e in this._eventsInProgress){
                    const { handlerName: t1, originalEvent: o } = this._eventsInProgress[e];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e], l = i[t1] || o, a[`${e}end`] = l);
                }
                for(const e in a)this._fireEvent(e, a[e]);
                const c = al(this._eventsInProgress);
                if (o && (r || s) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e)=>0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e.A("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e.A(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e)=>{
                    this._frameId = void 0, this.handleEvent(new ll("renderFrame", {
                        timeStamp: e
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const ul = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class _l extends e.E {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aV([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e.ci(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e, t1) {
                return this.jumpTo({
                    center: e
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e.P.convert(t1).mult(-1), this.panTo(this.transform.center, e.h({
                    offset: t1
                }, i), o);
            }
            panTo(t1, i, o) {
                return this.easeTo(e.h({
                    center: t1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e, t1) {
                return this.jumpTo({
                    zoom: e
                }, t1), this;
            }
            zoomTo(t1, i, o) {
                return this.easeTo(e.h({
                    zoom: t1
                }, i), o);
            }
            zoomIn(e, t1) {
                return this.zoomTo(this.getZoom() + 1, e, t1), this;
            }
            zoomOut(e, t1) {
                return this.zoomTo(this.getZoom() - 1, e, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e, t1) {
                return this.jumpTo({
                    bearing: e
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e, t1) {
                return this.jumpTo({
                    padding: e
                }, t1), this;
            }
            rotateTo(t1, i, o) {
                return this.easeTo(e.h({
                    bearing: t1
                }, i), o);
            }
            resetNorth(t1, i) {
                return this.rotateTo(0, e.h({
                    duration: 1e3
                }, t1), i), this;
            }
            resetNorthPitch(t1, i) {
                return this.easeTo(e.h({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, t1), i), this;
            }
            snapToNorth(e, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e, t1) {
                return this.jumpTo({
                    pitch: e
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e.aG.convert(t1);
                const o = i && i.bearing || 0, r = i && i.pitch || 0, s = t1.getNorthWest(), n = t1.getSouthEast();
                return this._cameraForBounds(this.transform, s, n, o, r, i);
            }
            _extendPadding(t1) {
                const i = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                return null == t1 ? e.h({}, i, this.transform.padding) : "number" == typeof t1 ? {
                    top: t1,
                    bottom: t1,
                    right: t1,
                    left: t1
                } : e.h({}, i, t1);
            }
            _extendCameraOptions(t1) {
                return (t1 = e.h({
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t1)).padding = this._extendPadding(t1.padding), t1;
            }
            _minimumAABBFrustumDistance(e, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, r, s, n) {
                const a = t1.clone(), l = this._extendCameraOptions(n);
                a.bearing = r, a.pitch = s;
                const c = e.ci.convert(i), h = e.ci.convert(o), d = .5 * (c.lat + h.lat), u = .5 * (c.lng + h.lng), _ = e.eO(d, u), p = e.au([], _), f = e.au([], e.bF([], p, [
                    0,
                    1,
                    0
                ])), m = e.bF([], f, p), g = [
                    f[0],
                    f[1],
                    f[2],
                    0,
                    m[0],
                    m[1],
                    m[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    _,
                    e.eO(c.lat, c.lng),
                    e.eO(h.lat, c.lng),
                    e.eO(h.lat, h.lng),
                    e.eO(c.lat, h.lng),
                    e.eO(d, c.lng),
                    e.eO(d, h.lng),
                    e.eO(c.lat, u),
                    e.eO(h.lat, u)
                ];
                let y = e.d6.fromPoints(v.map((t1)=>[
                        e.bG(f, t1),
                        e.bG(m, t1),
                        e.bG(p, t1)
                    ]));
                const x = e.ad([], y.center, g);
                0 === e.eP(x) && e.eQ(x, 0, 0, 1), e.au(x, x), e.c1(x, x, e.aB), a.center = e.eR(x);
                const b = a.getWorldToCameraMatrix(), w = e.bi(new Float64Array(16), b);
                y = e.d6.applyTransform(y, e.az([], b, g));
                const T = this._extendAABB(y, a, l, r);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                y = T, e.ad(x, x, b);
                const E = .5 * (y.max[2] - y.min[2]), S = this._minimumAABBFrustumDistance(a, y), I = e.c1([], [
                    0,
                    0,
                    1
                ], E), C = e.d5(I, x, I), R = S + (0 === a.pitch ? 0 : e.bD(x, C)), A = a.globeCenterInViewSpace, D = e.at([], x, [
                    A[0],
                    A[1],
                    A[2]
                ]);
                e.au(D, D), e.c1(D, D, R);
                const P = e.d5([], x, D);
                e.ad(P, P, w);
                const L = e.eB / e.aB, z = e.ae(P), M = e.cb(Math.max(z * L - e.eB, Number.EPSILON), 0), O = Math.min(a.zoomFromMercatorZAdjusted(M), l.maxZoom);
                return O > .5 * (e.cX + e.cI) ? (a.setProjection({
                    name: "mercator"
                }), a.zoom = O, this._cameraForBounds(a, i, o, r, s, n)) : {
                    center: a.center,
                    zoom: O,
                    bearing: r,
                    pitch: s
                };
            }
            _extendAABB(t1, i, o, r) {
                const s = .5 * ((o.padding.left || 0) + (o.padding.right || 0)), n = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)), a = n, l = s, c = s, h = n, d = i.width - (l + c), u = i.height - (a + h), _ = e.at([], t1.max, t1.min), p = Math.min(d / _[0], u / _[1]), f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);
                if (isNaN(f)) return null;
                const m = i.scale / i.zoomScale(f), g = new e.d6([
                    t1.min[0] - l * m,
                    t1.min[1] - h * m,
                    t1.min[2]
                ], [
                    t1.max[0] + c * m,
                    t1.max[1] + a * m,
                    t1.max[2]
                ]), v = ("number" == typeof o.offset.x && "number" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.al(r));
                return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = e.h({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e.ac.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, r, s, n) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, r, s, n);
                const a = t1.clone(), l = this._extendCameraOptions(n);
                a.bearing = r, a.pitch = s;
                const c = e.ci.convert(i), h = e.ci.convert(o), d = new e.ci(c.lng, h.lat), u = new e.ci(h.lng, c.lat), _ = a.project(c), p = a.project(h), f = this.queryTerrainElevation(c), m = this.queryTerrainElevation(h), g = this.queryTerrainElevation(d), v = this.queryTerrainElevation(u), y = [
                    [
                        _.x,
                        _.y,
                        Math.min(f || 0, m || 0, g || 0, v || 0)
                    ],
                    [
                        p.x,
                        p.y,
                        Math.max(f || 0, m || 0, g || 0, v || 0)
                    ]
                ];
                let x = e.d6.fromPoints(y);
                const b = a.getWorldToCameraMatrix(), w = e.bi(new Float64Array(16), b);
                x = e.d6.applyTransform(x, b);
                const T = this._extendAABB(x, a, l, r);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                x = T;
                const E = .5 * e.at([], x.max, x.min)[2], S = this._minimumAABBFrustumDistance(a, x), I = [
                    0,
                    0,
                    1,
                    0
                ];
                e.aA(I, I, b), e.eS(I, I);
                const C = e.c1([], I, S + E), R = e.d5([], x.center, C);
                e.ad(x.center, x.center, w), e.ad(R, R, w);
                const A = a.unproject(new e.P(x.center[0], x.center[1])), D = e.eT(a.projection, A), P = Math.pow(2, D), L = Math.min(a._zoomFromMercatorZ(R[2] * a.pixelsPerMeter * P / a.worldSize), l.maxZoom);
                return a.mercatorFromTransition && L < .5 * (e.cX + e.cI) ? (a.setProjection({
                    name: "globe"
                }), a.zoom = L, this._cameraForBounds(a, i, o, r, s, n)) : {
                    center: A,
                    zoom: L,
                    bearing: r,
                    pitch: s
                };
            }
            fitBounds(e, t1, i) {
                const o = this.cameraForBounds(e, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, r, s) {
                const n = e.P.convert(t1), a = e.P.convert(i), l = new e.P(Math.min(n.x, a.x), Math.min(n.y, a.y)), c = new e.P(Math.max(n.x, a.x), Math.max(n.y, a.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, a)) return this;
                const h = this.transform.pointLocation3D(l), d = this.transform.pointLocation3D(c), u = this.transform.pointLocation3D(new e.P(l.x, c.y)), _ = this.transform.pointLocation3D(new e.P(c.x, l.y)), p = [
                    Math.min(h.lng, d.lng, u.lng, _.lng),
                    Math.min(h.lat, d.lat, u.lat, _.lat)
                ], f = [
                    Math.max(h.lng, d.lng, u.lng, _.lng),
                    Math.max(h.lat, d.lat, u.lat, _.lat)
                ], m = r && r.pitch ? r.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, f, o, m, r);
                return this._fitInternal(g, r, s);
            }
            _fitInternal(t1, i, o) {
                return t1 ? (i = e.h(t1, i)).linear ? this.easeTo(i, o) : this.flyTo(i, o) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let r = !1, s = !1, n = !1;
                "zoom" in t1 && o.zoom !== +t1.zoom && (r = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e.ci.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (s = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (n = !0, o.pitch = +t1.pitch);
                const a = "number" == typeof t1.padding ? this._extendPadding(t1.padding) : t1.padding;
                if (null != t1.padding && !o.isPaddingEqual(a)) if (!1 === t1.retainPadding) {
                    const e = o.clone();
                    e.padding = a, o.setLocationAtPoint(o.center, e.centerPoint);
                } else o.padding = a;
                return t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.A("movestart", i)).fire(new e.A("move", i)), r && this.fire(new e.A("zoomstart", i)).fire(new e.A("zoom", i)).fire(new e.A("zoomend", i)), s && this.fire(new e.A("rotatestart", i)).fire(new e.A("rotate", i)).fire(new e.A("rotateend", i)), n && this.fire(new e.A("pitchstart", i)).fire(new e.A("pitch", i)).fire(new e.A("pitchend", i)), this.fire(new e.A("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e.w(ul), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e.w(ul), this;
                this.stop();
                const r = o.zoom, s = o.pitch, n = o.bearing;
                o.setFreeCameraOptions(t1);
                const a = r !== o.zoom, l = s !== o.pitch, c = n !== o.bearing;
                return this.fire(new e.A("movestart", i)).fire(new e.A("move", i)), a && this.fire(new e.A("zoomstart", i)).fire(new e.A("zoom", i)).fire(new e.A("zoomend", i)), c && this.fire(new e.A("rotatestart", i)).fire(new e.A("rotate", i)).fire(new e.A("rotateend", i)), l && this.fire(new e.A("pitchstart", i)).fire(new e.A("pitch", i)).fire(new e.A("pitchend", i)), this.fire(new e.A("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = e.h({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e.eK
                }, t1)).animate || this._prefersReducedMotion(t1)) && (t1.duration = 0);
                const o = this.transform, r = this.getZoom(), s = this.getBearing(), n = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, s) : s, h = "pitch" in t1 ? +t1.pitch : n, d = this._extendPadding(t1.padding), u = e.P.convert(t1.offset);
                let _, p, f;
                if ("globe" === o.projection.name) {
                    const i = e.ac.fromLngLat(o.center), r = u.rotate(-o.angle);
                    i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
                    const s = i.toLngLat(), n = e.ci.convert(t1.center || s);
                    this._normalizeCenter(n), _ = o.centerPoint.add(r), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.aD(n.lng), e.aH(n.lat)).mult(o.worldSize).sub(p);
                } else {
                    _ = o.centerPoint.add(u);
                    const i = o.pointLocation(_), r = e.ci.convert(t1.center || i);
                    this._normalizeCenter(r), p = o.project(i), f = o.project(r).sub(p);
                }
                const m = o.zoomScale(l - r);
                let g, v;
                t1.around && (g = e.ci.convert(t1.around), v = o.locationPoint(g));
                const y = this._zooming || l !== r, x = this._rotating || s !== c, b = this._pitching || h !== n, w = !o.isPaddingEqual(d), T = !1 === t1.retainPadding ? o.clone() : o, E = (o)=>(E)=>{
                        if (y && (o.zoom = e.ai(r, l, E)), x && (o.bearing = e.ai(s, c, E)), b && (o.pitch = e.ai(n, h, E)), w && (T.interpolatePadding(a, d, E), _ = T.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e = o.zoomScale(o.zoom - r), t1 = l > r ? Math.min(2, m) : Math.max(.5, m), i = Math.pow(t1, 1 - E), s = o.unproject(p.add(f.mult(E * i)).mult(e));
                            o.setLocationAtPoint(o.renderWorldCopies ? s.wrap() : s, _);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(E, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                const S = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = y, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, S), this._ease(E(o), (e)=>{
                    "sea" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i || o.moving || this.fire(new e.A("movestart", t1)), this._zooming && !o.zooming && this.fire(new e.A("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e.A("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e.A("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e.A("move", t1)), this._zooming && this.fire(new e.A("zoom", t1)), this._rotating && this.fire(new e.A("rotate", t1)), this._pitching && this.fire(new e.A("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, r = this._rotating, s = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.A("zoomend", t1)), r && this.fire(new e.A("rotateend", t1)), s && this.fire(new e.A("pitchend", t1)), this.fire(new e.A("moveend", t1));
            }
            flyTo(t1, i) {
                if (this._prefersReducedMotion(t1)) {
                    const o = e.aF(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around",
                        "padding",
                        "retainPadding"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = e.h({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e.eK
                }, t1);
                const o = this.transform, r = this.getZoom(), s = this.getBearing(), n = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? e.ay(+t1.zoom, o.minZoom, o.maxZoom) : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, s) : s, h = "pitch" in t1 ? +t1.pitch : n, d = this._extendPadding(t1.padding), u = o.zoomScale(l - r), _ = e.P.convert(t1.offset);
                let p = o.centerPoint.add(_);
                const f = o.pointLocation(p), m = e.ci.convert(t1.center || f);
                this._normalizeCenter(m);
                const g = o.project(f), v = o.project(m).sub(g);
                let y = t1.curve;
                const x = Math.max(o.width, o.height), b = x / u, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e.ay(Math.min(t1.minZoom, r, l), o.minZoom, o.maxZoom), s = x / o.zoomScale(i - r);
                    y = Math.sqrt(s / w * 2);
                }
                const T = y * y;
                function E(e) {
                    const t1 = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function S(e) {
                    return (Math.exp(e) - Math.exp(-e)) / 2;
                }
                function I(e) {
                    return (Math.exp(e) + Math.exp(-e)) / 2;
                }
                const C = E(0);
                let R = function(e) {
                    return I(C) / I(C + y * e);
                }, A = function(e) {
                    return x * ((I(C) * (S(t1 = C + y * e) / I(t1)) - S(C)) / T) / w;
                    //TURBOPACK unreachable
                    ;
                    var t1;
                }, D = (E(1) - C) / y;
                if (Math.abs(w) < 1e-6 || !isFinite(D)) {
                    if (Math.abs(x - b) < 1e-6) return this.easeTo(t1, i);
                    const e = b < x ? -1 : 1;
                    D = Math.abs(Math.log(b / x)) / y, A = function() {
                        return 0;
                    }, R = function(t1) {
                        return Math.exp(e * y * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * D / ("screenSpeed" in t1 ? +t1.screenSpeed / y : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const P = s !== c, L = h !== n, z = !o.isPaddingEqual(d), M = !1 === t1.retainPadding ? o.clone() : o, O = (o)=>(u)=>{
                        const f = u * D, y = 1 / R(f);
                        o.zoom = 1 === u ? l : r + o.scaleZoom(y), P && (o.bearing = e.ai(s, c, u)), L && (o.pitch = e.ai(n, h, u)), z && (M.interpolatePadding(a, d, u), p = M.centerPoint.add(_));
                        const x = 1 === u ? m : o.unproject(g.add(v.mult(A(f))).mult(y));
                        return o.setLocationAtPoint(o.renderWorldCopies ? x.wrap() : x, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(O, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                return this._zooming = !0, this._rotating = P, this._pitching = L, this._padding = z, this._prepareEase(i, !1), this._ease(O(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _requestRenderFrame(e) {}
            _cancelRenderFrame(e) {}
            _stop(e, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e = this._onEaseEnd;
                    this._onEaseEnd = void 0, e.call(this, t1);
                }
                if (!e) {
                    const e = this.handlers;
                    e && e.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e.q.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e.q.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e.bQ(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e) {
                const t1 = this.transform;
                if (t1.maxBounds) return;
                if ("globe" !== t1.projection.name && !t1.renderWorldCopies) return;
                const i = e.lng - t1.center.lng;
                e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t1) {
                return this._respectPrefersReducedMotion && e.q.prefersReducedMotion && !(t1 && t1.essential);
            }
            _emulate(e, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), r = [], s = e(i.clone());
                for(let e = 0; e <= o; e++){
                    const t1 = s(e / o);
                    r.push(t1.clone());
                }
                return r;
            }
            _preloadTiles(e, t1) {}
        }
        class pl {
            constructor(t1 = {}){
                this.options = t1, e.aV([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e) {
                const t1 = this.options && this.options.compact, i = e._getUIString("AttributionControl.ToggleAttribution");
                this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i);
                const o = l("span", "mapboxgl-ctrl-icon", this._compactButton);
                return o.setAttribute("aria-hidden", "true"), o.setAttribute("title", i), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e, t1, o)=>(t1.value && (e += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
                    t1.href = `${e.e.FEEDBACK_URL}/${o}#${fa(this._map, !0)}`, t1.rel = "noopener nofollow";
                }
            }
            _updateData(e) {
                !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e = [];
                if (this._map.style.stylesheet) {
                    const e = this._map.style.stylesheet;
                    this.styleOwner = e.owner, this.styleId = e.id;
                }
                const t1 = this._map.style._mergedSourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e.indexOf(t1.attribution) < 0 && e.push(t1.attribution);
                    }
                }
                e.sort((e, t1)=>e.length - t1.length), e = e.filter((t1, i)=>{
                    for(let o = i + 1; o < e.length; o++)if (e[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [
                    ...this.options.customAttribution,
                    ...e
                ] : e.unshift(this.options.customAttribution));
                const i = e.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class fl {
            constructor(){
                e.aV([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e) {
                this._map = e, this._container = l("div", "mapboxgl-ctrl");
                const t1 = l("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e = this._map.style._sourceCaches;
                if (0 === Object.entries(e).length) return !0;
                for(const t1 in e){
                    const i = e[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e = this._container.children;
                if (e.length) {
                    const t1 = e[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class ml {
            constructor(){
                e.aV([
                    "_onIndoorUpdate"
                ], this);
            }
            onAdd(e) {
                return this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._map.indoor.on("indoorupdate", (e)=>this._onIndoorUpdate({
                        selectedFloorId: e.selectedFloorId,
                        floors: e.floors
                    })), this._container;
            }
            _createButton(e, t1) {
                const i = l("button", e, this._container);
                return i.type = "button", i.addEventListener("click", t1), i;
            }
            _setButtonTitle(e, t1) {
                this._map && (e.setAttribute("aria-label", t1), e.innerHTML = `<strong>${t1}</strong>`, e.firstElementChild && e.firstElementChild.setAttribute("title", t1));
            }
            onRemove() {
                this._container && this._container.remove(), this._map && this._map.indoor && (this._map.indoor.off("indoorupdate", this._onIndoorUpdate), this._map = null);
            }
            getDefaultPosition() {
                return "right";
            }
            _onIndoorUpdate(e) {
                if (!e || !e.floors) return void (this._container.style.display = "none");
                const t1 = this._model;
                this._model = e, this._container.style.display = "inline-block";
                const i = e.floors.sort((e, t1)=>e.levelOrder - t1.levelOrder);
                t1 ? (Array.from(this._container.children).forEach((e)=>e.remove()), this.addCurrentFloors(i)) : this.addCurrentFloors(i);
            }
            addCurrentFloors(e) {
                for (const t1 of e){
                    const e = this._createButton("mapboxgl-ctrl-level-button", ()=>{
                        this._map._selectIndoorFloor(t1.id), Array.from(this._container.children).forEach((e)=>{
                            e.classList.remove("mapboxgl-ctrl-level-button-selected");
                        }), e.classList.add("mapboxgl-ctrl-level-button-selected");
                    });
                    this._setButtonTitle(e, t1.shortName), this._model && t1.id === this._model.selectedFloorId && (this._map._selectIndoorFloor(t1.id), e.classList.add("mapboxgl-ctrl-level-button-selected")), this._container.append(e);
                }
            }
        }
        class gl {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e) return void (t1.cancelled = !0);
            }
            run(e = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        class vl {
            constructor(e){
                this.jumpTo(e);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e.dx((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }
            jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }
            easeTo(e, t1, i) {
                this._start = this.getValue(t1), this._end = e, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const yl = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox homepage",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use â + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        };
        class xl extends e.A {
            constructor(e, t1, i, o){
                const { point: r, lngLat: s, originalEvent: n, target: a } = e;
                super(e.type, {
                    point: r,
                    lngLat: s,
                    originalEvent: n,
                    target: a
                }), this.preventDefault = ()=>{
                    e.preventDefault();
                }, this.id = t1, this.interaction = i, this.feature = o;
            }
        }
        class bl {
            constructor(e){
                this.map = e, this.interactionsByType = new Map, this.delegatedInteractions = new Map, this.typeById = new Map, this.filters = new Map, this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map, this.prevHoveredFeatures = new Map;
            }
            add(t1, i) {
                if (this.typeById.has(t1)) throw new Error(`Interaction id "${t1}" already exists.`);
                const o = i.filter;
                let r = i.type;
                o && this.filters.set(t1, e.b3(o)), "mouseover" === r && (r = "mouseenter"), "mouseout" === r && (r = "mouseleave");
                const s = this.interactionsByType.get(r) || new Map;
                "mouseenter" === r || "mouseleave" === r ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t1, i)) : 0 === s.size && this.map.on(r, this.handleType), 0 === s.size && this.interactionsByType.set(r, s), s.set(t1, i), this.typeById.set(t1, r);
            }
            get(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                const i = this.interactionsByType.get(t1);
                return i ? i.get(e) : void 0;
            }
            remove(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                this.typeById.delete(e), this.filters.delete(e);
                const i = this.interactionsByType.get(t1);
                i && (i.delete(e), "mouseenter" === t1 || "mouseleave" === t1 ? (this.delegatedInteractions.delete(e), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i.size && this.map.off(t1, this.handleType));
            }
            queryTargets(e, t1) {
                const i = [];
                for (const [e, o] of t1)o.target && i.push({
                    targetId: e,
                    target: o.target,
                    filter: this.filters.get(e)
                });
                return this.map.style.queryRenderedTargets(e, i, this.map.transform);
            }
            handleMove(e) {
                this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map;
                const t1 = this.queryTargets(e.point, Array.from(this.delegatedInteractions).reverse());
                t1.length && (e.type = "mouseenter", this.handleType(e, t1));
                const i = new Map;
                for (const [e, { feature: t1 }] of this.prevHoveredFeatures)this.hoveredFeatures.has(e) || i.set(t1.id, t1);
                i.size && (e.type = "mouseleave", this.handleType(e, Array.from(i.values())));
            }
            handleOut(e) {
                const t1 = Array.from(this.hoveredFeatures.values()).map(({ feature: e })=>e);
                t1.length && (e.type = "mouseleave", this.handleType(e, t1)), this.hoveredFeatures.clear();
            }
            handleType(t1, i) {
                const o = "mouseenter" === t1.type;
                if (o && !this.interactionsByType.has(t1.type)) return void e.w("mouseenter interaction required for mouseleave to work.");
                const r = Array.from(this.interactionsByType.get(t1.type)).reverse(), s = !!i;
                i = i || this.queryTargets(t1.point, r);
                let n = !1;
                const a = new Set;
                for (const l of i){
                    for (const [i, c] of r){
                        if (!c.target) continue;
                        const r = l.variants ? l.variants[i] : null;
                        if (r) {
                            for (const h of r){
                                if (lt(h, l, a, i)) continue;
                                const r = new e.dr(l, h), d = at(h, l, i);
                                s && (r.state = this.map.getFeatureState(r));
                                const u = o ? this.prevHoveredFeatures.get(d) : null, _ = new xl(t1, i, c, r), p = u ? u.stop : c.handler(_);
                                if (o && this.hoveredFeatures.set(d, {
                                    feature: l,
                                    stop: p
                                }), !1 !== p) {
                                    n = !0;
                                    break;
                                }
                            }
                            if (n) break;
                        }
                    }
                    if (n) break;
                }
                if (!n) for (const [e, i] of r){
                    const { handler: o, target: r } = i;
                    if (!r && !1 !== o(new xl(t1, e, i, null))) break;
                }
            }
        }
        function wl(t1, i) {
            if (Array.isArray(t1) && Array.isArray(i)) {
                const e = new Set(t1), o = new Set(i);
                return e.size === o.size && t1.every((e)=>o.has(e));
            }
            return e.bv(t1, i);
        }
        const Tl = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            antialias: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            respectPrefersReducedMotion: !0,
            crossSourceCollisions: !0,
            collectResourceTiming: !1,
            testMode: !1,
            precompilePrograms: !0,
            scaleFactor: 1,
            spriteFormat: "auto"
        }, El = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class Sl {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new ka({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new Na({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e.aV([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e, t1) {
                this.mouseRotate.mousedown(e, t1), this.mousePitch && this.mousePitch.mousedown(e, t1), _();
            }
            move(e, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e, t1), r = o && o.bearingDelta;
                if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e, t1), r = o && o.pitchDelta;
                    r && i.setPitch(i.getPitch() + r);
                }
            }
            off() {
                const e = this.element;
                e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t1) {
                this.down(e.h({}, t1, {
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }), g(this.element, t1)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e) {
                this.move(e, g(this.element, e));
            }
            mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }
            touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }, this._startPos));
            }
            touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e.targetTouches)[0], this.move({
                    preventDefault: ()=>e.preventDefault()
                }, this._lastPos));
            }
            touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        function Il(t1, i, o) {
            if (t1 = new e.ci(t1.lng, t1.lat), i) {
                const r = new e.ci(t1.lng - 360, t1.lat), s = new e.ci(t1.lng + 360, t1.lat), n = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), a = o.locationPoint3D(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint3D(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < n) ? t1 = r : o.locationPoint3D(s).distSqr(i) < a && (l || Math.abs(s.lng - o.center.lng) < n) && (t1 = s);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e = o.locationPoint3D(t1);
                if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const Cl = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        }, Rl = {
            rotation: 0,
            rotationAlignment: "auto",
            pitchAlignment: "auto",
            occludedOpacity: .2,
            altitude: 0
        };
        class Al extends e.E {
            constructor(t1, i){
                super(), (t1 instanceof HTMLElement || i) && (t1 = e.h({
                    element: t1
                }, i)), e.aV([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this);
                const { anchor: o = "center", color: r = "#3FB1CE", scale: s = 1, draggable: n = !1, clickTolerance: a = 0, rotation: l = Rl.rotation, rotationAlignment: c = Rl.rotationAlignment, pitchAlignment: h = Rl.pitchAlignment, occludedOpacity: d = Rl.occludedOpacity, altitude: u = Rl.altitude } = t1 || {};
                this._anchor = o, this._color = r, this._scale = s, this._draggable = n, this._clickTolerance = a, this._rotation = l, this._rotationAlignment = c, this._pitchAlignment = h, this._occludedOpacity = d, this._altitude = u, this._state = "inactive", this._isDragging = !1, this._updateMoving = ()=>this._update(!0), t1 && t1.element ? (this._element = t1.element, this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    0
                ])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    -14
                ])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e)=>{
                    e.preventDefault();
                }), this._element.addEventListener("mousedown", (e)=>{
                    e.preventDefault();
                });
                const _ = this._element.classList;
                for(const e in Cl)_.remove(`mapboxgl-marker-anchor-${e}`);
                _.add(`mapboxgl-marker-anchor-${this._anchor}`);
                const p = t1 && t1.className ? t1.className.trim().split(/\s+/) : [];
                _.add(...p), this._popup = null;
            }
            _createDefaultMarker() {
                const e = l("div"), t1 = c("svg", {
                    display: "block",
                    height: 41 * this._scale + "px",
                    width: 27 * this._scale + "px",
                    viewBox: "0 0 27 41"
                }, e);
                if (0 === this._altitude) {
                    const e = c("radialGradient", {
                        id: "shadowGradient"
                    }, c("defs", {}, t1));
                    c("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, e), c("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, e), c("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, t1);
                }
                return c("path", {
                    fill: this._color,
                    d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                }, t1), c("path", {
                    opacity: .25,
                    d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                }, t1), c("circle", {
                    fill: "white",
                    cx: 13.5,
                    cy: 13.5,
                    r: 5.5
                }, t1), e;
            }
            addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }
            remove() {
                const e = this._map;
                return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e.ci.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            setAltitude(e) {
                return e === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e || 0 !== this._altitude && 0 === e) && (this._element = this._createDefaultMarker()), this._altitude = e || Rl.altitude, this._update()), this;
            }
            getAltitude() {
                return this._altitude;
            }
            getElement() {
                return this._element;
            }
            setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e, e._marker = this, e._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e) {
                const t1 = e.code, i = e.charCode || e.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e) {
                const t1 = e.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e = this._popup;
                return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e = this._map, t1 = this._pos;
                if (!e || !t1) return !1;
                const i = e.unproject(t1, this._altitude), o = e.getFreeCameraOptions();
                if (!o.position) return !1;
                const r = o.position.toLngLat();
                return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i, this._altitude);
                let r;
                t1._showingGlobe() && e.eW(t1.transform, this._lngLat) ? r = 0 : (r = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e = this._pos;
                if (!e || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${Cl[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e = i.getPitch();
                    return e ? `rotateX(${e}deg)` : "";
                }
                const r = e.cU(e.eX(i.transform, this._lngLat)), s = t1.sub(e.eY(i.transform)), n = Math.abs(s.x) + Math.abs(s.y);
                if (0 === n) return "";
                const a = r / n;
                return `rotateX(${-s.y * a}deg) rotateY(${s.x * a}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const r = this.getRotationAlignment();
                if ("map" === r) if (i._showingGlobe()) {
                    const t1 = i.project(new e.ci(this._lngLat.lng, this._lngLat.lat + .001), this._altitude), r = i.project(new e.ci(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(t1);
                    o = e.cU(Math.atan2(r.y, r.x)) - 90;
                } else o = -i.getBearing();
                else if ("horizon" === r) {
                    const r = e.af(4, 6, i.getZoom()), s = e.eY(i.transform);
                    s.y += r * i.transform.height;
                    const n = t1.sub(s), a = e.cU(Math.atan2(n.y, n.x));
                    o = (a > 90 ? a - 270 : a + 90) * (1 - r);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(e) {
                cancelAnimationFrame(this._updateFrameId);
                const t1 = this._map;
                t1 && (t1.transform.renderWorldCopies && (this._lngLat = Il(this._lngLat, this._pos, t1.transform)), this._pos = t1.project(this._lngLat, this._altitude), !0 === e ? this._updateFrameId = requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), t1._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t1._showingGlobe() || t1.getTerrain() || t1.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e.P.convert(t1), this._update(), this;
            }
            addClassName(e) {
                return this._element.classList.add(e), this;
            }
            removeClassName(e) {
                return this._element.classList.remove(e), this;
            }
            toggleClassName(e) {
                return this._element.classList.toggle(e);
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, r = this._positionDelta;
                if (o && r) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(r), this._lngLat = i.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.A("dragstart"))), this.fire(new e.A("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.A("dragend")), this._state = "inactive";
            }
            _addDragHandler(e) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e) {
                this._draggable = !!e;
                const t1 = this._map;
                return t1 && (e ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e) {
                return this._rotation = e || Rl.rotation, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e) {
                return this._rotationAlignment = e || Rl.rotationAlignment, this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e) {
                return this._pitchAlignment = e || Rl.pitchAlignment, this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e) {
                return this._occludedOpacity = e || Rl.occludedOpacity, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const Dl = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, Pl = {
            maxWidth: 100,
            unit: "metric"
        }, Ll = {
            kilometer: "km",
            meter: "m",
            mile: "mi",
            foot: "ft",
            "nautical-mile": "nm"
        }, zl = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            altitude: 0
        }, Ml = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function Ol(t1 = new e.P(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e.P(0, t1);
                    case "top-left":
                        return new e.P(o, o);
                    case "top-right":
                        return new e.P(-o, o);
                    case "bottom":
                        return new e.P(0, -t1);
                    case "bottom-left":
                        return new e.P(o, -o);
                    case "bottom-right":
                        return new e.P(-o, -o);
                    case "left":
                        return new e.P(t1, 0);
                    case "right":
                        return new e.P(-t1, 0);
                }
                return new e.P(0, 0);
            }
            return t1 instanceof e.P || Array.isArray(t1) ? e.P.convert(t1) : e.P.convert(t1[i] || [
                0,
                0
            ]);
        }
        const Fl = {
            version: t1,
            supported: a.supported,
            setRTLTextPlugin: e.f0,
            getRTLTextPluginStatus: e.e$,
            Map: class extends _l {
                constructor(t1){
                    o.mark(i.create);
                    const r = t1;
                    if (null != (t1 = e.h({}, Tl, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e.eU(window) && (t1.antialias = !1, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Qi(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies, null, null), t1), this._repaint = !!t1.repaint, this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new gl, this._domRenderTaskQueue = new gl, this._controls = [], this._markers = [], this._popups = [], this._mapId = e.a$(), this._locale = e.h({}, yl, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._tessellationStep = t1.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t1.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new vl(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t1.scaleFactor, this._requestManager = new T(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, this._contextCreateOptions = t1.contextCreateOptions ? Object.assign({}, t1.contextCreateOptions) : {}, "string" == typeof t1.container) {
                        const e = document.getElementById(t1.container);
                        if (!e) throw new Error(`Container '${t1.container.toString()}' not found.`);
                        this._container = e;
                    } else {
                        if (!(t1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), this._spriteFormat = t1.spriteFormat, e.aV([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._tp || (this._tp = new Yn), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showOverdrawInspector"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileBoundaries"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showParseStatus"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "repaint"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileAABBs"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showPadding"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showCollisionBoxes", {
                        noSave: !0
                    }), this._tp.registerParameter(this.transform, [
                        "Debug"
                    ], "freezeTileCoverage", {
                        noSave: !0
                    }, ()=>{
                        this._update();
                    }), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showTerrainWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers2DWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers3DWireframe"), this._tp.registerParameter(this, [
                        "Scaling"
                    ], "_scaleFactor", {
                        min: .1,
                        max: 10,
                        step: .1
                    }, ()=>{
                        this.setScaleFactor(this._scaleFactor);
                    }), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    if (this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new dl(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, (t1.style || !t1.testMode) && this.setStyle(t1.style || e.e.DEFAULT_STYLE, {
                        config: t1.config,
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), this.indoor = new mo(this), t1.hash && (this._hash = new pa("string" == typeof t1.hash && t1.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                        null == r.center && null == r.zoom || (this.transform._unmodified = !1), this.jumpTo({
                            center: t1.center,
                            zoom: t1.zoom,
                            bearing: t1.bearing,
                            pitch: t1.pitch
                        });
                        const i = t1.bounds;
                        i && (this.resize(), this.fitBounds(i, e.h({}, t1.fitBoundsOptions, {
                            duration: 0
                        })));
                    }
                    this.resize(), t1.attributionControl && this.addControl(new pl({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new fl, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e.A(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e.A(`${t1.dataType}dataloading`, t1));
                    }), this._interactions = new bl(this);
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e.z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const r = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e.z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e.A("movestart", t1)).fire(new e.A("move", t1)), this.fire(new e.A("resize", t1)), i && this.fire(new e.A("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e.aG.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = t1 ?? -2) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e.A("zoomstart")).fire(new e.A("zoom")).fire(new e.A("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = t1 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e.A("zoomstart")).fire(new e.A("zoom")).fire(new e.A("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = t1 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e.A("pitchstart")).fire(new e.A("pitch")).fire(new e.A("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = t1 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e.A("pitchstart")).fire(new e.A("pitch")).fire(new e.A("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getScaleFactor() {
                    return this._scaleFactor;
                }
                setScaleFactor(e) {
                    return this._scaleFactor = e, this.painter.scaleFactor = e, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((e)=>"symbol" === e.type), this._update(!0), this;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(e) {
                    return "auto" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e)=>"auto" === e ? navigator.language : e) : e;
                }
                setLanguage(e) {
                    const t1 = this._parseLanguage(e);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style.reloadSources();
                    for (const e of this._controls)e._setLanguage && e._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this._styleDirty = !0, this.style.reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
                        name: e
                    }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e.cI ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e.cI && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(!0));
                }
                _prioritizeAndUpdateProjection(e, t1) {
                    return this._updateProjection(e || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    return i = "globe" === t1.name && this.transform.zoom >= e.cI ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
                }
                project(t1, i) {
                    return this.transform.locationPoint3D(e.ci.convert(t1), i);
                }
                unproject(t1, i) {
                    return this.transform.pointLocation3D(e.P.convert(t1), i);
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e, t1, i) {
                    const o = (e)=>{
                        let i = [];
                        if (Array.isArray(t1)) {
                            const o = t1.filter((e)=>this.getLayer(e));
                            i = o.length ? this.queryRenderedFeatures(e, {
                                layers: o
                            }) : [];
                        } else i = this.queryRenderedFeatures(e, {
                            target: t1
                        });
                        return i;
                    };
                    if ("mouseenter" === e || "mouseover" === e) {
                        let r = !1;
                        const s = (t1)=>{
                            const s = o(t1.point);
                            s.length ? r || (r = !0, i.call(this, new Ea(e, this, t1.originalEvent, {
                                features: s
                            }))) : r = !1;
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: s,
                                mouseout: ()=>{
                                    r = !1;
                                }
                            }
                        };
                    }
                    if ("mouseleave" === e || "mouseout" === e) {
                        let r = !1;
                        const s = (t1)=>{
                            o(t1.point).length ? r = !0 : r && (r = !1, i.call(this, new Ea(e, this, t1.originalEvent)));
                        }, n = (t1)=>{
                            r && (r = !1, i.call(this, new Ea(e, this, t1.originalEvent)));
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: s,
                                mouseout: n
                            }
                        };
                    }
                    {
                        const r = (e)=>{
                            const t1 = o(e.point);
                            t1.length && (e.features = t1, i.call(this, e), delete e.features);
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                [e]: r
                            }
                        };
                    }
                }
                on(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.on(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);
                    for(const e in o.delegates)this.on(e, o.delegates[e]);
                    return this;
                }
                once(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.once(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    for(const e in o.delegates)this.once(e, o.delegates[e]);
                    return this;
                }
                off(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.off(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                    return o && ((e)=>{
                        for(let o = 0; o < e.length; o++){
                            const r = e[o];
                            if (r.listener === i && wl(r.targets, t1)) {
                                for(const e in r.delegates)this.off(e, r.delegates[e]);
                                return e.splice(o, 1), this;
                            }
                        }
                    })(o), this;
                }
                queryRenderedFeatures(t1, i) {
                    if (!this.style) return [];
                    if (void 0 === t1 || t1 instanceof e.P || Array.isArray(t1) || void 0 !== i || (i = t1, t1 = void 0), t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], !i) {
                        const e = this.style.queryRenderedFeatures(t1, void 0, this.transform), i = this.style.queryRenderedFeatureset(t1, void 0, this.transform);
                        return e.concat(i);
                    }
                    let o = !0;
                    if (i.target && (o = this._isTargetValid(i.target), o && !i.layers)) return this.style.queryRenderedFeatureset(t1, i, this.transform);
                    let r = !0;
                    if (i.layers && Array.isArray(i.layers)) {
                        for (const e of i.layers)if (!this._isValidId(e)) {
                            r = !1;
                            break;
                        }
                        if (r && !i.target) return this.style.queryRenderedFeatures(t1, i, this.transform);
                    }
                    let s = [];
                    return r && (s = s.concat(this.style.queryRenderedFeatures(t1, i, this.transform))), o && (s = s.concat(this.style.queryRenderedFeatureset(t1, i, this.transform))), s;
                }
                querySourceFeatures(e, t1) {
                    return !e || "string" == typeof e && !this._isValidId(e) ? [] : this.style.querySourceFeatures(e, t1);
                }
                isPointOnSurface(t1) {
                    const { name: i } = this.transform.projection;
                    return "globe" !== i && "mercator" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t1));
                }
                addInteraction(e, t1) {
                    return this._interactions.add(e, t1), this;
                }
                removeInteraction(e) {
                    return this._interactions.remove(e), this;
                }
                getCooperativeGestures() {
                    return this._cooperativeGestures;
                }
                setCooperativeGestures(e) {
                    return this._cooperativeGestures = e, this;
                }
                setStyle(t1, i) {
                    return i = e.h({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i), this.style && t1 && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t1, (o, r)=>{
                        if (o) {
                            const r = "string" == typeof o ? o : o instanceof Error ? o.message : o.error;
                            e.w(`Unable to perform style diff: ${r}. Rebuilding the style from scratch.`), this._updateStyle(t1, i);
                        } else r && this._update(!0);
                    }, ()=>this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e) {
                    const t1 = this._locale[e];
                    if (null == t1) throw new Error(`Missing UI string '${e}'`);
                    return t1;
                }
                _updateStyle(t1, i) {
                    if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t1) {
                        const o = e.h({}, i);
                        i && i.config && (o.initialConfig = i.config, delete o.config), this.style = new Io(this, o).load(t1), this.style.setEventedParent(this, {
                            style: this.style
                        });
                    }
                    return this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Io(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), !1);
                }
                _isValidId(t1) {
                    return null == t1 ? (this.fire(new e.z(new Error("IDs can't be empty."))), !1) : !e.dk(t1) || (this.fire(new e.z(new Error(`IDs can't contain special symbols: "${t1}".`))), !1);
                }
                _isTargetValid(e) {
                    return "featuresetId" in e ? this._isValidId("importId" in e ? e.importId : e.featuresetId) : "layerId" in e && this._isValidId(e.layerId);
                }
                _areTargetsValid(e) {
                    if (Array.isArray(e)) {
                        for (const t1 of e)if (!this._isValidId(t1)) return !1;
                        return !0;
                    }
                    return this._isTargetValid(e);
                }
                addSource(e, t1) {
                    return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t1), this._update(!0)) : this;
                }
                isSourceLoaded(e) {
                    return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);
                }
                areTilesLoaded() {
                    return this.style.areTilesLoaded();
                }
                addSourceType(e, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t1, i);
                }
                removeSource(e) {
                    return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;
                }
                getSource(e) {
                    return this._isValidId(e) ? this.style.getOwnSource(e) : null;
                }
                addImage(t1, i, { pixelRatio: o = 1, sdf: r = !1, stretchX: s, stretchY: n, content: a } = {}) {
                    this._lazyInitEmptyStyle();
                    const l = e.I.from(t1);
                    if (i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {
                        const { width: t1, height: c, data: h } = e.q.getImageData(i);
                        this.style.addImage(l, {
                            data: new e.r({
                                width: t1,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: s,
                            stretchY: n,
                            content: a,
                            sdf: r,
                            version: 0,
                            usvg: !1
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: c, height: h } = i, d = i;
                        this.style.addImage(l, {
                            data: new e.r({
                                width: c,
                                height: h
                            }, new Uint8Array(d.data)),
                            pixelRatio: o,
                            stretchX: s,
                            stretchY: n,
                            content: a,
                            sdf: r,
                            usvg: !1,
                            version: 0,
                            userImage: d
                        }), d.onAdd && d.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    this._lazyInitEmptyStyle();
                    const o = e.I.from(t1), r = this.style.getImage(o);
                    if (!r) return void this.fire(new e.z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const s = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.q.getImageData(i) : i, { width: n, height: a, data: l } = s;
                    if (void 0 === n || void 0 === a) return void this.fire(new e.z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (n !== (r.usvg ? r.icon.usvg_tree.width : r.data.width) || a !== (r.usvg ? r.icon.usvg_tree.height : r.data.height)) return void this.fire(new e.z(new Error(`The width and height of the updated image (${n}, ${a})\n                must be that same as the previous version of the image\n                (${r.data.width}, ${r.data.height})`)));
                    const c = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);
                    let h = !1;
                    r.usvg ? (r.data = new e.r({
                        width: n,
                        height: a
                    }, new Uint8Array(l)), r.usvg = !1, r.icon = void 0, h = !0) : r.data.replace(l, c), this.style.updateImage(o, r, h);
                }
                hasImage(t1) {
                    return t1 ? !!this.style && !!this.style.getImage(e.I.from(t1)) : (this.fire(new e.z(new Error("Missing required image id"))), !1);
                }
                removeImage(t1) {
                    this.style.removeImage(e.I.from(t1));
                }
                loadImage(t1, i) {
                    e.o(this._requestManager.transformRequest(t1, e.R.Image), (t1, o)=>{
                        i(t1, o instanceof HTMLImageElement ? e.q.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages().map((e)=>e.name);
                }
                addModel(e, t1) {
                    this._lazyInitEmptyStyle(), this.style.addModel(e, t1);
                }
                hasModel(t1) {
                    return t1 ? this.style.hasModel(t1) : (this.fire(new e.z(new Error("Missing required model id"))), !1);
                }
                removeModel(e) {
                    this.style.removeModel(e);
                }
                listModels() {
                    return this.style.listModels();
                }
                addLayer(e, t1) {
                    return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t1), this._update(!0)) : this;
                }
                getSlot(e) {
                    const t1 = this.getLayer(e);
                    return t1 && t1.slot || null;
                }
                setSlot(e, t1) {
                    return this.style.setSlot(e, t1), this.style.mergeLayers(), this._update(!0);
                }
                addImport(t1, i) {
                    return this.style.addImport(t1, i).catch((t1)=>this.fire(new e.z(new Error("Failed to add import", t1)))), this;
                }
                updateImport(e, t1) {
                    return "string" != typeof t1 && t1.id !== e ? (this.removeImport(e), this.addImport(t1)) : (this.style.updateImport(e, t1), this._update(!0));
                }
                removeImport(e) {
                    return this.style.removeImport(e), this;
                }
                moveImport(e, t1) {
                    return this.style.moveImport(e, t1), this._update(!0);
                }
                moveLayer(e, t1) {
                    return this._isValidId(e) ? (this.style.moveLayer(e, t1), this._update(!0)) : this;
                }
                removeLayer(e) {
                    return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;
                }
                getLayer(e) {
                    if (!this._isValidId(e)) return null;
                    const t1 = this.style.getOwnLayer(e);
                    return t1 ? "custom" === t1.type ? t1.implementation : t1.serialize() : void 0;
                }
                getSlots() {
                    return this.style.getSlots();
                }
                setLayerZoomRange(e, t1, i) {
                    return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t1, i), this._update(!0)) : this;
                }
                setFilter(e, t1, i = {}) {
                    return this._isValidId(e) ? (this.style.setFilter(e, t1, i), this._update(!0)) : this;
                }
                getFilter(e) {
                    return this._isValidId(e) ? this.style.getFilter(e) : null;
                }
                setPaintProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setPaintProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getPaintProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getPaintProperty(e, t1) : null;
                }
                setLayoutProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setLayoutProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getLayoutProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getLayoutProperty(e, t1) : null;
                }
                getGlyphsUrl() {
                    return this.style.getGlyphsUrl();
                }
                setGlyphsUrl(e) {
                    return this.style.setGlyphsUrl(e), this._update(!0);
                }
                getSchema(e) {
                    return this.style.getSchema(e);
                }
                setSchema(e, t1) {
                    return this.style.setSchema(e, t1), this._update(!0);
                }
                getConfig(e) {
                    return this.style.getConfig(e);
                }
                setConfig(e, t1) {
                    return this.style.setConfig(e, t1), this._update(!0);
                }
                getConfigProperty(e, t1) {
                    return this.style.getConfigProperty(e, t1);
                }
                setConfigProperty(e, t1, i) {
                    return this.style.setConfigProperty(e, t1, i), this._update(!0);
                }
                getFeaturesetDescriptors(e) {
                    return this.style.getFeaturesetDescriptors(e);
                }
                setLights(e) {
                    if (this._lazyInitEmptyStyle(), e && 1 === e.length && "flat" === e[0].type) {
                        const t1 = e[0];
                        t1.properties ? this.style.setFlatLight(t1.properties, t1.id, {}) : this.style.setFlatLight({}, "flat");
                    } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                    return this._update(!0);
                }
                getLights() {
                    const e = this.style.getLights() || [];
                    return 0 === e.length && e.push({
                        id: this.style.light.id,
                        type: "flat",
                        properties: this.style.getFlatLight()
                    }), e;
                }
                setLight(e, t1 = {}) {
                    return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([
                        {
                            id: "flat",
                            type: "flat",
                            properties: e
                        }
                    ]);
                }
                getLight() {
                    return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
                }
                setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                setSnow(e) {
                    return this._lazyInitEmptyStyle(), this.style.setSnow(e), this._update(!0);
                }
                getSnow() {
                    return this.style ? this.style.getSnow() : null;
                }
                setRain(e) {
                    return this._lazyInitEmptyStyle(), this.style.setRain(e), this._update(!0);
                }
                getRain() {
                    return this.style ? this.style.getRain() : null;
                }
                setColorTheme(e) {
                    return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);
                }
                setImportColorTheme(e, t1) {
                    return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e, t1), this._update(!0);
                }
                setCamera(e) {
                    return this.style.setCamera(e), this._triggerCameraUpdate(e);
                }
                _triggerCameraUpdate(e) {
                    return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e["camera-projection"]));
                }
                getCamera() {
                    return this.style.camera;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.ci.convert(t1), this.transform) : 0;
                }
                setFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.setFeatureState(e, t1), this._update());
                }
                removeFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.removeFeatureState(e, t1), this._update());
                }
                getFeatureState(e) {
                    return e.source && !this._isValidId(e.source) ? null : this.style.getFeatureState(e);
                }
                _selectIndoorFloor(e) {
                    this.indoor.selectFloor(e);
                }
                _addIndoorControl() {
                    this._indoorControl || (this._indoorControl = new ml), this.addControl(this._indoorControl, "right");
                }
                _removeIndoorControl() {
                    this._indoorControl && this.removeControl(this._indoorControl);
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const e = this._container.getBoundingClientRect().width || 400, t1 = this._container.getBoundingClientRect().height || 300;
                    let i, o, r, s = this._container;
                    for(; s && (!o || !r);){
                        const e = window.getComputedStyle(s).transform;
                        e && "none" !== e && (i = e.match(/matrix.*\((.+)\)/)[1].split(", "), i[0] && "0" !== i[0] && "1" !== i[0] && (o = i[0]), i[3] && "0" !== i[3] && "1" !== i[3] && (r = i[3])), s = s.parentElement;
                    }
                    this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = r ? Math.abs(t1 / r) : t1;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e = this._container;
                    e.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e);
                    this._canvas = l("canvas", "mapboxgl-canvas", t1), this._interactive && (t1.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = l("div", "mapboxgl-control-container", e), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top",
                        "top-right",
                        "right",
                        "bottom-right",
                        "bottom",
                        "bottom-left",
                        "left"
                    ].forEach((e)=>{
                        o[e] = l("div", `mapboxgl-ctrl-${e}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e.q.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e) {
                    this._markers.push(e);
                }
                _removeMarker(e) {
                    const t1 = this._markers.indexOf(e);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e) {
                    this._popups.push(e);
                }
                _removePopup(e) {
                    const t1 = this._popups.indexOf(e);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = e.h({}, a.supported.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), i = this._canvas.getContext("webgl2", t1);
                    i ? (j(i, !0), this.painter = new ua(i, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp, this._worldview), this.on("data", (e)=>{
                        "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e.l.testSupport(i)) : this.fire(new e.z(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.A("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.A("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                idle() {
                    return !this.isMoving() && this.loaded();
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                frameReady() {
                    return this.loaded() && !this._placementDirty;
                }
                _update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }
                _cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }
                _requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }
                _render(t1) {
                    let r;
                    this.fire(new e.A("renderstart")), ++this._frameId;
                    const s = this.painter.context.extTimerQuery, n = e.q.now(), a = this.painter.context.gl;
                    if (this.listens("gpu-timing-frame") && (r = a.createQuery(), a.beginQuery(s.TIME_ELAPSED_EXT, r)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const l = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e.q.now(), r = new e.aa(t1, {
                            now: o,
                            fadeDuration: l,
                            pitch: i,
                            transition: this.style.transition,
                            worldview: this._worldview
                        });
                        this.style.update(r);
                    }
                    this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let c = !1;
                    this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c = this._updateAverageElevation(n), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c = this._updateAverageElevation(n);
                    const h = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
                    if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), h && (this._placementDirty = h.needsRerender), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showParseStatus: this.showParseStatus,
                        wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe
                        },
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: l,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e.A("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.A("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), r) {
                        const t1 = e.q.now() - n;
                        a.endQuery(s.TIME_ELAPSED_EXT), setTimeout(()=>{
                            const i = a.getQueryParameter(r, a.QUERY_RESULT) / 1e6;
                            a.deleteQuery(r), this.fire(new e.A("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e.A("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e.A("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const d = this._sourcesDirty || this._styleDirty || this._placementDirty || c;
                    if (d || this._repaint) this.triggerRepaint();
                    else {
                        const t1 = this.idle();
                        if (t1 && (c = this._updateAverageElevation(n, !0)), c) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e.A("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e.A("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && B(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e) {
                    for (const t1 of this._markers)e && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e, t1 = !1) {
                    const i = (e)=>(this.transform.averageElevation = e, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                    if (o || (t1 || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t1 = this.transform.averageElevation;
                        let r = this.transform.sampleAverageElevation();
                        null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r) ? r = 0 : this._averageElevationLastSampledAt = e;
                        const s = Math.abs(t1 - r);
                        if (s > 1) {
                            if (this._isInitialLoad || o) return this._averageElevation.jumpTo(r), i(r);
                            this._averageElevation.easeTo(r, e, 300);
                        } else if (s > 1e-4) return this._averageElevation.jumpTo(r), i(r);
                    }
                    return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
                }
                _authenticate() {
                    N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === w || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            j(t1, !1), this._logoControl instanceof fl && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.z(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _postStyleLoadEvent() {
                    this.style.globalId && O(this._requestManager._customAccessToken, {
                        map: this,
                        style: this.style.globalId,
                        importedStyles: this.style.getImportGlobalIds()
                    });
                }
                _updateTerrain() {
                    const e = this._isDragging();
                    this.painter.updateTerrain(this.style, e);
                }
                _calculateSpeedIndex() {
                    const e = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function r(e) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t1.canvasCopies.map(r), t1.timeStamps);
                }
                _canvasPixelComparison(e, t1, i) {
                    let o = i[1] - i[0];
                    const r = e.length / 4;
                    for(let s = 0; s < t1.length; s++){
                        const n = t1[s];
                        let a = 0;
                        for(let t1 = 0; t1 < n.length; t1 += 4)n[t1] === e[t1] && n[t1 + 1] === e[t1 + 1] && n[t1 + 2] === e[t1 + 2] && n[t1 + 3] === e[t1 + 3] && (a += 1);
                        o += (i[s + 2] - i[s + 1]) * (1 - a / r);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e of this._controls)e.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), U.delete(this.painter.context.gl), k.remove(), L.remove(), this._removed = !0, this.fire(new e.A("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e.q.frame((e)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? this.style.getSourceCaches() : [];
                    return e.bt(i, (e, i)=>e._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e) {
                    this._trackResize && this.resize({
                        originalEvent: e
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._tp.refreshUI(), this._update());
                }
                get showParseStatus() {
                    return !!this._showParseStatus;
                }
                set showParseStatus(e) {
                    this._showParseStatus !== e && (this._showParseStatus = e, this._tp.refreshUI(), this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                }
                set showLayers2DWireframe(e) {
                    this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                }
                set showLayers3DWireframe(e) {
                    this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._tp.refreshUI(), this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this._tp.refreshUI(), e ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._tp.refreshUI(), this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this._tp.refreshUI(), this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e) {
                    this._vertices = e, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, this._tp.refreshUI(), e && this._update());
                }
                _setCacheLimits(t1, i) {
                    e.eV(t1, i);
                }
                get version() {
                    return t1;
                }
            },
            NavigationControl: class {
                constructor(t1 = {}){
                    this.options = e.h({}, El, t1), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this.options.showZoom && (e.aV([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aV([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e
                        }) : t1.resetNorth({}, {
                            originalEvent: e
                        }));
                    }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = e.getZoom(), i = t1 === e.getMaxZoom(), o = t1 === e.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
                    e._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Sl(e, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e = this._map;
                    e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e, t1) {
                    const i = l("button", e, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e.E {
                constructor(t1 = {}){
                    super();
                    const i = navigator.geolocation;
                    this.options = e.h({
                        geolocation: i
                    }, Dl, t1), e.aV([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = _a(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e) {
                    return this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(e) {
                    const t1 = (t1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = t1, e(t1);
                    };
                    void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({
                        name: "geolocation"
                    }).then((e)=>t1("denied" !== e.state)).catch(()=>t1()) : t1();
                }
                _isOutOfMapMaxBounds(e) {
                    const t1 = this._map.getMaxBounds(), i = e.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e.A("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t1), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.A("geolocate", t1)), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e.ci(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, r = this._map.getBearing(), s = e.h({
                        bearing: r
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), s, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e.ci(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e.cb(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) if (1 === t1.code) {
                            this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                            const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
                        } else {
                            if (3 === t1.code && this._noTimeout) return;
                            this._setErrorState();
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.A("error", t1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Al({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Al({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.A("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e.w("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e.A("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.A("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.A("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const e = ()=>{
                        "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
                    };
                    "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t1)=>{
                        "granted" === t1 && e();
                    }).catch(console.error) : e();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: pl,
            ScaleControl: class {
                constructor(t1 = {}){
                    this.options = e.h({}, Pl, t1), this._isNumberFormatSupported = function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "short",
                                unit: "meter"
                            }), !0;
                        } catch (e) {
                            return !1;
                        }
                    }(), e.aV([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e / 2, r = t1.unproject([
                        o,
                        i
                    ]), s = t1.unproject([
                        o + e,
                        i
                    ]), n = r.distanceTo(s);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * n;
                        t1 > 5280 ? this._setScale(e, t1 / 5280, "mile") : this._setScale(e, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e, n / 1852, "nautical-mile") : n >= 1e3 ? this._setScale(e, n / 1e3, "kilometer") : this._setScale(e, n, "meter");
                }
                _setScale(e, t1, i) {
                    this._map._requestDomTask(()=>{
                        const o = function(e) {
                            const t1 = Math.pow(10, `${Math.floor(e)}`.length - 1);
                            let i = e / t1;
                            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e) {
                                const t1 = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
                                return Math.round(e * t1) / t1;
                            }(i), t1 * i;
                        }(t1), r = o / t1;
                        this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "short",
                            unit: i
                        }).format(o) : `${o}&nbsp;${Ll[i]}`, this._container.style.width = e * r + "px";
                    });
                }
                onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e) {
                    this._language = e, this._update();
                }
                setUnit(e) {
                    this.options.unit = e, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1 = {}){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof HTMLElement ? this._container = t1.container : e.w("Full screen control 'container' must be a DOM element.")), e.aV([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const e = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    l("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            IndoorControl: ml,
            Popup: class extends e.E {
                constructor(t1){
                    super(), this.options = e.h(Object.create(zl), t1), this._altitude = this.options.altitude, e.aV([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e.A("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e.A("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e.ci.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                getAltitude() {
                    return this._altitude;
                }
                setAltitude(e) {
                    return this._altitude = e, this._update(), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e = this._map;
                    return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(e) {
                    return this.setDOMContent(document.createTextNode(e));
                }
                setHTML(e) {
                    const t1 = document.createDocumentFragment(), i = document.createElement("body");
                    let o;
                    for(i.innerHTML = e; o = i.firstChild, o;)t1.appendChild(o);
                    return this.setDOMContent(t1);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }
                setDOMContent(e) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e), this.options.closeButton) {
                        const e = this._closeButton = l("button", "mapboxgl-popup-close-button", t1);
                        e.type = "button", e.setAttribute("aria-label", "Close popup"), e.innerHTML = '<span aria-hidden="true">&#215;</span>', e.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }
                removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }
                setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }
                toggleClassName(e) {
                    let t1;
                    return this._classList.delete(e) ? t1 = !1 : (this._classList.add(e), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e) {
                    this._update(e.point);
                }
                _getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const r = i.offsetWidth, s = i.offsetHeight, n = o.x < r / 2, a = o.x > t1.transform.width - r / 2;
                    if (o.y + e < s) return n ? "top-left" : a ? "top-right" : "top";
                    if (o.y > t1.transform.height - s) {
                        if (n) return "bottom-left";
                        if (a) return "bottom-right";
                    }
                    return n ? "left" : a ? "right" : "bottom";
                }
                _updateClassList() {
                    const e = this._container;
                    if (!e) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let r = this._container;
                    if (r || (r = this._container = l("div", "mapboxgl-popup", i.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Il(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const o = this._pos = this._trackPointer && t1 instanceof e.P ? t1 : i.project(this._lngLat, this._altitude), r = Ol(this.options.offset), s = this._anchor = this._getAnchor(r.y), n = Ol(this.options.offset, s), a = o.add(n).round();
                        i._requestDomTask(()=>{
                            this._container && s && (this._container.style.transform = `${Cl[s]} translate(${a.x}px,${a.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e.eW(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e = this._container.querySelector(Ml);
                    e && e.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            },
            Marker: Al,
            Style: Io,
            LngLat: e.ci,
            LngLatBounds: e.aG,
            Point: e.P,
            MercatorCoordinate: e.ac,
            FreeCameraOptions: $i,
            Evented: e.E,
            config: e.e,
            prewarm: e.e_,
            clearPrewarmedResources: e.eZ,
            get accessToken () {
                return e.e.ACCESS_TOKEN;
            },
            set accessToken (t){
                e.e.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e.e.API_URL;
            },
            set baseApiUrl (t){
                e.e.API_URL = t;
            },
            get workerCount () {
                return e.f7.workerCount;
            },
            set workerCount (t){
                e.f7.workerCount = t;
            },
            get maxParallelImageRequests () {
                return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e.e.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e.f6(t1);
            },
            get workerUrl () {
                return e.f5.workerUrl;
            },
            set workerUrl (t){
                e.f5.workerUrl = t;
            },
            get workerClass () {
                return e.f5.workerClass;
            },
            set workerClass (t){
                e.f5.workerClass = t;
            },
            get workerParams () {
                return e.f5.workerParams;
            },
            set workerParams (t){
                e.f5.workerParams = t;
            },
            get dracoUrl () {
                return e.f4();
            },
            set dracoUrl (t){
                e.f3(t);
            },
            get meshoptUrl () {
                return e.f2();
            },
            set meshoptUrl (t){
                e.f1(t);
            },
            setNow: e.q.setNow,
            restoreNow: e.q.restoreNow
        };
        return Fl;
    });
    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
}); //# sourceMappingURL=mapbox-gl.js.map
}}),

};

//# sourceMappingURL=node_modules_mapbox-gl_dist_mapbox-gl_b87cdc87.js.map